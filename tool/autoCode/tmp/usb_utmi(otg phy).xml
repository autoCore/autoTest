<?xml version="1.0" encoding="UTF-8"?>
	<spirit:component xmlns:kactus2="http://funbase.cs.tut.fi/" xmlns:spirit="http://www.spiritconsortium.org/XMLSchema/SPIRIT/1.5" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.spiritconsortium.org/XMLSchema/SPIRIT/1.5 http://www.spiritconsortium.org/XMLSchema/SPIRIT/1.5/index.xsd">
		<spirit:vendor>org.example</spirit:vendor>
		<spirit:library>example_lib</spirit:library>
		<spirit:name>usb_utmi(otg phy)</spirit:name>
		<spirit:version>example_version</spirit:version>
<spirit:memoryMaps>
<spirit:memoryMap>
<spirit:name>some_register_map</spirit:name>
<spirit:displayName>RDL Example Registers</spirit:displayName>
<spirit:addressBlock>
<spirit:name>some_register_map</spirit:name>
<spirit:displayName>ASR Module Registers</spirit:displayName>
<spirit:description>This address map contains some example registers to show how RDL can be utilized in various situations.</spirit:description>
<spirit:baseAddress>0xD4207000</spirit:baseAddress>
<spirit:range>0x2000</spirit:range>
<spirit:width>32</spirit:width>
<spirit:usage> </spirit:usage>
<spirit:volatile>true</spirit:volatile>
<spirit:register>
<spirit:name>PLL_CTRL0</spirit:name>
<spirit:description>USB2 PHY PLL Register</spirit:description>
<spirit:addressOffset>0X0</spirit:addressOffset>
<spirit:size>32</spirit:size>
<spirit:volatile>true</spirit:volatile>
<spirit:access>read-write</spirit:access>
<spirit:reset>
<spirit:value>0</spirit:value>
<spirit:mask>0xffffffff</spirit:mask>
</spirit:reset>
<spirit:field>
<spirit:name>PLL_READY</spirit:name>
<spirit:description>pll ready  0 = pll not locked  1 = pll locked</spirit:description>
<spirit:bitOffset>31</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>R_ROTATE</spirit:name>
<spirit:description>rotate select  0 = control is rotated by 90 degrees  1 = reference resistor is parallel with the pad</spirit:description>
<spirit:bitOffset>30</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>SEL_LPFR</spirit:name>
<spirit:description>select lpfr  0x0 = frefclk/refdiv[6:0] = 4 mhz to 5 mhz range  0x1 = frefclk/refdiv[6:0] is in 2 mhz to 2.5 mhz range  0x2 = frefclk/refdiv[6:0] is in 1 mhz to 1.25 mhz range  11 = reserved</spirit:description>
<spirit:bitOffset>28</spirit:bitOffset>
<spirit:bitWidth>2</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>FBDIV</spirit:name>
<spirit:description>feedback clock divider select  0x00 to 0x0f = invalid  0x10 to 0x1ff = divided by 16 to 511 directly  default is set for 40 mhz refclk. if a refclk frequency other than 40 mhz is used, this value must be changed before powering up the pll.</spirit:description>
<spirit:bitOffset>16</spirit:bitOffset>
<spirit:bitWidth>9</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>VDDL</spirit:name>
<spirit:description>pll 1.1v regulator output voltage control  0x0 = vdd  0x1 = 0.9v  0x2 = 1.0v  0x3 =1.1v</spirit:description>
<spirit:bitOffset>14</spirit:bitOffset>
<spirit:bitWidth>2</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>VDDM</spirit:name>
<spirit:description>1.8v regulator voltage control  0x0 = 1.7v  0x1 = 1.8v  0x2 = 1.9v  0x3 = 2.0v</spirit:description>
<spirit:bitOffset>12</spirit:bitOffset>
<spirit:bitWidth>2</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>ICP</spirit:name>
<spirit:description>pll charge-pump current select  icp[3:0] icp  0x0 = 15 &lt;mu&gt;a  0x1 = 20 &lt;mu&gt;a  0x2 = 25 &lt;mu&gt;a  0x3 = 30 &lt;mu&gt;a  0x4 = 35 &lt;mu&gt;a  0x5 = 40 &lt;mu&gt;a  0x6 = 45 &lt;mu&gt;a  0x7 = 50 &lt;mu&gt;a</spirit:description>
<spirit:bitOffset>8</spirit:bitOffset>
<spirit:bitWidth>4</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>REFDIV</spirit:name>
<spirit:description>reference clock divider select  0x0 = bypass, equivalent to divided by 1  0x1 = invalid  0x2 = divided by 2  0x3 to 0x7f = divided by 3 to 127  default is set for 40 mhz refclk. if a refclk frequency other than 40 mhz is used, this value must be changed before powering up the pll.</spirit:description>
<spirit:bitOffset>0</spirit:bitOffset>
<spirit:bitWidth>7</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
</spirit:register>
<spirit:register>
<spirit:name>PLL_CTRL1</spirit:name>
<spirit:description>PLL Control Register 1</spirit:description>
<spirit:addressOffset>0X4</spirit:addressOffset>
<spirit:size>32</spirit:size>
<spirit:volatile>true</spirit:volatile>
<spirit:access>read-write</spirit:access>
<spirit:reset>
<spirit:value>0</spirit:value>
<spirit:mask>0xffffffff</spirit:mask>
</spirit:reset>
<spirit:field>
<spirit:name>PLL_STRESS_TEST</spirit:name>
<spirit:description>stress test mode  0 = normal mode  1 = stress test mode</spirit:description>
<spirit:bitOffset>14</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>CLK_BLK_EN</spirit:name>
<spirit:description>480 mhz clock block enable to avoid overshooting issue  0 = when lock detect and kvco calibration
done, sent the clock out  1 = always sent clock out</spirit:description>
<spirit:bitOffset>13</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>REFCLK_SEL</spirit:name>
<spirit:description>refclk select  0 = choose refclkc_in1 for usb2 phy  1 = choose refclkc_in2</spirit:description>
<spirit:bitOffset>12</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>CLK160M_EN</spirit:name>
<spirit:description>160 mhz clock dig_clk160m output enable  1 = 160 mhz clock is enabled. it will output refclk before pll is locked or 160 mhz after pll is locked.  0 = 160 mhz clock is disabled</spirit:description>
<spirit:bitOffset>11</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>TXCLK_EN</spirit:name>
<spirit:description>enable 480 mhz clock output  0=disabled, no txclk 480mhz output  1=enabled</spirit:description>
<spirit:bitOffset>10</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>TESTMON_PLL</spirit:name>
<spirit:description>controls test_pin analog test point  for marvell internal use only. default is high-z</spirit:description>
<spirit:bitOffset>4</spirit:bitOffset>
<spirit:bitWidth>4</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>PLL_SUSPEND_EN</spirit:name>
<spirit:description>pll suspend enable  0 = pll power is not affected by suspend  1 = suspendm is allowed to power down pll  for multi-port phy, if this field is 1 in all channels, suspend = 0 will power off pll, otherwise, pll power will not be affected by suspend</spirit:description>
<spirit:bitOffset>3</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>PLL_RESET</spirit:name>
<spirit:description>pll reset  0 = use por_reset to reset pll  1 = reset pll</spirit:description>
<spirit:bitOffset>2</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>PU_PLL_BY_REG</spirit:name>
<spirit:description>power up pll  0 = power up pll by pu_pll port  1 = power up pll by pu_pll register bit</spirit:description>
<spirit:bitOffset>1</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>PU_PLL42</spirit:name>
<spirit:description>power up  0 = power down usb phy pll  1 = power up usb phy pll  if suspendm from all channels are asserted and pll_suspend_en is 1, then pll will
be powered off automatically even pu is 1. in addition, pll is always controlled by pin in scan mode. pll is always off in iddq_test mode.</spirit:description>
<spirit:bitOffset>0</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
</spirit:register>
<spirit:register>
<spirit:name>CALIBRATION_CTRL1</spirit:name>
<spirit:description>Calibration Control Register</spirit:description>
<spirit:addressOffset>0X8</spirit:addressOffset>
<spirit:size>32</spirit:size>
<spirit:volatile>true</spirit:volatile>
<spirit:access>read-write</spirit:access>
<spirit:reset>
<spirit:value>0</spirit:value>
<spirit:mask>0xffffffff</spirit:mask>
</spirit:reset>
<spirit:field>
<spirit:name>PLLCAL_DONE</spirit:name>
<spirit:description>pll calibration done  1 = pll calibration is done  0 = not done</spirit:description>
<spirit:bitOffset>31</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>CURRENT_KVCO</spirit:name>
<spirit:description>kvco value currently used</spirit:description>
<spirit:bitOffset>28</spirit:bitOffset>
<spirit:bitWidth>3</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>CURRENT_IMP</spirit:name>
<spirit:description>current imp value</spirit:description>
<spirit:bitOffset>24</spirit:bitOffset>
<spirit:bitWidth>4</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>IMPCAL_DONE</spirit:name>
<spirit:description>impedance calibration done  1 = impedance calibration is done  0 = not done</spirit:description>
<spirit:bitOffset>23</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>PLLCAL_START</spirit:name>
<spirit:description>pll calibration start  control kvco calibration for pll, every 0 to 1 transition will start vco calibration and keep this bit 1 unless you want to calibrate again.
it is better to use vco calibration to cover all process corners.</spirit:description>
<spirit:bitOffset>22</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>PLLCAL</spirit:name>
<spirit:description>change pll vco calibration voltage  0x0 = vdd  0x1 = 1.0v (default)  0x2 = 1.05v  0x3 = 1.1v</spirit:description>
<spirit:bitOffset>20</spirit:bitOffset>
<spirit:bitWidth>2</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>KVCO_EXT</spirit:name>
<spirit:description>select kvco control signal kvco_cal[2:0]  0 = select calibration kvco  1 = select register control kvco[2:0]</spirit:description>
<spirit:bitOffset>19</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>UTM_KVCO56</spirit:name>
<spirit:description>pll kvco control  0x0 = high kvco  ...  0x7 = low kvco  this field is only valid if kvco_ext = 1.</spirit:description>
<spirit:bitOffset>16</spirit:bitOffset>
<spirit:bitWidth>3</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>VCOCAL_POL</spirit:name>
<spirit:description>vcocal polarity  0 = use up/down signal from analog part  1 = invert up/down signal polarity</spirit:description>
<spirit:bitOffset>15</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>IMPCAL_POL</spirit:name>
<spirit:description>impcal polarity  0 = use up/down signal from analog part  1 = invert up/down signal polarity</spirit:description>
<spirit:bitOffset>14</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>IMPCAL_START</spirit:name>
<spirit:description>impedance calibration start  control impedance calibration, every 0 to 1 transition will start impedance calibration and keep this bit 1 unless you want to calibrate again,it is better to use impedance calibration to cover all process corners.</spirit:description>
<spirit:bitOffset>13</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>EXT_RCAL_EN</spirit:name>
<spirit:description>impedance calibration enable control  0 = use the auto calibration results  1 = use the value set by ext_rcal[3:0]</spirit:description>
<spirit:bitOffset>12</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>EXT_FS_IMP_EN</spirit:name>
<spirit:description>fs impedance calibration enable control  0 = use the auto calibration results  1 = use the value set by ext_fs_imp[3:0]</spirit:description>
<spirit:bitOffset>11</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>IMPCAL_VTH</spirit:name>
<spirit:description>impedance calibration threshold setting  vth[2:0] impedance  0x0 = 900/16 = 56 ohms  0x1 = 900/17 = 53 ohms  ...  0x4 = 900/20 = 45 ohms  ...  0x7 = 900/23 = 39 ohms  each product must tune this register respectively. in hs mode, with 45 ohm termination on dp/dm. sweep register setting to make sepp equal to 400 mv.</spirit:description>
<spirit:bitOffset>8</spirit:bitOffset>
<spirit:bitWidth>3</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>EXT_RCAL</spirit:name>
<spirit:description>ext_rcal  refer to ext_fs_imp[3:0]</spirit:description>
<spirit:bitOffset>4</spirit:bitOffset>
<spirit:bitWidth>4</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>EXT_FS_IMP</spirit:name>
<spirit:description>tx fs driver impedance adjusting for hs loading  target is 45 ohms  imp_cal[3:0] impedance (se)  0x0 = 900/12 = 75 ohms  0x1 = 900/13 = 69 ohms  0x2 = 900/14 = 64 ohms  …  0x8 = 900/20 = 45 ohms  …  0xf = 900/27 = 33 ohms  this is only used in testing mode, where reg_ex_fs_rcal_en = 1.</spirit:description>
<spirit:bitOffset>0</spirit:bitOffset>
<spirit:bitWidth>4</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
</spirit:register>
<spirit:register>
<spirit:name>USB2_TX_0</spirit:name>
<spirit:description>Tx Channel Control Register 0</spirit:description>
<spirit:addressOffset>0X0C</spirit:addressOffset>
<spirit:size>32</spirit:size>
<spirit:volatile>true</spirit:volatile>
<spirit:access>read-write</spirit:access>
<spirit:reset>
<spirit:value>0</spirit:value>
<spirit:mask>0xffffffff</spirit:mask>
</spirit:reset>
<spirit:field>
<spirit:name>PU_BY_REG</spirit:name>
<spirit:description>power control  0 = tx/rx channel power is controlled by pu_phyx port  1 = power is controlled by pu_ana register bit  the power is always controlled by pu_phyx pin in
scan mode</spirit:description>
<spirit:bitOffset>25</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>PU_ANA</spirit:name>
<spirit:description>power up tx/rx channel analog part  1 = power up tx/rx channel analog part  0 = turn it off</spirit:description>
<spirit:bitOffset>24</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>PU_VDDR18</spirit:name>
<spirit:description>reserved for analog part</spirit:description>
<spirit:bitOffset>23</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>AMP</spirit:name>
<spirit:description>tx output driver amplitude control  amp[2:0]  i (total) amp  0x0 = 12.6 ma 283.5 mv  0x1 = 14.4 ma 324.0 mv  0x2 = 16.2 ma 364.5 mv  0x3 = 18.0 ma 405.0 mv  0x4 = 19.8 ma 445.5 mv  0x5 = 21.6 ma 486.0 mv  0x6 = 23.4 ma 526.5 mv  0x7 = 25.2 ma 567.0 mv  from icc current</spirit:description>
<spirit:bitOffset>20</spirit:bitOffset>
<spirit:bitWidth>3</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>IMP_SEL_LS</spirit:name>
<spirit:description>ls tx driver fine adjustment  this field controls 15 cells of the 27 ls tx driver cells. the total number of driver cells enabled is the sum of the cells enabled by
drv_en_ls and by imp_sel_ls  for example, if drv_en_ls = 0x3 (enables 6 cells) and imp_sel_ls = 0x1 (enables 1 cell), the total number of ls driver cells is 7  imp_cal[3:0]  ls drive cell control  0x0 = no cell on  0x1 = 1 cell on  0x2 = 2 cells on  ...  0xf = 15 cells on</spirit:description>
<spirit:bitOffset>16</spirit:bitOffset>
<spirit:bitWidth>4</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>DRV_EN_LS</spirit:name>
<spirit:description>ls tx driver strength coarse control  the whole ls driver includes 27 driver cells. drv_en_ls[3:0] controls 12 cells with granularity of 3 cells, imp_sel_ls[3:0] control 15 cells with granularity of 1 cell. according to chip test result, around 7 driver cells are optimal for ls eye.  0x1 = 3 programmable cell on  0x3 = 6 programmable cell on  0x7 = 9 programmable cell on  0xf = 12 programmable cell on  marvell recommends changing this field to 0x1 by software after power up. but still need to tune for optimal setting for ls eye with test result.</spirit:description>
<spirit:bitOffset>12</spirit:bitOffset>
<spirit:bitWidth>4</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>FSDRV_EN</spirit:name>
<spirit:description>fs driver enable  the whole fs driver includes 12 programmable driver cell and 15 calibration driver cell.  0x1 = 3 programmable cell on  0x3 = 6 programmable cell on  0x7 = 9 programmable cell on  0xf = 12 programmable cell on</spirit:description>
<spirit:bitOffset>8</spirit:bitOffset>
<spirit:bitWidth>4</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>LOWVDD_EN</spirit:name>
<spirit:description>low vdd enable  the design supports low regulator voltage for hs drive, when the regulator voltage for hs drive is low, the driver requires larger device.  0 = for 1.6v  1 = for 1.5v</spirit:description>
<spirit:bitOffset>6</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>HS_SR_SEL</spirit:name>
<spirit:description>rise/fall time of hs transmitter control  0x00 = shortest rise/fall  0x11 = longest rise/fall</spirit:description>
<spirit:bitOffset>4</spirit:bitOffset>
<spirit:bitWidth>2</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>HSDRV_EN</spirit:name>
<spirit:description>hs driver enable  the whole hs driver has been split into 4 small drivers. each register of sdrv_en[3:0] controls 1 small driver.</spirit:description>
<spirit:bitOffset>0</spirit:bitOffset>
<spirit:bitWidth>4</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
</spirit:register>
<spirit:register>
<spirit:name>USB2_TX_1</spirit:name>
<spirit:description>Tx Channel Control Register 1</spirit:description>
<spirit:addressOffset>0X10</spirit:addressOffset>
<spirit:size>32</spirit:size>
<spirit:volatile>true</spirit:volatile>
<spirit:access>read-write</spirit:access>
<spirit:reset>
<spirit:value>0</spirit:value>
<spirit:mask>0xffffffff</spirit:mask>
</spirit:reset>
</spirit:register>
<spirit:register>
<spirit:name>USB2_RX_0</spirit:name>
<spirit:description>Rx Channel Control Register 0</spirit:description>
<spirit:addressOffset>0X14</spirit:addressOffset>
<spirit:size>32</spirit:size>
<spirit:volatile>true</spirit:volatile>
<spirit:access>read-write</spirit:access>
<spirit:reset>
<spirit:value>0</spirit:value>
<spirit:mask>0xffffffff</spirit:mask>
</spirit:reset>
<spirit:field>
<spirit:name>CHIRPMODE_SEL</spirit:name>
<spirit:description>chirp mode selection  0 = normal chirp mode  1 = special chirp mode  marvell recommends normal chirp mode for normal usb operation.</spirit:description>
<spirit:bitOffset>29</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>SQ_ANA_DTC_SEL</spirit:name>
<spirit:description>analog squelch detect enable  0 = disable analog squelch detect  1 = enable analog squelch detect</spirit:description>
<spirit:bitOffset>28</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>SQ_ANA_VREF</spirit:name>
<spirit:description>analog squelch detect reference voltage  0x0 = dp/dm valley voltage plus 55 mv  0x1 = dp/dm valley voltage plus 60 mv  0x2 = dp/dm valley voltage plus 65 mv  0x3 = dp/dm valley voltage plus 70 mv</spirit:description>
<spirit:bitOffset>26</spirit:bitOffset>
<spirit:bitWidth>2</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>RESET_EXT</spirit:name>
<spirit:description>register reset signal  0 = no reset  1 = reset</spirit:description>
<spirit:bitOffset>25</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>RESET_EXT_EN</spirit:name>
<spirit:description>reset signal select  0 = select internal reset signal  1 = select reset_ext register</spirit:description>
<spirit:bitOffset>24</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>TESTMON</spirit:name>
<spirit:description>controls test_pin analog test point</spirit:description>
<spirit:bitOffset>20</spirit:bitOffset>
<spirit:bitWidth>4</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>STRESS_TEST_MODE</spirit:name>
<spirit:description>stress test mode  1 = stress test mode  0 = normal mode</spirit:description>
<spirit:bitOffset>19</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>SQ_VHL_SEL</spirit:name>
<spirit:description>sq threshold select  0 = vosl  1 = vosh</spirit:description>
<spirit:bitOffset>16</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>SQ_DET_EN</spirit:name>
<spirit:description>sq enable</spirit:description>
<spirit:bitOffset>15</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>SQ_CM_SEL</spirit:name>
<spirit:description>squelch and non-squelch threshold common mode  voltage moves down 120 mv to 240 mv.</spirit:description>
<spirit:bitOffset>14</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>SQ_DLY_SEL</spirit:name>
<spirit:description>sq delay select  0x0 = no delay  0x1 = delay 1 clock  0x2 = delay 2 clocks  0x3 = delay 3 clocks</spirit:description>
<spirit:bitOffset>12</spirit:bitOffset>
<spirit:bitWidth>2</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>LINESTATE_EN</spirit:name>
<spirit:description>linestate enable  always set to 1</spirit:description>
<spirit:bitOffset>10</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>DISCON_THRESH</spirit:name>
<spirit:description>host disconnect detector threshold select  thresh[1:0] vh (mv)  0x0 = 260  0x1 = 270  0x2 = 280  0x3 = 290  the envelope detector circuits only use half amplitude of the single-ended signal to compare with the threshold.</spirit:description>
<spirit:bitOffset>8</spirit:bitOffset>
<spirit:bitWidth>2</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>RXVDDL</spirit:name>
<spirit:description>rx regulator output voltage control  0x0 = vdd  0x1 = 1.1v  0x2 =1.2v  0x3 = 1.3v</spirit:description>
<spirit:bitOffset>6</spirit:bitOffset>
<spirit:bitWidth>2</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>RXVDD18</spirit:name>
<spirit:description>1.8v regulator voltage control</spirit:description>
<spirit:bitOffset>4</spirit:bitOffset>
<spirit:bitWidth>2</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>SQ_THRESH</spirit:name>
<spirit:description>squelch and un-squelch threshold select  th[3:0] vos v100h v150h vosl vosh (mv)  0x0 = 480 640 652.5 160 172.5  0x1 = 320 480 492.5 160 172.5  0x2 = 450 600 612.5 150 162.5  0x3 =300 450 462.5 150 162.5  0x4 =  420 560 572.5 140 152.5  0x5 = 280 420 432.5 140 152.5  0x6 = 390 520 532.5 130 142.5  0x7 = 260 390 402.5 130 142.5  0x8 = 360 480 492.5 120 132.5  0xa = 330 440 452.5 110 122.5  0xc = 300 400 412.5 100 112.5  0xd = 200 300 312.5 100 112.5  0xe = 270 360 372.5 90 102.5  0xf 180 270 282.5 90 102.5  vosh is the nominal squelch threshold. all other columns are for internal information only.</spirit:description>
<spirit:bitOffset>0</spirit:bitOffset>
<spirit:bitWidth>4</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
</spirit:register>
<spirit:register>
<spirit:name>USB2_RX_1</spirit:name>
<spirit:description>Rx Channel Control Register 1</spirit:description>
<spirit:addressOffset>0X18</spirit:addressOffset>
<spirit:size>32</spirit:size>
<spirit:volatile>true</spirit:volatile>
<spirit:access>read-write</spirit:access>
<spirit:reset>
<spirit:value>0</spirit:value>
<spirit:mask>0xffffffff</spirit:mask>
</spirit:reset>
<spirit:field>
<spirit:name>REG_SQCAL_DONE</spirit:name>
<spirit:description>squelch calibration done  this field indicates whether squelch calibration is done or not.  0 = not done  1 = done</spirit:description>
<spirit:bitOffset>31</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>SQ_DPDM_AMP_SEL</spirit:name>
<spirit:description>sq threshold select  0x0 = 130 mv  0x1 = 140 mv  0x2 = 150 mv  0x3 = 160 mv</spirit:description>
<spirit:bitOffset>6</spirit:bitOffset>
<spirit:bitWidth>2</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>REG_SQ_UD_SWAP</spirit:name>
<spirit:description>invert analog squelch calibration up/down signal polarity  0 = don’t invert  1 = invert</spirit:description>
<spirit:bitOffset>5</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>REG_SQCAL_START</spirit:name>
<spirit:description>squelch calibration start  every rising edge of this register bit starts squelch calibration.</spirit:description>
<spirit:bitOffset>4</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>EXT_SQ_AMP_CAL_EN</spirit:name>
<spirit:description>external squelch calibration enable</spirit:description>
<spirit:bitOffset>3</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>EXT_SQ_AMP_CAL</spirit:name>
<spirit:description>external squelch calibration number</spirit:description>
<spirit:bitOffset>0</spirit:bitOffset>
<spirit:bitWidth>3</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
</spirit:register>
<spirit:register>
<spirit:name>USB_DIG_0</spirit:name>
<spirit:description>Digital Control Register 0</spirit:description>
<spirit:addressOffset>0X1C</spirit:addressOffset>
<spirit:size>32</spirit:size>
<spirit:volatile>true</spirit:volatile>
<spirit:access>read-write</spirit:access>
<spirit:reset>
<spirit:value>0</spirit:value>
<spirit:mask>0xffffffff</spirit:mask>
</spirit:reset>
<spirit:field>
<spirit:name>BITSTAFFING_ERROR</spirit:name>
<spirit:description>hs bit stuffing error flag  write 1 to clear.</spirit:description>
<spirit:bitOffset>31</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>LOSS_OF_SYNC_ERROR</spirit:name>
<spirit:description>hs loss of sync error flag  write 1 to clear</spirit:description>
<spirit:bitOffset>30</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>FIFO_OVF_ERROR</spirit:name>
<spirit:description>hs rx fifo overflow error flag  write 1 to clear.</spirit:description>
<spirit:bitOffset>29</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>CORE_UTMI_SEL</spirit:name>
<spirit:description>utmi signal select  0 = allow reg_lat_utmi to work, actual utmi signals are not updated during packet is transferring  1 = always use utmi signals from controller.  this is the same as previous version.</spirit:description>
<spirit:bitOffset>26</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>SE1_FILT_SEL</spirit:name>
<spirit:description>linestate se1 filter select  0 = filter se1  1 = don’t filter</spirit:description>
<spirit:bitOffset>25</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>SE0_FILT_SEL</spirit:name>
<spirit:description>linestate se0 filter select  0 = filter se0  1 = don’t filter</spirit:description>
<spirit:bitOffset>24</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>EDGE_OPT_EN</spirit:name>
<spirit:description>edge optimization selection  0 = no edge optimization  1 = optimize edge</spirit:description>
<spirit:bitOffset>23</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>STOP_AT_RXERR</spirit:name>
<spirit:description>stop at rx_error selection  this field is used to select to stop rx when rx_error is detected or not.  0 = rx_active will last until sq = 1  1 = rx_active is de-asserted after rx error is found. the early_tx_enable bit must be set to 0.</spirit:description>
<spirit:bitOffset>22</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>RX_RUNAWAY_EN</spirit:name>
<spirit:description>rx run away enable  this field disables rx run away in case eop is not detected.  0 = rx run away is eliminated  1 = rx run away is allowed</spirit:description>
<spirit:bitOffset>21</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>LOSSOFSYNC_EN</spirit:name>
<spirit:description>loss of sync enable  this field enables loss of sync error to propagate to loss_of_sync_error register.  0 = disable  1 = enable</spirit:description>
<spirit:bitOffset>20</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>FIFOOVF_EN</spirit:name>
<spirit:description>fifo overflow error enable  this field enables fifo overflow error to propagate to rx_error.  0 = fifo_ovf will not assert rx_error  1 = enable</spirit:description>
<spirit:bitOffset>19</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>SQ_FILT</spirit:name>
<spirit:description>sq glitch filtering width select  this eliminates the glitch when sq = 0.  0x0 = no filtering  0x1 = filter 2 bits glitch  0x2 = filter 4 bits glitch  0x3 = filter 6 bits glitch  0x4 = filter 8 bits glitch  0x5 = filter 10 bits glitch  0x6 = filter 12 bits glitch  0x7 = filter 14 bits glitch</spirit:description>
<spirit:bitOffset>16</spirit:bitOffset>
<spirit:bitWidth>3</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>SQ_BLK</spirit:name>
<spirit:description>sq block  this field is used to set the hs data bits to block after sq falling edge.  0x0 = no blocking  0x1 = block 1 bit  0x2 = block 2 bits  0x3 = block 3 bits  0x4 = block 4 bits  0x5 = block 5 bits  0x6 = block 6 bits  0x7 = block 7 bits  the blocked data bits are ignored.</spirit:description>
<spirit:bitOffset>12</spirit:bitOffset>
<spirit:bitWidth>3</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>EARLY_TX_ENABLE</spirit:name>
<spirit:description>early tx enable  0 = after controller asserts tx_valid, phy will check usb bus squelch status. if it is squelch, tx will start immediately, otherwise, it will wait for squelch.  1 = hs tx will start after controller asserts tx_valid</spirit:description>
<spirit:bitOffset>11</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>RXFILT2_EN</spirit:name>
<spirit:description>rx filter 2 enable  0 = no filter2  1 = enable rx data sample filter2  data 001100 is corrected to 000000.  data 110011 is corrected to 111111</spirit:description>
<spirit:bitOffset>10</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>RXFILT1_EN</spirit:name>
<spirit:description>rx filter 1 enable  0 = no filter1  1 = enable rx data sample filter1  data 010 is corrected to 000.  data 101 is corrected to 111</spirit:description>
<spirit:bitOffset>9</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>LONG_EOP</spirit:name>
<spirit:description>long hs eop  compatible to old controller, hs eop is 40 bits long.</spirit:description>
<spirit:bitOffset>8</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>UTM_PLL_LOCK_BYPASS155</spirit:name>
<spirit:description>pll lock bypass  0 = output clk_out after pll is locked  1 = output clk_out after pll is on</spirit:description>
<spirit:bitOffset>7</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>CLK_SUSPEND_EN</spirit:name>
<spirit:description>clock suspend  0 = clk_out will be free-running clock  1 = enable utmi_suspendm to stop clk_out</spirit:description>
<spirit:bitOffset>6</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>HOST_DISCON_SEL1</spirit:name>
<spirit:description>host disconnect select 1  0 = enable suspend to gate off host_disconnect  1 = suspend does not gate off host_disconnect</spirit:description>
<spirit:bitOffset>5</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>HOST_DISCON_SEL0</spirit:name>
<spirit:description>host disconnect select 0  0 = sample hs_disconnect at the end of sof eop only  1 = sample hs_disconnect during the whole sof eop</spirit:description>
<spirit:bitOffset>4</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>SYNCDET_WINDOW_EN</spirit:name>
<spirit:description>sync detection window enable  this field defines a time window after non-squelch as sync detection period.  0 = detect sync as long as squelch = 0  1 = detect sync in the first 64 or 40 hs bits time after squelch = 0</spirit:description>
<spirit:bitOffset>3</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>SYNCDET_WIN32</spirit:name>
<spirit:description>sync detect window select  0 = 64-bit window after sq = 0  1 = 40-bit window after sq = 0</spirit:description>
<spirit:bitOffset>2</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>SYNC_NUM</spirit:name>
<spirit:description>minimum sync detect number of bits  0x0 = 00  0x1 = 0010  0x2 = 001010  0x3 = 00101010</spirit:description>
<spirit:bitOffset>0</spirit:bitOffset>
<spirit:bitWidth>2</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
</spirit:register>
<spirit:register>
<spirit:name>USB2_DIG_1</spirit:name>
<spirit:description>Digital Control Register 1</spirit:description>
<spirit:addressOffset>0X20</spirit:addressOffset>
<spirit:size>32</spirit:size>
<spirit:volatile>true</spirit:volatile>
<spirit:access>read-write</spirit:access>
<spirit:reset>
<spirit:value>0</spirit:value>
<spirit:mask>0xffffffff</spirit:mask>
</spirit:reset>
<spirit:field>
<spirit:name>REG_LSIDLE_PRE</spirit:name>
<spirit:description>fs/ls idle  0 = to drive fs idle after pre is sent  1 = to drive ls idle after pre is sent</spirit:description>
<spirit:bitOffset>30</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>REG_CLK_OUT_DLY</spirit:name>
<spirit:description>clk_out delay  to set clk_out delay after analog part is powered up or suspendm rising edge. clk_out will start to output xcvr_clk after delay defined by this register.  0x0 = no delay  0x1 = delay by 256 hs bit time  0x2 = delay by 512 hs bit time  0xbc = about 100.25 &lt;mu&gt;s  0xff = about 136 &lt;mu&gt;s</spirit:description>
<spirit:bitOffset>22</spirit:bitOffset>
<spirit:bitWidth>8</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>REG_SAMPLER_PREOFF</spirit:name>
<spirit:description>sampler pre shutoff  when reg_sampler_on=0, this bit controls if the sampler is turned off 2 hs bits before tx_enable=1  0 = sampler is off at tx_enable rising edge  1 = sampler is off 2 hs bits before tx_enable</spirit:description>
<spirit:bitOffset>21</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>REG_SAMPLER_ON</spirit:name>
<spirit:description>sampler control  to control if the sampler is always on or under register control.  0 = the rx sampler is controlled by reg_sampler_preoff and reg_sampleroff_dly [3:0]  1 = force sampler always on</spirit:description>
<spirit:bitOffset>20</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>REG_SAMPLEROFF_DLY</spirit:name>
<spirit:description>sampler off bits  when reg_sampler_on is 0, this bit controls the bits the sampler is turned off after tx_enable is 0. each step controls 2 hs bits off.  0x0 = sampler is turned on at tx_enable falling edge  0x1 = sampler is turned on 2 hs bits after tx_enable falling edge  0x8 = sampler is turned on 16 hs bits after tx_enable falling edge  0xf = sampler is turned on 30 hs bits after tx_enable falling edge</spirit:description>
<spirit:bitOffset>16</spirit:bitOffset>
<spirit:bitWidth>4</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>REG_SWAP_DPDM</spirit:name>
<spirit:description>swap dp/dm pad control  0 = dp/dm pads work as usb d+, d-  1 = dp/dm pads work as usb d-, d+</spirit:description>
<spirit:bitOffset>15</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>REG_LAT_UTMI</spirit:name>
<spirit:description>latch utmi xcvr_select, opmode, and term_select signals  0 = do not latch  1 = latch except during suspend</spirit:description>
<spirit:bitOffset>14</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>REG_OPMODE_SEL</spirit:name>
<spirit:description>opmode select  0 = use opmode from usb controller directly  1 = use opmode at tx_valid rising edge</spirit:description>
<spirit:bitOffset>13</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>REG_FLSMODELP_EN</spirit:name>
<spirit:description>fs/ls serial mode low power enable  0 = do not enable fs/ls serial mode low power  1 = enable</spirit:description>
<spirit:bitOffset>12</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>REG_FREERUNCLK_EN</spirit:name>
<spirit:description>static enable for free running clock output  0 = free running clock is disabled  1 = free running clock is enabled</spirit:description>
<spirit:bitOffset>11</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>REG_NOVBUS_DPDM00</spirit:name>
<spirit:description>dp/dm pull  when vbus is off:  0 = does not pull-down dp/dm pads  1 = pull-down dp/dm pads to 0  when vbus is off, dp/dm is pulled low by default</spirit:description>
<spirit:bitOffset>10</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>REG_FS_EOP_MODE</spirit:name>
<spirit:description>enable 1–3 se0 fs eop detection</spirit:description>
<spirit:bitOffset>7</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>REG_DP_PULLDOWN</spirit:name>
<spirit:description>pull-down dp  0 = no dp pull-down (default)  1 = manual dp pull-down</spirit:description>
<spirit:bitOffset>6</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>REG_DM_PULLDOWN</spirit:name>
<spirit:description>pull-down dm  0 = no dm pull-down (default)  1 = manual dp pull-down</spirit:description>
<spirit:bitOffset>5</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>REG_ARC_DPDM_MODE</spirit:name>
<spirit:description>use dp_pulldown and dm_pulldown from usb controller  0 = use register programmed pull-down  1 = user usb controller pull-down
(default)</spirit:description>
<spirit:bitOffset>4</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>REG_FS_RX_ERROR_MODE2</spirit:name>
<spirit:description>disable multiple fs_rx_error within packet</spirit:description>
<spirit:bitOffset>3</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>REG_FS_RX_ERROR_MODE1</spirit:name>
<spirit:description>enable fast fs_rx_error return to 0  valid only with reg_rx_error_mode is 1.</spirit:description>
<spirit:bitOffset>2</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>REG_FS_RX_ERROR_MODE</spirit:name>
<spirit:description>enable fs rx_error return to 0 at 1 fs bit time</spirit:description>
<spirit:bitOffset>1</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>REG_FORCE_END_EN</spirit:name>
<spirit:description>force rx_active enable  this field is used to enable force rx_active to 0 when there are consecutive bit-stuff errors with length over 14fs bits time.</spirit:description>
<spirit:bitOffset>0</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
</spirit:register>
<spirit:register>
<spirit:name>USB2_TEST_0</spirit:name>
<spirit:description>USB2 Test Control Register 0</spirit:description>
<spirit:addressOffset>0X24</spirit:addressOffset>
<spirit:size>32</spirit:size>
<spirit:volatile>true</spirit:volatile>
<spirit:access>read-write</spirit:access>
<spirit:reset>
<spirit:value>0</spirit:value>
<spirit:mask>0xffffffff</spirit:mask>
</spirit:reset>
<spirit:field>
<spirit:name>TEST_FAIL</spirit:name>
<spirit:description>test error flag  0 = error not occurred  1 = error occurred  this flag must be read after test_done changes from 0 to 1. otherwise the read value is undefined.</spirit:description>
<spirit:bitOffset>31</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>TEST_DONE</spirit:name>
<spirit:description>test finish indicator  0 = test not finished  1 = test finished  if test_done is not asserted after the time it should have been set, it is also a failed chip.</spirit:description>
<spirit:bitOffset>30</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>REG_TEST_EN</spirit:name>
<spirit:description>test enable  1 = start loopback test</spirit:description>
<spirit:bitOffset>29</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>REG_TEST_DIG_LPBK</spirit:name>
<spirit:description>enable digital loopback  0 = analog loopback  1 = digital loopback</spirit:description>
<spirit:bitOffset>28</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>REG_TEST_ANA_LPBK</spirit:name>
<spirit:description>enable analog loopback test mode</spirit:description>
<spirit:bitOffset>27</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>REG_TEST_BYPASS</spirit:name>
<spirit:description>enable bypass mode (bypass bitstuff/encoder)</spirit:description>
<spirit:bitOffset>26</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>REG_TEST_UTMI_SEL</spirit:name>
<spirit:description>enable utmi test registers  test_tx_bitstuff_en, test_suspendm, test_reset, test_term_select, test_xcvr_select, test_opmode.  this bit must be set to 0 for normal operation mode.</spirit:description>
<spirit:bitOffset>25</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>REG_TEST_TX_BITSTUFF_EN</spirit:name>
<spirit:description>utmi test mode tx_bitstuff_en</spirit:description>
<spirit:bitOffset>23</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>REG_TEST_SUSPENDM</spirit:name>
<spirit:description>utmi test mode suspendm</spirit:description>
<spirit:bitOffset>22</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>REG_TEST_RESET</spirit:name>
<spirit:description>utmi test mode reset</spirit:description>
<spirit:bitOffset>21</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>REG_TEST_TERM_SELECT</spirit:name>
<spirit:description>utmi test mode term_select</spirit:description>
<spirit:bitOffset>20</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>REG_TEST_XVCR_SELECT</spirit:name>
<spirit:description>utmi test mode xcvr_select</spirit:description>
<spirit:bitOffset>18</spirit:bitOffset>
<spirit:bitWidth>2</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>REG_TEST_OP_MODE</spirit:name>
<spirit:description>utmi test mode op_mode</spirit:description>
<spirit:bitOffset>16</spirit:bitOffset>
<spirit:bitWidth>2</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>REG_TEST_SKIP</spirit:name>
<spirit:description>digital loopback starting position  0x0 = no rotation  0x1 = rotate by 1-bit  0x2 = rotate by 2-bit  0x3 = rotate by 3-bit  0x4 = rotate by 4-bit  0x5 = rotate by 5-bit  0x6 = rotate by 6-bit  0x7 = rotate by 7-bit</spirit:description>
<spirit:bitOffset>12</spirit:bitOffset>
<spirit:bitWidth>3</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>REG_TEST_MODE</spirit:name>
<spirit:description>programmable predefined tx pattern  0x0 = use tx_pattern register  0x1 = incremental pattern. 00, 01, 02, …, ff, 00  0x2 = circular pattern = 01-&gt;02-&gt;04-&gt;08-&gt;10-&gt;20-&gt;40-&gt;80-&gt;01  0x3= prbs pattern</spirit:description>
<spirit:bitOffset>8</spirit:bitOffset>
<spirit:bitWidth>2</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>REG_TEST_TX_PATTERN</spirit:name>
<spirit:description>programmable tx pattern  for 16-bit mode, bits[15:8] pattern is the same as bits[7:0]. this pattern register is used when test_mode[1:0]=2’b00</spirit:description>
<spirit:bitOffset>0</spirit:bitOffset>
<spirit:bitWidth>8</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
</spirit:register>
<spirit:register>
<spirit:name>USB2_TEST_1</spirit:name>
<spirit:description>USB2 Test Control Register 1</spirit:description>
<spirit:addressOffset>0X28</spirit:addressOffset>
<spirit:size>32</spirit:size>
<spirit:volatile>true</spirit:volatile>
<spirit:access>read-write</spirit:access>
<spirit:reset>
<spirit:value>0</spirit:value>
<spirit:mask>0xffffffff</spirit:mask>
</spirit:reset>
<spirit:field>
<spirit:name>TEST_LEN</spirit:name>
<spirit:description>loopback test length  this is a new register for v2.0. the loopback test length can be any number of bytes from 1 to 2047.  0x00 = non-stop loopback test  0x01 to 0x7ff = 1 byte to 2047 bytes  it is recommended not to run loopback test longer than 1024 bytes.</spirit:description>
<spirit:bitOffset>0</spirit:bitOffset>
<spirit:bitWidth>11</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
</spirit:register>
<spirit:register>
<spirit:name>RSVD1</spirit:name>
<spirit:description>Reserved</spirit:description>
<spirit:addressOffset>0X2C</spirit:addressOffset>
<spirit:size>32</spirit:size>
<spirit:volatile>true</spirit:volatile>
<spirit:access>read-write</spirit:access>
<spirit:reset>
<spirit:value>0</spirit:value>
<spirit:mask>0xffffffff</spirit:mask>
</spirit:reset>
<spirit:field>
<spirit:name>USB_MON</spirit:name>
<spirit:description>usb2 phy mon_bus read out.</spirit:description>
<spirit:bitOffset>16</spirit:bitOffset>
<spirit:bitWidth>16</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>UTM_231</spirit:name>
<spirit:description>reserved for future use</spirit:description>
<spirit:bitOffset>0</spirit:bitOffset>
<spirit:bitWidth>16</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>REG_MON_SEL</spirit:name>
<spirit:description>phy_mon digital test bus select</spirit:description>
<spirit:bitOffset>0</spirit:bitOffset>
<spirit:bitWidth>16</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
</spirit:register>
<spirit:register>
<spirit:name>RSVD2</spirit:name>
<spirit:description>Reserved</spirit:description>
<spirit:addressOffset>0X30</spirit:addressOffset>
<spirit:size>32</spirit:size>
<spirit:volatile>true</spirit:volatile>
<spirit:access>read-write</spirit:access>
<spirit:reset>
<spirit:value>0</spirit:value>
<spirit:mask>0xffffffff</spirit:mask>
</spirit:reset>
</spirit:register>
<spirit:register>
<spirit:name>USB2_OTG</spirit:name>
<spirit:description>USB2OTG Control Register</spirit:description>
<spirit:addressOffset>0X34</spirit:addressOffset>
<spirit:size>32</spirit:size>
<spirit:volatile>true</spirit:volatile>
<spirit:access>read-write</spirit:access>
<spirit:reset>
<spirit:value>0</spirit:value>
<spirit:mask>0xffffffff</spirit:mask>
</spirit:reset>
<spirit:field>
<spirit:name>OTG_CONTROL_BY_PIN</spirit:name>
<spirit:description>otg control by pin  1 = otg power is controlled by pu pin. pu pin also controls rx/tx channel power  0=otg power is controlled by register bit
pu_otg</spirit:description>
<spirit:bitOffset>5</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>PU_OTG</spirit:name>
<spirit:description>power up otg  1= power up otg module if otg_by_pin=0  0=power down otg module if otg_by_pin=0  otg module is automatically turned off in iddq test mode or scan mode</spirit:description>
<spirit:bitOffset>4</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>TESTMON_OTG</spirit:name>
<spirit:description>otg analog dc testing output control register  it is forced to 0x0 in scan mode inside the phy bit[2:0] otg_tp value  0x0 or 0x1 = hz  0x4 = vbus_limit up to 1.2v  0x5 = v1p0 1.0v  0x6 = vpbs18 1.08v at tt, 1.8v  0x7 = vbus_quarter 1.25v at vbus=5v</spirit:description>
<spirit:bitOffset>0</spirit:bitOffset>
<spirit:bitWidth>3</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
</spirit:register>
<spirit:register>
<spirit:name>USB2_CHGDTC</spirit:name>
<spirit:description>USB2Charger Detector Control Register</spirit:description>
<spirit:addressOffset>0X38</spirit:addressOffset>
<spirit:size>32</spirit:size>
<spirit:volatile>true</spirit:volatile>
<spirit:access>read-write</spirit:access>
<spirit:reset>
<spirit:value>0</spirit:value>
<spirit:mask>0xffffffff</spirit:mask>
</spirit:reset>
<spirit:field>
<spirit:name>ENABLE_SWITCH_DM</spirit:name>
<spirit:description>control connection between charge detect circuit and dm port  0 = turn off the switch  1 = turn on the switch</spirit:description>
<spirit:bitOffset>13</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>ENABLE_SWITCH_DP</spirit:name>
<spirit:description>control connection between charge detect circuit and dp port  0 = turn off the switch  1 = turn on the switch</spirit:description>
<spirit:bitOffset>12</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>VSRC_CHARGE</spirit:name>
<spirit:description>controlled vsrc reference voltage  0x0 =  0.55v  0x1 = 0.6v (default)  0x2 = 0.65v  0x3 = 0.7v</spirit:description>
<spirit:bitOffset>10</spirit:bitOffset>
<spirit:bitWidth>2</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>VDAT_CHARGE</spirit:name>
<spirit:description>controlled vdat reference voltage  0x0 = 0.3v  0x1 = 0.325v (default)  0x2 = 0.35v  0x3 = 0.4v</spirit:description>
<spirit:bitOffset>8</spirit:bitOffset>
<spirit:bitWidth>2</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>CDP_DM_AUTO_SWITCH</spirit:name>
<spirit:description>dm control  1 = automatic turn on dm(d_minus) port switch when chg_dtc_out=1. this is for cdp detection only.  0 = dm switch still controlled by enable_switch_dm</spirit:description>
<spirit:bitOffset>7</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>DP_DM_SWAP_CTRL</spirit:name>
<spirit:description>dp/dm swap control  this bit is used for the charger detector.  0 = for portable device use. d+ is driven to 0.6v and d- is used to detect charger present or not.  1 = for downstream port charging. d- is driven to 0.6v and d+ is used to detect charger present or not</spirit:description>
<spirit:bitOffset>6</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>PU_CHRG_DTC</spirit:name>
<spirit:description>power-up signal for charge detect circuit  it is forced to 0 in scan mode or iddq test mode.  1 = power on  0 = power off  it is forced off in scan mode</spirit:description>
<spirit:bitOffset>5</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>PD_EN</spirit:name>
<spirit:description>portable device mode  1 = to turn on portable device mode  0 = turn off  it is forced off in scan mode</spirit:description>
<spirit:bitOffset>4</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>DCP_EN</spirit:name>
<spirit:description>dedicated charger port mode  1 = to turn on dedicated charger port mode  0 = turn off  it is forced off in scan mode</spirit:description>
<spirit:bitOffset>3</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>CDP_EN</spirit:name>
<spirit:description>charging downstream port mode  1 = to turn on charging downstream port mode  0 = turn off  it is forced off in scan mode</spirit:description>
<spirit:bitOffset>2</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>TESTMON_CHRGDTC</spirit:name>
<spirit:description>analog dc test control signal for charge detector  it is forced to  in scan mode.  0x0 = tri-state at test_pin  0x1 = vref_0p6v 0.6v  0x2 = vdat_ref 0.325v  0x3 = chrg_dtc_out “0 or dvdd”</spirit:description>
<spirit:bitOffset>0</spirit:bitOffset>
<spirit:bitWidth>2</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
</spirit:register>
<spirit:register>
<spirit:name>RSVD3</spirit:name>
<spirit:description>Reserved</spirit:description>
<spirit:addressOffset>0X3C</spirit:addressOffset>
<spirit:size>32</spirit:size>
<spirit:volatile>true</spirit:volatile>
<spirit:access>read-write</spirit:access>
<spirit:reset>
<spirit:value>0</spirit:value>
<spirit:mask>0xffffffff</spirit:mask>
</spirit:reset>
</spirit:register>
<spirit:register>
<spirit:name>IP_REVISION</spirit:name>
<spirit:description>IP Revision Register</spirit:description>
<spirit:addressOffset>0XC0</spirit:addressOffset>
<spirit:size>32</spirit:size>
<spirit:volatile>true</spirit:volatile>
<spirit:access>read-write</spirit:access>
<spirit:reset>
<spirit:value>0</spirit:value>
<spirit:mask>0xffffffff</spirit:mask>
</spirit:reset>
<spirit:field>
<spirit:name>PHY_IP_REVISION</spirit:name>
<spirit:description>read ip_revision[15:0]</spirit:description>
<spirit:bitOffset>16</spirit:bitOffset>
<spirit:bitWidth>16</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>IP_REVISION</spirit:name>
<spirit:description>read phy_ip_revision[15:0]</spirit:description>
<spirit:bitOffset>0</spirit:bitOffset>
<spirit:bitWidth>16</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
</spirit:register>
<spirit:register>
<spirit:name>USB_CTL</spirit:name>
<spirit:description>USB Control Register</spirit:description>
<spirit:addressOffset>0XC4</spirit:addressOffset>
<spirit:size>32</spirit:size>
<spirit:volatile>true</spirit:volatile>
<spirit:access>read-write</spirit:access>
<spirit:reset>
<spirit:value>0</spirit:value>
<spirit:mask>0xffffffff</spirit:mask>
</spirit:reset>
<spirit:field>
<spirit:name>M_VBUSVALID_M_BVALID_M_AVALID</spirit:name>
<spirit:description>m_vbusvalid/m_bvalid/m_avalid control  whether use vbusvalid/bvalid/avalid from phy or register control:  bit [30] = 1, use usb_ctl[29]/[28]/[27] to control m_vbusvalid/m_bvalid/m_avalid seperatly   bit [30] = 0, use vbusvalid/bvalid/avalid from otg phy to m_vbusvalid/m_bvalid/m_avalid seperatly</spirit:description>
<spirit:bitOffset>30</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>M_VBUSVALID</spirit:name>
<spirit:description>m_vbusvalid control:   bit [29] = 1, m_vbusvalid =1,  bit [29] = 0, m_vbusvalid =0. only valid when usb_ctl[30]=1.</spirit:description>
<spirit:bitOffset>29</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>M_BVALID</spirit:name>
<spirit:description>m_bvalid control:   bit [28] = 1, m_bvalid =1,  bit [28] = 0, m_bvalid =0. only valid when usb_ctl[30]=1.</spirit:description>
<spirit:bitOffset>28</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>M_AVALID</spirit:name>
<spirit:description>m_avalid control:   bit [27] = 1, m_avalid =1,   bit [27] = 0, m_avalid =0. only valid when usb_ctl[30]=1.</spirit:description>
<spirit:bitOffset>27</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>VBUSVALID295</spirit:name>
<spirit:description>phy vbus_on control :  bit [26] = 1,use m_avalid to control vbus_on  bit [26] = 0, don't us m_avalid to control vbus_on</spirit:description>
<spirit:bitOffset>26</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>VBUSVALID296</spirit:name>
<spirit:description>phy vbus_on control :  bit [25] = 1,use m_bvalid to control vbus_on  bit [25] = 0, don't us m_bvalid to control vbus_on</spirit:description>
<spirit:bitOffset>25</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>VBUSVALID297</spirit:name>
<spirit:description>phy vbus_on control :  bit [24] = 1,use m_vbusvalid to control vbus_on  bit [24] = 0, don't us m_vbusvalid to control vbus_on</spirit:description>
<spirit:bitOffset>24</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>VBUS_ON</spirit:name>
<spirit:description>phy vbus_on control :  bit [12] = 1, use bit[13] to control otg phy vbus_on  bit [12] = 0, use hw m_vbusvalid or m_bvalid or m_avalid  to vbus_on, according to bit[26:24] set.</spirit:description>
<spirit:bitOffset>12</spirit:bitOffset>
<spirit:bitWidth>2</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>OTG_SUSPENDM_EN</spirit:name>
<spirit:description>suspendm from otg controller will effect otg phy suspendm or not
1: when otg controller suspendm is not indicate phy suspend, phy will not suspend. when otg controller suspendm want phy suspend, then if phy suspend or not depend on icusb sph controller
0: suspendm of ogt phy will not be effected by otg controller</spirit:description>
<spirit:bitOffset>11</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>REG_XCVR_SELECT_1</spirit:name>
<spirit:description>register control to phy interface xcvr_select_1</spirit:description>
<spirit:bitOffset>10</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>REG_SEL</spirit:name>
<spirit:description>register select  1 = register bit used to control otg phy utmi  0 = controller controls otg phy utmi</spirit:description>
<spirit:bitOffset>8</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>REG_OPMODE</spirit:name>
<spirit:description>register control to phy interface op_mode</spirit:description>
<spirit:bitOffset>6</spirit:bitOffset>
<spirit:bitWidth>2</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>REG_TERM_SELECT</spirit:name>
<spirit:description>register control to phy interface term_select</spirit:description>
<spirit:bitOffset>5</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>REG_XCVR_SELECT_0</spirit:name>
<spirit:description>register control to phy interface xcvr_select_0</spirit:description>
<spirit:bitOffset>4</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>TEST_USB_MODE</spirit:name>
<spirit:description>internal debug mode</spirit:description>
<spirit:bitOffset>2</spirit:bitOffset>
<spirit:bitWidth>2</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>PU_PLL308</spirit:name>
<spirit:description>control to otg phy pu_pll pin</spirit:description>
<spirit:bitOffset>1</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>UTM_PU309</spirit:name>
<spirit:description>control to otg phy pu pin and pu_otg pin</spirit:description>
<spirit:bitOffset>0</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
</spirit:register>
<spirit:register>
<spirit:name>USB_INT_MISC</spirit:name>
<spirit:description>USB Int Misc Register</spirit:description>
<spirit:addressOffset>0XC8</spirit:addressOffset>
<spirit:size>32</spirit:size>
<spirit:volatile>true</spirit:volatile>
<spirit:access>read-write</spirit:access>
<spirit:reset>
<spirit:value>0</spirit:value>
<spirit:mask>0xffffffff</spirit:mask>
</spirit:reset>
<spirit:field>
<spirit:name>CHRG_INT_CLR</spirit:name>
<spirit:description>otg phy charge detection interrupt clear  1 = clear chrg detection interrupt  this bit will automatically return to 0 after programming to 0</spirit:description>
<spirit:bitOffset>6</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>CHRG_INT_EN</spirit:name>
<spirit:description>otg phy charger detection interrupt enable</spirit:description>
<spirit:bitOffset>5</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>CHRG_DTC_OUT</spirit:name>
<spirit:description>otg phy output chrg_dtc_out  chrg_dtc_out can reflect on this register bit</spirit:description>
<spirit:bitOffset>4</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>UTM_RESUME_INT320</spirit:name>
<spirit:description>usb resume interrupt status</spirit:description>
<spirit:bitOffset>3</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>VBUSDTC_OUT</spirit:name>
<spirit:description>otg phy output vbusdtc_out  vbusdtc_out can reflect on this register bit</spirit:description>
<spirit:bitOffset>2</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>USB_RESUME_INT_EN</spirit:name>
<spirit:description>usb resume interrupt enable</spirit:description>
<spirit:bitOffset>1</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>CORE_INTERRUPT</spirit:name>
<spirit:description>core interrupt  core interrupt is reflected on this register bit</spirit:description>
<spirit:bitOffset>0</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
</spirit:register>
<spirit:register>
<spirit:name>DBG_CTL</spirit:name>
<spirit:description>Debug Control Register</spirit:description>
<spirit:addressOffset>0XCC</spirit:addressOffset>
<spirit:size>32</spirit:size>
<spirit:volatile>true</spirit:volatile>
<spirit:access>read-write</spirit:access>
<spirit:reset>
<spirit:value>0</spirit:value>
<spirit:mask>0xffffffff</spirit:mask>
</spirit:reset>
<spirit:field>
<spirit:name>DBG_SEL</spirit:name>
<spirit:description>used for cw debug signal selection</spirit:description>
<spirit:bitOffset>0</spirit:bitOffset>
<spirit:bitWidth>32</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
</spirit:register>
<spirit:register>
<spirit:name>A_PHY1</spirit:name>
<spirit:description>A PHY 1 Register</spirit:description>
<spirit:addressOffset>0XD0</spirit:addressOffset>
<spirit:size>32</spirit:size>
<spirit:volatile>true</spirit:volatile>
<spirit:access>read-write</spirit:access>
<spirit:reset>
<spirit:value>0</spirit:value>
<spirit:mask>0xffffffff</spirit:mask>
</spirit:reset>
<spirit:field>
<spirit:name>CLK_SEL</spirit:name>
<spirit:description>pwrctl 32k clock selection  1 = use 32k clock for pwrctl  0 = use otg phy output 60m clock</spirit:description>
<spirit:bitOffset>10</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>UTM_XCVR_UDRDIS341</spirit:name>
<spirit:description>xcvr clock disable.
1= xcvr_clk sent to usb2 otg controller will be invalid</spirit:description>
<spirit:bitOffset>8</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>SRAM_RTC</spirit:name>
<spirit:description>software control to sram rtc</spirit:description>
<spirit:bitOffset>6</spirit:bitOffset>
<spirit:bitWidth>2</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>SRAM_WTC</spirit:name>
<spirit:description>software control to sram wtc</spirit:description>
<spirit:bitOffset>4</spirit:bitOffset>
<spirit:bitWidth>2</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>PU_SRAM_CTL</spirit:name>
<spirit:description>1: usb resume will valid pu_pll pin of otg phy</spirit:description>
<spirit:bitOffset>3</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>INT_MASK_SEL</spirit:name>
<spirit:description>usb interrupt mask select  1 = usb interrupt will be masked when there is no upstream write cycle and usb interrupt is low  0 = usb interupt will be sent out directly</spirit:description>
<spirit:bitOffset>2</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>SRAM_PDWN</spirit:name>
<spirit:description>software ccontrol to sram powerdown</spirit:description>
<spirit:bitOffset>1</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
</spirit:register>
<spirit:register>
<spirit:name>A_PHY2</spirit:name>
<spirit:description>A PHY 2 Register</spirit:description>
<spirit:addressOffset>0XD4</spirit:addressOffset>
<spirit:size>32</spirit:size>
<spirit:volatile>true</spirit:volatile>
<spirit:access>read-write</spirit:access>
<spirit:reset>
<spirit:value>0</spirit:value>
<spirit:mask>0xffffffff</spirit:mask>
</spirit:reset>
<spirit:field>
<spirit:name>TX_BITSTUFF_EN</spirit:name>
<spirit:description>control otg phy pin tx_bitstuff_en</spirit:description>
<spirit:bitOffset>0</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
</spirit:register>
</spirit:addressBlock>
</spirit:memoryMap>
</spirit:memoryMaps>
</spirit:component>