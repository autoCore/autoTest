config 16. 8.

tree "aibaux"

width 18.

group d:0xD401E800++0x03
    line.long 0x00 "AIB_NAND_IO_REG,AIB NAND I/O Domain Control Register"
        bitfld.long 0x00 6.--7. " AIB_NAND_IO_DCS  ,controls the output driver pull up/down network driven strength by selecting proper number of nmos/pmos fingers to turned on" "0,1,2,3"

group d:0xD401E804++0x03
    line.long 0x00 "AIB_ANT_IO_REG,AIB ANT I/O Domain Control Register"
        bitfld.long 0x00 3. " SL28             ,this field is the io input schmitt trigger control.   0 = disable    1 = enable" "0,1"
        bitfld.long 0x00 2. "     V18EN29  ,1.8v enable to pad   0 = 3.0v   1 = 1.8v" "0,1"
        bitfld.long 0x00 0. "  SL31  ,this field control the io output slew rate." "0,1"

group d:0xD401E808++0x03
    line.long 0x00 "AIB_GPIO1_IO_REG,AIB GPIO 1 I/O Domain Control Register"
        bitfld.long 0x00 6.--7. " AIB_GPIO_IO_DCS  ,controls the output driver pull up/down network driven strength by selecting proper number of nmos/pmos fingers to turned on" "0,1,2,3"

group d:0xD401E80C++0x03
    line.long 0x00 "AIB_GPIO2_IO_REG,AIB GPIO 2 I/O Domain Control Register"
        bitfld.long 0x00 2. " V18EN47          ,1.8v enable to pad" "0,1"
        bitfld.long 0x00 0. "     PDB      ,vddiox_pbgen pad power down  0 = power down" "0,1"

group d:0xD401E814++0x03
    line.long 0x00 "AIB_GPIO4_IO_REG,AIB GPIO4 I/O Domain Control Register"
        bitfld.long 0x00 6.--7. " AIB_GPIO4_IO_DCS ,controls the output driver pull up/down network driven strength by selecting proper number of nmos/pmos fingers to turned on" "0,1,2,3"

group d:0xD401E818++0x03
    line.long 0x00 "AIB_MEM_IO_REG,AIB MEM I/O Domain Control Register"

group d:0xD401E81C++0x03
    line.long 0x00 "AIB_MMC1_IO_REG,AIB MMC 1 I/O Domain Control Register"
        bitfld.long 0x00 3. " SL72             ,this field is the io input schmitt trigger control.   0 = disable    1 = enable" "0,1"
        bitfld.long 0x00 2. "     V18EN73  ,1.8v enable to pad   0 = 3.0v   1 = 1.8v" "0,1"
        bitfld.long 0x00 0. "  SL75  ,this field control the io output slew rate." "0,1"

group d:0xD401E824++0x03
    line.long 0x00 "AIB_PMIC1_IO_REG,AIB PMIC 1 I/O Domain Control Register"
        bitfld.long 0x00 6.--7. " AIB_PMIC1_IO_DCS ,controls the output driver pull up/down network driven strength by selecting proper number of nmos/pmos fingers to turned on" "0,1,2,3"

group d:0xD401E828++0x03
    line.long 0x00 "AIB_PMIC2_IO_REG,AIB PMIC 2 I/O Domain Control Register"
        bitfld.long 0x00 6.--7. " AIB_PMIC2_IO_DCS ,controls the output driver pull up/down network driven strength by selecting proper number of nmos/pmos fingers to turned on" "0,1,2,3"

group d:0xD401E82C++0x03
    line.long 0x00 "AIB_USIM_IO_REG,AIB USIM I/O Domain Control Register"
        bitfld.long 0x00 3. " SL99             ,this field is the io input schmitt trigger control.   0 = disable    1 = enable" "0,1"
        bitfld.long 0x00 2. "     V18EN100 ,1.8v enable to pad   0 = 3.0v   1 = 1.8v" "0,1"
        bitfld.long 0x00 0. "  SL102 ,this field control the io output slew rate." "0,1"

group d:0xD401E830++0x03
    line.long 0x00 "AIB_GPIO3_IO_REG,AIB GPIO3 I/O Domain Control Register"
        bitfld.long 0x00 6.--7. " AIB_GPIO3_IO_DCS ,controls the output driver pull up/down network driven strength by selecting proper number of nmos/pmos fingers to turned on" "0,1,2,3"

group d:0xD401EC00++0x03
    line.long 0x00 "AIB_AP_CFG_15_0,AIB AP config [15:0]"
        hexmask.long.word 0x00 0.--15. 1. " AIB_AP_CFG_15_0  ,aib ap_cfg override [15:0]"

group d:0xD401EC04++0x03
    line.long 0x00 "AIB_AP_CFG_31_16,AIB AP config [31:16]"
        hexmask.long.word 0x00 0.--15. 1. " AIB_AP_CFG_31_16 ,aib ap_cfg override [31:16]"

group d:0xD401EC08++0x03
    line.long 0x00 "AIB_AP_CFG_47_32,AIB AP config [47:32]"
        hexmask.long.word 0x00 0.--15. 1. " AIB_AP_CFG_47_32 ,aib ap_cfg override [47:32]"

group d:0xD401EC0C++0x03
    line.long 0x00 "AIB_AP_CFG_63_48,AIB AP config [63:48]"
        hexmask.long.word 0x00 0.--15. 1. " AIB_AP_CFG_63_48 ,aib ap_cfg override [63:48]"

group d:0xD401EC10++0x03
    line.long 0x00 "AIB_AP_CFG_79_64,AIB AP config [79:64]"
        hexmask.long.word 0x00 0.--15. 1. " AIB_AP_CFG_79_64 ,aib ap_cfg override [79:64]"

group d:0xD401EC14++0x03
    line.long 0x00 "AIB_CP_CFG_15_0,AIB CP config [15:0]"
        hexmask.long.word 0x00 0.--15. 1. " AIB_CP_CFG_15_0  ,aib cp_cfg override [15:0]"

tree.end

tree "rtc"

width 9.

group d:0xD4010000++0x03
    line.long 0x00 "RTC_CNR,RTC Counter Register"
        hexmask.long 0x00 0.--31. 1. " TC          ,time count"

group d:0xD4010004++0x03
    line.long 0x00 "RTC_AR,RTC Alarm Register"
        hexmask.long 0x00 0.--31. 1. " AT          ,alarm time"

group d:0xD4010008++0x03
    line.long 0x00 "RTC_SR,RTC Status Register"
        bitfld.long 0x00 3. " HZE         ,1-hz interrupt enable  0 = the 1-hz interrupt is not enabled  1 = the 1-hz interrupt is enabled" "0,1"
        bitfld.long 0x00 2. "         ALE   ,rtc alarm interrupt enable  0 = the rtc alarm interrupt is not enabled  1 = the rtc alarm interrupt is enabled  this interrupt must be cleared just prior to enabling it since it remembers past events (matches) even when not enabled." "0,1"
        bitfld.long 0x00 1. "     HZ      ,1-hz rising-edge detected  0 = no rising edge has been detected  1 = a rising edge has been detected and the <1-hz interrupt enable> field is set  writing 1 to this field clears the 1-hz level interrupt (rtc_hzclk and rtc_hzclk_int)." "0,1"
        bitfld.long 0x00 0. "     AL ,rtc alarm detected  0 = no alarm has been detected  1 = an alarm has been detected (rtc counter register matches rtc alarm register) and the <rtc alarm interrupt enable> field is set  writing 1s to this field clears the alarm level interrupt (rtc_slp_alarm)." "0,1"

group d:0xD401000C++0x03
    line.long 0x00 "RTC_TR,RTC Trim Register"
        bitfld.long 0x00 31. " LCK         ,locking bit for the trim value" "0,1"
        hexmask.long.word 0x00 16.--25. 1. "         D9_D0 ,trim delete count  this value represents the number of 32 khz clocks to delete when clock trimming begins."
        hexmask.long.word 0x00 0.--15. 1. "  C150_C0 ,clock divider count  this value is the integer portion of the clock trim logic."

group d:0xD4010010++0x03
    line.long 0x00 "RTC_PR,RTC Control Register"
        bitfld.long 0x00 0. " SW_ALARM    ,controls the alarm signal  0 = is off (alarm negated)  1 = is on (alarm asserted)" "0,1"

group d:0xD4010014++0x03
    line.long 0x00 "RTC_BRn,RTC Backup Registers"
        hexmask.long 0x00 0.--31. 1. " RTCS_DATA77 ,backup data"

tree.end

tree "dma"

width 16.

group d:0xD4000000++0x03
    line.long 0x00 "DMA_CSR015,DMA Channel Control/Status Registers 0-15"
        bitfld.long 0x00 31. " DM_RUN15                 ,run  this field allows software to start or stop the channel. if it is cleared in the middle of the burst, the burst is completed before the channel stops. setting this field starts the stopped channel.  if the channel is in a descriptor-fetch transfer and this field is set before writing a valid descriptor address to the dma descriptor address registers, no-descriptor fetch occurs.  this bit is reset as soon as it is cleared and when the channel stops normally. after the channel stops, the <stop interrupt> field is set. the <stop interrupt> field must be polled to read the channel status or to set the <stop interrupt enabled> field and expect an interrupt after the channel stops.  0 = stops the channel  1 = starts the channel" "0,1"
        bitfld.long 0x00 30. "         DM_NODESCFETCH16 ,no-descriptor fetch  this bit controls whether or not a channel has a descriptor. if this field is set, the channel is considered a simple channel with no descriptors. in this case, the dma does not initiate descriptor fetches when software sets the <run> field or when the byte count for the current transfer reaches zero.  to program the channel for a no-descriptor-fetch transfer, software must set, then write to the individual dma source address registers 0-31, dma target address registers 0-31, and dma command registers 0-31 for that channel. the dma descriptor address registers are not used in this mode and must not be written. the <run> field must be set to allow the channel to start the transfer.   if this field is cleared, the dmac initiates descriptor-fetches when software writes to the dma descriptor address registers, when the byte count for the current transfer reaches zero.  0 = descriptor-fetch transfer  1 = no-descriptor-fetch transfer" "0,1"
        bitfld.long 0x00 29. "   DM_STOPIRQEN17   ,stop interrupt enabled  this field enables the interrupt when the <stop interrupt> field is set. if this field is cleared, no interrupt is generated after the channel stops.  the <stop interrupt> field is set after system reset de-assertion. thus, if <stop interrupt> is set before the channel is started, an interrupt is generated.  0 = no interrupt if the channel is in uninitialized or stopped state  1 = interrupt enabled if the channel is in uninitialized or stopped state" "0,1"
        bitfld.long 0x00 28. "     DM_EORIRQEN18  ,setting the end-of-receive interrupt enable  this field triggers an interrupt on an eor condition. clearing this bit does not generate an eor-related interrupt.  0 = interrupt not triggered even if the <end of receive interrupt> field is set  1 = enable interrupt if <end of receive interrupt> is set" "0,1"
        textline "                          "
        bitfld.long 0x00 27. "DM_EORJMPEN19            ,jump to the next descriptor on eor  this field controls the descriptor flow when the mapped peripheral signals an eor to the dmac. see descriptor behavior on end-of-receive (eor) figure for the behavior of the descriptor during this condition.  this control bit has no effect on the channel for no-descriptor-fetch transfers (<no-descriptor fetch> set). the dmac completes the peripheral-to-memory data transfer on an eor, regardless of this field.  0 = dmac continues to hold the current descriptor and waits until the mapped peripheral makes another receive request.  1 = dmac jumps to the channel's next descriptor on receiving an eor from the mapped peripheral." "0,1"
        bitfld.long 0x00 26. "         DM_EORSTOPEN20   ,stop channel on eor  this field has no effect on the channel for no-descriptor-fetch transfers (<no-descriptor fetch> set). the dmac completes the peripheral-to-memory data transfer on an eor, regardless of this field.  setting this field causes the dmac to stop the channel on an eor and set the corresponding <stop interrupt> field. if the <stop interrupt enabled> field is set when this field is set, an interrupt occurs.  see descriptor behavior on end-of-receive (eor) figure for the behavior of the descriptor.  0 = dmac continues to hold the current descriptor and waits until the mapped peripheral makes another receive request.  1 = dmac stops the channel that received an eor from the mapped peripheral." "0,1"
        bitfld.long 0x00 25. "   DM_SETCMPST21    ,set descriptor compare status  this field partially controls <descriptor compare status>. setting this bit sets <descriptor compare status>. clearing this field has no effect on <descriptor compare status>. software can set the <descriptor compare status> even if the descriptor is not configured in the compare mode (<descriptor compare enable> field in dma command registers 0-31 = 0).   0 = no effect on <descriptor compare status>  1 = set <descriptor compare status>" "0,1"
        bitfld.long 0x00 24. "     DM_CLRCMPST22  ,clear descriptor compare status  this field partially controls <descriptor compare status>. setting this field clears <descriptor compare status>. clearing this field has no effect on <descriptor compare status>. software can set <descriptor compare status> even if the descriptor is not configured in the compare mode.  0 = no effect on <descriptor compare status>  1 = clear <descriptor compare status>" "0,1"
        textline "                          "
        bitfld.long 0x00 23. "DM_RASIRQEN23            ,request after channel stopped interrupt enable  0 = interrupt not triggered when a peripheral asserts a dma request after the channel has stopped  1 = set interrupt bit for that channel in the <channel interrupt> in the dma interrupt register when a peripheral asserts a dma request after the channel has stopped." "0,1"
        bitfld.long 0x00 22. "         DM_MASKRUN24     ,mask <run> during a programmed i/o write to this register  0 = software (programmed i/o write) can modify <run> during a write transaction  1 = software (programmed i/o write) can not modify <run> during a write transaction" "0,1"
        bitfld.long 0x00 21. "   LPAE_EN          ,long physical address extension enable this bit enable long physical address extension access. lpae_en bit applies to both descriptor mode and nondescriptor mode. 0 = lpae feature is disabled. for both descriptor mode, there is no need to program dma_dadr_h register. descriptors should still be 4 words(32bits per word, aligned on a 16-byte boundary in memory). for non-descriptor mode, there is no need to program dma_tadr_h and dma_sadr_h registers. sw need no change. 1 = lpae feature is enabled. for descriptor mode, sw must program dma_dadr_h register and prepare the 8 words (32bits per word, aligned on a 32-byte boundary in memory) descriptors in memory. for non-descriptor mode, sw must program dma_tadr_h and dma_sadr_h registers. lpae is a feature that can be turned on and off at any dma transfer. any non-lpae dma transfers can be interleaved with lpae dma transfers, or vice versa." "0,1"
        bitfld.long 0x00 10. "     DM_CMPST27     ,descriptor compare status  this field indicates the most recent status of the source and target compare operation. it is set on a successful compare of the source and target fields. an unsuccessful comparison clears it. refer to the description of <addrmode> in the dma command registers 0-31 for the various addressing modes used for this comparison. for details regarding the descriptor compare mode, refer to <descriptor compare enable> in the dma command registers 0 to 31.  the dmac updates cmpst only in descriptor compare mode (<descriptor compare enable> = 1).  this field can be set and cleared by setting <set descriptor compare status> and <clear descriptor compare status>, respectively.  if software attempts to concurrently set and clear this field by setting both <set descriptor compare status> and <clear descriptor compare status>, <set descriptor compare status> has higher precedence. modifying this bit after <run> is set and the channel is actively running leads to faulty behavior of the descriptor chain. the channel must be stopped before setting or clearing this field.  0 = indicates an unsuccessful address compare in descriptor-compare mode.  1 = indicates a successful compare of the current descriptor source and target addresses in descriptor-compare mode." "0,1"
        textline "                          "
        bitfld.long 0x00 9. "DM_EORINT28              ,end of receive interrupt  eorint pertains only to internal peripherals. this field indicates the status of the mapped peripheral's receive data. it is set after the dmac reads out the last trailing sample from the peripheral's receive fifo. the descriptor behavior on end-of-receive (eor) figure illustrates the behavior of the descriptor during this condition.  0 = dma continues with current descriptor because the internal peripheral is still actively receiving data  1 = channel mapped internal peripheral has no data remaining in its receive fifo and has completed all receive transactions. refer to the description of <jump to the next descriptor on eor> for the behavior of the dmac during this condition." "0,1"
        bitfld.long 0x00 8. "         DM_REQPEND30     ,request pending  this field indicates a pending request for the dma channel.  reqpend is cleared for a channel if that channel has no pending request or the request has just been issued to the memory interface in case of a read or write from the external companion chip to memory.   if dreq assertion sets reqpend and <run> is cleared to stop that channel, reqpend and the internal registers that hold the dreq assertion information, do not remain set. if the channel is restarted, reqpend must be reset by a descriptor that transfers dummy data (for example, a memory-to-memory transfer from a temporary location to another temporary location).   0 = no request is pending for the channel  1 = a request is pending for the channel" "0,1"
        bitfld.long 0x00 4. "   DM_RASINTR32     ,request after channel stopped  0 = no interrupt   1 = interrupt caused due to a request made by the peripheral after the respective channel stopped  this bit is reset by writing a 1." "0,1"
        bitfld.long 0x00 3. "     DM_STOPINTR33  ,stop interrupt  this is a read-only bit that reflects the channel state.  software must clear <stop interrupt enabled> to reset the interrupt. reprogramming the dma descriptor address registers and setting <run> restarts the channel.  0 = channel is running  1 = channel is in uninitialized or stopped state. if <stop interrupt enabled> is set, the dmac generates an interrupt." "0,1"
        textline "                          "
        bitfld.long 0x00 2. "DM_ENDINTR34             ,end interrupt  this field indicates that the current descriptor finished successfully and that <end interrupt enable> in the dma command registers 0-31 is set.   0 = no interrupt  1 = interrupt was caused due to successful completion of the current transaction and <length of the transfer in bytes> field in dma command registers 0-31 = 0" "0,1"
        bitfld.long 0x00 1. "         DM_STARTINTR35   ,start interrupt  this field indicates that the current descriptor was loaded successfully and that <startirqen> in the dma command registers 0-31 is set.   0 = no interrupt  1 = interrupt was caused due to successful descriptor fetch" "0,1"
        bitfld.long 0x00 0. "   DM_BUSERRINTR36  ,bus error interrupt  this field indicates that an error occurred during a data transfer on the internal bus. the error may be due to a bad descriptor source or target address (any address that is in the non-burstable or reserved space can cause a bus error on the system bus). only one error per channel is logged. the channel that caused the error is not updated at the end of the transfer and is not accessible until it is reprogrammed and the corresponding <run> field is set.  0 = no interrupt  1 = interrupt was caused by bus error" "0,1"

group d:0xD40000A0++0x03
    line.long 0x00 "DMA_ALGN,DMA Alignment Register"
        hexmask.long.word 0x00 0.--15. 1. " DM_DALGNX53              ,alignment control for channel x  0 = source and target addresses of channel x are default aligned (internal peripherals default to 4 byte alignment, external bus addresses default to 8 byte alignment)  1 = source and target addresses of channel x are as defined by user (byte aligned)"

group d:0xD40000A4++0x03
    line.long 0x00 "DMA_PCSR,DMA Programmed I/O Control Status Register"
        bitfld.long 0x00 31. " DM_BRGSPLIT71            ,activate posted writes and split reads  0 = de-activate posted writes, split responses, split completions and retries.  activate posted writes, split responses, split completions and retries." "0,1"
        bitfld.long 0x00 0. "         DM_BRGBUSY74     ,bridge busy status  0 = no pending pio transactions across peripheral bus. a new pio transaction is not retried in this case.  1 = pending pio transaction across peripheral bus. any further pio transactions on the system bus are retried." "0,1"

group d:0xD40000E0++0x03
    line.long 0x00 "DMA_RQSR0,DREQ Status Register 0"
        bitfld.long 0x00 8. " DM_CLR88                 ,clearing pending request  writing 0x1 to this field clears the <request pending> field and thereby clears all pending requests made by the external dma request pin dreq. writing 0x0 to this field has no effect. this field can be used for clearing the requests if the channel mapped to dreq was prematurely stopped by software. this field must be set only after the mapped channel has stopped (<stop interrupt> field in the dma channel control/status registers 0-15 is set). clearing the requests of a running channel results in unpredictable behavior.  0 = no effect on <request pending>  1 = clear all pending requests registered in <request pending>" "0,1"
        bitfld.long 0x00 0.--4. "         DM_REQPEND90     ,request pending  indicates the number of pending requests on dreq." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"

group d:0xD40000F0++0x03
    line.long 0x00 "DMA_INT,DMA Interrupt Register"
        hexmask.long.word 0x00 0.--15. 1. " DM_CHLINTRX105           ,channel interrupt  this field indicates that dma channel x has been interrupted.  0 = no interrupt  1 = interrupt"

group d:0xD4000100++0x03
    line.long 0x00 "DMA_RCMRx,DMA Request to Channel Map Registers 0-51"
        bitfld.long 0x00 7. " DM_MAPVLD115             ,map valid channel  defines whether the request is mapped to a valid channel. if the field is set, the request is mapped to a valid channel indicated by <channel number>. if the field is cleared, the request is unmapped.  this bit can also be used to mask the request.  0 = request is unmapped  1 = request is mapped to a valid channel indicated by <channel number>" "0,1"
        bitfld.long 0x00 0.--4. "         DM_CHLNUM117     ,channel number  indicates the valid channel number if <map valid channel> is set. do not map two active requests to the same channel since it produces unpredictable results." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"

group d:0xD4000200++0x03
    line.long 0x00 "DMA_DADRx,DMA Descriptor Address Registers 0-15"
        hexmask.long 0x00 4.--31. 1. " DM_DESCRIPTOR_ADDRESS132 ,descriptor address  contains address of next descriptor."
        bitfld.long 0x00 1. "  DM_BREN134       ,enable descriptor branch  works with the <descriptor compare status> field in the dma channel control/status registers 0-31 to determine which descriptor is fetched next. if both this field and <descriptor compare status> are set, the dmac fetches the next descriptor from (ddadrx + 32 bytes). if either of the bits is cleared, dmac fetches the next descriptor from the dma descriptor address registers.  this field is relevant only for descriptor-fetch transactions (<no-descriptor fetch> field in the dma channel control/status registers 0-31 = 0).  see dreq timing requirements figure for details about the operational flow.  0 = disable descriptor branching. fetch the next descriptor from register ddadrx.  1 = enable descriptor branching" "0,1"
        bitfld.long 0x00 0. "   DM_STOP135       ,stop  if this field is cleared, a new descriptor fetch based on dma descriptor address registers and other control information is initiated after the current descriptor is completely processed.  0 = run channel  1 = stop channel after completely processing this descriptor and before fetching the next descriptor (<length of the transfer in bytes> field in dma command registers 0-31 = 0)" "0,1"

group d:0xD4000204++0x03
    line.long 0x00 "DMA_SADRx,DMA Source Address Registers 0-15"
        hexmask.long 0x00 3.--31. 1. " DM_SRCADDR152            ,source address  source address of the on-chip peripheral, external peripheral, companion chip, or address of a memory location"
        bitfld.long 0x00 2. "  DM_SRCADDR2153   ,srcaddr[2] if <source address> is a memory location and alignment register is configured. see dma alignment register for programming details and restrictions.  srcaddr[2] if <source address> is an on-chip peripheral.  reserved for all companion-chip or external peripheral-related transfers.  reserved for special dma modes, such as compare modes." "0,1"
        bitfld.long 0x00 0.--1. "   DM_SRCADDR0154   ,srcaddr[1:0] if <source address> is a memory location and alignment register is configured. see dma alignment register for programming details and restrictions.  reserved if <source address> is an on-chip peripheral.  reserved for all companion-chip or external peripheral related transfers.  reserved for special dma modes, such as compare modes." "0,1,2,3"

group d:0xD4000208++0x03
    line.long 0x00 "DMA_TADRx,DMA Target Address Registers 0-15"
        hexmask.long 0x00 3.--31. 1. " DM_TRGADDR171            ,target address  target address of the on-chip peripheral, external peripheral, companion chip, or address of a memory location"
        bitfld.long 0x00 2. "  DM_TRGADDR2172   ,trgaddr[2] if <target address> is a memory location and alignment register is configured. see dma alignment register for programming details and restrictions.  trgaddr[2] if <target address> is an on-chip peripheral.  reserved for all companion-chip or external peripheral-related transfers.  reserved for special dma modes, such as compare modes." "0,1"
        bitfld.long 0x00 0.--1. "   DM_TRGADDR0173   ,trgaddr[1:0], if target address is a memory location and alignment register is configured. see dma alignment register for programming details and restrictions.  reserved if target address is an on-chip peripheral.  reserved for all companion-chip or external peripheral related transfers.  reserved for special dma modes, such as compare modes." "0,1,2,3"

group d:0xD400020C++0x03
    line.long 0x00 "DMA_CMDx,DMA Command Registers 0-15"
        bitfld.long 0x00 31. " DM_INCSRCADDR187         ,source address increment  if the source address is an internal peripheral fifo address or external i/o address, the address is not incremented on each successive access. in these cases, this field must be cleared.  0 = do not increment source address  1 = increment source address" "0,1"
        bitfld.long 0x00 30. "         DM_INCTRGADDR188 ,target address increment  if the target address is an internal peripheral fifo address or external i/o address, the address is not incremented on each successive accesses. in these cases, this field must be cleared.  0 = do not increment target address  1 = increment target address" "0,1"
        bitfld.long 0x00 29. "   DM_FLOWSRC189    ,source flow control  the flow control of the source bit must be set if the source is an on-chip peripheral or external companion chip.  setting both this field and <target flow control> causes unpredictable behavior.  0 = do not wait for request signals associated with this channel  1 = wait for a request signal before initiating the data transfer" "0,1"
        bitfld.long 0x00 28. "     DM_FLOWTRG190  ,target flow control  the flow control of the target bit must be set if the target is an on-chip peripheral or external companion chip.  setting both the <source flow control> and this field causes unpredictable behavior.  0 = do not wait for request signals associated with this channel  1 = wait for a request signal before initiating the data transfer" "0,1"
        textline "                          "
        bitfld.long 0x00 25. "DM_CMPEN192              ,descriptor compare enable  this field must be cleared for normal dma operations.  setting the field enables the descriptor-compare mode, in which the dmac treats the current descriptor as a special case and compares data that corresponds to the source and target fields.   <addrmode> is used to determine the addressing mode before the compare operation.  0 = dma does not perform any address-compare operations  1 = dma recognizes the current descriptor as a special case and compares data based on the source address and target address fields. if the compare is true, the channel's <descriptor compare status> field in the dma channel control/status registers 0-31 is set. if the compare is false, <descriptor compare status> is cleared." "0,1"
        bitfld.long 0x00 23. "         DM_ADDRMODE194   ,addressing mode  this field controls the addressing mode for descriptor comparison and is valid only in the descriptor compare mode (<descriptor compare enable> = 1).  reserved if <descriptor compare enable> = 0.  if <descriptor compare enable> is set, the bits specify the addressing modes of the source address and target address fields. if either field contains an address, the dmac fetches the data at that address and uses it for the compare operation.  0 = source address field contains address, and target address field contains address  1 = source address field contains address, and target address field contains data  if dalgnx is clear, then the lowest three bits of immediate data are forced to be 0 before comparison. if dalgnx is set, then the lowest three bits of immediate data are not forced to be 0 before comparison." "0,1"
        bitfld.long 0x00 22. "   DM_STARTIRQEN195 ,start interrupt enable  this field indicates that the interrupt is enabled as soon as the descriptor is loaded.   in no-descriptor-fetch transfers, this field is reserved.  0 = interrupt not triggered after descriptor is loaded  1 = set interrupt bit for that channel in the <channel interrupt> field in the dma interrupt register when the descriptor (4 words) for the channel is loaded" "0,1"
        bitfld.long 0x00 21. "     DM_ENDIRQEN196 ,end interrupt enable  0 = interrupt is not triggered when length decrements to zero.  1 = set the dint interrupt bit for the channel when length decrements to zero." "0,1"
        textline "                          "
        bitfld.long 0x00 16.--18. "DM_SIZE198               ,maximum burst size  maximum burst size of each data transfer  0x0 = reserved  0x1 = 8 bytes  0x2 = 16 bytes  0x3 = 32 bytes  0x4 = 64 bytes  the size must be less than or equal to the serviced peripheral fifo trigger threshold to properly handle the respective fifo trailing bytes." "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 14.--15. "         DM_WIDTH199      ,width of the on-chip peripheral  this field is reserved for operations that do not involve on-chip peripherals, such as memory-to-memory moves and companion-chip-related operations.  width must be 0x0 for memory-to-memory moves or companion-chip-related operations.  0x0 = reserved for on-chip peripheral-related transactions  0x1 = 1 byte  0x2 = half-word (2 bytes)  0x3 = word (4 bytes)" "0,1,2,3"
        hexmask.long.word 0x00 0.--12. 1. "   DM_LEN201        ,length of the transfer in bytes  this field is the length of transfer in bytes. len = 0 means zero bytes for descriptor-fetch transactions. len = 0 is an invalid setting for no-descriptor-fetch transactions. programming len = 0 in the descriptor-fetch mode when <descriptor compare enable> is clear (normal data transfer mode) causes the channel to immediately discard the descriptor after it is fetched from memory. if the descriptor chain has more descriptors, the channel fetches the next valid descriptor. the channel stops if the descriptor chain has no more descriptors. the maximum transfer length is (8k-1) bytes.  if the transfer is of the memory-to-memory type, the length of the transfer may be any value (except for the len = 0 restriction in no-descriptor-fetch mode) up to a maximum of (8k -1) bytes. if the transfer involves an external peripheral (or a companion chip), then the length of the transfer must be an integer multiple of the peripheral fifo threshold (or water-mark).  if the transfer involves any of the on-chip peripherals, the length of the transfer must be as follows:"

group d:0xD4000300++0x03
    line.long 0x00 "DMA_DADR_Hx,DMA Descriptor Address Higher Bits Registers 0-15"
        hexmask.long.byte 0x00 0.--7. 1. " DESCRIPTOR_ADDRESS_H     ,descriptor address higher bits [39:32]. contains address of next descriptor higher bits [39:32]"

group d:0xD4000304++0x03
    line.long 0x00 "DMA_SADR_Hx,DMA Source Address Higher Bits Registers 0-15"
        hexmask.long.byte 0x00 0.--7. 1. " SOURCE_ADDRESS_H         ,source address higher bits source address higher bits[39:32] contains address of source higher bits[39:32]."

group d:0xD4000308++0x03
    line.long 0x00 "DMA_TADR_Hx,DMA Target Address Higher Bits Registers 0-15"
        hexmask.long.byte 0x00 0.--7. 1. " TARGET_ADDRESS_H         ,target address higher bits target address higher bits[39:32] contains address of target higher bits[39:32]."

group d:0xD4000000++0x03
    line.long 0x00 "DUMMY_REGISTER,This is a Dummy Register"
        hexmask.long 0x00 0.--31. 1. " DM_DUMMY250              ,this is a dummy register used as a workaround to fix an issue with the rev 2.21 perl script that requires another register follow the last include file (shown above). ignore this register as it will not show up in documentation anyway. (mclark)"

tree.end

tree "ipc"

width 10.

group d:0xD401D000++0x03
    line.long 0x00 "IPC_DW,Dummy Write Register"
        hexmask.long 0x00 0.--31. 1. " APB_IPC_DW   ,some ipc register need an dummy write operation before an read operation."

group d:0xD401D004++0x03
    line.long 0x00 "IPC_WDR,Write Data Register"
        hexmask.long 0x00 0.--31. 1. " APB_IPC_WDR  ,write data  includes a 32-bit control word to be transferred to the other side (that will be polling it). the content of this word is defined by application."

group d:0xD401D008++0x03
    line.long 0x00 "IPC_ISRW,Interrupt Set Register Write"
        hexmask.long.word 0x00 0.--15. 1. " APB_IPC_ISRW ,interrupt set  this register allows setting four different interrupts in the other side's interrupt controller.  an interrupt can be set by writing 1 to the corresponding interrupt bit in this register, as described below:"

group d:0xD401D00C++0x03
    line.long 0x00 "IPC_ICR,Interrupt Clear Register"
        hexmask.long.word 0x00 0.--15. 1. " APB_IPC_ICR  ,interrupt clear  this register is used to clear an interrupt which was asserted by the other side, by writing 1 to the corresponding interrupt bit in this register (no need to write 0 after 1)."

group d:0xD401D010++0x03
    line.long 0x00 "IPC_IIR,Interrupt Identification Register"
        hexmask.long.word 0x00 0.--15. 1. " APB_IPC_IIR  ,interrupt identification  this register is used to read the interrupt source received from the other side. if the ipc was identified as the interrupt source, one may read the interrupt identification register and identify which one of the 11 possible ipc interrupts was asserted.   note that when [10:8] were the only bits to be asserted, reading the interrupt identification register is redundant, since there is a one-to-one mapping between the interrupt source and interrupt representation on the interrupt identification register. however, when the received interrupt is <q>data_ack</q> interrupt, one must read the interrupt identification register in order to identify the interrupt cause.  note that before reading this register, one must perform a <q>dummy</q> write operation (to ipc_dw register) that latches the data to the read register. without performing the <q>write before read</q> operation, data will not be updated and old data will be read."

group d:0xD401D014++0x03
    line.long 0x00 "IPC_RDR,Read Data Register"
        hexmask.long 0x00 0.--31. 1. " APB_IPC_RDR  ,read data  this register is used to poll the write data register of the other side.   note that before reading this register, one must perform a <q>dummy</q> write operation (to ipc_dw register) that latches the data to the read register. without performing the <q>write before read</q> operation, data will not be updated and old data will be read."

tree.end

tree "tsen"

width 16.

group d:0xD4013300++0x03
    line.long 0x00 "TSEN_PCTRL,TSEN PIN Control Register"
        bitfld.long 0x00 22. " TEMP_DATA_OUTPUT_MODE ,0: result with coefficient multiply; 1: result is original adc output." "0,1"
        bitfld.long 0x00 15.--17. "     VTEST_SEL2     ,second time input voltage (0.5v ~1.2v) control.  generate different internal voltage for adc self-test; no use for normal operation mode." "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 12.--14. "     VTEST_SEL1  ,first time input voltage (0.5v ~1.2v) control.  generate different internal voltage for adc self-test; no use for normal operation mode." "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 7. "   TSEN_RAW_SEL ,sd-adc dither control 1:en_dither 0:enn_dither default:1" "0,1"
        textline "                          "
        bitfld.long 0x00 4.--6. "BJT_SEL               ,000-default internal bjt, otherwise, external bjt" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 3. "     TSEN_ISO_EN    ,dvdd and avdd18 domain isolation enable bit.   ‘0’: normal operation  ‘1’: isolate dvdd and avdd18 power domain" "0,1"
        bitfld.long 0x00 3. "     TEMP_MODE   ,0-single test, 1-consecutive test" "0,1"
        bitfld.long 0x00 1.--2. "   INPUT_SEL    ,selectsd-adc input: 00：sensor input  01：short input 10:part of vref 11:outchip input" "0,1,2,3"
        textline "                          "
        bitfld.long 0x00 0. "EN_SENSOR             ,sensor power up 1:power-up 0:power-down" "0,1"

group d:0xD4013304++0x03
    line.long 0x00 "TSEN_INT_CLR,TSEN INTERRUPT CLEAR Register"
        bitfld.long 0x00 0. " TSEN_INT_CLR          ,interrupt clear. write 1 to clear interrupt" "0,1"

group d:0xD4013308++0x03
    line.long 0x00 "TSEN_INT_MASK,TSEN INTERRUPT MASK Register"
        bitfld.long 0x00 0. " TSEN_INT_MASK         ,interrupt clear. write 1 to mask interrupt" "0,1"

group d:0xD4013314++0x03
    line.long 0x00 "TSEN_READ_DATA,TSEN READ DATA Register"
        hexmask.long.word 0x00 16.--31. 1. " TSE_46                ,"
        hexmask.long.word 0x00 0.--15. 1. "  TSEN_READ_DATA ,tsensor result"

group d:0xD4013318++0x03
    line.long 0x00 "TSEN_TIME_CTRL,TSEN TIME CONTROL Register"
        hexmask.long.byte 0x00 24.--31. 1. " TSE_54                ,"
        hexmask.long.word 0x00 8.--23. 1. "    FILTER_PERIOD  ,filter sample period.  based on 4mhz clk cycle"
        bitfld.long 0x00 4.--7. "  RST_ADC_CNT ,reset wait time" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 0.--3. "  WAIT_REF_CNT ,reset reference time" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"

tree.end

tree "twsi"

width 17.

group d:0xD4011000++0x03
    line.long 0x00 "TWSI_CR,Standard TWSI Register"
        bitfld.long 0x00 31. " RXOV_IE       ,receive fifo overrun interrupt enable  0 = receive fifo overrun (isr[rxov]) interrupt is not enabled  1 = receive fifo overrun (isr[rxov]) interrupt is enabled" "0,1"
        bitfld.long 0x00 30. "         RXF_IE         ,receive fifo full interrupt enable  0 = receive fifo full (isr[rxf]) interrupt is not enabled  1 = receive fifo full (isr[rxf]) interrupt is enabled" "0,1"
        bitfld.long 0x00 29. "     RXHF_IE           ,receive fifo half full interrupt enable  0 = receive fifo half full (isr[rxhf]) interrupt is not enabled  1 = receive fifo half full (isr[rxhf]) interrupt is enabled" "0,1"
        bitfld.long 0x00 28. "     TXE_IE         ,transmit fifo empty interrupt enable  0 = transmit fifo empty (isr[txe]) interrupt is not enabled  1 = transmit fifo empty (isr[txe]) interrupt is enabled" "0,1"
        textline "                           "
        bitfld.long 0x00 27. "TXDONE_IE     ,transaction done interrupt enable  0 = transaction done (isr[txd]) interrupt is not enabled.  1 = transaction done (isr[txd]) interrupt is enabled." "0,1"
        bitfld.long 0x00 26. "         MSDE           ,master stop detected enable:  0 = master stop detect (isr[msd]) status is not enabled.  1 = master stop detect (isr[msd]) status is enabled." "0,1"
        bitfld.long 0x00 25. "     MSDIE             ,master stop detected interrupt enable:  0 = disable interrupt.  1 = enables the twsi unit to interrupt the <var product number> upon detecting a master stop sent by the twsi unit." "0,1"
        bitfld.long 0x00 24. "     SSDIE          ,slave stop detected interrupt enable:  0 = disable interrupt.  1 = enables the twsi to interrupt the <var product number> when it detects a stop condition while in slave mode." "0,1"
        textline "                           "
        bitfld.long 0x00 23. "SADIE         ,slave address detected interrupt enable:  0 = disable interrupt.  1 = enables the twsi to interrupt the <var product number> upon detecting a slave address match or a general call address." "0,1"
        bitfld.long 0x00 22. "         BEIE           ,bus error interrupt enable:  0 = disable interrupt.  1 = enables the twsi to interrupt the <var product number> for the following twsi bus errors:" "0,1"
        bitfld.long 0x00 21. "     GCD               ,general call disable:  0 = enable the twsi to respond to general call messages.  1 = disable twsi response to general call messages as a slave.  this bit must be set when sending a master mode general call message from the twsi." "0,1"
        bitfld.long 0x00 20. "     DRFIE          ,dbr receive full interrupt enable:  0 = disable interrupt.  1 = enables the twsi to interrupt the <var product number> when the idbr has received a data byte from the twsi bus." "0,1"
        textline "                           "
        bitfld.long 0x00 19. "ITEIE         ,idbr transmit empty interrupt enable:  0 = disable interrupt.  1 = enables the twsi to interrupt the <var product number> after transmitting a byte onto the twsi bus." "0,1"
        bitfld.long 0x00 18. "         ALDIE          ,arbitration loss detected interrupt enable:  0 = disable interrupt.  1 = enables the twsi to interrupt the <var product number> upon losing arbitration while in master mode." "0,1"
        bitfld.long 0x00 15.--17. "     TWSI0_41          ,reserved" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 14. "     IUE            ,twsi unit enable:  0 = disables the unit and does not master any transactions or respond to any slave transactions.  1 = enables the twsi (defaults to slave-receive mode).  software must guarantee the twsi bus is idle before setting this bit.  software must guarantee that the internal clock to the twsi unit is enabled (d0cken_b[4] must be set) before setting or clearing this bit." "0,1"
        textline "                           "
        bitfld.long 0x00 13. "SCLE          ,scl enable:  0 = disables the twsi from driving the scl line.  1 = enables the twsi clock output for master-mode operation." "0,1"
        bitfld.long 0x00 12. "         MA             ,master abort:  used by the twsi in master mode to generate a stop without transmitting another data byte:  0 = the twsi transmits stop on if icr[stop] is set.  1 = the twsi sends stop without data transmission.  when in master-transmit mode, after transmitting a data byte, the icr[tb] bit is cleared and idbr[ite] bit is set. when no more data bytes need to be sent, setting master abort bit sends the stop. the icr[tb] bit must remain clear.  in master-receive mode, when a nak is sent without a stop (icr[stop] bit was not set) and the <var product number> does not send a repeated start, setting this bit sends the stop. once again, the icr[tb] bit must remain clear." "0,1"
        bitfld.long 0x00 11. "     I2C_BUS_RESET_REQ ,the twsi will do bus reset upon this bit set.this bit is self-cleared" "0,1"
        bitfld.long 0x00 10. "     UR             ,unit reset:  0 = no reset.  1 = reset the twsi only." "0,1"
        textline "                           "
        bitfld.long 0x00 8.--9. "MODE          ,bus mode (master operation):  0:0 up to 100 kbps operation - standard-mode  0:1 up to 400 kbps operation - fast-mode  1:0up to 3.4 mbps slave operation slave and up to 3.3 mbps master operation - hs-mode, standard mode when not doing a high speed transfer  1:1up to 3.4 mbps slave operation and up to 3.3 mbps master operation - hs-mode, fast mode when not doing a high speed transfer  bus mode (slave operation):  0:xhs-mode is disabled. twsi unit uses standard/fast mode timing on the sda pin.  1:xhs-mode is enabled. twsi unit uses hs-mode timing on the sda pin when a master code is received." "0,1,2,3"
        bitfld.long 0x00 7. "         TWSI0_DMA_EN49 ,dma enable for both tx and rx fifos  0 = dma mode is not enabled  1 = dma mode enabled" "0,1"
        bitfld.long 0x00 6. "     GPIOEN            ,gpio mode enable for scl during hs mode.  0 = gpio mode is not enabled and so we have open collector output for scl.  1 = gpio mode is enabled and so scl output is directly driven by twsi." "0,1"
        bitfld.long 0x00 5. "     FIFOEN         ,fifo mode  0 = fifo mode is not enabled and so we idbr has to be used to write and read data  1 = fifo mode is enabled and so fifos can be used." "0,1"
        textline "                           "
        bitfld.long 0x00 4. "TXBEGIN       ,transaction begin. set this for a new transaction only after isr[txdone] is set  0 = no transaction starting  1 = a new transaction begins  this is cleared by the hardware at the end of each transaction after a stop bit is sent out. the s/w has to set it again to start a new transaction." "0,1"
        bitfld.long 0x00 3. "         TWSI0_TB55     ,transfer byte:  used to send or receive a byte on the twsi bus:  0 = cleared by twsi when the byte is sent/received.  1 = send/receive a byte.   the <var product number> can monitor this bit to determine when the byte transfer has completed. in master or slave mode, after each byte transfer including acknowledge pulse, the twsi holds the scl line low (inserting wait states) until tb is set." "0,1"
        bitfld.long 0x00 2. "     ACKNAK56          ,the positive/negative acknowledge control bit, acknak, defines the type of acknowledge pulse sent by the twsi when in master receive mode:  0 = send a positive acknowledge (ack) pulse after receiving a data byte.  1 = send a negative acknowledge (nak) pulse after receiving a data byte.  the twsi automatically sends an ack pulse when responding to its slave address or when responding in slave-receive mode, regardless of the acknak control-bit setting." "0,1"
        bitfld.long 0x00 1. "     TWSI0_STOP57   ,stop:  used to initiate a stop condition after transferring the next data byte on the twsi bus when in master mode. in master-receive mode, the acknak control bit must be set in conjunction with the stop bit. see section 12.4.3.3, stop condition for details of the stop state.  0 = do not send a stop.  1 = send a stop." "0,1"
        textline "                           "
        bitfld.long 0x00 0. "START         ,start:  used to initiate a start condition to the twsi unit when in master mode. see section 12.4.3.1, start condition for details of the start state.  0 = do not send a start pulse.  1 = send a start pulse." "0,1"

group d:0xD4011004++0x03
    line.long 0x00 "TWSI_SR,TWSI Status Register"
        bitfld.long 0x00 31. " RXOV          ,receive fifo overrun (used in fifo mode)  0 = transmit fifo not overrun  1 = transmit fifo overrun happened" "0,1"
        bitfld.long 0x00 30. "         RXF            ,receive fifo full (used in fifo mode)  0 = receive fifo in not full  1 = receive fifo is full" "0,1"
        bitfld.long 0x00 29. "     RXHF              ,receive fifo half full (used in fifo mode)  0 = receive fifo in not half full  1 = receive fifo is half full" "0,1"
        bitfld.long 0x00 28. "     TWSI0_TXE77    ,transmit fifo empty (used in fifo mode)  0 = transmit fifo is not empty  1 = transmit fifo is empty" "0,1"
        textline "                           "
        bitfld.long 0x00 27. "TXDONE        ,transaction done (used in fifo mode)  0 = transaction is not done.   1 = transaction is done" "0,1"
        bitfld.long 0x00 26. "         MSD            ,master stop detected:  0 = no master stop detected.  1 = this bit is set by the twsi unit when all of the following are true:" "0,1"
        bitfld.long 0x00 25. "     TWSI0_83          ,reserved" "0,1"
        bitfld.long 0x00 24. "     SSD            ,slave stop detected:  0 = no stop detected.  1 = set when the twsi detects a stop while in slave-receive or slave-transmit mode." "0,1"
        textline "                           "
        bitfld.long 0x00 23. "SAD           ,slave address detected:  0 = no slave address was detected.  1 = the twsi detected a seven-bit address that matches the general call address or isar. an interrupt is signalled when enabled in the icr." "0,1"
        bitfld.long 0x00 22. "         BED            ,bus error detected:  0 = no error detected.  1 = the twsi sets this bit when it detects one of the following error conditions:  as a master transmitter, no ack was detected on the interface after a byte was sent.  as a slave receiver, the twsi generates a nak pulse." "0,1"
        bitfld.long 0x00 21. "     GCAD              ,general call address detected:  0 = no general call address received.  1 = twsi received a general call address." "0,1"
        bitfld.long 0x00 20. "     IRF            ,idbr receive full:  0 = the idbr has not received a new data byte or the twsi is idle.  1 = the idbr register received a new data byte from the twsi bus. an interrupt is signalled when enabled in the icr." "0,1"
        textline "                           "
        bitfld.long 0x00 19. "ITE           ,idbr transmit empty:  0 = the data byte is still being transmitted.  1 = the twsi has finished transmitting a data byte on the twsi bus. an interrupt is signalled when enabled in the icr." "0,1"
        bitfld.long 0x00 18. "         ALD            ,arbitration loss detected:  used during multi-master operation:  0 = cleared when arbitration is won or never took place.  1 = set when the twsi loses arbitration." "0,1"
        bitfld.long 0x00 17. "     EBB               ,early bus busy  0 = twsi bus is idle or the twsi is using the bus (that is, unit busy).  1 = set when the unit detects that the scl or sda line is low without a start condition. bit will remain set until the twsi unit detects the bus is idle by detecting a stop condition. bit will also be set whenever the ibb bit is set." "0,1"
        bitfld.long 0x00 16. "     IBB            ,twsi bus busy:  0 = twsi bus is idle or the twsi is using the bus (that is, unit busy).  1 = set when the twsi bus is busy but the <var product number> twsi is not involved in the transaction." "0,1"
        textline "                           "
        bitfld.long 0x00 15. "UB            ,unit busy:  0 = twsi not busy.  1 = set when the <var product number> twsi is busy. this is defined as the time between the first start and stop." "0,1"
        bitfld.long 0x00 14. "         ACKNAK95       ,ack/nack status:  0 = the twsi received or sent an ack on the bus.   1 = the twsi received or sent a nak.on the bus.  this bit is used in slave-transmit mode to determine when the byte transferred is the last one. this bit is updated after each byte and ack/nak information is received." "0,1"
        bitfld.long 0x00 13. "     RWM               ,read/write mode:  0 = the twsi is in master-transmit or slave-receive mode.   1 = the twsi is in master-receive or slave-transmit mode.   this is the r/nw bit of the slave address. it is cleared automatically by hardware after a stop state." "0,1"
        hexmask.long.word 0x00 0.--12. 1. "     TWSI0_97       ,reserved"

group d:0xD4011008++0x03
    line.long 0x00 "TWSI_SAR,TWSI Slave Address Register"
        hexmask.long 0x00 7.--31. 1. " TWSI0_106     ,reserved"
        hexmask.long.byte 0x00 0.--6. 1. "  SLAVE_ADDRESS  ,the seven-bit address to which the twsi responds when in slave-receive mode"

group d:0xD401100C++0x03
    line.long 0x00 "TWSI_DBR,TWSI Data Buffer Register"
        hexmask.long.tbyte 0x00 8.--31. 1. " TWSI0_118     ,reserved"
        hexmask.long.byte 0x00 0.--7. 1. "    DATA_BUFFER    ,buffer for twsi bus send/receive data."

group d:0xD4011010++0x03
    line.long 0x00 "TWSI_LCR,TWSI Load Count Register"
        bitfld.long 0x00 27.--31. " HLVL          ,decrementer load value for high speed mode scl (master mode) for low phase. the twsi in master mode will generate an scl to support up to 1.8 mbps data rate with the reset value." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"
        hexmask.long.word 0x00 18.--26. 1. "        HLVH           ,decrementer load value for high speed mode scl (master mode) for high phase. the twsi in master mode will generate an scl to support up to 1.8 mbps data rate with the reset value."
        hexmask.long.word 0x00 9.--17. 1. "  FLV               ,decrementer load value for fast mode scl (master mode) for both high and low phase.   twsi in master mode generates an scl to support up to 400 kbps data rate with the reset value."
        hexmask.long.word 0x00 0.--8. 1. "  SLV            ,decrementer load value for standard mode scl (master mode) for both high & low phase.   twsi in master mode generates an scl to support up to 100 kbps data rate with the reset value."

group d:0xD4011014++0x03
    line.long 0x00 "TWSI_WCR,TWSI Wait Count Register"
        hexmask.long.tbyte 0x00 15.--31. 1. " TWSI0_142     ,reserved"
        bitfld.long 0x00 10.--14. "    HS_COUNT2      ,count value for defining high speed mode stop bit setup and hold times.  default: decimal 5" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"
        bitfld.long 0x00 5.--9. "    HS_COUNT1         ,count value for defining high speed mode start bit setup and hold times.  default: decimal 1" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"
        bitfld.long 0x00 0.--4. "    TWSI0_COUNT147 ,controls the counter values defining the setup and hold times in standard and fast mode  recommended values:  01010 => 33 mhz twsi functional clock  10100 => 66 mhz twsi functional clock  default: decimal 26" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"

group d:0xD4011018++0x03
    line.long 0x00 "TWSI_RST_CYC,TWSI Bus reset cycle counter"
        bitfld.long 0x00 0.--3. " RST_CYC       ,the cycles of scl during bus reset" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"

group d:0xD401101C++0x03
    line.long 0x00 "TWSI_BMR,TWSI Bus Monitor Register"
        hexmask.long 0x00 2.--31. 1. " TWSI0_168     ,reserved"
        bitfld.long 0x00 1. "  SCL            ,ibmr[scl] continuously reflects the value of the scl pin." "0,1"
        bitfld.long 0x00 0. "     TWSI0_SDA170      ,ibmr[sda] continuously reflects the value of the sda pin." "0,1"

group d:0xD4011020++0x03
    line.long 0x00 "TWSI_WFIFO,TWSI Write FIFO Register"
        hexmask.long.tbyte 0x00 12.--31. 1. " TWSI0_179     ,reserved"
        bitfld.long 0x00 8.--11. "    CONTROL        ,twsi bus send/receive data control bits. these control bits are essentially icr[3:0] bits." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        hexmask.long.byte 0x00 0.--7. 1. "    TWSI0_DATA181     ,twsi bus send data for write transactions and dummy data for read transactions"

group d:0xD4011024++0x03
    line.long 0x00 "TWSI_WFIFO_WPTR,TWSI Write FIFO Write Pointer Register"
        hexmask.long 0x00 4.--31. 1. " TWSI0_189     ,reserved"
        bitfld.long 0x00 0.--3. "  TWSI0_DATA190  ,this is the location in the tx fifo where the next entry will be written to by the software." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"

group d:0xD4011028++0x03
    line.long 0x00 "TWSI_WFIFO_RPTR,TWSI Write FIFO Read Pointer Register"
        hexmask.long 0x00 4.--31. 1. " TWSI0_198     ,reserved"
        bitfld.long 0x00 0.--3. "  TWSI0_DATA199  ,this is the location in the tx fifo where the next entry will be read from by the hardware." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"

group d:0xD401102C++0x03
    line.long 0x00 "TWSI_RFIFO,TWSI Read FIFO Register"
        hexmask.long.byte 0x00 0.--7. 1. " TWSI0_DATA208 ,twsi bus receive data for read transactions."

group d:0xD4011030++0x03
    line.long 0x00 "TWSI_RFIFO_WPTR,TWSI Read FIFO Write Pointer Register"
        bitfld.long 0x00 0.--4. " TWSI0_DATA217 ,this is the location in the rx fifo where the next entry will be written to by the hardware." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"

group d:0xD4011034++0x03
    line.long 0x00 "TWSI_RFIFO_RPTR,TWSI Read FIFO Read Pointer Register"
        bitfld.long 0x00 0.--4. " TWSI0_DATA226 ,this is the location in the rx fifo where the next entry will be read from by the software." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"

tree.end

tree "usb_otg"

width 28.

group d:0xD4208000++0x03
    line.long 0x00 "USB_ID,Identification Register"
        bitfld.long 0x00 29.--31. " CIVERSION         ,identifies the ci version" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 25.--28. "         VERSION          ,identifies the core version" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 21.--24. "    US_REVISION26    ,revision number of the core" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 16.--20. "  TAG              ,identifies the tag of core" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"
        textline "                                      "
        hexmask.long.byte 0x00 8.--15. 1. "NID               ,ones complement version of id"
        hexmask.long.byte 0x00 0.--5. 1. "        US_ID30          ,configuration number  this number is set to 0x05 and indicates that the peripheral is the usb-hs usb 2.0 core."

group d:0xD4208004++0x03
    line.long 0x00 "USB_HWGENERAL,General Hardware Parameters Register"
        bitfld.long 0x00 10.--11. " US_SM38           ,reserved for internal testing" "0,1,2,3"
        bitfld.long 0x00 6.--9. "         US_PHYM39        ,reserved for internal testing" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 4.--5. "    US_PHYW40        ,reserved for internal testing" "0,1,2,3"
        bitfld.long 0x00 3. "   US_BWT41         ,reserved for internal testing" "0,1"
        textline "                                      "
        bitfld.long 0x00 1.--2. "US_CLKC42         ,reserved for internal testing" "0,1,2,3"
        bitfld.long 0x00 0. "         US_RT43          ,reserved for internal testing" "0,1"

group d:0xD4208008++0x03
    line.long 0x00 "USB_HWHOST,Host Hardware Parameters Register"
        hexmask.long.byte 0x00 24.--31. 1. " US_TTPER50        ,reserved for internal testing"
        hexmask.long.byte 0x00 16.--23. 1. "        US_TTASY51       ,reserved for internal testing"
        bitfld.long 0x00 1.--3. "    US_NPORT53       ,reserved for internal testing" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 0. "   US_HC54          ,reserved for internal testing" "0,1"

group d:0xD420800C++0x03
    line.long 0x00 "USB_HWDEVICE,Device Hardware Parameters Register"
        bitfld.long 0x00 1.--5. " US_DEVEP62        ,reserved for internal testing" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"
        bitfld.long 0x00 0. "        US_DC63          ,device capable  reserved for internal testing" "0,1"

group d:0xD4208010++0x03
    line.long 0x00 "USB_HWTXBUF,TX Buffer Hardware Parameters Register"
        bitfld.long 0x00 31. " US_TXLCR70        ,reserved for internal testing" "0,1"
        hexmask.long.byte 0x00 16.--23. 1. "         US_TXCHANADD72   ,reserved for internal testing"
        hexmask.long.byte 0x00 8.--15. 1. "    US_TXADD73       ,reserved for internal testing"
        hexmask.long.byte 0x00 0.--7. 1. "  US_TCBURST74     ,reserved for internal testing"

group d:0xD4208014++0x03
    line.long 0x00 "USB_HWRXBUF,RX Buffer Hardware Parameters Register"
        hexmask.long.byte 0x00 8.--15. 1. " US_RXADD82        ,reserved for internal testing"
        hexmask.long.byte 0x00 0.--7. 1. "        US_RXBURST83     ,reserved for internal testing"

group d:0xD4208018++0x03
    line.long 0x00 "USB_HWRXBUF,RX Buffer Hardware Parameters Register"
        bitfld.long 0x00 28.--31. " EP7_TXFIFO_SIZE   ,to define tx fifo size for endpoint7" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 24.--27. "        EP6_TXFIFO_SIZE  ,to define tx fifo size for endpoint6" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 20.--23. "    EP5_TXFIFO_SIZE  ,to define tx fifo size for endpoint5" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 16.--19. "  EP4_TXFIFO_SIZE  ,to define tx fifo size for endpoint4" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        textline "                                      "
        bitfld.long 0x00 12.--15. "EP3_TXFIFO_SIZE   ,to define tx fifo size for endpoint3" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 8.--11. "        EP2_TXFIFO_SIZE  ,to define tx fifo size for endpoint2" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 4.--7. "    EP1_TXFIFO_SIZE  ,to define tx fifo size for endpoint1" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 0.--3. "  EP0_TXFIFO_SIZE  ,to define tx fifo size for endpoint0" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"

group d:0xD420801C++0x03
    line.long 0x00 "USB_HWRXBUF,RX Buffer Hardware Parameters Register"
        bitfld.long 0x00 28.--31. " EP15_TXFIFO_SIZE  ,to define tx fifo size for endpoint15" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 24.--27. "        EP14_TXFIFO_SIZE ,to define tx fifo size for endpoint14" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 20.--23. "    EP13_TXFIFO_SIZE ,to define tx fifo size for endpoint13" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 16.--19. "  EP12_TXFIFO_SIZE ,to define tx fifo size for endpoint12" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        textline "                                      "
        bitfld.long 0x00 12.--15. "EP11_TXFIFO_SIZE  ,to define tx fifo size for endpoint11" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 8.--11. "        EP10_TXFIFO_SIZE ,to define tx fifo size for endpoint10" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 4.--7. "    EP9_TXFIFO_SIZE  ,to define tx fifo size for endpoint9" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 0.--3. "  EP8_TXFIFO_SIZE  ,to define tx fifo size for endpoint8" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"

group d:0xD4208080++0x03
    line.long 0x00 "GPTIMER0LD,Device/Host Timer Registers"
        hexmask.long.tbyte 0x00 0.--23. 1. " GPTLD             ,this field is the value to be loaded into the gptcnt countdown timer on a reset action. the value in this register represents the time in microseconds minus 1 for the timer duration."

group d:0xD4208084++0x03
    line.long 0x00 "GPTIMER0CTRL,"
        bitfld.long 0x00 31. " GTPRUN            ,this bit enables the general-purpose timer to run. setting or clearing this bit will not have an effect on the gptcnt counter value." "0,1"
        bitfld.long 0x00 30. "         GPTRST           ,writing a one to this bit will reload the gptcnt with the value in gptld." "0,1"
        bitfld.long 0x00 24. "     GPTMODE          ,0b' – one shot; '1b' – repeat. this bit selects between a single timer countdown and a looped countdown. in one-shot mode, the timer will count down to zero, generate an interrupt and stop until the counter is reset by software. in repeat mode, the timer will count down to zero, generate an interrupt and automatically reload the counter to begin again." "0,1"
        hexmask.long.tbyte 0x00 0.--23. 1. "   GPTCNT           ,this field is the value of the running timer."

group d:0xD4208088++0x03
    line.long 0x00 "GPTIMER1LD,"
        hexmask.long.byte 0x00 0.--7. 1. " US_CAPLENGTH150   ,caplength"

group d:0xD4208102++0x03
    line.long 0x00 "USB_HCIVERSION,Host Interface Version Number - EHCI Compliant Register"
        hexmask.long.word 0x00 0.--15. 1. " US_HCIVERSION157  ,hciversion"

group d:0xD4208104++0x03
    line.long 0x00 "USB_HCSPARAMS,Host Ctrl. Structural Parameters EHCI Compliant with"
        bitfld.long 0x00 24.--27. " US_N_TT165        ,number of transaction translators (n_tt)  this field indicates the number of embedded transaction translators associated with the usb2.0 host controller.  this in a non-ehci field to support embedded tt." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 20.--23. "        US_N_PTT166      ,number of ports per transaction translator (n_ptt)  this field indicates the number of ports assigned to each transaction translator within the usb2.0 host controller.  this in a non-ehci field to support embedded tt." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 16. "    US_PI168         ,port indicators (p indicator)  this bit indicates whether the ports support port indicator control.  1 = port status and control registers include a read/writeable field for controlling the state of the port indicator  this field will always be 1." "0,1"
        bitfld.long 0x00 12.--15. "   US_N_CC169       ,number of companion controller (n_cc)  this field indicates the number of companion controllers associated with this usb2.0 host controller.  0 = there are no internal companion controllers. port-ownership hand-off is not supported.  in this implementation, this field will always be 0." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        textline "                                      "
        bitfld.long 0x00 8.--11. "US_N_PCC170       ,number of ports per companion controller  this field indicates the number of ports supported per internal companion controller. it is used to indicate the port routing configuration to the system software.  the number in this field must be consistent with <n_ports[3:0]> and <n_cc[3:0]>." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 4. "        US_PPC172        ,port power control  this field indicates whether the host controller implementation includes port power control.  0 = ports do not have port power switches  the value of this field affects the functionality of the port power field in each port status and control register." "0,1"
        bitfld.long 0x00 0.--3. "     US_N_PORTS173    ,number of downstream ports  this field specifies the number of physical downstream ports implemented on this host controller." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"

group d:0xD4208108++0x03
    line.long 0x00 "USB_HCCPARAMS,Host Ctrl. Capability Parameters EHCI Compliant"
        hexmask.long.byte 0x00 8.--15. 1. " US_EECP181        ,ehci extended capabilities pointer  this optional field indicates the existence of a capabilities list.  0x00 = no extended capabilities are implemented"
        bitfld.long 0x00 4.--7. "        US_IST182        ,isochronous scheduling threshold  this field indicates, relative to the current position of the executing host controller, where software can reliably update the isochronous schedule. when bit [7] is zero, the value of the least significant 3 bits indicates the number of micro-frames a host controller can hold a set of isochronous data structures (one or more) before flushing the state.  this field will always be 0." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 2. "    US_ASP184        ,asynchronous schedule park capability  1 = the host controller supports the park feature for high-speed queue heads in the asynchronous schedule. the feature can be disabled or enabled and set to a specific level by using the <asynchronous schedule park mode enable> and <asp[1:0]> fields in the usb command register.  this field will always be 1." "0,1"
        bitfld.long 0x00 1. "   US_PFL185        ,programmable frame list flag  1 = system software can specify and use a smaller frame list and configure the host controller via the <fs[1:0]> field in the usb command register. the frame list must always be aligned on a 4k-page boundary. this requirement ensures that the frame list is always physically contiguous.  this field will always be 1." "0,1"
        textline "                                      "
        bitfld.long 0x00 0. "US_ADC186         ,64-bit addressing capability  this field will always be 0. no 64-bit addressing capability is supported." "0,1"

group d:0xD4208120++0x03
    line.long 0x00 "USB_DCIVERSION,Dev. Interface Version Number Register"
        hexmask.long.word 0x00 0.--15. 1. " US_DCIVERSION194  ,dciversion"

group d:0xD4208124++0x03
    line.long 0x00 "USB_DCCPARAMS,Device Ctrl. Capability Parameters Register"
        bitfld.long 0x00 8. " US_HC202          ,host capable  1 = this controller is capable of operating as an ehci compatible usb 2.0 host controller" "0,1"
        bitfld.long 0x00 7. "         US_DC203         ,device capable  1 = this controller is capable of operating as a usb 2.0 device" "0,1"
        bitfld.long 0x00 0.--4. "     US_DEN205        ,device endpoint number  this field indicates the number of endpoints built into the device controller. if this controller is not device capable, then this field will be 0. valid values are 0 to 16." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"

group d:0xD4208140++0x03
    line.long 0x00 "USB_CMD,USB Command Register"
        hexmask.long.byte 0x00 16.--23. 1. " US_ITC217         ,interrupt threshold control  the system software uses this field to set the maximum rate at which the host/device controller will issue interrupts. this field contains the maximum interrupt interval measured in micro-frames. valid values are provided below.  value maximum interrupt interval:  0x00 = immediate (no threshold)  0x01 = 1 micro-frame  0x02 = 2 micro-frames  0x04 = 4 micro-frames  0x08 = 8 micro-frames  0x10 = 16 micro-frames  0x20 = 32 micro-frames  0x40 = 64 micro-frames"
        bitfld.long 0x00 1. "        US_RST219        ,controller reset (reset)  software uses this field to reset the controller. it is set to 0 by the host/device controller when the reset process is complete. software cannot terminate the reset process early by writing 0 to this register.  host controller: when software writes 1 to this bit, the host controller resets its internal pipelines, timers, counters, state machines etc. to their initial value. any transaction currently in progress on usb is immediately terminated. a usb reset is not driven on downstream ports. software should not set this bit to 1 when the <hchaited> field in the usb status register is a zero. attempting to reset an actively running host controller will result in undefined behavior.  device controller: when software writes 1 to this bit, the device controller resets its internal pipelines, timers, counters, state machines etc. to their initial value. writing 1 to this bit when the device is in the attached state is not recommended, since the effect on an attached host is undefined. in order to ensure that the device is not in an attached state before initiating a device controller reset, all primed endpoints should be flushed and the <run/stop> field in the usb command register should be set to 0." "0,1"
        bitfld.long 0x00 0. "     US_RS220         ,run/stop (rs)  0 = stop  1 = run  host controller: when set to 1, the host controller proceeds with the execution of the schedule. the host controller continues execution as long as this bit is set to a 1. when this bit is set to 0, the host controller completes the current transaction on the usb and then halts. the <hchaited> field in the usb status register indicates when the host controller has finished the transaction and has entered the stopped state. software should not write a 1 to this field unless the host controller is in the halted state (when <hchaited> = 1).  device controller: writing 1 to this field will cause the device controller to enable a pull-up on d+ and initiate an attach event. this control bit is not directly connected to the pull-up enable, as the pull-up will become disabled upon transitional into high-speed mode. software should use this field to prevent an attach event before the device controller has been properly initialized. writing 0 to this will cause a detach event." "0,1"

group d:0xD4208144++0x03
    line.long 0x00 "USB_STS,USB Status Register"
        bitfld.long 0x00 25. " US_TI1228         ,this bit is set when the counter in the gptimer1ctrl register transitions to zero. writing a one to this bit will clear it." "0,1"
        bitfld.long 0x00 24. "         TI2              ,this bit is set when the counter in the gptimer2ctrl register transitions to zero. writing a one to this bit will clear it." "0,1"
        bitfld.long 0x00 19. "     US_UPI231        ,this bit is set by the host controller when the cause of an interrupt is a completion of a usb transaction where the transfer descriptor (td) has an interrupt on complete (ioc) bit set and the td was from the periodic schedule. this bit is also set by the host controller when a short packet is detected and the packet is on the periodic schedule. a short packet is when the actual number of bytes received was less than expected. this bit is not used by the device controller and will always be zero." "0,1"
        bitfld.long 0x00 18. "   US_UAI232        ,this bit is set by the host controller when the cause of an interrupt is a completion of a usb transaction where the transfer descriptor (td) has an interrupt on complete (ioc) bit set and the td was from the asynchronous schedule. this bit is also set by the host when a short packet is detected and the packet is on the asynchronous schedule. a short packet is when the actual number of bytes received was less than expected. this bit is not used by the device controller and will always be zero." "0,1"
        textline "                                      "
        bitfld.long 0x00 16. "US_NAKI234        ,this bit is read-only. it is set by hardware when for a particular endpoint both the tx/rx" "0,1"
        bitfld.long 0x00 10. "         US_ULPII236      ,ulpi interrupt  when the ulpi viewport is present in the design, an event completion will set this interrupt.  this is used by both host and device controller. only present in designs where configuration constant vusb_hs_phy_ulpi = 1." "0,1"
        bitfld.long 0x00 8. "     US_SLI238        ,dcsuspend  when a device controller enters a suspend state from an active state, this bit will be set to 1. the device controller clears the bit upon exiting from a suspend state." "0,1"
        bitfld.long 0x00 7. "   US_SRI239        ,sof received  0 = default. when the device controller detects a start of (micro) frame, this field will be set to 1. when a sof is extremely late, the device controller will automatically set this bit to indicate that an sof was expected. therefore, this field will be set roughly every 1 ms in device fs mode and every 125 ms in hs mode and will be synchronized to the actual sof that is received.  since the device controller is initialized to fs before connect, this field will be set at an interval of 1 ms during the prelude to connect and chirp.  in host mode, this bit will be set every 125 <mu>s and can be used by the host controller driver as a time base.  software writes 1 to this bit to clear it.  this is a non-ehci status bit." "0,1"
        textline "                                      "
        bitfld.long 0x00 6. "US_URI240         ,usb reset received  when the device controller detects a usb reset and enters the default state, this bit will be set to 1. software can write 1 to this field to clear the usb reset received status bit." "0,1"
        bitfld.long 0x00 5. "         AAI_0B_08H       ,interrupt on async advance  system software can force the host controller to issue an interrupt the next time the host controller advances the asynchronous schedule by writing 1 to the <interrupt on async advance doorbell> field in the usb command register. this status bit indicates the assertion of that interrupt source." "0,1"
        bitfld.long 0x00 4. "     US_SEI242        ,in the bvci implementation of the usbhs core, this bit is not used, and will always be cleared to '0b'. in the amba implementation, this bit will be set to '1b' when an error response is seen by the master interface (hresp[1:0]=error)." "0,1"
        bitfld.long 0x00 3. "   US_FRI243        ,frame list rollover  the host controller sets this field to 1 when the frame list index rolls over from its maximum value to 0. the exact value at which the rollover occurs depends on the frame list size. for example. if the frame list size (as programmed in the <fs[1:0]> field in the usb command register) is 1024, the usb frame index register rolls over every time frindex[13] toggles. similarly, if the size is 512, the host controller sets this bit to a one every time fhindex[12] toggles." "0,1"
        textline "                                      "
        bitfld.long 0x00 2. "US_PCI244         ,port change detect  the host controller sets this bit to 1 when on any port a connect status occurs, a port enable/disable change occurs, or the <force port resume> field in the port status/control register is set as the result of a j-k transition on the suspended port.  the device controller sets this bit to 1 when the port controller enters the full or high-speed operational state.  when the port controller exits the full or high-speed operation states due to reset or suspend events, the notification mechanisms are the <iaa> field in the usb command register and the <dcsuspend> bits respectively.  this bit is not ehci compatible." "0,1"
        bitfld.long 0x00 1. "         US_UEI245        ,usb error interrupt (usberrint)  when completion of a usb transaction results in an error condition, this field is set by the host/device controller. this field is set along with the <ui>, if the td on which the error interrupt occurred also had its interrupt on complete (ioc) bit set.  the device controller detects resume signaling only." "0,1"
        bitfld.long 0x00 0. "     US_UI246         ,usb interrupt (usbint)  this field is set by the host/device controller when the cause of an interrupt is a completion of a usb transaction where the transfer descriptor (td) has an interrupt on complete (ioc) bit set.  this bit is also set by the host/device controller when a short packet is detected. a short packet is when the actual number of bytes received was less than the expected number of bytes." "0,1"

group d:0xD4208148++0x03
    line.long 0x00 "USB_INTR,USB Interrupt Enable Register"
        bitfld.long 0x00 25. " US_TIE1254        ,when this bit is a one, and the ti1 bit in the extsts register is a one, the controller will issue an interrupt. the interrupt is acknowledged by software clearing the ti1 bit." "0,1"
        bitfld.long 0x00 24. "         US_TIE0255       ,when this bit is a one, and the ti0 bit in the extsts register is a one, the controller will issue an interrupt. the interrupt is acknowledged by software clearing the ti0 bit." "0,1"
        bitfld.long 0x00 19. "     US_UPEI257       ,when this bit is a one, and the upi bit in the extsts register is a one, the host controller will issue an interrupt at the next interrupt threshold. the interrupt is acknowledged by software clearing the upi bit." "0,1"
        bitfld.long 0x00 18. "   US_UAEI258       ,when this bit is a one, and the uai bit in the extsts register is a one, the host controller will issue an interrupt at the next interrupt threshold. the interrupt is acknowledged by software clearing the uai bit." "0,1"
        textline "                                      "
        bitfld.long 0x00 16. "US_NAKE260        ,nak interrupt enable  this bit is set by software if it wants to enable the hardware interrupt for the <nak interrupt bit> field in the usb status register. if both this bit and the corresponding <nak interrupt bit> field are set, a hardware interrupt is generated." "0,1"
        bitfld.long 0x00 10. "         US_ULPIE262      ,when this bit is a one, and the ulpi interrupt bit in the usbsts register transitions, the controller will issue and interrupt. the interrupt is acknowledged by software writing a one to the ulpi interrupt bit." "0,1"
        bitfld.long 0x00 8. "     US_SLE264        ,sleep enable  when this bit is 1, and the <dcsuspend> field in the usb status register transitions, the device controller will issue an interrupt. the interrupt is acknowledged by software writing 1 to the <dcsuspend> field.  only used by the device controller." "0,1"
        bitfld.long 0x00 7. "   US_SRE265        ,sof received enable  when this bit is 1, and the <sof received> field in the usb status register is 1, the device controller will issue an interrupt. the interrupt is acknowledged by software clearing the <sof received> field." "0,1"
        textline "                                      "
        bitfld.long 0x00 6. "US_URE266         ,usb reset enable  when this bit is 1, and the <usb reset received> field in the usb status register is 1, the device controller will issue an interrupt. the interrupt is acknowledged by software clearing the <usb reset received> field.  only used by the device controller." "0,1"
        bitfld.long 0x00 5. "         US_AAE267        ,interrupt on async advance enable  when this bit is 1, and the <aai 0b-08h> field in the usb status register is 1, the host controller will issue an interrupt at the next interrupt threshold. the interrupt is acknowledged by software clearing the <aai 0b-08h> field.  only used by the host controller." "0,1"
        bitfld.long 0x00 4. "     US_SEE268        ,system error enable  when this bit is 1, and bit 4 in the usb status register is 1, the host/device controller will issue an interrupt. the interrupt is acknowledged by software clearing bit 4 in the usb status register." "0,1"
        bitfld.long 0x00 3. "   US_FRE269        ,frame list rollover enable  when this bit is 1, and the <frame list rollover> field in the usb status register is 1, the host controller will issue an interrupt. the interrupt is acknowledged by software clearing the <frame list rollover> field.  only used by the host controller." "0,1"
        textline "                                      "
        bitfld.long 0x00 2. "US_PCE270         ,port change detect enable  when this bit is 1, and the <port change detect> field in the usb status register is 1, the host/device controller will issue an interrupt. the interrupt is acknowledged by software clearing the <port change detect> field." "0,1"
        bitfld.long 0x00 1. "         US_UEE271        ,usb error interrupt enable  when this bit is 1, and the <usb error interrupt (usberrint)> field in the usb status register is 1, the host controller will issue an interrupt at the next interrupt threshold. the interrupt is acknowledged by software clearing the <usb error interrupt (usberrint)> field." "0,1"
        bitfld.long 0x00 0. "     US_UE272         ,usb interrupt enable  when this bit is 1 and the <usb interrupt (usbint)> field in the usb status register is 1, the host/device controller will issue an interrupt at the next interrupt threshold. the interrupt is acknowledged by software clearing the <usb interrupt (usbint)> field." "0,1"

group d:0xD420814C++0x03
    line.long 0x00 "USB_FRINDEX,USB Frame Index Register"
        hexmask.long.word 0x00 0.--13. 1. " US_FRINDEX280     ,frame index  the value in this register increments at the end of each time frame (e.g. micro-frame). bits [n:3] are used for the frame list current index. this means that each location of the frame list is accessed 8 times (frames or micro-frames) before moving to the next index.  the following illustrates values of n based on the value of the <fs[1:0]> field in the usb command register, when used in host mode.  usbcmd [frame list size] number elements n  0x0 (1024) = 12  0x1 (512) = 11  0x2 (256) = 10  0x3 (128) = 9  0x4 (64) = 8  0x5 (32) = 7  0x6 (16) = 6  0x7 (8) = 5  in device mode, the value is the current frame number of the last frame transmitted. it is not used as an index.  in either mode, bits 2:0 indicate the current microframe."

group d:0xD4208154++0x03
    line.long 0x00 "USB_PERIODICLISTBASE,Host Controller Frame List Base Address Register (Host Mode)"
        hexmask.long.tbyte 0x00 12.--31. 1. " US_BASEADR287     ,base address (low)  these bits correspond to memory address signals [31:12], respectively. only used by the host controller."

group d:0xD4208154++0x03
    line.long 0x00 "USB_DEVICEADDR,Device Controller USB Device Address Register (Device Mode)"
        hexmask.long.byte 0x00 25.--31. 1. " USBADR            ,device address  these bits correspond to the usb device address"
        bitfld.long 0x00 24. "        USBADRA          ,device address advance  0 = any writes to <device address> are instantaneous  1 = at the same time or before <device address> is written, the write to the device address field is staged and held in a hidden register. after an in occurs on endpoint 0 and is acked, device address will be loaded from the holding register.  hardware will automatically clear this bit on the following conditions:" "0,1"

group d:0xD4208158++0x03
    line.long 0x00 "USB_ASYNCLISTADDR,Host Controller Next Asynchronous List Address Register"
        hexmask.long 0x00 5.--31. 1. " US_ASYBASE308     ,link pointer low (lpl)  these bits correspond to memory address signals [31:5], respectively. this field may only reference a queue head (oh). only used by the host controller."

group d:0xD4208158++0x03
    line.long 0x00 "USB_ENDPOINTLISTADDR,Address at Endpoint List in Memory Register"
        hexmask.long.tbyte 0x00 11.--31. 1. " EPBASE            ,endpoint list pointer (low)  these bits correspond to memory address signals [31:11], respectively. this field will reference a list of up to 32 qhs. (that is, one queue head per endpoint and direction.)"

group d:0xD4208160++0x03
    line.long 0x00 "USB_BURSTSIZE,Programmable Burst Size Register - Host Controller"
        hexmask.long.word 0x00 8.--16. 1. " US_TXPBURST325    ,programmable tx burst length  this register represents the maximum length of a the burst in 32-bit words while moving data from system memory to the usb bus."
        hexmask.long.byte 0x00 0.--7. 1. "      US_RXPBURST326   ,programmable rx burst length  this register represents the maximum length of a the burst in 32-bit words while moving data from the usb bus to system memory."

group d:0xD4208178++0x03
    line.long 0x00 "USB_ENDPTNAK,Endpoint NAK Register"
        hexmask.long.word 0x00 16.--31. 1. " US_EPTN334        ,tx endpoint nak  each tx endpoint has 1 bit in this field. the bit is set when the device sends a nak handshake on a received in token for the corresponding endpoint.  bit 3 – endpoint #3  bit 2 – endpoint #2  bit 1 – endpoint #1  bit 0 – endpoint #0  all other bits are reserved."
        hexmask.long.word 0x00 0.--15. 1. "      US_EPRN335       ,rx endpoint nak  each rx endpoint has 1 bit in this field. the bit is set when the device sends a nak handshake on a received out or ping token for the corresponding endpoint.  bit 3 – endpoint #3  bit 2 – endpoint #2  bit 1 – endpoint #1  bit 0 – endpoint #0  all other bits are reserved."

group d:0xD420817C++0x03
    line.long 0x00 "USB_ENDPTNAKEN,Endpoint NAK Enable Register"
        hexmask.long.word 0x00 16.--31. 1. " US_EPTNE342       ,tx endpoint nak enable  each bit is an enable bit for the corresponding <eptn [15:0]> field in the endptnak. if this bit is set and the corresponding <eptn [15:0]> bit is set, the <nak interrupt bit> field in the usb status register is set.  bit 3 – endpoint #3  bit 2 – endpoint #2  bit 1 – endpoint #1  bit 0 – endpoint #0  all other bits are reserved."
        hexmask.long.word 0x00 0.--15. 1. "      US_EPRNE343      ,rx endpoint nak enable  each bit is an enable bit for the corresponding <eprn [15:0]> field in the endptnak. if this bit is set and the corresponding <eprn [15:0]> bit is set, the <nak interrupt bit> field in the usb status register is set.  bit 3 – endpoint #3  bit 2 – endpoint #2  bit 1 – endpoint #1  bit 0 – endpoint #0  all other bits are reserved."

group d:0xD4208184++0x03
    line.long 0x00 "USB_PORTSC,Port Status/Control Register"
        bitfld.long 0x00 30.--31. " US_PTS350         ,parallel transceiver select  utmi/utmi+  this bit is not defined in the ehci specification." "0,1,2,3"
        bitfld.long 0x00 29. "         US_STS351        ,this register bit is used in conjunction with the configuration constant vusb_hs_phy_serial to control whether the parallel or serial transceiver interface is selected for fs and ls operation. the serial interface engine can be used in combination with the utmi+ physical interface to provide fs/ls signaling instead of the parallel interface. if vusb_hs_phy_serial is set for 0 or 1 then this bit is read only. if vusb_hs_phy_serial is 2 or 3 then this bit is read/write. this bit has no effect unless parallel transceiver select is set to utmi+. the serial/1.1 and ic_usb physical interface will use the serial interface engine for fs/ls signaling regardless of this bit value." "0,1"
        bitfld.long 0x00 28. "     US_PTW352        ,parallel transceiver width  8-bit [60 mhz] utmi  this bit is not defined in the ehci specification." "0,1"
        bitfld.long 0x00 26.--27. "   US_PSPD353       ,port speed  this register field indicates the speed at which the port is operating. for hs mode operation in the host controller and hs/fs operation in the device controller, the port routing steers data to the protocol engine. for fs and ls mode operation in the host controller, the port routing steers data to the protocol engine w/ embedded transaction translator.  0x0 = full speed  0x1 = low speed  0x2 = high speed  this bit is not defined in the ehci specification." "0,1,2,3"
        textline "                                      "
        bitfld.long 0x00 25. "US_PTS2354        ,parallel transceiver select – rw. default = implementation dependent. msb bit of pts field." "0,1"
        bitfld.long 0x00 24. "         US_PFSC355       ,port force full speed connect  writing this bit to 1 will force the port to only connect at full speed. it disables the chirp sequence that allows the port to identify itself as high speed. this is useful for testing fs configurations with a hs host, hub, or device.  this field is not defined in the ehci specification.  this field is for debugging purposes." "0,1"
        bitfld.long 0x00 23. "     US_PHCD356       ,phy low power suspend - clock disable (plpscd)  0 = enables the phy clock  1 = disables the phy clock  reading this field will indicate the status of the phy clock.  the phy clock cannot be disabled if it is being used as the system clock.  in device mode, the phy can be put into low power suspend clock disable when the device is not running (<run/stop> field in the usb command register = 0) or the host has signaled suspend (<suspend> field in the port status/control register = 1). low power suspend will be cleared automatically when the host has signaled resume. before forcing a resume from the device, the device controller driver must clear this field.  in host mode, the phy can be put into low power suspend clock disable when the downstream device has been put into suspend mode or when no downstream device is connected. low power suspend is completely under the control of software.  this field is not defined in the ehci specification." "0,1"
        bitfld.long 0x00 22. "   US_WKOC357       ,wake on disconnect enable (wkdscnnt_e)  writing this bit to 1 enables the port to be sensitive to device disconnects as wake-up events.  this field is 0 if <port power> field in the port status/control register is 0 or in device mode.  this bit is output from the controller as signal pwrctl_wake_dscnnt_en (otg/host core only) for use by an external power control circuit." "0,1"
        textline "                                      "
        bitfld.long 0x00 21. "WKDC              ,wake on disconnect enable (wkdscnnt_e)  writing this bit to 1 enables the port to be sensitive to device disconnects as wake-up events.  this field is 0 if <port power> field in the port status/control register is 0 or in device mode.  this bit is output from the controller as signal pwrctl_wake_dscnnt_en (otg/host core only) for use by an external power control circuit." "0,1"
        bitfld.long 0x00 20. "         US_WKCN359       ,wake on connect enable (wkcnnt_e)  writing this field to 1 enables the port to be sensitive to device connects as wake-up events.  this field is 0 if <port power> field in the port status/control (portsc) register is zero or in device mode.  this bit is output from the controller as signal pwrctl_wake_dscnnt_en (otg/host core only) for use by an external power control circuit." "0,1"
        bitfld.long 0x00 16.--19. "     US_PTC360        ,port test control  any other value than 0 indicates that the port is operating in test mode.  0x0 = test_mode_disable  0x1 = j_ state  0x2 = k_state  0x3 = se0 (host) / nak (device)  0x4 = packet  0x5 = force_enable_hs  0x6 = force_enable_fs  0x7 = force_enable_ls  0x8 to 0xf = reserved  the force_enable_fs and force enable_ls are extensions to the test mode support specified in the ehci specification. writing this field to any of the force_enable_{hs/fs/ls} values will force the port into the connected and enabled state at the selected speed. writing this field back to test_mode_disable will allow the port state machines to progress normally from that point.  low speed operations are not supported as a peripheral device." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 14.--15. "  US_PIC361        ,port indicator control  writing to this field has no effect if the <port indicators (p indicator)> field in the host ctrl. structural parameters (hcsparams) ehci compliant with extensions register is 0. if <port indicators (p indicator)> is 1, then the bit is:  0x0 = port indicators are off  0x1 = amber  0x2 = green  0x3 = undefined  refer to the usb specification revision 2.0 [3] for a description on how these bits are to be used.  this field is output from the controller as signals port_ind_ctl_1 and port_ind_ctl_0 for use by an external led driving circuit." "0,1,2,3"
        textline "                                      "
        bitfld.long 0x00 13. "US_PO362          ,port owner hand off is not implemented in this design, therefore this bit will always read back as 0b." "0,1"
        bitfld.long 0x00 12. "         US_PP363         ,port power (pp)  the function of this field depends on the value of the <ppc> field in the host ctrl. structural parameters ehci compliant with extensions register. the behavior is as follows:  <ppc> pp operation  0 0 ro — a device controller with no otg capability does not have port power control switches.  1 1/0 – rw. host/otg controller requires port power control switches. this field represents the current setting of the switch (0 = off, 1 = on). when power is not available on a port (that is, this field equals 0), the port is non-functional and will not report attaches, detaches, etc.  when an over-current condition is detected on a powered port and <ppc> is 1, the bit in each affected port may be transitioned by the host controller driver from 1 to 0 (removing power from the port).  this feature is implemented in the host/otg controller (<ppc> = 1).  in a device only implementation, port power control is not necessary, thus <ppc> and this field = 0." "0,1"
        bitfld.long 0x00 10.--11. "     US_LS364         ,line status  this field reflects the current logical levels of the d+ (bit 11) and d- (bit 10) signal lines. the encoding of the bits are:  0x0 = se0  0x2 = j-state  0x1 = k-state  0x3 = undefined  in host mode, the use of linestate by the host controller driver is not necessary (unlike ehci) because the port controller state machine and the port routing manage the connection of ls and fs.  in device mode, the use of linestate by the device controller driver is not necessary." "0,1,2,3"
        bitfld.long 0x00 9. "   US_HSP365        ,high-speed port  0 = host/device connected to the port is not in a high-speed mode  1 = host/device connected to the port is in high-speed mode" "0,1"
        textline "                                      "
        bitfld.long 0x00 8. "US_PR368          ,port reset  this field is 0 if <port power> is 0.  in host mode:  0 = port is not in reset  1 = port is in reset  when software writes 1 to this field, the bus-reset sequence as defined in the usb specification revision 2.0 is started. this field will automatically change to 0 after the reset sequence is complete. this behavior is different from ehci where the host controller driver is required to set this bit to 0 after the reset duration is timed in the driver.  in device mode: this bit is a read only status bit. device reset from the usb bus is also indicated in the usb status register." "0,1"
        bitfld.long 0x00 7. "         US_SUSP369       ,suspend  in host mode:  0 = port not in suspend state  1 = port in suspend state    the <pe> field in the port status/control register and suspend bit of this register define the port states as follows:  0x = disable  10 = enable  11 = suspend  when in suspend state, downstream propagation of data is blocked on this port, except for port reset. the blocking occurs at the end of the current transaction if a transaction was in progress when this bit was written to 1. in the suspend state, the port is sensitive to resume detection. note that the bit status does not change until the port is suspended and that there may be a delay in suspending a port if there is a transaction currently in progress on the usb.  the host controller will unconditionally set this bit to zero when software sets the <fpr> bit to zero. the host controller ignores a write of zero to this bit.  if the host software sets this bit to a one when the port is not enabled (i.e. <pe> bit is a zero), the results are undefined.  this field is zero if <pp> is zero in host mode.    in device mode:  0 = port not in suspend state  1 = port in suspend state  in device mode, this bit is a read only status bit." "0,1"
        bitfld.long 0x00 6. "     US_FPR370        ,force port resume  0 = no resume (k-state) detected/driven on port  1 = resume detected/driven on port    in host mode: software sets this field to 1 to drive resume signaling. the host controller sets this bit to 1 if a j-to-k transition is detected while the port is in the suspend state. when this bit transitions to 1 because a j-to-k transition is detected, the <port change detect> field in the usb status register is also set to 1. this field will automatically change to 0 after the resume sequence is complete. this behavior is different from ehci where the host controller driver is required to set this bit to 0 after the resume duration is timed in the driver." "0,1"
        bitfld.long 0x00 5. "   US_OCC373        ,over-current change  1 = this field gets set to 1 when there is a change to over-current active. software clears this field by writing 1 to this bit position." "0,1"
        textline "                                      "
        bitfld.long 0x00 4. "US_OCA374         ,over-current active  0 = this port does not have an over-current condition. this field will automatically transition from 1 to 0 when the over current condition is removed." "0,1"
        bitfld.long 0x00 3. "         US_PEC375        ,port enable/disable change  0 = no change  1 = port enabled/disabled status has changed  in host mode: for the root hub, this field gets set to 1 only when a port is disabled due to disconnect on the port or due to the appropriate conditions existing at the eof2 point (see chapter 11 of the usb specification). software clears this by writing 1 to it.   this field is 0 if <port power> is 0.  in device mode: the device port is always enabled. (this bit will be 0.)" "0,1"
        bitfld.long 0x00 2. "     US_PE376         ,port enabled/disabled  0 = disable (default)  1 = enable  in host mode: ports can only be enabled by the host controller as a part of the reset and enable. software cannot enable a port by writing 1 to this field. ports can be disabled by either a fault condition (disconnect event or other fault condition) or by the host software. note that the bit status does not change until the port state actually changes. there may be a delay in disabling or enabling a port due to other host controller and bus events.  when the port is disabled, (0) downstream propagation of data is blocked except for reset.  this field is 0 if <port power> is 0 in host mode.  in device mode: the device port is always enabled. (this bit will be 1.)" "0,1"
        bitfld.long 0x00 1. "   US_CSC377        ,connect status change  0 = no change  1 = change in current connect status  in host mode: indicates a change has occurred in the port's current connect status. the host/device controller sets this field for all changes to the port device connect status, even if system software has not cleared an existing connect status change. for example, the insertion status changes twice before system software has cleared the changed condition, hub hardware will be setting an already-set bit (that is, the bit will remain set). software clears this field by writing 1 to it.  this field is 0 if <port power> is zero in host mode.  in device mode: this bit is undefined in device controller mode." "0,1"
        textline "                                      "
        bitfld.long 0x00 0. "US_CCS378         ,current connect status  in host mode: this value reflects the current state of the port and may not correspond directly to the event that caused the <connect status change> field to be set.  0 = no device is present  1 = device is present on port  this field is 0 if <port power> is zero in host mode.  in device mode: when set to 1, it indicates that the device successfully attached and is operating in either high speed or full speed as indicated by the <high-speed port> field. when set to 0, it indicates that the device did not attach successfully or was forcibly disconnected by the software writing 0 to the run bit in the usb command register. it does not state the device being disconnected or suspended.  0 = not attached  1 = attached" "0,1"

group d:0xD42081A4++0x03
    line.long 0x00 "USB_OTGSC,OTG Status and Control Register"
        bitfld.long 0x00 30. " DPIE              ,data pulse interrupt enable" "0,1"
        bitfld.long 0x00 29. "         1MSE             ,1 millisecond timer interrupt enable" "0,1"
        bitfld.long 0x00 28. "     BSEIE            ,b session end interrupt enable  setting this field enables the b session end interrupt." "0,1"
        bitfld.long 0x00 27. "   BSVIE            ,b session valid interrupt enable  setting this field enables the b session valid interrupt." "0,1"
        textline "                                      "
        bitfld.long 0x00 26. "ASVIE             ,a session valid interrupt enable  setting this field enables the a session valid interrupt." "0,1"
        bitfld.long 0x00 25. "         AVVIE            ,a vbus valid interrupt enable  setting this field enables the a vbus valid interrupt." "0,1"
        bitfld.long 0x00 24. "     IDIE             ,usb id interrupt enable  setting this field enables the usb id interrupt." "0,1"
        bitfld.long 0x00 22. "   DPIS             ,data pulse interrupt status  this bit is set when data bus pulsing occurs on dp or dm. data bus pulsing is only detected when the <controller mode> field in the usb device mode register = host (0x3) and the <port power> field in the port status/control register = off (0).  software must write 1 to clear this field." "0,1"
        textline "                                      "
        bitfld.long 0x00 21. "1MSS              ,1 millisecond timer interrupt status  this bit is set once every millisecond.  software must write 1 to clear this bit." "0,1"
        bitfld.long 0x00 20. "         BSEIS            ,b session end interrupt status  this bit is set when vbus has fallen below the b session end threshold.  software must write 1 to clear this bit." "0,1"
        bitfld.long 0x00 19. "     BSVIS            ,b session valid interrupt status  this bit is set when vbus has either risen above or fallen below the b session valid threshold (0.8 vdc).  software must write 1 to clear this bit." "0,1"
        bitfld.long 0x00 18. "   ASVIS            ,a session valid interrupt status  this bit is set when vbus has either risen above or fallen below the a session valid threshold (0.8 vdc).  software must write 1 to clear this bit." "0,1"
        textline "                                      "
        bitfld.long 0x00 17. "AVVIS             ,a vbus valid interrupt status  this field is set when vbus has either risen above or fallen below the vbus valid threshold (4.4 vdc) on an a device.  software must write 1 to clear this bit." "0,1"
        bitfld.long 0x00 16. "         IDIS             ,usb id interrupt status  this bit is set when a change on the id input has been detected.  software must write 1 to clear this field." "0,1"
        bitfld.long 0x00 14. "     DPS              ,data bus pulsing status  1 = data bus pulsing is being detected on the port" "0,1"
        bitfld.long 0x00 13. "   1MST             ,1 millisecond timer toggle  this field toggles once per millisecond." "0,1"
        textline "                                      "
        bitfld.long 0x00 12. "BSE               ,b session end  indicates vbus is below the b session end threshold." "0,1"
        bitfld.long 0x00 11. "         BSV              ,b session valid  indicates vbus is above the b session valid threshold." "0,1"
        bitfld.long 0x00 10. "     ASV              ,a session valid  indicates vbus is above the a session valid threshold." "0,1"
        bitfld.long 0x00 9. "   AVV              ,a vbus valid  indicates vbus is above the a vbus valid threshold." "0,1"
        textline "                                      "
        bitfld.long 0x00 8. "US_ID408          ,usb id  0 = a device  1 = b device" "0,1"
        bitfld.long 0x00 7. "         HABA             ,hardware assist b-disconnect to a-connect  0 = disabled  1 = enable automatic b-disconnect to a-connect sequence" "0,1"
        bitfld.long 0x00 6. "     HADP             ,hardware assist data pulse (write to set)  1 = start data pulse sequence" "0,1"
        bitfld.long 0x00 5. "   IDPU             ,id pullup  this field provides control over the id pull-up resister.  0 = off  1 = on  when this bit is 0, the id input will not be sampled." "0,1"
        textline "                                      "
        bitfld.long 0x00 4. "DP                ,data pulsing  setting this field causes the pullup on dp to be asserted for data pulsing during srp." "0,1"
        bitfld.long 0x00 3. "         OT               ,otg termination  this field must be set when the otg device is in device mode, this controls the pulldown on dm." "0,1"
        bitfld.long 0x00 2. "     HAAR             ,hardware assist auto-reset  0 = disabled  1 = enable automatic reset after connect on host port" "0,1"
        bitfld.long 0x00 1. "   VC               ,vbus charge  setting this field causes the vbus line to be charged. this is used for vbus pulsing during srp." "0,1"
        textline "                                      "
        bitfld.long 0x00 0. "VD                ,vbus_discharge  setting this field causes vbus to discharge through a resistor." "0,1"

group d:0xD42081A8++0x03
    line.long 0x00 "USB_MODE,USB Device Mode Register"
        bitfld.long 0x00 15. " SRT               ,when the controller is in host mode, this bit enables a bypass of the chirp j/k reset handshake, saving 6-7ms in simulation time for each reset sequence. this bit should only be used for initial system integration simulations, and should always be set to 0 for normal operation." "0,1"
        bitfld.long 0x00 5. "         VBPS             ,this bit is connected to the vbus_pwr_select output and can be used for any generic control but is named to be used by logic that selects between an on-chip vbus power source (charge pump) and an off-chip source in systems when both are available." "0,1"
        bitfld.long 0x00 4. "     US_SDIS427       ,stream disable mode  0 = inactive  1 = active  device mode: setting to a 1 disables double priming on both rx and tx for low bandwidth systems. this mode ensures that when the rx and tx buffers are sufficient to contain an entire packet, that the standard double buffering scheme is disabled to prevent overruns/underruns in bandwidth limited systems." "0,1"
        bitfld.long 0x00 3. "   US_SLOM432       ,setup lockout mode  in device mode, this field controls behavior of the setup lock mechanism. see control endpoint operation model.  0 = setup lockouts on  1 = setup lockouts off (dcd requires use of setup data buffer tripwire in the usb command register)" "0,1"
        textline "                                      "
        bitfld.long 0x00 2. "US_ES433          ,endian select  this field can change the byte ordering of the transfer buffers to match the host microprocessor bus architecture. the bit fields in the microprocessor interface and the dma data structures (including the setup buffer within the device qh) are unaffected by the value of this field because they are based upon 32-bit words.  0 = little endian – first byte referenced in least significant byte of 32-bit word  1 = big endian - first byte referenced in most significant byte of 32-bit word" "0,1"
        bitfld.long 0x00 0.--1. "         US_CM434         ,controller mode  controller mode is defaulted to the proper mode for host only and device only implementations. for those designs that contain both host and device capability, the controller will default to an idle state and will need to be initialized to the desired operating mode after reset. for combination host/device controllers, this register can only be written once after reset. if it is necessary to switch modes, software must reset the controller by writing to the <controller reset (reset)> field in the usb command register before reprogramming this register.  0x0 = idle  0x1 = reserved  0x2 = device controller  0x3 = host controller" "0,1,2,3"

group d:0xD42081AC++0x03
    line.long 0x00 "USB_ENDPTSETUPSTAT,Endpoint Setup Status Register"
        hexmask.long.word 0x00 0.--15. 1. " ENDPTSETUPSTAT150 ,setup endpoint status  for every setup transaction that is received, a corresponding bit in this register is set to 1. software must clear or acknowledge the setup transfer by writing 1 to a respective bit after it has read the setup data from queue head. the response to a setup packet as in the order of operations and total response time is crucial to limit bus time outs while the setup lock our mechanism is engaged. see managing endpoints in the device operational mode.  this register is only used in device mode."

group d:0xD42081B0++0x03
    line.long 0x00 "USB_ENDPTPRIME,Endpoint Initialization Register"
        hexmask.long.word 0x00 16.--31. 1. " PETB              ,prime endpoint transmit buffer  for each endpoint, a corresponding bit is used to request that a buffer prepared for a transmit operation in order to respond to a usb in/interrupt transaction. software should write 1 to the corresponding bit when posting a new transfer descriptor to an endpoint. hardware will automatically use this bit to begin parsing for a new transfer descriptor from the queue head and prepare a transmit buffer. hardware will clear this bit when the associated endpoint(s) is (are) successfully primed.  these bits will be momentarily set by hardware during hardware re-priming operations when a dtd is retired, and the dqh is updated.  petb[3] – endpoint #3  petb[2] – endpoint #2  petb[1] – endpoint #1  petb[0] – endpoint #0  all other bits are reserved."
        hexmask.long.word 0x00 0.--15. 1. "      PERB             ,prime endpoint receive buffer  for each endpoint, a corresponding bit is used to request a buffer prepare for a receive operation for when a usb host initiates a usb out transaction. software should write 1 to the corresponding bit whenever posting a new transfer descriptor to an endpoint. hardware will automatically use this bit to begin parsing for a new transfer descriptor from the queue head and prepare a receive buffer. hardware will clear this bit when the associated endpoint(s) is (are) successfully primed.  these bits will be momentarily set by hardware during hardware re-priming operations when a dtd is retired, and the dqh is updated.  bit 3 – endpoint #3  bit 2 – endpoint #2  bit 1 – endpoint #1  bit 0 – endpoint #0  all other bits are reserved."

group d:0xD42081B4++0x03
    line.long 0x00 "USB_ENDPTFLUSH,Endpoint De-Initialize Register"
        hexmask.long.word 0x00 16.--31. 1. " FETB              ,flush endpoint transmit buffer  writing 1 to a bit(s) in this register will cause the associated endpoint(s) to clear any primed buffers. if a packet is in progress for one of the associated endpoints, then that transfer will continue until completion. hardware will clear this register after the endpoint flush operation is successful.  fetb[3] – endpoint #3  fetb[2] – endpoint #2  fetb[1] – endpoint #1  fetb[0] – endpoint #0  all other bits are reserved."
        hexmask.long.word 0x00 0.--15. 1. "      FERB             ,flush endpoint receive buffer  writing 1 to a bit(s) will cause the associated endpoint(s) to clear any primed buffers. if a packet is in progress for one of the associated endpoints, then that transfer will continue until completion. hardware will clear this register after the endpoint flush operation is successful.  bit 3 – endpoint #3  bit 2 – endpoint #2  bit 1 – endpoint #1  bit 0 – endpoint #0  all other bits are reserved."

group d:0xD42081B8++0x03
    line.long 0x00 "USB_ENDPTSTAT,Endpoint STAT Register"
        hexmask.long.word 0x00 16.--31. 1. " ETBR              ,endpoint transmit buffer ready  one bit for each endpoint indicates status of the respective endpoint buffer. this bit is set to 1 by the hardware as a response to receiving a command from a corresponding bit in the endpoint initialization register. there will always be a delay between setting a bit in the endpoint initialization register and endpoint indicating ready. this delay time varies based upon the current usb traffic and the number of bits set in the endpoint initialization register. buffer ready is cleared by usb reset, by the usb dma system, or through the endpoint de-initialize register."
        hexmask.long.word 0x00 0.--15. 1. "      ERBR             ,endpoint receive buffer ready  one bit for each endpoint indicates status of the respective endpoint buffer. this bit is set to 1 by the hardware as a response to receiving a command from a corresponding bit in the endpoint initialization register. there will always be a delay between setting a bit in the endpoint initialization register and endpoint indicating ready. this delay time varies based upon the current usb traffic and the number of bits set in the endpoint initialization register. buffer ready is cleared by usb reset, by the usb dma system, or through the endpoint de-initialize register."

group d:0xD42081BC++0x03
    line.long 0x00 "USB_ENDPTCOMPLETE,Endpoint Complete Register"
        hexmask.long.word 0x00 16.--31. 1. " ETCE              ,endpoint transmit complete event  each bit indicates a transmit event (in/interrupt) occurred and software should read the corresponding endpoint queue to determine the endpoint status. if the corresponding ioc bit is set in the transfer descriptor, then this bit will be set simultaneously with the usbint. writing 1 will clear the corresponding bit in this register.  etce[3] – endpoint #3  etce[2] – endpoint #2  etce[1] – endpoint #1  etce[0] – endpoint #0  all other bits are reserved."
        hexmask.long.word 0x00 0.--15. 1. "      ERCE             ,endpoint receive complete event  each bit indicates a received event (out/setup) occurred and software should read the corresponding endpoint queue to determine the transfer status. if the corresponding ioc bit is set in the transfer descriptor, then this bit will be set simultaneously with the usbint. writing 1 will clear the corresponding bit in this register.  erce[3] – endpoint #3  erce[2] – endpoint #2  erce[1] – endpoint #1  erce[0] – endpoint #0  all other bits are reserved."

group d:0xD42081C0++0x03
    line.long 0x00 "USB_ENDPTCTRL0,Endpoint Control 0 Register"
        bitfld.long 0x00 23. " US_TXE486         ,tx endpoint enable  1 = enabled  endpoint0 is always enabled." "0,1"
        bitfld.long 0x00 18.--19. "         TXT488           ,tx endpoint type  0x0 = control  endpoint0 is fixed as a control end point." "0,1,2,3"
        bitfld.long 0x00 16. "     TXS490           ,tx endpoint stall  0 = end point ok  1 = end point stalled  software can write 1 to this field to force the endpoint to return a stall handshake to the host. it will continue returning stall until the field is cleared by software or it will automatically be cleared upon receipt of a new setup request." "0,1"
        bitfld.long 0x00 7. "   RXE492           ,rx endpoint enable  1 = enabled  endpoint0 is always enabled." "0,1"
        textline "                                      "
        bitfld.long 0x00 2.--3. "RXT494            ,rx endpoint type  0x0 = control  endpoint0 is fixed as a control end point." "0,1,2,3"
        bitfld.long 0x00 0. "         RXS496           ,rx endpoint stall  0 = end point ok  1 = end point stalled  software can write 1 to this field to force the endpoint to return a stall handshake to the host. it will continue returning stall until the field is cleared by software or it will automatically be cleared upon receipt of a new setup request." "0,1"

group d:0xD42081C4++0x03
    line.long 0x00 "USB_ENDPTCTRL1-ENDPTCTRL15,Endpoint Control 1 to Endpoint Control 15 Registers"
        bitfld.long 0x00 23. " US_TXE504         ,tx endpoint enable  0 = disabled  1 = enabled  an endpoint should be enabled only after it has been configured." "0,1"
        bitfld.long 0x00 22. "         TXR              ,tx data toggle reset (ws)  write 1 reset pid sequence  whenever a configuration event is received for this endpoint, software must write 1 to this field in order to synchronize the data pid's between the host and device." "0,1"
        bitfld.long 0x00 21. "     TXI              ,tx data toggle inhibit  0 = pid sequencing enabled  1 = pid sequencing disabled  this field is only used for test and should always be written as 0. writing 1 to this field will cause this endpoint to ignore the data toggle sequence and always transmit data0 for a data packet." "0,1"
        bitfld.long 0x00 18.--19. "   TXT508           ,tx endpoint type  0x0 = control  0x1 = isochronous  0x2 = bulk  0x3 = interrupt" "0,1,2,3"
        textline "                                      "
        bitfld.long 0x00 17. "TXD               ,tx endpoint data source  0 = dual port memory buffer/dma engine  this field should always be written as 0." "0,1"
        bitfld.long 0x00 16. "         TXS510           ,tx endpoint stall  0 = end point ok  1 = end point stalled  this field will be set automatically upon receipt of a setup request if this endpoint is not configured as a control endpoint. it will be cleared automatically upon receipt of a setup request if this endpoint is configured as a control endpoint.  software can write 1 to this field to force the endpoint to return a stall handshake to the host. it will continue to return stall until this field is either cleared by software or automatically cleared as above." "0,1"
        bitfld.long 0x00 7. "     RXE512           ,rx endpoint enable  0 = disabled  1 = enabled  an endpoint should be enabled only after it has been configured." "0,1"
        bitfld.long 0x00 6. "   RXR              ,rx data toggle reset (ws) write  1 = reset pid sequence  whenever a configuration event is received for this endpoint, software must write 1 to this field in order to synchronize the data pid's between the host and device." "0,1"
        textline "                                      "
        bitfld.long 0x00 5. "RXI               ,rx data toggle inhibit  0 = disabled  1 = enabled  this field is only used for test and should always be written as 0. writing 1 to this field will cause this endpoint to ignore the data toggle sequence and always accept data packet regardless of their data pid." "0,1"
        bitfld.long 0x00 2.--3. "         RXT516           ,rx endpoint type  0x0 = control  0x1 = isochronous  0x2 = bulk  0x3 = reserved" "0,1,2,3"
        bitfld.long 0x00 1. "     US_RXD517        ,rx endpoint data sink tbd  0 = dual port memory buffer/dma engine  this field should always be written as 0." "0,1"
        bitfld.long 0x00 0. "   RXS518           ,rx endpoint stall  0 = end point ok  1 = end point stalled  this field will be set automatically upon receipt of a setup request if this endpoint is not configured as a control endpoint. it will be cleared automatically upon receipt a setup request if this endpoint is configured as a control endpoint.  software can write 1 to this field to force the endpoint to return a stall handshake to the host. it will continue to returning stall until this field is either cleared by software or automatically cleared as above." "0,1"

tree.end

tree "cpdma"

width 16.

group d:0xD0200000++0x03
    line.long 0x00 "DMA_CSR031,DMA Channel Control/Status Registers 0-31"
        bitfld.long 0x00 31. " DM_RUN16                 ,run  this field allows software to start or stop the channel. if it is cleared in the middle of the burst, the burst is completed before the channel stops. setting this field starts the stopped channel.  if the channel is in a descriptor-fetch transfer and this field is set before writing a valid descriptor address to the dma descriptor address registers, no-descriptor fetch occurs.  this bit is reset as soon as it is cleared and when the channel stops normally. after the channel stops, the <stop interrupt> field is set. the <stop interrupt> field must be polled to read the channel status or to set the <stop interrupt enabled> field and expect an interrupt after the channel stops.  0 = stops the channel  1 = starts the channel" "0,1"
        bitfld.long 0x00 30. "         DM_NODESCFETCH17 ,no-descriptor fetch  this bit controls whether or not a channel has a descriptor. if this field is set, the channel is considered a simple channel with no descriptors. in this case, the dma does not initiate descriptor fetches when software sets the <run> field or when the byte count for the current transfer reaches zero.  to program the channel for a no-descriptor-fetch transfer, software must set, then write to the individual dma source address registers 0-31, dma target address registers 0-31, and dma command registers 0-31 for that channel. the dma descriptor address registers are not used in this mode and must not be written. the <run> field must be set to allow the channel to start the transfer.   if this field is cleared, the dmac initiates descriptor-fetches when software writes to the dma descriptor address registers, when the byte count for the current transfer reaches zero.  0 = descriptor-fetch transfer  1 = no-descriptor-fetch transfer" "0,1"
        bitfld.long 0x00 29. "   DM_STOPIRQEN18   ,stop interrupt enabled  this field enables the interrupt when the <stop interrupt> field is set. if this field is cleared, no interrupt is generated after the channel stops.  the <stop interrupt> field is set after system reset de-assertion. thus, if <stop interrupt> is set before the channel is started, an interrupt is generated.  0 = no interrupt if the channel is in uninitialized or stopped state  1 = interrupt enabled if the channel is in uninitialized or stopped state" "0,1"
        bitfld.long 0x00 28. "     DM_EORIRQEN19  ,setting the end-of-receive interrupt enable  this field triggers an interrupt on an eor condition. clearing this bit does not generate an eor-related interrupt.  0 = interrupt not triggered even if the <end of receive interrupt> field is set  1 = enable interrupt if <end of receive interrupt> is set" "0,1"
        textline "                          "
        bitfld.long 0x00 27. "DM_EORJMPEN20            ,jump to the next descriptor on eor  this field controls the descriptor flow when the mapped peripheral signals an eor to the dmac. see descriptor behavior on end-of-receive (eor) figure for the behavior of the descriptor during this condition.  this control bit has no effect on the channel for no-descriptor-fetch transfers (<no-descriptor fetch> set). the dmac completes the peripheral-to-memory data transfer on an eor, regardless of this field.  0 = dmac continues to hold the current descriptor and waits until the mapped peripheral makes another receive request.  1 = dmac jumps to the channel's next descriptor on receiving an eor from the mapped peripheral." "0,1"
        bitfld.long 0x00 26. "         DM_EORSTOPEN21   ,stop channel on eor  this field has no effect on the channel for no-descriptor-fetch transfers (<no-descriptor fetch> set). the dmac completes the peripheral-to-memory data transfer on an eor, regardless of this field.  setting this field causes the dmac to stop the channel on an eor and set the corresponding <stop interrupt> field. if the <stop interrupt enabled> field is set when this field is set, an interrupt occurs.  see descriptor behavior on end-of-receive (eor) figure for the behavior of the descriptor.  0 = dmac continues to hold the current descriptor and waits until the mapped peripheral makes another receive request.  1 = dmac stops the channel that received an eor from the mapped peripheral." "0,1"
        bitfld.long 0x00 25. "   DM_SETCMPST22    ,set descriptor compare status  this field partially controls <descriptor compare status>. setting this bit sets <descriptor compare status>. clearing this field has no effect on <descriptor compare status>. software can set the <descriptor compare status> even if the descriptor is not configured in the compare mode (<descriptor compare enable> field in dma command registers 0-31 = 0).   0 = no effect on <descriptor compare status>  1 = set <descriptor compare status>" "0,1"
        bitfld.long 0x00 24. "     DM_CLRCMPST23  ,clear descriptor compare status  this field partially controls <descriptor compare status>. setting this field clears <descriptor compare status>. clearing this field has no effect on <descriptor compare status>. software can set <descriptor compare status> even if the descriptor is not configured in the compare mode.  0 = no effect on <descriptor compare status>  1 = clear <descriptor compare status>" "0,1"
        textline "                          "
        bitfld.long 0x00 23. "DM_RASIRQEN24            ,request after channel stopped interrupt enable  0 = interrupt not triggered when a peripheral asserts a dma request after the channel has stopped  1 = set interrupt bit for that channel in the <channel interrupt> in the dma interrupt register when a peripheral asserts a dma request after the channel has stopped." "0,1"
        bitfld.long 0x00 22. "         DM_MASKRUN25     ,mask <run> during a programmed i/o write to this register  0 = software (programmed i/o write) can modify <run> during a write transaction  1 = software (programmed i/o write) can not modify <run> during a write transaction" "0,1"
        bitfld.long 0x00 10. "   DM_CMPST27       ,descriptor compare status  this field indicates the most recent status of the source and target compare operation. it is set on a successful compare of the source and target fields. an unsuccessful comparison clears it. refer to the description of <addrmode> in the dma command registers 0-31 for the various addressing modes used for this comparison. for details regarding the descriptor compare mode, refer to <descriptor compare enable> in the dma command registers 0 to 31.  the dmac updates cmpst only in descriptor compare mode (<descriptor compare enable> = 1).  this field can be set and cleared by setting <set descriptor compare status> and <clear descriptor compare status>, respectively.  if software attempts to concurrently set and clear this field by setting both <set descriptor compare status> and <clear descriptor compare status>, <set descriptor compare status> has higher precedence. modifying this bit after <run> is set and the channel is actively running leads to faulty behavior of the descriptor chain. the channel must be stopped before setting or clearing this field.  0 = indicates an unsuccessful address compare in descriptor-compare mode.  1 = indicates a successful compare of the current descriptor source and target addresses in descriptor-compare mode." "0,1"
        bitfld.long 0x00 9. "     DM_EORINT28    ,end of receive interrupt  eorint pertains only to internal peripherals. this field indicates the status of the mapped peripheral's receive data. it is set after the dmac reads out the last trailing sample from the peripheral's receive fifo. the descriptor behavior on end-of-receive (eor) figure illustrates the behavior of the descriptor during this condition.  0 = dma continues with current descriptor because the internal peripheral is still actively receiving data  1 = channel mapped internal peripheral has no data remaining in its receive fifo and has completed all receive transactions. refer to the description of <jump to the next descriptor on eor> for the behavior of the dmac during this condition." "0,1"
        textline "                          "
        bitfld.long 0x00 8. "REQPEND30                ,request pending  this field indicates a pending request for the dma channel.  reqpend is cleared for a channel if that channel has no pending request or the request has just been issued to the memory interface in case of a read or write from the external companion chip to memory.   if dreq assertion sets reqpend and <run> is cleared to stop that channel, reqpend and the internal registers that hold the dreq assertion information, do not remain set. if the channel is restarted, reqpend must be reset by a descriptor that transfers dummy data (for example, a memory-to-memory transfer from a temporary location to another temporary location).   0 = no request is pending for the channel  1 = a request is pending for the channel" "0,1"
        bitfld.long 0x00 4. "         DM_RASINTR32     ,request after channel stopped  0 = no interrupt   1 = interrupt caused due to a request made by the peripheral after the respective channel stopped  this bit is reset by writing a 1." "0,1"
        bitfld.long 0x00 3. "   DM_STOPINTR33    ,stop interrupt  this is a read-only bit that reflects the channel state.  software must clear <stop interrupt enabled> to reset the interrupt. reprogramming the dma descriptor address registers and setting <run> restarts the channel.  0 = channel is running  1 = channel is in uninitialized or stopped state. if <stop interrupt enabled> is set, the dmac generates an interrupt." "0,1"
        bitfld.long 0x00 2. "     DM_ENDINTR34   ,end interrupt  this field indicates that the current descriptor finished successfully and that <end interrupt enable> in the dma command registers 0-31 is set.   0 = no interrupt  1 = interrupt was caused due to successful completion of the current transaction and <length of the transfer in bytes> field in dma command registers 0-31 = 0" "0,1"
        textline "                          "
        bitfld.long 0x00 1. "DM_STARTINTR35           ,start interrupt  this field indicates that the current descriptor was loaded successfully and that <startirqen> in the dma command registers 0-31 is set.   0 = no interrupt  1 = interrupt was caused due to successful descriptor fetch" "0,1"
        bitfld.long 0x00 0. "         DM_BUSERRINTR36  ,bus error interrupt  this field indicates that an error occurred during a data transfer on the internal bus. the error may be due to a bad descriptor source or target address (any address that is in the non-burstable or reserved space can cause a bus error on the system bus). only one error per channel is logged. the channel that caused the error is not updated at the end of the transfer and is not accessible until it is reprogrammed and the corresponding <run> field is set.  0 = no interrupt  1 = interrupt was caused by bus error" "0,1"

group d:0xD02000A0++0x03
    line.long 0x00 "DMA_ALGN,DMA Alignment Register"
        hexmask.long 0x00 0.--31. 1. " DM_DALGNX52              ,alignment control for channel x  0 = source and target addresses of channel x are default aligned (internal peripherals default to 4 byte alignment, external bus addresses default to 8 byte alignment)  1 = source and target addresses of channel x are as defined by user (byte aligned)"

group d:0xD02000A4++0x03
    line.long 0x00 "DMA_PCSR,DMA Programmed I/O Control Status Register"
        bitfld.long 0x00 31. " DM_BRGSPLIT70            ,activate posted writes and split reads  0 = de-activate posted writes, split responses, split completions and retries.  activate posted writes, split responses, split completions and retries." "0,1"
        bitfld.long 0x00 2. "         DPCSR_2_R        ," "0,1"
        bitfld.long 0x00 1. "   DPCSR_1_R        ," "0,1"
        bitfld.long 0x00 0. "     DM_BRGBUSY74   ,bridge busy status  0 = no pending pio transactions across peripheral bus. a new pio transaction is not retried in this case.  1 = pending pio transaction across peripheral bus. any further pio transactions on the system bus are retried." "0,1"

group d:0xD02000E0++0x03
    line.long 0x00 "DMA_RQSR0,DREQ Status Register 0"
        bitfld.long 0x00 8. " CLR88                    ,clearing pending request  writing 0x1 to this field clears the <request pending> field and thereby clears all pending requests made by the external dma request pin dreq. writing 0x0 to this field has no effect. this field can be used for clearing the requests if the channel mapped to dreq was prematurely stopped by software. this field must be set only after the mapped channel has stopped (<stop interrupt> field in the dma channel control/status registers 0-31 is set). clearing the requests of a running channel results in unpredictable behavior.  0 = no effect on <request pending>  1 = clear all pending requests registered in <request pending>" "0,1"
        bitfld.long 0x00 0.--4. "         REQPEND90        ,request pending  indicates the number of pending requests on dreq." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"

group d:0xD02000E4++0x03
    line.long 0x00 "DMA_RQSR1,DREQ Status Register 1"
        bitfld.long 0x00 8. " CLR98                    ,clearing pending request  writing 0x1 to this field clears the <request pending> field and thereby clears all pending requests made by the external dma request pin dreq. writing 0x0 to this field has no effect. this field can be used for clearing the requests if the channel mapped to dreq was prematurely stopped by software. this field must be set only after the mapped channel has stopped (<stop interrupt> field in the dma channel control/status registers 0-31 is set). clearing the requests of a running channel results in unpredictable behavior.  0 = no effect on <request pending>  1 = clear all pending requests registered in <request pending>" "0,1"
        bitfld.long 0x00 0.--4. "         REQPEND100       ,request pending  indicates the number of pending requests on dreq." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"

group d:0xD02000E8++0x03
    line.long 0x00 "DMA_RQSR2,DREQ Status Register 2"
        bitfld.long 0x00 8. " CLR107                   ,clearing pending request  writing 0x1 to this field clears the <request pending> field and thereby clears all pending requests made by the external dma request pin dreq. writing 0x0 to this field has no effect. this field can be used for clearing the requests if the channel mapped to dreq was prematurely stopped by software. this field must be set only after the mapped channel has stopped (<stop interrupt> field in the dma channel control/status registers 0-31 is set). clearing the requests of a running channel results in unpredictable behavior.  0 = no effect on <request pending>  1 = clear all pending requests registered in <request pending>" "0,1"
        bitfld.long 0x00 0.--4. "         REQPEND109       ,request pending  indicates the number of pending requests on dreq." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"

group d:0xD02000F0++0x03
    line.long 0x00 "DMA_INT,DMA Interrupt Register"
        hexmask.long 0x00 0.--31. 1. " DM_CHLINTRX123           ,channel interrupt  this field indicates that dma channel x has been interrupted.  0 = no interrupt  1 = interrupt"

group d:0xD0200100++0x03
    line.long 0x00 "DMA_RCMRx0,DMA Request to Channel Map Registers 0-63 and 64-99"

group d:0xD0201100++0x03
    line.long 0x00 "DMA_RCMRx1,DMA Request to Channel Map Registers 0-63 and 64-99"
        bitfld.long 0x00 7. " DM_MAPVLD133             ,map valid channel  defines whether the request is mapped to a valid channel. if the field is set, the request is mapped to a valid channel indicated by <channel number>. if the field is cleared, the request is unmapped.  this bit can also be used to mask the request.  0 = request is unmapped  1 = request is mapped to a valid channel indicated by <channel number>" "0,1"
        bitfld.long 0x00 0.--4. "         DM_CHLNUM135     ,channel number  indicates the valid channel number if <map valid channel> is set. do not map two active requests to the same channel since it produces unpredictable results." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"

group d:0xD0200200++0x03
    line.long 0x00 "DMA_DADRx,DMA Descriptor Address Registers"
        hexmask.long 0x00 4.--31. 1. " DM_DESCRIPTOR_ADDRESS150 ,descriptor address  contains address of next descriptor."
        bitfld.long 0x00 1. "  DM_BREN152       ,enable descriptor branch  works with the <descriptor compare status> field in the dma channel control/status registers 0-31 to determine which descriptor is fetched next. if both this field and <descriptor compare status> are set, the dmac fetches the next descriptor from (ddadrx + 32 bytes). if either of the bits is cleared, dmac fetches the next descriptor from the dma descriptor address registers.  this field is relevant only for descriptor-fetch transactions (<no-descriptor fetch> field in the dma channel control/status registers 0-31 = 0).  see dreq timing requirements figure for details about the operational flow.  0 = disable descriptor branching. fetch the next descriptor from register ddadrx.  1 = enable descriptor branching" "0,1"
        bitfld.long 0x00 0. "   DM_STOP153       ,stop  if this field is cleared, a new descriptor fetch based on dma descriptor address registers and other control information is initiated after the current descriptor is completely processed.  0 = run channel  1 = stop channel after completely processing this descriptor and before fetching the next descriptor (<length of the transfer in bytes> field in dma command registers 0-31 = 0)" "0,1"

group d:0xD0200204++0x03
    line.long 0x00 "DMA_SADRx,DMA Source Address Registers 0-31"
        hexmask.long 0x00 3.--31. 1. " DM_SRCADDR170            ,source address  source address of the on-chip peripheral, external peripheral, companion chip, or address of a memory location"
        bitfld.long 0x00 2. "  DM_SRCADDR2171   ,srcaddr[2] if <source address> is a memory location and alignment register is configured. see dma alignment register for programming details and restrictions.  srcaddr[2] if <source address> is an on-chip peripheral.  reserved for all companion-chip or external peripheral-related transfers.  reserved for special dma modes, such as compare modes." "0,1"
        bitfld.long 0x00 0.--1. "   DM_SRCADDR0172   ,srcaddr[1:0] if <source address> is a memory location and alignment register is configured. see dma alignment register for programming details and restrictions.  reserved if <source address> is an on-chip peripheral.  reserved for all companion-chip or external peripheral related transfers.  reserved for special dma modes, such as compare modes." "0,1,2,3"

group d:0xD0200208++0x03
    line.long 0x00 "DMA_TADRx,DMA Target Address Registers 0-31"
        hexmask.long 0x00 3.--31. 1. " DM_TRGADDR189            ,target address  target address of the on-chip peripheral, external peripheral, companion chip, or address of a memory location"
        bitfld.long 0x00 2. "  DM_TRGADDR2190   ,trgaddr[2] if <target address> is a memory location and alignment register is configured. see dma alignment register for programming details and restrictions.  trgaddr[2] if <target address> is an on-chip peripheral.  reserved for all companion-chip or external peripheral-related transfers.  reserved for special dma modes, such as compare modes." "0,1"
        bitfld.long 0x00 0.--1. "   DM_TRGADDR0191   ,trgaddr[1:0], if target address is a memory location and alignment register is configured. see dma alignment register for programming details and restrictions.  reserved if target address is an on-chip peripheral.  reserved for all companion-chip or external peripheral related transfers.  reserved for special dma modes, such as compare modes." "0,1,2,3"

group d:0xD020020C++0x03
    line.long 0x00 "DMA_CMDx,DMA Command Registers 0-31"
        bitfld.long 0x00 31. " DM_INCSRCADDR205         ,source address increment  if the source address is an internal peripheral fifo address or external i/o address, the address is not incremented on each successive access. in these cases, this field must be cleared.  0 = do not increment source address  1 = increment source address" "0,1"
        bitfld.long 0x00 30. "         DM_INCTRGADDR206 ,target address increment  if the target address is an internal peripheral fifo address or external i/o address, the address is not incremented on each successive accesses. in these cases, this field must be cleared.  0 = do not increment target address  1 = increment target address" "0,1"
        bitfld.long 0x00 29. "   DM_FLOWSRC207    ,source flow control  the flow control of the source bit must be set if the source is an on-chip peripheral or external companion chip.  setting both this field and <target flow control> causes unpredictable behavior.  0 = do not wait for request signals associated with this channel  1 = wait for a request signal before initiating the data transfer" "0,1"
        bitfld.long 0x00 28. "     DM_FLOWTRG208  ,target flow control  the flow control of the target bit must be set if the target is an on-chip peripheral or external companion chip.  setting both the <source flow control> and this field causes unpredictable behavior.  0 = do not wait for request signals associated with this channel  1 = wait for a request signal before initiating the data transfer" "0,1"
        textline "                          "
        bitfld.long 0x00 25. "DM_CMPEN210              ,descriptor compare enable  this field must be cleared for normal dma operations.  setting the field enables the descriptor-compare mode, in which the dmac treats the current descriptor as a special case and compares data that corresponds to the source and target fields.   <addrmode> is used to determine the addressing mode before the compare operation.  0 = dma does not perform any address-compare operations  1 = dma recognizes the current descriptor as a special case and compares data based on the source address and target address fields. if the compare is true, the channel's <descriptor compare status> field in the dma channel control/status registers 0-31 is set. if the compare is false, <descriptor compare status> is cleared." "0,1"
        bitfld.long 0x00 23. "         DM_ADDRMODE212   ,addressing mode  this field controls the addressing mode for descriptor comparison and is valid only in the descriptor compare mode (<descriptor compare enable> = 1).  reserved if <descriptor compare enable> = 0.  if <descriptor compare enable> is set, the bits specify the addressing modes of the source address and target address fields. if either field contains an address, the dmac fetches the data at that address and uses it for the compare operation.  0 = source address field contains address, and target address field contains address  1 = source address field contains address, and target address field contains data  if dalgnx is clear, then the lowest three bits of immediate data are forced to be 0 before comparison. if dalgnx is set, then the lowest three bits of immediate data are not forced to be 0 before comparison." "0,1"
        bitfld.long 0x00 22. "   DM_STARTIRQEN213 ,start interrupt enable  this field indicates that the interrupt is enabled as soon as the descriptor is loaded.   in no-descriptor-fetch transfers, this field is reserved.  0 = interrupt not triggered after descriptor is loaded  1 = set interrupt bit for that channel in the <channel interrupt> field in the dma interrupt register when the descriptor (4 words) for the channel is loaded" "0,1"
        bitfld.long 0x00 21. "     DM_ENDIRQEN214 ,end interrupt enable  0 = interrupt is not triggered when length decrements to zero.  1 = set the dint interrupt bit for the channel when length decrements to zero." "0,1"
        textline "                          "
        bitfld.long 0x00 16.--17. "DM_SIZE216               ,maximum burst size  maximum burst size of each data transfer  0x0 = reserved  0x1 = 8 bytes  0x2 = 16 bytes  0x3 = 32 bytes  the size must be less than or equal to the serviced peripheral fifo trigger threshold to properly handle the respective fifo trailing bytes." "0,1,2,3"
        bitfld.long 0x00 14.--15. "         DM_WIDTH217      ,width of the on-chip peripheral  this field is reserved for operations that do not involve on-chip peripherals, such as memory-to-memory moves and companion-chip-related operations.  width must be 0x0 for memory-to-memory moves or companion-chip-related operations.  0x0 = reserved for on-chip peripheral-related transactions  0x1 = 1 byte  0x2 = half-word (2 bytes)  0x3 = word (4 bytes)" "0,1,2,3"
        hexmask.long.word 0x00 0.--12. 1. "   DM_LEN219        ,length of the transfer in bytes  this field is the length of transfer in bytes. len = 0 means zero bytes for descriptor-fetch transactions. len = 0 is an invalid setting for no-descriptor-fetch transactions. programming len = 0 in the descriptor-fetch mode when <descriptor compare enable> is clear (normal data transfer mode) causes the channel to immediately discard the descriptor after it is fetched from memory. if the descriptor chain has more descriptors, the channel fetches the next valid descriptor. the channel stops if the descriptor chain has no more descriptors. the maximum transfer length is (8k-1) bytes.  if the transfer is of the memory-to-memory type, the length of the transfer may be any value (except for the len = 0 restriction in no-descriptor-fetch mode) up to a maximum of (8k -1) bytes. if the transfer involves an external peripheral (or a companion chip), then the length of the transfer must be an integer multiple of the peripheral fifo threshold (or water-mark).  if the transfer involves any of the on-chip peripherals, the length of the transfer must be as follows:"

group d:0xD0200000++0x03
    line.long 0x00 "DUMMY_REGISTER,This is a Dummy Register"
        hexmask.long 0x00 0.--31. 1. " DM_DUMMY234              ,this is a dummy register used as a workaround to fix an issue with the rev 2.21 perl script that requires another register follow the last include file (shown above). ignore this register as it will not show up in documentation anyway. (mclark)"

tree.end

tree "gpio"

width 12.

group d:0xD4019000++0x03
    line.long 0x00 "GPIO_PLR,GPIO Pin-Level Register"
        hexmask.long 0x00 0.--31. 1. " PLX    ,gpio port level n (where n = 0 through 31)   0 = port state is low  1 = port state is high"

group d:0xD401900C++0x03
    line.long 0x00 "GPIO_PDR,GPIO Pin Direction Register"
        hexmask.long 0x00 0.--31. 1. " PDX65  ,gpio port direction n (where n = 0 through 31)  0 = port configured as an input  1 = port configured as an output"

group d:0xD4019018++0x03
    line.long 0x00 "GPIO_PSR,GPIO Pin Output Set Register"
        hexmask.long 0x00 0.--31. 1. " PSX    ,gpio output port set n (where n = 0 through 31)  0 = port level unaffected  1 = if port configured as an output, set port level logic high"

group d:0xD4019024++0x03
    line.long 0x00 "GPIO_PCR,GPIO Pin Output Clear Register"
        hexmask.long 0x00 0.--31. 1. " PCX    ,gpio output port clear n (where n = 0 through 31)  0 = port level unaffected  1 = if port configured as an output, clear port level logic low"

group d:0xD4019030++0x03
    line.long 0x00 "GPIO_RER,GPIO Rising-Edge Detect Enable Register"
        hexmask.long 0x00 0.--31. 1. " REX    ,gpio port n rising-edge detect enable (where n = 0 through 31)  0 = disable rising-edge detect enable  1 = set corresponding gpio edge detect status register status bit when a rising edge is detected on the gpio port"

group d:0xD401903C++0x03
    line.long 0x00 "GPIO_FERx,GPIO Falling-Edge Detect Enable Register"
        hexmask.long 0x00 0.--31. 1. " FEX    ,gpio port falling-edge detect enable n (where n = 0 through 31)  0 = disable falling-edge detect enable  1 = set corresponding gpio edge detect status register status bit when a falling edge is detected on the gpio port"

group d:0xD4019048++0x03
    line.long 0x00 "GPIO_EDR,GPIO Edge Detect Status Register"
        hexmask.long 0x00 0.--31. 1. " EDX    ,gpio edge detect status n (where n = 0 through 31)  0 = no edge detect has occurred on the port as specified in gpio rising-edge detect enable and/or gpio falling-edge detect enable registers  1 = edge detect has occurred on the port as specified in the gpio rising-edge detect enable and/or gpio falling-edge detect enable registers"

group d:0xD4019054++0x03
    line.long 0x00 "GPIO_SDR,Bit-wise Set of GPIO Direction Register"
        hexmask.long 0x00 0.--31. 1. " PDX150 ,set gpio port direction n (where n = 0 through 31)  0 = gpio pin direction register bit not affected  1 = gpio pin direction register bit is set and gpiox function is set to output"

group d:0xD4019060++0x03
    line.long 0x00 "GPIO_CDR,Bit-wise Clear of GPIO Direction Register"
        hexmask.long 0x00 0.--31. 1. " PDX165 ,set gpio port direction n (where n = 0 through 31)  0 = gpio pin direction register bit not affected  1 = gpio pin direction register bit is cleared and gpio n function is set to input"

group d:0xD401906C++0x03
    line.long 0x00 "GPIO_SRERx,Bit-wise Set of GPIO Rising Edge Detect Enable Register"
        hexmask.long 0x00 0.--31. 1. " PDX183 ,set gpio rising edge detect enable n (where n = 0 through 31)  0 = gpio rising-edge detect enable register bit is not affected  1 = gpio rising-edge detect enable register bit is set"

group d:0xD4019078++0x03
    line.long 0x00 "GPIO_CRERx,Bit-wise Clear of GPIO Rising Edge Detect Enable Register"
        hexmask.long 0x00 0.--31. 1. " PDX190 ,clear gpio rising edge detect enable n (where n = 0 through 31)  0 = gpio rising-edge detect enable register bit is not affected  1 = gpio rising-edge detect enable register bit is cleared"

group d:0xD4019084++0x03
    line.long 0x00 "GPIO_SFER,Bit-wise Set of GPIO Falling Edge Detect Enable Register"
        hexmask.long 0x00 0.--31. 1. " PDX208 ,set gpio falling edge detect enable n (where n = 0 through 31)  0 = gpio falling-edge detect enable register bit not affected  1 = gpio falling-edge detect enable register bit is set"

group d:0xD4019090++0x03
    line.long 0x00 "GPIO_CFER,Bit-wise Clear of GPIO Falling Edge Detect Enable Register"
        hexmask.long 0x00 0.--31. 1. " PDX215 ,clear gpio falling edge detect enable n (where n = 0 through 31)  0 = gpio falling-edge detect enable register bit not affected  1 = gpio falling-edge detect enable register bit is cleared"

group d:0xD401909C++0x03
    line.long 0x00 "APMASK_REG,<var Processor: Mohawk> Bit-wise Mask of GPIO Edge Detect Register"
        hexmask.long 0x00 0.--31. 1. " PDX222 ,mask gpio edge detect n (where n = 0 through 31)  0 = gpio edge detects are masked   1 = gpio edge detects are not masked"

group d:0xD40190A8++0x03
    line.long 0x00 "CPMASK_REG,<var Processor: Comm> Bit-wise Mask of GPIO Edge Detect Register"
        hexmask.long 0x00 0.--31. 1. " PDX229 ,mask gpio edge detect n (where n = 0 through 31)  0 = gpio edge detects are masked   1 = gpio edge detects are not masked"

tree.end

tree "genericcounter"

width 9.

group d:0xD5001000++0x03
    line.long 0x00 "CNTCR,Counter Control Register,"
        bitfld.long 0x00 1. " HDBG14  ,halt on debug. the possible values are: 0 halt on debug, hltdbg signal into the counter has no effect. 1 halt on debug, hltdbg signal into the counter halts the counter" "0,1"
        bitfld.long 0x00 0. "         EN ,enable. the possible values are: 0 the counter is disabled and not incrementing. 1 the counter is enabled and is incrementing." "0,1"

group d:0xD5001004++0x03
    line.long 0x00 "CNTSR,Counter Status Register,"
        bitfld.long 0x00 1. " HDBG24  ,debug halted." "0,1"

group d:0xD5001008++0x03
    line.long 0x00 "CNTCVLW,Current value of counter[31:0]"
        hexmask.long 0x00 0.--31. 1. " CNTCVLW ,current value of counter[31:0]"

group d:0xD500100C++0x03
    line.long 0x00 "CNTCVUP,Current value of counter[63:32]"
        hexmask.long 0x00 0.--31. 1. " CNTCVUP ,current value of counter[63:32]"

group d:0xD5001020++0x03
    line.long 0x00 "CNTFID0,Base frequency ID"
        hexmask.long 0x00 0.--31. 1. " FREQ    ,frequency in number of ticks per second."

tree.end

tree "pwm"

width 9.

group d:0xD401A000++0x03
    line.long 0x00 "PWM_CRx,PWM Control Registers"
        bitfld.long 0x00 6. " SD ,pulse width modulator shutdown mode  0 = graceful shutdown of pwmx when the <var product number> stops the clocks to the pwm  1 = abrupt shutdown of pwmx when the <var product number> stops the clocks to the pwm" "0,1"
        hexmask.long.byte 0x00 0.--5. 1. "     PWM0_PRESCALE25 ,prescale  the scaled counter clock frequency is: <br>psclk_pwmx / (prescalex +1)"

group d:0xD401A004++0x03
    line.long 0x00 "PWM_DCR,PWM Duty Cycle Registers"
        bitfld.long 0x00 10. " FD ,full duty cycle  0 = pwm_outx is determined by the <duty cycle of pwm_outx> value  1 = pwm_outx is continuously asserted" "0,1"
        hexmask.long.word 0x00 0.--9. 1. "     DCYCLE          ,duty cycle of pwm_outx  0 = pwm_outx is continuously de-asserted  1 = pwm_outx is high for the number of 13 mhz clock periods equal to this field x (<prescale> in pwm control registers + 1)  if <full duty cycle> is set, this field has no effect on the output of pwmx."

group d:0xD401A008++0x03
    line.long 0x00 "PWM_PCR,PWM Period Control Registers"
        hexmask.long.word 0x00 0.--9. 1. " PV ,period value  the value of scaled clock cycles per cycle of pwm_outx plus one.  if all zeros are written to this register, the signal remains high."

tree.end

tree "resourceipc"

width 17.

group d:0xD40B0000++0x03
    line.long 0x00 "RIPCx_STATUS,RIPCx Status Register"
        bitfld.long 0x00 0. " RIPC0_STATUS24 ,see functional description for explanation on read/write values." "0,1"

group d:0xD40B0004++0x03
    line.long 0x00 "RIPCx_APPS_INT,RIPCx <var Processor: App> Core Interrupt Request Register"
        hexmask.long 0x00 1.--31. 1. " MSG32          ,resource ipc message  for software use"
        bitfld.long 0x00 0. "  INT_REQ33 ,write 1 = request an interrupt to relevant core when resource becomes free  software must clear this bit after the core receives the interrupt." "0,1"

group d:0xD40B0008++0x03
    line.long 0x00 "RIPCx_COMM_INT,RIPCx <var Processor: Comm> Core Interrupt Request Register"
        hexmask.long 0x00 1.--31. 1. " MSG40          ,resource ipc message  for software use"
        bitfld.long 0x00 0. "  INT_REQ41 ,write 1 = request an interrupt to relevant core when resource becomes free  software must clear this bit after the core receives the interrupt." "0,1"

group d:0xD40B000C++0x03
    line.long 0x00 "RIPCx_MSA_INT,RIPCx <var Processor: MSA> Core Interrupt Request Register"
        hexmask.long 0x00 1.--31. 1. " MSG48          ,resource ipc message  for software use"
        bitfld.long 0x00 0. "  INT_REQ49 ,write 1 = request an interrupt to relevant core when resource becomes free  software must clear this bit after the core receives the interrupt." "0,1"

group d:0xD40B0014++0x03
    line.long 0x00 "RIPCx_APPS_INFO,RIPCx <var Processor: App> Core Info Register"
        hexmask.long 0x00 0.--31. 1. " MSG56          ,resource ipc message  for software use"

group d:0xD40B0018++0x03
    line.long 0x00 "RIPCx_COMM_INFO,RIPCx <var Processor: Comm> Core Info Register"
        hexmask.long 0x00 0.--31. 1. " MSG63          ,resource ipc message  for software use"

group d:0xD40B001C++0x03
    line.long 0x00 "RIPCx_MSA_INFO,RIPCx <var Processor: MSA> Core Info Register"
        hexmask.long 0x00 0.--31. 1. " MSG70          ,resource ipc message  for software use"

tree.end

tree "pmuccu"

width 17.

group d:0xF00E0000++0x03
    line.long 0x00 "CCCR,Communication Subsystem Clock Configuration Register"
        bitfld.long 0x00 16. " L2CF      ,l2 cache clock force  0 = l2 cache clock is not forced  1 = l2 cache clock is always on" "0,1"
        bitfld.long 0x00 1.--3. "       CSCD      ,not used" "0,1,2,3,4,5,6,7"

group d:0xF00E0004++0x03
    line.long 0x00 "CCSR,Communication Subsystem Clock Status Register (not used any longer)"
        bitfld.long 0x00 1.--3. " CSCD_S    ,communication subsystem clock divider status  0x0 = reserved  0x1 = communication subsystem clock equals input clock divided by 1  0x2 = communication subsystem clock equals input clock divided by 2  0x3 = communication subsystem clock equals input clock divided by 3  0x4 = communication subsystem clock equals input clock divided by 4  0x5 = reserved  0x6 = reserved  0x7 = reserved  this bit is update after frequency change procedure completion (see gcccr f bit)." "0,1,2,3,4,5,6,7"

group d:0xF00E0008++0x03
    line.long 0x00 "GCCCR,Grayback Core Clock Control Register (not used any longer)"
        bitfld.long 0x00 0. " F         ,core frequency change  0 = no  core frequency change is performed  1 =  core frequency change sequence will begin when written  new cscd_s values must be programmed before setting the f bit.  software should not try to set the f bit when it is already a 1. doing so may result in undefined behavior." "0,1"

group d:0xF00E0100++0x03
    line.long 0x00 "MPCR,Communication Subsystem Power Control Register"
        bitfld.long 0x00 24. " LMP_REQ50 ,td modem power request  0 = disable lte modem power  1 = enable td modem power  changing the state of this bit initiates an immediate change. the actual status of the td modem power is indicated by cpsr[wms]. software should wait until the status matches the request before making a new request. power is always removed from lte when the msa system enters deep sleep. if this bit=1, then modem power will be on when gb power is on" "0,1"
        bitfld.long 0x00 23. "       LMP_REQ51 ,lte modem power request  0 = disable lte modem power  1 = enable lte modem power  changing the state of this bit initiates an immediate change. the actual status of the lte modem power is indicated by cpsr[wms]. software should wait until the status matches the request before making a new request. power is always removed from lte when the msa system enters deep sleep. if this bit=1, then modem power will be on when gb power is on" "0,1"
        bitfld.long 0x00 22. "  WMP_REQ ,w-cdma modem power request  0 = disable w-cdma modem power  1 = enable w-cdma modem power  changing the state of this bit initiates an immediate change. the actual status of the w-cdma modem power is indicated by cpsr[wms]. software should wait until the status matches the request before making a new request. power is always removed from w-cdma when the msa system enters deep sleep. if this bit=1, then modem power will be on when gb power is on" "0,1"
        bitfld.long 0x00 0.--1. "  PM  ,power mode select. <00> do not turn off msa power when msa sleep mode is reached <01 or 11> enter msa power off when msa sleep mode is reached <10> enter msa power off when msa sleep mode is reached and the modem slow clock has bb_d2_entry_ok signal asserted   deep sleep exit resets this bit to the value indicated in the reset row." "0,1,2,3"

group d:0xF00E0114++0x03
    line.long 0x00 "CMCR,Communication Subsystem Miscellaneous Counters Register "

group d:0xF00E0118++0x03
    line.long 0x00 "MPSR,Communication Subsystem Power Status Register"
        bitfld.long 0x00 28.--31. " CC_SWR70  ,software-controlled reset events tracking field. this field can be written (and read) to any value between 0x0 and 0xf. in order to track events through wdt reset events.  this field's content does not affect  functionality in any way" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 7. "      TMS       ,td modem power status  0 = lte modem power disabled  1 = td modem power enabled." "0,1"
        bitfld.long 0x00 6. "  LMS     ,lte modem power status  0 = lte modem power disabled  1 = lte modem power enabled." "0,1"
        bitfld.long 0x00 5. "  WMS ,w-cdma modem power status  0 = w-cdma modem power disabled  1 = w-cdma modem power enabled." "0,1"
        textline "                           "
        bitfld.long 0x00 1. "LPM       ,deep sleep state exit reset  0 = has not occurred since the last time software or subsystem reset cleared this bit  1 = has occurred since the last time software or subsystem reset cleared this bit  when the system experiences a power on reset lpm field would be cleared." "0,1"

group d:0xF00E0120++0x03
    line.long 0x00 "CWER,Communication Subsystem general purpose wakeup enable"
        hexmask.long.tbyte 0x00 0.--17. 1. " CC_85     ,enable the general purpose wakeup"

group d:0xF00E0128++0x03
    line.long 0x00 "Cwesr_wakeup_en,Communication Subsystem general wakeup global enable"
        bitfld.long 0x00 31. " CC_93     ,reset the wakeup event to cp_" "0,1"
        bitfld.long 0x00 30. "       WAKEUP_EN ,the global wake enable signal for general purpose wakeup" "0,1"

group d:0xF00E0130++0x03
    line.long 0x00 "CIER,Communication Subsystem Interrupt Enable Register"
        bitfld.long 0x00 0. " FC_IE     ,frequency change interrupt enable  0 = do not generate an interrupt after a frequency change procedure is completed  1 = generate an interrupt after a frequency change procedure is completed" "0,1"

group d:0xF00E0140++0x03
    line.long 0x00 "CGDES,MSA Deep Sleep Entry Status Register"
        bitfld.long 0x00 0.--2. " GDES      ,msa core deep sleep entry status  this field is maintained entirely by msa core software to synchronize entry into deep sleep with the controller core.  deep sleep entry codes:  a (0x0) = core is running, no deep sleep -related activity in progress  d (0x6) = msa is in deep sleep state.  all other values are reserved." "0,1,2,3,4,5,6,7"

group d:0xF00E0200++0x03
    line.long 0x00 "CSSR,Communication Subsystem Spare Register"

tree.end

tree "timingctrl"

width 16.

group d:0xD401E7F8++0x03
    line.long 0x00 "AIB_spare0_reg,AIB spare0 Register"

group d:0xD401E7FC++0x03
    line.long 0x00 "AIB_spare1_reg,AIB spare1 Register"

tree.end

tree "uart"

width 10.

group d:0xD4017000++0x03
    line.long 0x00 "UART_RBR,Receive Buffer Register"
        hexmask.long.byte 0x00 24.--31. 1. " BYTE_324             ,byte 3  this field is only valid in 32-bit peripheral bus mode."
        hexmask.long.word 0x00 16.--24. 1. "    BYTE_225         ,byte 2  this field is only valid in 32-bit peripheral bus mode."
        hexmask.long.byte 0x00 8.--15. 1. "  BYTE_126       ,byte 1  this field is only valid in 32-bit peripheral bus mode."
        hexmask.long.byte 0x00 0.--7. 1. "  BYTE_027     ,byte 0"

group d:0xD4017000++0x03
    line.long 0x00 "UART_THR,Transmit Holding Register"
        hexmask.long.byte 0x00 24.--31. 1. " BYTE_335             ,byte 3  this field is only valid in 32-bit peripheral bus mode."
        hexmask.long.word 0x00 16.--24. 1. "    BYTE_236         ,byte 2  this field is only valid in 32-bit peripheral bus mode."
        hexmask.long.byte 0x00 8.--15. 1. "  BYTE_137       ,byte 1  this field is only valid in 32-bit peripheral bus mode."
        hexmask.long.byte 0x00 0.--7. 1. "  BYTE_038     ,byte 0"

group d:0xD4017000++0x03
    line.long 0x00 "UART_DLL,Divisor Latch Low Byte Register"
        hexmask.long.byte 0x00 0.--7. 1. " DLL                  ,divisor latch low  low-byte compare value to generate baud rate"

group d:0xD4017004++0x03
    line.long 0x00 "UART_DLH,Divisor Latch High Byte Register"
        hexmask.long.byte 0x00 0.--7. 1. " DLH                  ,divisor latch high  high-byte compare value to generate baud rate"

group d:0xD4017004++0x03
    line.long 0x00 "UART_IER,Interrupt Enable Register"
        bitfld.long 0x00 8. " HSE                  ,high speed uart enable  when high speed mode is enabled, the uart uses a 59.429 mhz input clock rather than a 14.857 mhz input clock. high speed mode should only be used for baud rates of 1.8 or 3.6 mbps.  0 = high speed mode is disabled (regular mode)  1 = high speed mode is enabled" "0,1"
        bitfld.long 0x00 7. "     DMAE             ,dma requests enable  0 = dma requests are disabled  1 = dma requests are enabled" "0,1"
        bitfld.long 0x00 6. "     UUE            ,uart unit enable  0 = unit is disabled  1 = unit is enabled" "0,1"
        bitfld.long 0x00 5. "   NRZE         ,nrz coding enable  nrz encoding/decoding is only used in uart mode, not in infrared mode. if the serial infrared receiver or transmitter is enabled, nrz coding is disabled.  0 = nrz coding disabled  1 = nrz coding enabled" "0,1"
        textline "                    "
        bitfld.long 0x00 4. "RTOIE                ,receiver time-out interrupt enable  the source for this field is the <time out detected> field in the interrupt identification register.  0 = receiver data time-out interrupt disabled  1 = receiver data time-out interrupt enabled" "0,1"
        bitfld.long 0x00 3. "     AP_UA_MIE80      ,modem interrupt enable  the source for this field is the <interrupt source encoded> field in the interrupt identification register.  0 = modem status interrupt disabled  1 = modem status interrupt enabled" "0,1"
        bitfld.long 0x00 2. "     RLSE           ,receiver line status interrupt enable  the source for this field is the <interrupt source encoded> field in the interrupt identification register.  0 = receiver line status interrupt disabled  1 = receiver line status interrupt enabled" "0,1"
        bitfld.long 0x00 1. "   AP_UA_TIE82  ,transmit data request interrupt enable  the source for this field is the <interrupt source encoded> field in the interrupt identification register.  0 = transmit fifo data request interrupt disabled  1 = transmit fifo data request interrupt enabled" "0,1"
        textline "                    "
        bitfld.long 0x00 0. "RAVIE                ,receiver data available interrupt enable  the source for this field is the <interrupt source encoded> field in the interrupt identification register.  0 = receiver data available (trigger threshold reached) interrupt disabled  1 = receiver data available (trigger threshold reached) interrupt enabled" "0,1"

group d:0xD4017008++0x03
    line.long 0x00 "UART_IIR,Interrupt Identification Register"
        bitfld.long 0x00 6.--7. " FIFOES10             ,fifo mode enable status  0x0 = non-fifo mode is selected  0x1 to 0x2 = reserved  0x3 = fifo mode is selected (<transmit and receive fifo enable> field in the fifo control register = 1)" "0,1,2,3"
        bitfld.long 0x00 5. "     AP_UA_EOC92      ,dma end of descriptor chain (see 32-bit peripheral bus section in the <var product number> datasheet)  0 = dma has not signaled the end of its programmed descriptor chain  1 = dma has signaled the end of its programmed descriptor chain" "0,1"
        bitfld.long 0x00 4. "     ABL            ,auto-baud lock (see auto-baud-rate detection section in the <var product number> datasheet)  0 = auto-baud circuitry has not programmed divisor latch registers  1 = divisor latch registers programmed by auto-baud circuitry" "0,1"
        bitfld.long 0x00 3. "   TOD          ,time out detected (see character timeout interrupt section in the <var product number> datasheet)  0 = no time out interrupt is pending  1 = time out interrupt is pending (fifo mode only)" "0,1"
        textline "                    "
        bitfld.long 0x00 1.--2. "IID10                ,interrupt source encoded  0x0 = modem status (cts, dsr, ri, dcd modem signals changed state)  0x1 = transmit fifo requests data  0x2 = received data available  0x3 = receive error (overrun, parity, framing, break, fifo error. see modem status register)" "0,1,2,3"
        bitfld.long 0x00 0. "     NIP              ,interrupt pending  0 = interrupt is pending (active low)  1 = no interrupt is pending" "0,1"

group d:0xD4017008++0x03
    line.long 0x00 "UART_FCR,FIFO Control Register"
        bitfld.long 0x00 6.--7. " ITL                  ,interrupt trigger level (threshold)  when the number of bytes in the receive fifo equals the interrupt trigger threshold programmed into this field and the received-data-available interrupt is enabled via the interrupt enable register, an interrupt is generated and appropriate bits are set in the interrupt identification register. the receive dma request is also generated when the trigger threshold is reached.   0x0 = 1 byte or more in fifo causes interrupt (not valid in dma mode)  0x1 = 8 bytes or more in fifo causes interrupt and dma request  0x2 = 16 bytes or more in fifo causes interrupt and dma request  0x3 = 32 bytes or more in fifo causes interrupt and dma request" "0,1,2,3"
        bitfld.long 0x00 5. "     BUS              ,32-bit peripheral bus  0 = 8-bit peripheral bus  1 = 32-bit peripheral bus" "0,1"
        bitfld.long 0x00 4. "     AP_UA_TRAIL124 ,trailing bytes  0 = trailing bytes are removed by the <var product number>   1 = trailing bytes are removed by the dmac" "0,1"
        bitfld.long 0x00 3. "   TIL          ,transmitter interrupt level  0 = interrupt/dma request when fifo is half empty  1 = interrupt/dma request when fifo is empty" "0,1"
        textline "                    "
        bitfld.long 0x00 2. "AP_UA_RESETTF126     ,reset transmit fifo  when this field is set, all the bytes in the transmit fifo are cleared. the <transmit data request> field in the line status register is set and the interrupt identification register shows a transmitter requests data interrupt, if the <transmit data request interrupt enable> field in the interrupt enable register is set. the transmit shift register is not cleared, and it completes the current transmission.  0 = writing 0 has no effect  1 = the transmit fifo is cleared" "0,1"
        bitfld.long 0x00 1. "     AP_UA_RESETRF127 ,reset receive fifo  when this field is set, all the bytes in the receive fifo are cleared. the <data ready> field in the line status register is reset to 0. all the error bits in the fifo and the <fifo error status> field in the line status register are cleared. any error bits, oe, pe, fe or bi, that had been set in the line status register are still set. the receive shift register is not cleared. if the interrupt identification register had been set to received data available, it is cleared.   0 = no effect  1 = the receive fifo is cleared" "0,1"
        bitfld.long 0x00 0. "     TRFIFOE        ,transmit and receive fifo enable  this field enables/disables the transmit and receive fifos. when set, both fifos are enabled (fifo mode). when clear, the fifos are both disabled (non-fifo mode). writing 0x0 to this field clears all bytes in both fifos. when changing from fifo mode to non-fifo mode and vice versa, data is cleared automatically from the fifos. this field must be set when other fields in this register are written or the other bits are not programmed.  0 = fifos are disabled  1 = fifos are enabled" "0,1"

group d:0xD401700C++0x03
    line.long 0x00 "UART_LCR,Line Control Register"
        bitfld.long 0x00 7. " DLAB                 ,divisor latch access bit  must be set to access the divisor latch registers of the baud-rate generator during a read or write operation. must be clear to access the receive buffer, the transmit holding register or the interrupt enable register.  0 = access transmit holding register, receive buffer register, and interrupt enable register  1 = access divisor latch registers (dll and dlh)" "0,1"
        bitfld.long 0x00 6. "     SB               ,set break  causes a break condition to be transmitted to the receiving uart. acts only on the txd pin and has no effect on the transmit logic. in fifo mode, wait until the transmitter is idle (<transmitter empty> field in the line status register = 1] to set and clear sb.  0 = no effect on txd output  1 = forces txd output to 0 (space)" "0,1"
        bitfld.long 0x00 5. "     STKYP          ,sticky parity  forces the bit value at the parity bit location to be the opposite of the <even parity select> field rather than the parity value. this stops parity generation. if <parity enable> = 0, this field is ignored.  0 = no effect on parity bit  1 = forces parity bit to be opposite of <even parity select> field value" "0,1"
        bitfld.long 0x00 4. "   AP_UA_EPS141 ,even parity select  if <parity enable> = 0, this field is ignored.  0 = sends or checks for odd parity  1 = sends or checks for even parity" "0,1"
        textline "                    "
        bitfld.long 0x00 3. "PEN                  ,parity enable  this field enables a parity bit to be generated on transmission or checked on reception.   0 = no parity  1 = parity" "0,1"
        bitfld.long 0x00 2. "     STB              ,stop bits  specifies the number of stop bits transmitted and received in each character. when receiving, the receiver checks only the first stop bit.  this field must be clear.  0 = 1 stop bit" "0,1"
        bitfld.long 0x00 0.--1. "     WLS10          ,word length select  specifies the number of data bits in each transmitted or received character.  0x0, 0x1, 0x2 = 7-bit character  0x3 = 8-bit character" "0,1,2,3"

group d:0xD4017010++0x03
    line.long 0x00 "UART_MCR,Modem Control Register"
        bitfld.long 0x00 5. " AFE                  ,auto-flow control enable  0 = auto-rts and auto-cts are disabled  1 = auto-cts is enabled. if <request to send> is also set, both auto-cts and auto-rts are enabled." "0,1"
        bitfld.long 0x00 4. "     LOOP             ,loopback mode  this field provides a local loopback feature for diagnostic testing of the uart. when set, the following occurs: the transmitter serial output is set to a logic 1 state. the receiver serial input is disconnected from the pin. the output of the transmit shift register is <q>looped back</q> into the receive shift register input. the four modem control inputs (ctsn, dsrn, dcdn, and rin) are disconnected from the pins and the modem control output pins (rtsn and dtrn) are forced to their inactive state.  coming out of the loopback mode may result in unpredictable activation of the delta bits (bits 30) in the modem status register. marvell recommends that the modem status register be read once to clear its delta bits.  loopback mode must be configured before the uart is enabled.  the lower four bits of this register are connected to the upper four modem status register bits." "0,1"
        bitfld.long 0x00 3. "     OUT2           ,out2 signal control  out2 connects the uart interrupt output to the interrupt controller unit. when <loopback mode> is clear  0 = uart interrupt is disabled  1 = uart interrupt is enabled  when <loopback mode> is set, interrupts always go to the <var product number>  0 = <data carrier detect> field in the modem status register forced to 0  1 = <data carrier detect> field forced to 1" "0,1"
        bitfld.long 0x00 2. "   OUT1         ,test bit  this field is only used in loopback mode. otherwise, it is ignored.  0 = force <ring indicator> field in the modem status register to 0  1 = force <ring indicator> field to 1" "0,1"
        textline "                    "
        bitfld.long 0x00 1. "RTS                  ,request to send  0 = non-auto-flow mode  rtsn pin is 1  auto-rts disabled. auto-flow works only with auto-cts.  1 = auto-flow mode  rtsn pin is 0  auto-rts enabled. auto-flow works with both auto-cts and auto-rts." "0,1"
        bitfld.long 0x00 0. "     DTR              ,data terminal ready  0 = dtrn pin is 1  1 = dtrn pin is 0" "0,1"

group d:0xD4017014++0x03
    line.long 0x00 "UART_LSR,Line Status Register"
        bitfld.long 0x00 7. " FIFOE                ,fifo error status  in non-fifo mode, this bit is clear. in fifo mode, this field is set when there is at least one parity error, framing error, or break indication for any of the characters in the fifo. a <var product number> read of the this register does not reset this field. this field is reset when all erroneous characters have been read from the fifo. if dma requests are enabled (<dma requests enable> field in the interrupt enable register set) and this field is set, the error interrupt is generated, and no receive dma request is generated even when the receive fifo reaches the trigger threshold. once the errors have been cleared by reading the fifo, dma requests are re-enabled automatically. if dma requests are not enabled (<dma requests enable> field clear), this field set does not generate an error interrupt.  0 = no fifo or no errors in receive fifo  1 = at least one character in receive fifo has errors" "0,1"
        bitfld.long 0x00 6. "     AP_UA_TEMT178    ,transmitter empty  set when the transmit holding register and the transmit shift register are both empty. it is cleared when either the transmit holding register or the transmit shift register contains a data character. in fifo mode, this field is set when the transmit fifo and the transmit shift register are both empty.  0 = there is data in the transmit shift register, the transmit holding register, or the fifo  1 = all the data in the transmitter has been shifted out" "0,1"
        bitfld.long 0x00 5. "     TDRQ           ,transmit data request  this field indicates that the uart is ready to accept a new character for transmission. in addition, this field causes the uart to issue an interrupt to the <var product number> when the transmit data request interrupt enable is set and generates the dma request to the dma controller if dma requests and fifo mode are enabled. this field is set when a character is transferred from the transmit holding register into the transmit shift register. this field is cleared with the loading of the transmit holding register. in fifo mode, this field is set when half of the characters in the fifo have been loaded into the transmit shift register or the <reset transmit fifo> field in the fifo control register has been set. it is cleared when the fifo has more than half data. if more than 64 characters are loaded into the fifo, the excess characters are lost.  0 = there is data in the holding register or fifo waiting to be shifted out  1 = the transmit fifo has half or less than half data" "0,1"
        bitfld.long 0x00 4. "   BI           ,break interrupt  this field is set when the received data input is held low for longer than a full-word transmission time (the total time of start bit + data bits + parity bit + stop bit). it is cleared when the <var product number> reads the lsr. in fifo mode, only one character equal to 0x00, is loaded into the fifo regardless of the length of the break condition. bi shows the break condition for the character at the front of the fifo, not the most recently received character.  0 = no break signal has been received  1 = break signal received" "0,1"
        textline "                    "
        bitfld.long 0x00 3. "FE                   ,framing error  this field indicates that the received character did not have a valid stop bit. it is set when the bit following the last data bit or parity bit is detected to be 0. it is cleared when the <var product number> reads this register. the uart will resynchronize after a framing error. to do this, it assumes that the framing error was due to the next start bit, so it samples this start bit twice and then reads in the data. in fifo mode, this field shows a framing error for the character at the front of the fifo, not for the most recently received character.  0 = no framing error  1 = invalid stop bit has been detected" "0,1"
        bitfld.long 0x00 2. "     AP_UA_PE182      ,parity error  indicates that the received data character does not have the correct even or odd parity, as selected by the even parity select bit. this field is set upon detection of a parity error and is cleared when the <var product number> reads this register. in fifo mode, this field shows a parity error for the character at the front of the fifo, not the most recently received character.   0 = no parity error  1 = parity error has occurred" "0,1"
        bitfld.long 0x00 1. "     OE             ,overrun error  in non-fifo mode, indicates that data in the receive buffer register was not read by the <var product number> before the next character was received. the new character is lost. in fifo mode, this field indicates that all 64 bytes of the fifo are full and the most recently received byte has been discarded. this field is set upon detection of an overrun condition and cleared when the <var product number> reads this register.  0 = no data has been lost  1 = receive data has been lost" "0,1"
        bitfld.long 0x00 0. "   DR           ,data ready  set when a complete incoming character has been received and transferred into the receive buffer register or the fifo. in non-fifo mode, this field is cleared when the receive buffer is read. in fifo mode, this field is cleared if the fifo is empty (last character has been read from receive buffer register) or the fifo is reset with the <reset receive fifo> field in the fifo control register.  0 = no data has been received  1 = data is available in receive buffer register or the fifo" "0,1"

group d:0xD4017018++0x03
    line.long 0x00 "UART_MSR,Modem Status Register"
        bitfld.long 0x00 7. " DCD                  ,data carrier detect  complement of the data-carrier-detect (dcdn) input. equivalent to <out2 signal control> field in the modem control register if <loopback mode> is set in the modem control register.  0 = dcdn pin is 1  1 = dcdn pin is 0" "0,1"
        bitfld.long 0x00 6. "     RI               ,ring indicator  complement of the ring-indicator (rin) input. equivalent to <test bit> field in the modem control register if <loopback mode> is set.  0 = rin pin is 1  1 = rin pin is 0" "0,1"
        bitfld.long 0x00 5. "     DSR            ,data set ready  complement of the data-set-ready (dsrn) input. equivalent to <data terminal ready> field in the modem control register if <loopback mode> is set.  0 = dsrn pin is 1  1 = dsrn pin is 0" "0,1"
        bitfld.long 0x00 4. "   CTS          ,clear to send  complement of the clear-to-send (ctsn) input. equivalent to <request to send> field in the modem control register if <loopback mode> is set.  0 = ctsn pin is 1  1 = ctsn pin is 0" "0,1"
        textline "                    "
        bitfld.long 0x00 3. "DDCD                 ,delta data carrier detect  0 = no change in dcdn pin since last read of this register  1 = dcdn pin has changed state" "0,1"
        bitfld.long 0x00 2. "     TERI             ,trailing edge ring indicator  0 = rin pin has not changed from 0 to 1 since last read of this register  1 = rin pin has changed state" "0,1"
        bitfld.long 0x00 1. "     DDSR           ,delta data set ready  0 = no change in dsrn pin since last read of this register  1 = dsrn pin has changed state" "0,1"
        bitfld.long 0x00 0. "   DCTS         ,delta clear to send  0 = no change in ctsn pin since last read of this register  1 = ctsn pin has changed state" "0,1"

group d:0xD401701C++0x03
    line.long 0x00 "UART_SCR,Scratchpad Register"
        hexmask.long.byte 0x00 0.--7. 1. " SCRATCHPAD           ,scratchpad  this field has no effect on uart functions."

group d:0xD4017020++0x03
    line.long 0x00 "UART_ISR,Infrared Selection Register"
        bitfld.long 0x00 4. " RXPL                 ,receive data polarity  0 = sir decoder takes positive pulses as zeros  1 = sir decoder takes negative pulses as zeros" "0,1"
        bitfld.long 0x00 3. "     TXPL             ,transmit data polarity  0 = sir encoder generates a positive pulse for a data bit of 0  1 = sir encoder generates a negative pulse for a data bit of 0" "0,1"
        bitfld.long 0x00 2. "     XMODE          ,transmit pulse width select  when this field is clear, the uart 16x clock is used to clock the irda transmit and receive logic. when this field is set, receive decoder operation does not change, and the transmit encoder generates 1.6 ms pulses (that are 3/16 of a bit time at 115.2 kbps) instead of pulses 3/16 of a bit time wide. marvell recommends setting this field.  0 = transmit pulse width is 3/16 of a bit time wide  1 = transmit pulse width is 1.6 ms" "0,1"
        bitfld.long 0x00 1. "   RCVEIR       ,receiver sir enable  when this field is set, the signal from the rxd pin is processed by the irda decoder before it is fed to the uart. if this field is clear, then all clocking to the irda decoder is blocked and the rxd pin is fed directly to the uart.  0 = receiver is in uart mode  1 = receiver is in infrared mode" "0,1"
        textline "                    "
        bitfld.long 0x00 0. "XMITIR               ,transmitter sir enable  when this field is set, the normal txd output from the uart is processed by the irda encoder before it is fed to the device pin. if this field is clear, all clocking to the irda encoder is blocked and the uart's txd signal is connected directly to the device pin.  when transmitter sir enable is set, the txd output pin, which is in a normally high default state, switches to a normally low default state. this can cause a false start bit unless the infrared led is disabled before this field is set.  0 = transmitter is in uart mode  1 = transmitter is in infrared mode" "0,1"

group d:0xD4017024++0x03
    line.long 0x00 "UART_FOR,Receive FIFO Occupancy Register"
        hexmask.long.byte 0x00 0.--5. 1. " BYTE_COUNT           ,byte count  this field is used for the number of bytes (0-63) remaining in the receive fifo."

group d:0xD4017028++0x03
    line.long 0x00 "UART_ABR,Auto-Baud Control Register"
        bitfld.long 0x00 3. " ABT                  ,abt  0 = formula used to calculate baud rates, allowing all possible baud rates to be chosen by uart as shown in section 9.4.2.1.2  1 = table used to calculate baud rates, which limits uart to choosing common baud rates" "0,1"
        bitfld.long 0x00 2. "     ABUP             ,abup  0 = <var product number> programs divisor latch registers  1 = uart programs divisor latch registers" "0,1"
        bitfld.long 0x00 1. "     ABLIE          ,ablie  0 = auto-baud-lock interrupt disabled (source <auto-baud lock> field)  1 = auto-baud-lock interrupt enabled (source <auto-baud lock> field)" "0,1"
        bitfld.long 0x00 0. "   ABE          ,abe  0 = auto-baud disabled  1 = auto-baud enabled" "0,1"

group d:0xD401702C++0x03
    line.long 0x00 "UART_ACR,Auto-Baud Count Register"
        hexmask.long.word 0x00 0.--15. 1. " AP_UA_COUNT_VALUE265 ,count value  this field is used for the number of 14.857-mhz clock cycles within a start-bit pulse."

tree.end

tree "mimir"

width 27.

group d:0xC0500000++0x03
    line.long 0x00 "GPU_ID,   Contains information related to the model and revision of the GPU.  Removed GPU IDs and product_id_t.  Removed erroneous PRODUCT_ID field. "
        hexmask.long.byte 0x00 4.--11. 1. " VERSION_MINOR             ,   It contains the minor release number of the GPU. This is the 'P' part of an 'RnPn' release number. "
        bitfld.long 0x00 12.--15. "                                            VERSION_MAJOR          ,   It contains the major release number of the GPU. This is the 'R' part of an 'RnPn' release number. " "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 16.--19. "                                            PRODUCT_MAJOR        ,   This field contains a value indicating a product release within a product generation implementing a particular major version of the architecture.  The first product implementing a particular major version of the architecture would have 0 in this field. In order that this is not affected by release scheduling, it is recommended that this number is allocated early in the project.  For example, since the Mali-T820, Mali-T860, Mali-T830, and Mali-T880 GPUs are based on the same major architecture version, they would have been labelled products 0, 1, 2 and 3 under this scheme.  To identify a single product, regardless of revisions, it is sufficient to look only at the  ARCH_MAJOR and PRODUCT_MAJOR fields.       This is to avoid the problem of reallocating PRODUCT_MAJOR IDs at every minor version of the architecture. So, for example, assume that the Mimir GPU was released at architecture revision 6.0.7, and assigned  PRODUCT_MAJOR ID 0 . If we then release a new GPU called (say) Thunnorad at architecture version 6.0.9, then this would be assigned  PRODUCT_MAJOR ID 1 , as it is the second product for       major architecture version 6, not the first product at minor architecture version 6.0.9. This also allows us to also update Mimir to 6.0.9 at a future release without having to reassign its  PRODUCT_MAJOR ID. Clarified what parts of the product ID identify a product as opposed to revisions. " "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 24.--27. "                                            ARCH_MINOR                ,   This field contains the minor revision value for the version of the architecture implemented by this hardware. For example, for architecture version 6.1.0, this field would be set to 1. " "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        textline "                                     "
        bitfld.long 0x00 28.--31. "ARCH_MAJOR                ,   This field contains the major revision value for the version of the architecture implemented by this hardware. For example, for architecture version 6.1.0, this field would be set to 6. " "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 20.--23. "                                            ARCH_REV               ,   This field contains the patch revision value for the version of the architecture implemented by this hardware.      This is a signed value to allow for preview releases, so for instance previews of Architecture spec version 6.1.0 might be labelled 6.1.-8 and 6.1.-7. " "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 0.--3. "                                            VERSION_STATUS       ,   It contains the status of the GPU release. This has no architecturally defined values, but should reset to 0  at each minor or major release, and increases by one for each intermediate release status (alpha, beta, EAC, etc.)  The named values indicated here will be valid for one particular implementation only.  VERSION_STATUS should be reset to 0 at each minor or major release.  VERSION_STATUS is now defined as an enum included from the implementation config file. " "beta:  Beta ,dev_15:  Development release 15 ,eac:  EAC ,3,4,5,6,7,8,9,10,11,12,13,14,15"

group d:0xC0500004++0x03
    line.long 0x00 "L2_FEATURES,   Contains information about the features of the level 2 cache. "
        hexmask.long.byte 0x00 0.--7. 1. " LINE_SIZE                 ,   It contains the base-2 logarithm of the cache's line size, in bytes. "
        hexmask.long.byte 0x00 8.--15. 1. "                                            ASSOCIATIVITY          ,   It contains the base-2 logarithm of the cache's associativity (number of ways). "
        hexmask.long.byte 0x00 16.--23. 1. "                                            CACHE_SIZE           ,   It contains the base-2 logarithm of the cache's total size, in bytes. "
        hexmask.long.byte 0x00 24.--31. 1. "                                            EXTERNAL_BUS_WIDTH        ,   It contains the base-2 logarithm of the cache's external data bus size, in bits. "

group d:0xC050000C++0x03
    line.long 0x00 "TILER_FEATURES,   Contains information about the features of the tiler. "
        bitfld.long 0x00 6.--7. " Res1                      ,Res1" "0,1,2,3"
        hexmask.long.tbyte 0x00 12.--31. 1. "                                             Res2                   ,Res2"
        hexmask.long.byte 0x00 0.--5. 1. "                                        BIN_SIZE             ,   It contains the base-2 logarithm of the tiler's bin size, in bytes. "
        bitfld.long 0x00 8.--11. "                                            MAX_LEVELS                ,   It specifies the maximum number of hierarchy levels may be enabled at any one time. This is the maximum number of '1' bits in the Hierarchy Mask field of the Frame Buffer Descriptor. " "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"

group d:0xC0500010++0x03
    line.long 0x00 "MEM_FEATURES,   Contains information about the features of the memory system. "
        hexmask.long.byte 0x00 2.--7. 1. " Res3                      ,Res3"
        hexmask.long.tbyte 0x00 12.--31. 1. "                                            Res4                   ,Res4"
        bitfld.long 0x00 8.--11. "                                        L2_SLICES            ,   It contains the number of slices in the level 2 cache, minus 1. " "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 0. "                                            COHERENT_CORE_GROUP       ,COHERENT_CORE_GROUP" "false,true"
        textline "                                     "
        bitfld.long 0x00 1. "COHERENT_SUPER_GROUP      ,COHERENT_SUPER_GROUP" "false,true"

group d:0xC0500014++0x03
    line.long 0x00 "MMU_FEATURES,   Describes the configuration of the Memory Management Unit in the GPU. "
        hexmask.long.byte 0x00 24.--31. 1. " Res5                      ,Res5"
        hexmask.long.byte 0x00 0.--7. 1. "                                            VA_BITS                ,   The number of bits which are significant for virtual addresses. All 64 bits of an address are decoded, but only the region from 0 to 2  VA_BITS -1 can be mapped to physical memory. Other address ranges result in a translation fault."
        hexmask.long.byte 0x00 8.--15. 1. "                                            PA_BITS              ,   The number of bits which are significant for physical addresses. All 64 bits of an address are decoded, but only the region from 0 to 2  PA_BITS -1 corresponds to real physical memory. Other address ranges result in a translation fault.       Note that this does not guarantee that this amount of physical memory is actually available, just that there is the potential to attach it exists."
        hexmask.long.byte 0x00 16.--23. 1. "                                            IPA_BITS                  ,   The number of bits which are significant for intermediate physical addresses. All 64 bits of an address are decoded, but only the region from 0 to 2  IPA_BITS -1 correspond to addressable intermediate-physical memory. Other address ranges result in a translation fault. If this is 0, this indicates that there is no Stage 2 translation. In this case, the Stage 1 translation therefore translates directly from virtual addresses to physical addresses.  Added  IPA_BITS to MMU_FEATURES register."

group d:0xC0500018++0x03
    line.long 0x00 "AS_PRESENT,   Contains information about which address spaces are present on this GPU. "
        hexmask.long 0x00 0.--31. 1. " AS_PRESENT                ,   Indicates which address spaces are actually available in the hardware. "

group d:0xC050001C++0x03
    line.long 0x00 "JS_PRESENT,   Contains information about which job slots are present on this GPU. "
        hexmask.long 0x00 0.--31. 1. " JS_PRESENT                ,   Indicates which job slots are actually available in the hardware. "

group d:0xC0500020++0x03
    line.long 0x00 "GPU_IRQ_RAWSTAT,   This register contains the raw unmasked interrupt sources for GPU-wide status and exception handling.  Writing to this register will force bits on, but will not clear them. The new state is the logical OR of the previous state and the written value.  Writing a zero to a bit will have no effect. Use the GPU_IRQ_CLEAR register to clear interrupts. "
        hexmask.long.byte 0x00 1.--6. 1. " Res6                      ,Res6"
        bitfld.long 0x00 11.--15. "                                            Res7                   ,Res7" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"
        hexmask.long.word 0x00 18.--31. 1. "                                            Res8                 ,Res8"
        bitfld.long 0x00 0. "                                          GPU_FAULT                 ,GPU_FAULT" "false:    No GPU fault. ,true"
        textline "                                     "
        bitfld.long 0x00 7. "MULTIPLE_GPU_FAULTS       ,MULTIPLE_GPU_FAULTS" "false:    No multiple fault. ,true"
        bitfld.long 0x00 8. "                 RESET_COMPLETED        ,   Modified reset values for registers. " "false,true"
        bitfld.long 0x00 9. "                                         POWER_CHANGED_SINGLE ,POWER_CHANGED_SINGLE" "false:    No power changes. ,true"
        bitfld.long 0x00 10. "                  POWER_CHANGED_ALL         ,POWER_CHANGED_ALL" "false:    No power changes. ,true"
        textline "                                     "
        bitfld.long 0x00 16. "PRFCNT_SAMPLE_COMPLETED   ,PRFCNT_SAMPLE_COMPLETED" "false,true"
        bitfld.long 0x00 17. "                                         CLEAN_CACHES_COMPLETED ,CLEAN_CACHES_COMPLETED" "false,true"

group d:0xC0500024++0x03
    line.long 0x00 "GPU_IRQ_CLEAR,   This register has the same layout as GPU_IRQ_RAWSTAT. Write a one to a bit in this register to clear the corresponding bit in GPU_IRQ_RAWSTAT. "
        hexmask.long.byte 0x00 1.--6. 1. " Res9                      ,Res9"
        bitfld.long 0x00 11.--15. "                                            Res10                  ,Res10" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"
        hexmask.long.word 0x00 18.--31. 1. "                                            Res11                ,Res11"
        bitfld.long 0x00 0. "                                          GPU_FAULT                 ,GPU_FAULT" "false:    No GPU fault. ,true"
        textline "                                     "
        bitfld.long 0x00 7. "MULTIPLE_GPU_FAULTS       ,MULTIPLE_GPU_FAULTS" "false:    No multiple fault. ,true"
        bitfld.long 0x00 8. "                 RESET_COMPLETED        ,   Modified reset values for registers. " "false,true"
        bitfld.long 0x00 9. "                                         POWER_CHANGED_SINGLE ,POWER_CHANGED_SINGLE" "false:    No power changes. ,true"
        bitfld.long 0x00 10. "                  POWER_CHANGED_ALL         ,POWER_CHANGED_ALL" "false:    No power changes. ,true"
        textline "                                     "
        bitfld.long 0x00 16. "PRFCNT_SAMPLE_COMPLETED   ,PRFCNT_SAMPLE_COMPLETED" "false,true"
        bitfld.long 0x00 17. "                                         CLEAN_CACHES_COMPLETED ,CLEAN_CACHES_COMPLETED" "false,true"

group d:0xC0500028++0x03
    line.long 0x00 "GPU_IRQ_MASK,   This register has the same layout as GPU_IRQ_RAWSTAT. Set each bit in this to one to enable the corresponding interrupt source, and to zero to disable it. "
        hexmask.long.byte 0x00 1.--6. 1. " Res12                     ,Res12"
        bitfld.long 0x00 11.--15. "                                            Res13                  ,Res13" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"
        hexmask.long.word 0x00 18.--31. 1. "                                            Res14                ,Res14"
        bitfld.long 0x00 0. "                                          GPU_FAULT                 ,GPU_FAULT" "false:    No GPU fault. ,true"
        textline "                                     "
        bitfld.long 0x00 7. "MULTIPLE_GPU_FAULTS       ,MULTIPLE_GPU_FAULTS" "false:    No multiple fault. ,true"
        bitfld.long 0x00 8. "                 RESET_COMPLETED        ,   Modified reset values for registers. " "false,true"
        bitfld.long 0x00 9. "                                         POWER_CHANGED_SINGLE ,POWER_CHANGED_SINGLE" "false:    No power changes. ,true"
        bitfld.long 0x00 10. "                  POWER_CHANGED_ALL         ,POWER_CHANGED_ALL" "false:    No power changes. ,true"
        textline "                                     "
        bitfld.long 0x00 16. "PRFCNT_SAMPLE_COMPLETED   ,PRFCNT_SAMPLE_COMPLETED" "false,true"
        bitfld.long 0x00 17. "                                         CLEAN_CACHES_COMPLETED ,CLEAN_CACHES_COMPLETED" "false,true"

group d:0xC050002C++0x03
    line.long 0x00 "GPU_IRQ_STATUS,   This register has the same layout as GPU_IRQ_RAWSTAT. This register contains the result of anding together GPU_IRQ_RAWSTAT and GPU_IRQ_MASK. If any bits in this register are set, the external GPU control interrupt line is asserted, signaling an interrupt request to the CPU. "
        hexmask.long.byte 0x00 1.--6. 1. " Res15                     ,Res15"
        bitfld.long 0x00 11.--15. "                                            Res16                  ,Res16" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"
        hexmask.long.word 0x00 18.--31. 1. "                                            Res17                ,Res17"
        bitfld.long 0x00 0. "                                          GPU_FAULT                 ,GPU_FAULT" "false:    No GPU fault. ,true"
        textline "                                     "
        bitfld.long 0x00 7. "MULTIPLE_GPU_FAULTS       ,MULTIPLE_GPU_FAULTS" "false:    No multiple fault. ,true"
        bitfld.long 0x00 8. "                 RESET_COMPLETED        ,   Modified reset values for registers. " "false,true"
        bitfld.long 0x00 9. "                                         POWER_CHANGED_SINGLE ,POWER_CHANGED_SINGLE" "false:    No power changes. ,true"
        bitfld.long 0x00 10. "                  POWER_CHANGED_ALL         ,POWER_CHANGED_ALL" "false:    No power changes. ,true"
        textline "                                     "
        bitfld.long 0x00 16. "PRFCNT_SAMPLE_COMPLETED   ,PRFCNT_SAMPLE_COMPLETED" "false,true"
        bitfld.long 0x00 17. "                                         CLEAN_CACHES_COMPLETED ,CLEAN_CACHES_COMPLETED" "false,true"

group d:0xC0500030++0x03
    line.long 0x00 "GPU_COMMAND,   Writing values to this register will perform GPU-wide commands.  During SOFT_RESET or HARD_RESET commands, the Job Manager retains the value of GPU_IRQ_MASK[RESET_COMPLETED]. "
        hexmask.long 0x00 0.--31. 1. " GPU_COMMAND               ,   Added SET_SECURE_MODE to GPU_COMMAND register.  Changed SET_SECURE_MODE to SET_PROTECTED_MODE. "

group d:0xC0500034++0x03
    line.long 0x00 "GPU_STATUS,   The GPU status register contains a set of flags showing the overall state of the GPU. "
        hexmask.long.tbyte 0x00 8.--31. 1. " Res18                     ,Res18"
        bitfld.long 0x00 0. "                                        GPU_ACTIVE             ,GPU_ACTIVE" "false,true"
        bitfld.long 0x00 1. "                                         PWR_ACTIVE           ,PWR_ACTIVE" "false,true"
        bitfld.long 0x00 2. "                                         PRFCNT_ACTIVE             ,PRFCNT_ACTIVE" "false,true"
        textline "                                     "
        bitfld.long 0x00 3. "JOB_ACTIVE                ,JOB_ACTIVE" "false,true"
        bitfld.long 0x00 4. "                                         PAGE_FAULT             ,PAGE_FAULT" "false,true"
        bitfld.long 0x00 5. "                                         IRQ_ACTIVE           ,IRQ_ACTIVE" "false,true"
        bitfld.long 0x00 6. "                                         CYCLE_COUNT_ACTIVE        ,CYCLE_COUNT_ACTIVE" "false,true"
        textline "                                     "
        bitfld.long 0x00 7. "PROTECTED_MODE_ACTIVE     ,   Added protected mode indicator to GPU_STATUS register. " "false,true"

group d:0xC0500038++0x03
    line.long 0x00 "LATEST_FLUSH,   If cache flush reduction is enabled, then this register contains the Flush ID associated with the lastest clean-and-invalidate operation.  This value is set to 0xFFFFE0 on reset, and incremented by the hardware every time a cache flush is performed by the GPU.  When enqueuing a new job chain, the value in this register should be used to set the  FLUSH_ID_NEXT register of the new job chain.      It is then possible for the GPU to determine if the GPU cache has already been flushed since submission of the job. If so, we may be able to      determine that the memory state between CPU and GPU is already consistent and the GPU need not issue another cache flush. Further details on which cache flushes may be suppressed can be found in the description of the  ENABLE_FLUSH_REDUCTION flag."
        hexmask.long.byte 0x00 24.--31. 1. " Res19                     ,Res19"
        hexmask.long.tbyte 0x00 0.--23. 1. "                                            FLUSH_ID               ,   When operating in 'cache flush reduction' mode, each job chain has an associated ID which is used to identify cache flushes.  This ID is a sequential 24-bit value. When the job manager is asked to perform a flush, it compares the job chain flush ID with the latest flush ID. If the job chain ID is equal to the latest flush, then a flush is performed.  Care must be taken in the overflow case. If the software setting up the ID detects that an overflow may occur, the job chain should be tagged with the maximum value of the  LATEST_FLUSH register. This ensures that flushes are correctly performed, at the possible cost of a few redundant flushes. Added cache flush reduction  LATEST_FLUSH.flush_id field narrowed to 24 bits, changed reset value.  Cache flush actually happens when FLUSH_ID_NEXT is equal to LATEST_FLUSH in flush reduction mode. "

group d:0xC050003C++0x03
    line.long 0x00 "GPU_FAULTSTATUS,   This register contains extended status information after a fault. If read before a fault occurs, its contents are the reset value, 0, which indicates no fault.  See  ExceptionStatus for details on the contents and layout of the fault status value. If multiple faults occur before the first is handled, the subsequent faults are ignored. They may fault again after handling the first one. Software must indicate that it has handled the fault by clearing the appropriate interrupt bit.  If the GPU is in protected mode, this register will read as zero.  Changed access type of GPU_FAULTSTATUS register when in protected mode. "
        hexmask.long.tbyte 0x00 8.--31. 1. " exception_data            , This can be interpretted as a bitfield that may include access type and source ID. "
        hexmask.long.byte 0x00 0.--7. 1. "                                        exception_type         ,   Added new MMU exception types.  Changed INTERRUPTED exception type to SUSPENDED.  Added exception types for new events EUREKA and KABOOM.  Removed aliases for OK - used to also be called IDLE and NOT_STARTED.  Documented that a KABOOM instruction will cause other jobs to hard-stop.  Removed OUT_OF_MEMORY_AFBC error as it can only occur with non-sparse allocation (now removed).  Removed INSTR_TYPE_MISMATCH, INSTR_OPERAND_FAULT, INSTR_TLS_FAULT, INSTR_ALIGN_FAULT; added IMPRECISE_FAULT (0x5B).  Split SHAREABILITY_FAULT into GPU_SHAREABILITY_FAULT, SYSTEM_SHAREABILITY_FAULT and GPU_CACHEABILITY_FAULT. "

group d:0xC0500040++0x03
    line.long 0x00 "GPU_FAULTADDRESS_LO,   If a GPU exception occurs, then the physical address causing the fault is shown in this register.  If multiple faults occur before the first is handled, the subsequent faults are ignored. They may fault again after handling the first one. Software must indicate that it has handled the fault by clearing the appropriate interrupt bit. "
        hexmask.long 0x00 0.--31. 1. " GPU_FAULTADDRESS_LO       ,   It contains the physical address at which the GPU fault occurred. "

group d:0xC0500044++0x03
    line.long 0x00 "GPU_FAULTADDRESS_HI,   If a GPU exception occurs, then the physical address causing the fault is shown in this register.  If multiple faults occur before the first is handled, the subsequent faults are ignored. They may fault again after handling the first one. Software must indicate that it has handled the fault by clearing the appropriate interrupt bit. "
        hexmask.long 0x00 0.--31. 1. " GPU_FAULTADDRESS_HI       ,   It contains the physical address at which the GPU fault occurred. "

group d:0xC0500050++0x03
    line.long 0x00 "PWR_KEY,   The power manager key register must be written before any of the power control override registers can be written to.  Since incorrectly setting any of the PWR_OVERRIDEn registers may potentially lock up or damage a device, they are write protected by default.  By writing the value 0x2968A819 to this register, the PWR_OVERRIDEn registers are temporarily made writable. The next write access to the GPU can then update them. If writing multiple registers, the PWR_KEY register must be written before each register is updated.  The registers are write protected automatically after any write access to the GPU. If the first write after unlocking the registers are not to any of the power override registers, the registers are still write protected, causing any later update attempt to be ignored. "
        hexmask.long 0x00 0.--31. 1. " PWR_KEY                   ,   It must be written with the value 0x2968A819 to unlock writes to the other power state registers. This key value was generated at random, and has no special significance except that it is unlikely to occur by chance. "

group d:0xC0500054++0x03
    line.long 0x00 "PWR_OVERRIDE0,   The power manager override register 0 allows aspects of how individual cores are powered up and down to be overridden.  This register is write protected by default. A special key value must be written to the PWR_KEY register to allow this register to be updated.  The override fields allow the low-level signals used for controlling power gating to behave differently from normal. This can be used for testing, or for working around power gating problems. As such, they require low-level understanding of the implementation details of the power domain controller.  The override values are propagated to individual power domains on any power up or power down operation. To change the override modes for a power domain, the power state of the domain must be changed. Domains that are powered on must be powered off, and domains that are powered off must be powered on.  Writing to this register while any power change commands are pending is  UNDEFINED . Setting incorrect values in this register may cause  UNPREDICTABLE behaviour of the entire system. Do not write to this register unless explicitly specified by the device manufacturer. The only guaranteed safe value for this register is 0. Removed CLKEN_OVERRIDE from PWR_OVERRIDE0 register. "
        bitfld.long 0x00 6.--7. " Res20                     ,Res20" "0,1,2,3"
        bitfld.long 0x00 22. "                                             Res21                  ,Res21" "0,1"
        bitfld.long 0x00 30.--31. "                                             Res22                ,Res22" "0,1,2,3"
        hexmask.long.byte 0x00 16.--21. 1. "                                             PWRTRANS_LIMIT            ,   It contains the number of power domains which may be in transition at any one time, minus 1. "
        textline "                                     "
        hexmask.long.byte 0x00 24.--29. 1. "THROTTLE_LIMIT            ,   This field contains the number of shader cores which may be in startup at any one time, minus 1.       A core is considered to be starting after the core is sent a task (load_descriptor/run),       until the first response to a RUN command (which includes LOAD_DESCRIPTOR with run_immediately).  If the  THROTTLE_ENABLE flag is clear, then this field is ignored. The intent of this is to smooth out sudden changes in dynamic power, in a similar way to how  PWRTRANS_LIMIT smooths out sudden changes in static power. Added core startup throttling fields to PWR_OVERRIDE0 "
        bitfld.long 0x00 0.--1. "                                            PWRUP_OVERRIDE         ,   It overrides the handling of the power manager's PWRUP signal. " "OVERRIDE_NONE:  The signal behaves normally ,OVERRIDE_INVERT,OVERRIDE_ON,OVERRIDE_OFF"
        bitfld.long 0x00 2.--3. "  ISOLATE_OVERRIDE     ,   It overrides the handling of the power manager's ISOLATE signal. " "OVERRIDE_NONE:  The signal behaves normally ,OVERRIDE_INVERT,OVERRIDE_ON,OVERRIDE_OFF"
        bitfld.long 0x00 4.--5. "  RESET_OVERRIDE            ,   It overrides the handling of the power manager's RESET signal. " "OVERRIDE_NONE:  The signal behaves normally ,OVERRIDE_INVERT,OVERRIDE_ON,OVERRIDE_OFF"
        textline "                                     "
        bitfld.long 0x00 8.--9. "PWRUP_ACK_OVERRIDE        ,   It overrides the handling of the power manager's PWRUP signal. " "OVERRIDE_NONE:  The signal behaves normally ,OVERRIDE_INVERT,OVERRIDE_ON,OVERRIDE_OFF"
        bitfld.long 0x00 10.--11. "  ISOLATE_ACK_OVERRIDE   ,   It overrides the handling of the power manager's PWRUP signal. " "OVERRIDE_NONE:  The signal behaves normally ,OVERRIDE_INVERT,OVERRIDE_ON,OVERRIDE_OFF"
        bitfld.long 0x00 12.--13. "  FUNC_ISO_OVERRIDE    ,   It overrides the handling of the power manager's FUNC_ISOLATE signal.  Added FUNC_ISO_OVERRIDE field to PWR_OVERRIDE0 register. " "OVERRIDE_NONE:  The signal behaves normally ,OVERRIDE_INVERT,OVERRIDE_ON,OVERRIDE_OFF"
        bitfld.long 0x00 14.--15. "  FUNC_ISO_ACK_OVERRIDE     ,   It overrides the handling of the power manager's FUNC_ISOLATE_ACK signal.  Added FUNC_ISO_ACK_OVERRIDE field to PWR_OVERRIDE0 register. " "OVERRIDE_NONE:  The signal behaves normally ,OVERRIDE_INVERT,OVERRIDE_ON,OVERRIDE_OFF"
        textline "                                     "
        bitfld.long 0x00 23. "THROTTLE_ENABLE           ,THROTTLE_ENABLE" "false,true"

group d:0xC0500058++0x03
    line.long 0x00 "PWR_OVERRIDE1,   In addition to the power control values in power manager override register 0, the device manufacturer may also choose to use this register to affect how power management behaves.  Setting incorrect values in this register may cause  UNPREDICTABLE behaviour of the entire system. Do not write to this register unless explicitly specified by the device manufacturer. The only guaranteed safe value for this register is 0."
        hexmask.long 0x00 0.--31. 1. " PWR_OVERRIDE1             ,   System-specific power control values. "

group d:0xC0500060++0x03
    line.long 0x00 "PRFCNT_BASE_LO,   This register contains the start of a memory region where the performance counter values can be written. The required size of this are depends on the GPU configuration and the setting in the PRFCNT_CONFIG register.  The address is a virtual address in the address space specified by the ADDRESS_SPACE field in the PRFCNT_CONFIG register.  Writing to this register while the GPU is active and the performance counters are enabled is  UNDEFINED ."
        hexmask.long 0x00 0.--31. 1. " PRFCNT_BASE_LO            ,   It contains the base address of performance counter write area. "

group d:0xC0500064++0x03
    line.long 0x00 "PRFCNT_BASE_HI,   This register contains the start of a memory region where the performance counter values can be written. The required size of this are depends on the GPU configuration and the setting in the PRFCNT_CONFIG register.  The address is a virtual address in the address space specified by the ADDRESS_SPACE field in the PRFCNT_CONFIG register.  Writing to this register while the GPU is active and the performance counters are enabled is  UNDEFINED ."
        hexmask.long 0x00 0.--31. 1. " PRFCNT_BASE_HI            ,   It contains the base address of performance counter write area. "

group d:0xC0500068++0x03
    line.long 0x00 "PRFCNT_CONFIG,   The performance counter configuration register controls how the performance counters work. For more details, see the section on Performance Counters. "
        hexmask.long.tbyte 0x00 9.--31. 1. " Res23                     ,Res23"
        bitfld.long 0x00 4.--7. "                                        ADDRESS_SPACE          ,   It contains the address space ID (ASID) used to translate virtual addresses when writing the performance counters to memory. Changing address space while the GPU is active and the counters are enabled is  UNDEFINED . Specifying an address space that is not supported (i.e. the corresponding bit in AS_PRESENT is 0) is UNDEFINED ." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 0.--3. "                                            MODE                 ,   Manual counter writing no longer automatically clears counters. Tiled mode is unchanged.  Manual counter writing reverted to clear counters, new MANUAL_NO_CLEAR mode added. " "OFF,MANUAL,TILE,MANUAL_NO_CLEAR,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 8. "                               SET_SELECT                ,   This flag allows selection of additional sets of counter events.        For those counter blocks that support it, this effectively selects between two sets of the event count inputs to the same counter block.        Since there is only one flag, all functional blocks are switched at the same time.        During switching, the counter values become  UNDEFINED as they may register counts from a mixture of sources.        It is therefore recommended that, after switching, performance counters are cleared by writing PRFCNT_CLEAR to the GPU_COMMAND register. Added  SET_SELECT flag to PRFCNT_CONFIG ." "false,true"

group d:0xC050006C++0x03
    line.long 0x00 "PRFCNT_JM_EN,   Performance counter enable for Job Manager. "
        hexmask.long 0x00 0.--31. 1. " PRFCNT_JM_EN              ,   The main use for this register is to reduce the bandwidth required to write out the performance counters to memory, and so reduce the impact the counters have on the performance of the GPU.  Bit 0 controls the writing of the performance metadata - the time stamp and counter enable mask.  Writing to these registers while performance counters are enabled is  UNDEFINED . Writing to these registers while the corresponding cores are powered off has no effect. "

group d:0xC0500070++0x03
    line.long 0x00 "PRFCNT_SHADER_EN,   Performance counter enable for shader cores. "
        hexmask.long 0x00 0.--31. 1. " PRFCNT_SHADER_EN          ,   The main use for this register is to reduce the bandwidth required to write out the performance counters to memory, and so reduce the impact the counters have on the performance of the GPU.  Bit 0 controls the writing of the performance metadata - the time stamp and counter enable mask.  Writing to these registers while performance counters are enabled is  UNDEFINED . Writing to these registers while the corresponding cores are powered off has no effect. "

group d:0xC0500074++0x03
    line.long 0x00 "PRFCNT_TILER_EN,   Performance counter enable for tiler. "
        hexmask.long 0x00 0.--31. 1. " PRFCNT_TILER_EN           ,   The main use for this register is to reduce the bandwidth required to write out the performance counters to memory, and so reduce the impact the counters have on the performance of the GPU.  Bit 0 controls the writing of the performance metadata - the time stamp and counter enable mask.  Writing to these registers while performance counters are enabled is  UNDEFINED . Writing to these registers while the corresponding cores are powered off has no effect. "

group d:0xC050007C++0x03
    line.long 0x00 "PRFCNT_MMU_L2_EN,   Performance counter enable for memory management unit and level 2 cache. "
        hexmask.long 0x00 0.--31. 1. " PRFCNT_MMU_L2_EN          ,   The main use for this register is to reduce the bandwidth required to write out the performance counters to memory, and so reduce the impact the counters have on the performance of the GPU.  Bit 0 controls the writing of the performance metadata - the time stamp and counter enable mask.  Writing to these registers while performance counters are enabled is  UNDEFINED . Writing to these registers while the corresponding cores are powered off has no effect. "

group d:0xC0500090++0x03
    line.long 0x00 "CYCLE_COUNT_LO,   The Job Manager contains a 64-bit cycle counter. This counter simply counts the number of clock cycles since it was started, the frequency of which is determined by the system as a whole and which may change due to voltage and frequency scaling. It therefore does not have a unique, fixed relationship with real time, but is guaranteed to be nondecreasing unless reset, and is very fine grained.  It is readable through the CYCLE_COUNT register, and can also be written to memory by a write value job.  This counter value is sent to each shader core, ensuring that all cores have a consistent and synchronized value readable from the shader.  The counter must be explicitly started. After reset the counter has value zero but is not running. To start the counter, issue a CYCLE_COUNT_START command to the GPU_COMMAND register.  When the GPU is not used, the counter should be stopped to reduce power consumption. To stop the counter, issue a CYCLE_COUNT_STOP command to the GPU_COMMAND register.  Note that this is implemented separately from, and in addition to, a system-wide constant-frequency counter "
        hexmask.long 0x00 0.--31. 1. " CYCLE_COUNT_LO            ,   It contains the number of GPU clock cycles since the counter was started. "

group d:0xC0500094++0x03
    line.long 0x00 "CYCLE_COUNT_HI,   The Job Manager contains a 64-bit cycle counter. This counter simply counts the number of clock cycles since it was started, the frequency of which is determined by the system as a whole and which may change due to voltage and frequency scaling. It therefore does not have a unique, fixed relationship with real time, but is guaranteed to be nondecreasing unless reset, and is very fine grained.  It is readable through the CYCLE_COUNT register, and can also be written to memory by a write value job.  This counter value is sent to each shader core, ensuring that all cores have a consistent and synchronized value readable from the shader.  The counter must be explicitly started. After reset the counter has value zero but is not running. To start the counter, issue a CYCLE_COUNT_START command to the GPU_COMMAND register.  When the GPU is not used, the counter should be stopped to reduce power consumption. To stop the counter, issue a CYCLE_COUNT_STOP command to the GPU_COMMAND register.  Note that this is implemented separately from, and in addition to, a system-wide constant-frequency counter "
        hexmask.long 0x00 0.--31. 1. " CYCLE_COUNT_HI            ,   It contains the number of GPU clock cycles since the counter was started. "

group d:0xC0500098++0x03
    line.long 0x00 "TIMESTAMP_LO,   This is a handy point from which the system global timestamp counter can be read. The value is the current broadcast value of the system time counter, as described in [7], which has a fixed relationship with real time and is coherent system-wide.  Although the time stamp value is continually updated externally from the GPU, propagation of the time stamp value to the GPU must be explicitly started in the same manned as the CYCLE_COUNT register, above.  So, after reset the current local copy of the timestamp has value zero and is not being actively updated. To start updates, issue a CYCLE_COUNT_START command to the GPU_COMMAND register.  When the GPU is not used, time stamp updates should be stopped to reduce power consumption. To stop the update, issue a CYCLE_COUNT_STOP command to the GPU_COMMAND register. "
        hexmask.long 0x00 0.--31. 1. " TIMESTAMP_LO              ,   It contains the global time stamp value. "

group d:0xC050009C++0x03
    line.long 0x00 "TIMESTAMP_HI,   This is a handy point from which the system global timestamp counter can be read. The value is the current broadcast value of the system time counter, as described in [7], which has a fixed relationship with real time and is coherent system-wide.  Although the time stamp value is continually updated externally from the GPU, propagation of the time stamp value to the GPU must be explicitly started in the same manned as the CYCLE_COUNT register, above.  So, after reset the current local copy of the timestamp has value zero and is not being actively updated. To start updates, issue a CYCLE_COUNT_START command to the GPU_COMMAND register.  When the GPU is not used, time stamp updates should be stopped to reduce power consumption. To stop the update, issue a CYCLE_COUNT_STOP command to the GPU_COMMAND register. "
        hexmask.long 0x00 0.--31. 1. " TIMESTAMP_HI              ,   It contains the global time stamp value. "

group d:0xC05000A0++0x03
    line.long 0x00 "THREAD_MAX_THREADS,   The maximum number of threads that can be in flight on each core. If this register is 0, then the information is not available on this implementation of the GPU. "
        hexmask.long 0x00 0.--31. 1. " THREAD_MAX_THREADS        ,   It contains the maximum number of threads per core. "

group d:0xC05000A4++0x03
    line.long 0x00 "THREAD_MAX_WORKGROUP_SIZE,   The maximum number of threads in a single workgroup. If this register is 0, then the information is not available on this implementation of the GPU. "
        hexmask.long 0x00 0.--31. 1. " THREAD_MAX_WORKGROUP_SIZE ,   It contains the maximum number of threads in a single workgroup. "

group d:0xC05000A8++0x03
    line.long 0x00 "THREAD_MAX_BARRIER_SIZE,   The maximum number of threads which may be simultaneously waiting at a hardware barrier. If this register is 0, then the information is not available on this implementation of the GPU. "
        hexmask.long 0x00 0.--31. 1. " THREAD_MAX_BARRIER_SIZE   ,   It contains the maximum number of threads waiting at a barrier. "

group d:0xC05000AC++0x03
    line.long 0x00 "THREAD_FEATURES,   Describes other features of the GPUs threading system. If this register is 0, then the information is not available on this implementation of the GPU. "
        hexmask.long.word 0x00 0.--15. 1. " MAX_REGISTERS             ,   It contains the total size of the register file available per core. Each register is 32 bits in size. "
        hexmask.long.byte 0x00 16.--23. 1. "                                          MAX_TASK_QUEUE         ,   It contains the maximum number of tasks which may be sent to a core before it becomes blocked. "
        hexmask.long.byte 0x00 24.--29. 1. "                                            MAX_TG_SPLIT         ,   This field contains the maximum allowed value of the  thread_group_split field in a job descriptor. This must be at least big enough to represent the largest supported workgroup size, even if this is represented using a non-compact encoding.        An example of this would be a workgroup of size 5x5x5 work items which takes 9 bits rather than the expected 7 bits to encode.        So for the relatively common maximum workgroup size of 256, this would need to be 10 or more.  Changed value of MAX_TG_SPLIT to 10, added note on why it has this value. "
        bitfld.long 0x00 30.--31. "                                            IMPLEMENTATION_TECHNOLOGY ,IMPLEMENTATION_TECHNOLOGY" "NOT_SPECIFIED,SILICON,FPGA,SOFTWARE"

group d:0xC05000B0++0x03
    line.long 0x00 "TEXTURE_FEATURES_0,   Contains information about which job slots are present on this GPU. "
        hexmask.long 0x00 0.--31. 1. " TEXTURE_FEATURES_0        ,   Indicates which indexed texture formats are actually available in the hardware. "

group d:0xC05000B4++0x03
    line.long 0x00 "TEXTURE_FEATURES_1,   Each bit in this register indicates that the texture unit supports a specific indexed texture format in the range 32..63. "
        hexmask.long 0x00 0.--31. 1. " TEXTURE_FEATURES_1        ,   Indicates which indexed texture formats are actually available in the hardware. "

group d:0xC05000B8++0x03
    line.long 0x00 "TEXTURE_FEATURES_2,   Each bit in this register indicates that the texture unit supports a specific indexed texture format in the range 64..95. "
        hexmask.long 0x00 0.--31. 1. " TEXTURE_FEATURES_2        ,   Indicates which indexed texture formats are actually available in the hardware. "

group d:0xC05000C0++0x03
    line.long 0x00 "JS0_FEATURES,   Contains various information of the features of Job Slot 0. "
        bitfld.long 0x00 0. " Res24                     ,Res24" "0,1"
        bitfld.long 0x00 8. "                                             Res25                  ,Res25" "0,1"
        hexmask.long.tbyte 0x00 11.--31. 1. "                                             Res26                ,Res26"
        bitfld.long 0x00 1. "                                        NULL                      ,NULL" "false,true"
        textline "                                     "
        bitfld.long 0x00 2. "WRITE_VALUE               ,   Corrected two references to Set value job. " "false,true"
        bitfld.long 0x00 3. "                                         CACHE_FLUSH            ,CACHE_FLUSH" "false,true"
        bitfld.long 0x00 4. "                                         COMPUTE_SHADER       ,COMPUTE_SHADER" "false,true"
        bitfld.long 0x00 5. "                                         VERTEX_SHADER             ,VERTEX_SHADER" "false,true"
        textline "                                     "
        bitfld.long 0x00 6. "GEOMETRY_SHADER           ,GEOMETRY_SHADER" "false,true"
        bitfld.long 0x00 7. "                                         TILER                  ,TILER" "false,true"
        bitfld.long 0x00 9. "                                         FRAGMENT_SHADER      ,FRAGMENT_SHADER" "false,true"
        bitfld.long 0x00 10. "                                         INDEXED_VERTEX_SHADER     ,   Added INDEXED_VERTEX_SHADER flag to  JSn_FEATURES registers." "false,true"

group d:0xC05000C4++0x03
    line.long 0x00 "JS1_FEATURES,   Contains various information of the features of Job Slot 1. "
        bitfld.long 0x00 0. " Res27                     ,Res27" "0,1"
        bitfld.long 0x00 8. "                                             Res28                  ,Res28" "0,1"
        hexmask.long.tbyte 0x00 11.--31. 1. "                                             Res29                ,Res29"
        bitfld.long 0x00 1. "                                        NULL                      ,NULL" "false,true"
        textline "                                     "
        bitfld.long 0x00 2. "WRITE_VALUE               ,   Corrected two references to Set value job. " "false,true"
        bitfld.long 0x00 3. "                                         CACHE_FLUSH            ,CACHE_FLUSH" "false,true"
        bitfld.long 0x00 4. "                                         COMPUTE_SHADER       ,COMPUTE_SHADER" "false,true"
        bitfld.long 0x00 5. "                                         VERTEX_SHADER             ,VERTEX_SHADER" "false,true"
        textline "                                     "
        bitfld.long 0x00 6. "GEOMETRY_SHADER           ,GEOMETRY_SHADER" "false,true"
        bitfld.long 0x00 7. "                                         TILER                  ,TILER" "false,true"
        bitfld.long 0x00 9. "                                         FRAGMENT_SHADER      ,FRAGMENT_SHADER" "false,true"
        bitfld.long 0x00 10. "                                         INDEXED_VERTEX_SHADER     ,   Added INDEXED_VERTEX_SHADER flag to  JSn_FEATURES registers." "false,true"

group d:0xC05000C8++0x03
    line.long 0x00 "JS2_FEATURES,   Contains various information of the features of Job Slot 2. "
        bitfld.long 0x00 0. " Res30                     ,Res30" "0,1"
        bitfld.long 0x00 8. "                                             Res31                  ,Res31" "0,1"
        hexmask.long.tbyte 0x00 11.--31. 1. "                                             Res32                ,Res32"
        bitfld.long 0x00 1. "                                        NULL                      ,NULL" "false,true"
        textline "                                     "
        bitfld.long 0x00 2. "WRITE_VALUE               ,   Corrected two references to Set value job. " "false,true"
        bitfld.long 0x00 3. "                                         CACHE_FLUSH            ,CACHE_FLUSH" "false,true"
        bitfld.long 0x00 4. "                                         COMPUTE_SHADER       ,COMPUTE_SHADER" "false,true"
        bitfld.long 0x00 5. "                                         VERTEX_SHADER             ,VERTEX_SHADER" "false,true"
        textline "                                     "
        bitfld.long 0x00 6. "GEOMETRY_SHADER           ,GEOMETRY_SHADER" "false,true"
        bitfld.long 0x00 7. "                                         TILER                  ,TILER" "false,true"
        bitfld.long 0x00 9. "                                         FRAGMENT_SHADER      ,FRAGMENT_SHADER" "false,true"
        bitfld.long 0x00 10. "                                         INDEXED_VERTEX_SHADER     ,   Added INDEXED_VERTEX_SHADER flag to  JSn_FEATURES registers." "false,true"

group d:0xC05000CC++0x03
    line.long 0x00 "JS3_FEATURES,   Contains various information of the features of Job Slot 3. "
        bitfld.long 0x00 0. " Res33                     ,Res33" "0,1"
        bitfld.long 0x00 8. "                                             Res34                  ,Res34" "0,1"
        hexmask.long.tbyte 0x00 11.--31. 1. "                                             Res35                ,Res35"
        bitfld.long 0x00 1. "                                        NULL                      ,NULL" "false,true"
        textline "                                     "
        bitfld.long 0x00 2. "WRITE_VALUE               ,   Corrected two references to Set value job. " "false,true"
        bitfld.long 0x00 3. "                                         CACHE_FLUSH            ,CACHE_FLUSH" "false,true"
        bitfld.long 0x00 4. "                                         COMPUTE_SHADER       ,COMPUTE_SHADER" "false,true"
        bitfld.long 0x00 5. "                                         VERTEX_SHADER             ,VERTEX_SHADER" "false,true"
        textline "                                     "
        bitfld.long 0x00 6. "GEOMETRY_SHADER           ,GEOMETRY_SHADER" "false,true"
        bitfld.long 0x00 7. "                                         TILER                  ,TILER" "false,true"
        bitfld.long 0x00 9. "                                         FRAGMENT_SHADER      ,FRAGMENT_SHADER" "false,true"
        bitfld.long 0x00 10. "                                         INDEXED_VERTEX_SHADER     ,   Added INDEXED_VERTEX_SHADER flag to  JSn_FEATURES registers." "false,true"

group d:0xC05000D0++0x03
    line.long 0x00 "JS4_FEATURES,   Contains various information of the features of Job Slot 4. "
        bitfld.long 0x00 0. " Res36                     ,Res36" "0,1"
        bitfld.long 0x00 8. "                                             Res37                  ,Res37" "0,1"
        hexmask.long.tbyte 0x00 11.--31. 1. "                                             Res38                ,Res38"
        bitfld.long 0x00 1. "                                        NULL                      ,NULL" "false,true"
        textline "                                     "
        bitfld.long 0x00 2. "WRITE_VALUE               ,   Corrected two references to Set value job. " "false,true"
        bitfld.long 0x00 3. "                                         CACHE_FLUSH            ,CACHE_FLUSH" "false,true"
        bitfld.long 0x00 4. "                                         COMPUTE_SHADER       ,COMPUTE_SHADER" "false,true"
        bitfld.long 0x00 5. "                                         VERTEX_SHADER             ,VERTEX_SHADER" "false,true"
        textline "                                     "
        bitfld.long 0x00 6. "GEOMETRY_SHADER           ,GEOMETRY_SHADER" "false,true"
        bitfld.long 0x00 7. "                                         TILER                  ,TILER" "false,true"
        bitfld.long 0x00 9. "                                         FRAGMENT_SHADER      ,FRAGMENT_SHADER" "false,true"
        bitfld.long 0x00 10. "                                         INDEXED_VERTEX_SHADER     ,   Added INDEXED_VERTEX_SHADER flag to  JSn_FEATURES registers." "false,true"

group d:0xC05000D4++0x03
    line.long 0x00 "JS5_FEATURES,   Contains various information of the features of Job Slot 5. "
        bitfld.long 0x00 0. " Res39                     ,Res39" "0,1"
        bitfld.long 0x00 8. "                                             Res40                  ,Res40" "0,1"
        hexmask.long.tbyte 0x00 11.--31. 1. "                                             Res41                ,Res41"
        bitfld.long 0x00 1. "                                        NULL                      ,NULL" "false,true"
        textline "                                     "
        bitfld.long 0x00 2. "WRITE_VALUE               ,   Corrected two references to Set value job. " "false,true"
        bitfld.long 0x00 3. "                                         CACHE_FLUSH            ,CACHE_FLUSH" "false,true"
        bitfld.long 0x00 4. "                                         COMPUTE_SHADER       ,COMPUTE_SHADER" "false,true"
        bitfld.long 0x00 5. "                                         VERTEX_SHADER             ,VERTEX_SHADER" "false,true"
        textline "                                     "
        bitfld.long 0x00 6. "GEOMETRY_SHADER           ,GEOMETRY_SHADER" "false,true"
        bitfld.long 0x00 7. "                                         TILER                  ,TILER" "false,true"
        bitfld.long 0x00 9. "                                         FRAGMENT_SHADER      ,FRAGMENT_SHADER" "false,true"
        bitfld.long 0x00 10. "                                         INDEXED_VERTEX_SHADER     ,   Added INDEXED_VERTEX_SHADER flag to  JSn_FEATURES registers." "false,true"

group d:0xC05000D8++0x03
    line.long 0x00 "JS6_FEATURES,   Contains various information of the features of Job Slot 6. "
        bitfld.long 0x00 0. " Res42                     ,Res42" "0,1"
        bitfld.long 0x00 8. "                                             Res43                  ,Res43" "0,1"
        hexmask.long.tbyte 0x00 11.--31. 1. "                                             Res44                ,Res44"
        bitfld.long 0x00 1. "                                        NULL                      ,NULL" "false,true"
        textline "                                     "
        bitfld.long 0x00 2. "WRITE_VALUE               ,   Corrected two references to Set value job. " "false,true"
        bitfld.long 0x00 3. "                                         CACHE_FLUSH            ,CACHE_FLUSH" "false,true"
        bitfld.long 0x00 4. "                                         COMPUTE_SHADER       ,COMPUTE_SHADER" "false,true"
        bitfld.long 0x00 5. "                                         VERTEX_SHADER             ,VERTEX_SHADER" "false,true"
        textline "                                     "
        bitfld.long 0x00 6. "GEOMETRY_SHADER           ,GEOMETRY_SHADER" "false,true"
        bitfld.long 0x00 7. "                                         TILER                  ,TILER" "false,true"
        bitfld.long 0x00 9. "                                         FRAGMENT_SHADER      ,FRAGMENT_SHADER" "false,true"
        bitfld.long 0x00 10. "                                         INDEXED_VERTEX_SHADER     ,   Added INDEXED_VERTEX_SHADER flag to  JSn_FEATURES registers." "false,true"

group d:0xC05000DC++0x03
    line.long 0x00 "JS7_FEATURES,   Contains various information of the features of Job Slot 7. "
        bitfld.long 0x00 0. " Res45                     ,Res45" "0,1"
        bitfld.long 0x00 8. "                                             Res46                  ,Res46" "0,1"
        hexmask.long.tbyte 0x00 11.--31. 1. "                                             Res47                ,Res47"
        bitfld.long 0x00 1. "                                        NULL                      ,NULL" "false,true"
        textline "                                     "
        bitfld.long 0x00 2. "WRITE_VALUE               ,   Corrected two references to Set value job. " "false,true"
        bitfld.long 0x00 3. "                                         CACHE_FLUSH            ,CACHE_FLUSH" "false,true"
        bitfld.long 0x00 4. "                                         COMPUTE_SHADER       ,COMPUTE_SHADER" "false,true"
        bitfld.long 0x00 5. "                                         VERTEX_SHADER             ,VERTEX_SHADER" "false,true"
        textline "                                     "
        bitfld.long 0x00 6. "GEOMETRY_SHADER           ,GEOMETRY_SHADER" "false,true"
        bitfld.long 0x00 7. "                                         TILER                  ,TILER" "false,true"
        bitfld.long 0x00 9. "                                         FRAGMENT_SHADER      ,FRAGMENT_SHADER" "false,true"
        bitfld.long 0x00 10. "                                         INDEXED_VERTEX_SHADER     ,   Added INDEXED_VERTEX_SHADER flag to  JSn_FEATURES registers." "false,true"

group d:0xC05000E0++0x03
    line.long 0x00 "JS8_FEATURES,   Contains various information of the features of Job Slot 8. "
        bitfld.long 0x00 0. " Res48                     ,Res48" "0,1"
        bitfld.long 0x00 8. "                                             Res49                  ,Res49" "0,1"
        hexmask.long.tbyte 0x00 11.--31. 1. "                                             Res50                ,Res50"
        bitfld.long 0x00 1. "                                        NULL                      ,NULL" "false,true"
        textline "                                     "
        bitfld.long 0x00 2. "WRITE_VALUE               ,   Corrected two references to Set value job. " "false,true"
        bitfld.long 0x00 3. "                                         CACHE_FLUSH            ,CACHE_FLUSH" "false,true"
        bitfld.long 0x00 4. "                                         COMPUTE_SHADER       ,COMPUTE_SHADER" "false,true"
        bitfld.long 0x00 5. "                                         VERTEX_SHADER             ,VERTEX_SHADER" "false,true"
        textline "                                     "
        bitfld.long 0x00 6. "GEOMETRY_SHADER           ,GEOMETRY_SHADER" "false,true"
        bitfld.long 0x00 7. "                                         TILER                  ,TILER" "false,true"
        bitfld.long 0x00 9. "                                         FRAGMENT_SHADER      ,FRAGMENT_SHADER" "false,true"
        bitfld.long 0x00 10. "                                         INDEXED_VERTEX_SHADER     ,   Added INDEXED_VERTEX_SHADER flag to  JSn_FEATURES registers." "false,true"

group d:0xC05000E4++0x03
    line.long 0x00 "JS9_FEATURES,   Contains various information of the features of Job Slot 9. "
        bitfld.long 0x00 0. " Res51                     ,Res51" "0,1"
        bitfld.long 0x00 8. "                                             Res52                  ,Res52" "0,1"
        hexmask.long.tbyte 0x00 11.--31. 1. "                                             Res53                ,Res53"
        bitfld.long 0x00 1. "                                        NULL                      ,NULL" "false,true"
        textline "                                     "
        bitfld.long 0x00 2. "WRITE_VALUE               ,   Corrected two references to Set value job. " "false,true"
        bitfld.long 0x00 3. "                                         CACHE_FLUSH            ,CACHE_FLUSH" "false,true"
        bitfld.long 0x00 4. "                                         COMPUTE_SHADER       ,COMPUTE_SHADER" "false,true"
        bitfld.long 0x00 5. "                                         VERTEX_SHADER             ,VERTEX_SHADER" "false,true"
        textline "                                     "
        bitfld.long 0x00 6. "GEOMETRY_SHADER           ,GEOMETRY_SHADER" "false,true"
        bitfld.long 0x00 7. "                                         TILER                  ,TILER" "false,true"
        bitfld.long 0x00 9. "                                         FRAGMENT_SHADER      ,FRAGMENT_SHADER" "false,true"
        bitfld.long 0x00 10. "                                         INDEXED_VERTEX_SHADER     ,   Added INDEXED_VERTEX_SHADER flag to  JSn_FEATURES registers." "false,true"

group d:0xC05000E8++0x03
    line.long 0x00 "JS10_FEATURES,   Contains various information of the features of Job Slot 10. "
        bitfld.long 0x00 0. " Res54                     ,Res54" "0,1"
        bitfld.long 0x00 8. "                                             Res55                  ,Res55" "0,1"
        hexmask.long.tbyte 0x00 11.--31. 1. "                                             Res56                ,Res56"
        bitfld.long 0x00 1. "                                        NULL                      ,NULL" "false,true"
        textline "                                     "
        bitfld.long 0x00 2. "WRITE_VALUE               ,   Corrected two references to Set value job. " "false,true"
        bitfld.long 0x00 3. "                                         CACHE_FLUSH            ,CACHE_FLUSH" "false,true"
        bitfld.long 0x00 4. "                                         COMPUTE_SHADER       ,COMPUTE_SHADER" "false,true"
        bitfld.long 0x00 5. "                                         VERTEX_SHADER             ,VERTEX_SHADER" "false,true"
        textline "                                     "
        bitfld.long 0x00 6. "GEOMETRY_SHADER           ,GEOMETRY_SHADER" "false,true"
        bitfld.long 0x00 7. "                                         TILER                  ,TILER" "false,true"
        bitfld.long 0x00 9. "                                         FRAGMENT_SHADER      ,FRAGMENT_SHADER" "false,true"
        bitfld.long 0x00 10. "                                         INDEXED_VERTEX_SHADER     ,   Added INDEXED_VERTEX_SHADER flag to  JSn_FEATURES registers." "false,true"

group d:0xC05000EC++0x03
    line.long 0x00 "JS11_FEATURES,   Contains various information of the features of Job Slot 11. "
        bitfld.long 0x00 0. " Res57                     ,Res57" "0,1"
        bitfld.long 0x00 8. "                                             Res58                  ,Res58" "0,1"
        hexmask.long.tbyte 0x00 11.--31. 1. "                                             Res59                ,Res59"
        bitfld.long 0x00 1. "                                        NULL                      ,NULL" "false,true"
        textline "                                     "
        bitfld.long 0x00 2. "WRITE_VALUE               ,   Corrected two references to Set value job. " "false,true"
        bitfld.long 0x00 3. "                                         CACHE_FLUSH            ,CACHE_FLUSH" "false,true"
        bitfld.long 0x00 4. "                                         COMPUTE_SHADER       ,COMPUTE_SHADER" "false,true"
        bitfld.long 0x00 5. "                                         VERTEX_SHADER             ,VERTEX_SHADER" "false,true"
        textline "                                     "
        bitfld.long 0x00 6. "GEOMETRY_SHADER           ,GEOMETRY_SHADER" "false,true"
        bitfld.long 0x00 7. "                                         TILER                  ,TILER" "false,true"
        bitfld.long 0x00 9. "                                         FRAGMENT_SHADER      ,FRAGMENT_SHADER" "false,true"
        bitfld.long 0x00 10. "                                         INDEXED_VERTEX_SHADER     ,   Added INDEXED_VERTEX_SHADER flag to  JSn_FEATURES registers." "false,true"

group d:0xC05000F0++0x03
    line.long 0x00 "JS12_FEATURES,   Contains various information of the features of Job Slot 12. "
        bitfld.long 0x00 0. " Res60                     ,Res60" "0,1"
        bitfld.long 0x00 8. "                                             Res61                  ,Res61" "0,1"
        hexmask.long.tbyte 0x00 11.--31. 1. "                                             Res62                ,Res62"
        bitfld.long 0x00 1. "                                        NULL                      ,NULL" "false,true"
        textline "                                     "
        bitfld.long 0x00 2. "WRITE_VALUE               ,   Corrected two references to Set value job. " "false,true"
        bitfld.long 0x00 3. "                                         CACHE_FLUSH            ,CACHE_FLUSH" "false,true"
        bitfld.long 0x00 4. "                                         COMPUTE_SHADER       ,COMPUTE_SHADER" "false,true"
        bitfld.long 0x00 5. "                                         VERTEX_SHADER             ,VERTEX_SHADER" "false,true"
        textline "                                     "
        bitfld.long 0x00 6. "GEOMETRY_SHADER           ,GEOMETRY_SHADER" "false,true"
        bitfld.long 0x00 7. "                                         TILER                  ,TILER" "false,true"
        bitfld.long 0x00 9. "                                         FRAGMENT_SHADER      ,FRAGMENT_SHADER" "false,true"
        bitfld.long 0x00 10. "                                         INDEXED_VERTEX_SHADER     ,   Added INDEXED_VERTEX_SHADER flag to  JSn_FEATURES registers." "false,true"

group d:0xC05000F4++0x03
    line.long 0x00 "JS13_FEATURES,   Contains various information of the features of Job Slot 13. "
        bitfld.long 0x00 0. " Res63                     ,Res63" "0,1"
        bitfld.long 0x00 8. "                                             Res64                  ,Res64" "0,1"
        hexmask.long.tbyte 0x00 11.--31. 1. "                                             Res65                ,Res65"
        bitfld.long 0x00 1. "                                        NULL                      ,NULL" "false,true"
        textline "                                     "
        bitfld.long 0x00 2. "WRITE_VALUE               ,   Corrected two references to Set value job. " "false,true"
        bitfld.long 0x00 3. "                                         CACHE_FLUSH            ,CACHE_FLUSH" "false,true"
        bitfld.long 0x00 4. "                                         COMPUTE_SHADER       ,COMPUTE_SHADER" "false,true"
        bitfld.long 0x00 5. "                                         VERTEX_SHADER             ,VERTEX_SHADER" "false,true"
        textline "                                     "
        bitfld.long 0x00 6. "GEOMETRY_SHADER           ,GEOMETRY_SHADER" "false,true"
        bitfld.long 0x00 7. "                                         TILER                  ,TILER" "false,true"
        bitfld.long 0x00 9. "                                         FRAGMENT_SHADER      ,FRAGMENT_SHADER" "false,true"
        bitfld.long 0x00 10. "                                         INDEXED_VERTEX_SHADER     ,   Added INDEXED_VERTEX_SHADER flag to  JSn_FEATURES registers." "false,true"

group d:0xC05000F8++0x03
    line.long 0x00 "JS14_FEATURES,   Contains various information of the features of Job Slot 14. "
        bitfld.long 0x00 0. " Res66                     ,Res66" "0,1"
        bitfld.long 0x00 8. "                                             Res67                  ,Res67" "0,1"
        hexmask.long.tbyte 0x00 11.--31. 1. "                                             Res68                ,Res68"
        bitfld.long 0x00 1. "                                        NULL                      ,NULL" "false,true"
        textline "                                     "
        bitfld.long 0x00 2. "WRITE_VALUE               ,   Corrected two references to Set value job. " "false,true"
        bitfld.long 0x00 3. "                                         CACHE_FLUSH            ,CACHE_FLUSH" "false,true"
        bitfld.long 0x00 4. "                                         COMPUTE_SHADER       ,COMPUTE_SHADER" "false,true"
        bitfld.long 0x00 5. "                                         VERTEX_SHADER             ,VERTEX_SHADER" "false,true"
        textline "                                     "
        bitfld.long 0x00 6. "GEOMETRY_SHADER           ,GEOMETRY_SHADER" "false,true"
        bitfld.long 0x00 7. "                                         TILER                  ,TILER" "false,true"
        bitfld.long 0x00 9. "                                         FRAGMENT_SHADER      ,FRAGMENT_SHADER" "false,true"
        bitfld.long 0x00 10. "                                         INDEXED_VERTEX_SHADER     ,   Added INDEXED_VERTEX_SHADER flag to  JSn_FEATURES registers." "false,true"

group d:0xC05000FC++0x03
    line.long 0x00 "JS15_FEATURES,   Contains various information of the features of Job Slot 15. "
        bitfld.long 0x00 0. " Res69                     ,Res69" "0,1"
        bitfld.long 0x00 8. "                                             Res70                  ,Res70" "0,1"
        hexmask.long.tbyte 0x00 11.--31. 1. "                                             Res71                ,Res71"
        bitfld.long 0x00 1. "                                        NULL                      ,NULL" "false,true"
        textline "                                     "
        bitfld.long 0x00 2. "WRITE_VALUE               ,   Corrected two references to Set value job. " "false,true"
        bitfld.long 0x00 3. "                                         CACHE_FLUSH            ,CACHE_FLUSH" "false,true"
        bitfld.long 0x00 4. "                                         COMPUTE_SHADER       ,COMPUTE_SHADER" "false,true"
        bitfld.long 0x00 5. "                                         VERTEX_SHADER             ,VERTEX_SHADER" "false,true"
        textline "                                     "
        bitfld.long 0x00 6. "GEOMETRY_SHADER           ,GEOMETRY_SHADER" "false,true"
        bitfld.long 0x00 7. "                                         TILER                  ,TILER" "false,true"
        bitfld.long 0x00 9. "                                         FRAGMENT_SHADER      ,FRAGMENT_SHADER" "false,true"
        bitfld.long 0x00 10. "                                         INDEXED_VERTEX_SHADER     ,   Added INDEXED_VERTEX_SHADER flag to  JSn_FEATURES registers." "false,true"

group d:0xC0500100++0x03
    line.long 0x00 "SHADER_PRESENT_LO,SHADER_PRESENT_LO"
        hexmask.long 0x00 0.--31. 1. " SHADER_PRESENT_LO         ,   Indicates which shader cores are actually available in the hardware. "

group d:0xC0500104++0x03
    line.long 0x00 "SHADER_PRESENT_HI,SHADER_PRESENT_HI"
        hexmask.long 0x00 0.--31. 1. " SHADER_PRESENT_HI         ,   Indicates which shader cores are actually available in the hardware. "

group d:0xC0500110++0x03
    line.long 0x00 "TILER_PRESENT_LO,TILER_PRESENT_LO"
        hexmask.long 0x00 0.--31. 1. " TILER_PRESENT_LO          ,   Indicates which tilers are actually available in the hardware. "

group d:0xC0500114++0x03
    line.long 0x00 "TILER_PRESENT_HI,TILER_PRESENT_HI"
        hexmask.long 0x00 0.--31. 1. " TILER_PRESENT_HI          ,   Indicates which tilers are actually available in the hardware. "

group d:0xC0500120++0x03
    line.long 0x00 "L2_PRESENT_LO,L2_PRESENT_LO"
        hexmask.long 0x00 0.--31. 1. " L2_PRESENT_LO             ,   Indicates which Level 2 caches are actually available in the hardware.  Where a number of shader cores share a L2 cache instance, the L2 cache instance is reported on the lowest-numbered core. "

group d:0xC0500124++0x03
    line.long 0x00 "L2_PRESENT_HI,L2_PRESENT_HI"
        hexmask.long 0x00 0.--31. 1. " L2_PRESENT_HI             ,   Indicates which Level 2 caches are actually available in the hardware.  Where a number of shader cores share a L2 cache instance, the L2 cache instance is reported on the lowest-numbered core. "

group d:0xC0500140++0x03
    line.long 0x00 "SHADER_READY_LO,SHADER_READY_LO"
        hexmask.long 0x00 0.--31. 1. " SHADER_READY_LO           ,   Indicates which shader cores are powered up and ready. "

group d:0xC0500144++0x03
    line.long 0x00 "SHADER_READY_HI,SHADER_READY_HI"
        hexmask.long 0x00 0.--31. 1. " SHADER_READY_HI           ,   Indicates which shader cores are powered up and ready. "

group d:0xC0500150++0x03
    line.long 0x00 "TILER_READY_LO,TILER_READY_LO"
        hexmask.long 0x00 0.--31. 1. " TILER_READY_LO            ,   Indicates which tiler units are powered up and ready. "

group d:0xC0500154++0x03
    line.long 0x00 "TILER_READY_HI,TILER_READY_HI"
        hexmask.long 0x00 0.--31. 1. " TILER_READY_HI            ,   Indicates which tiler units are powered up and ready. "

group d:0xC0500160++0x03
    line.long 0x00 "L2_READY_LO,L2_READY_LO"
        hexmask.long 0x00 0.--31. 1. " L2_READY_LO               ,   Indicates which level 2 caches are powered up and ready. "

group d:0xC0500164++0x03
    line.long 0x00 "L2_READY_HI,L2_READY_HI"
        hexmask.long 0x00 0.--31. 1. " L2_READY_HI               ,   Indicates which level 2 caches are powered up and ready. "

group d:0xC0500180++0x03
    line.long 0x00 "SHADER_PWRON_LO,SHADER_PWRON_LO"
        hexmask.long 0x00 0.--31. 1. " SHADER_PWRON_LO           ,   Requests that shader cores are to be powered on. This register should only be written when all previous power transitions have been completed, otherwise results are  UNDEFINED ."

group d:0xC0500184++0x03
    line.long 0x00 "SHADER_PWRON_HI,SHADER_PWRON_HI"
        hexmask.long 0x00 0.--31. 1. " SHADER_PWRON_HI           ,   Requests that shader cores are to be powered on. This register should only be written when all previous power transitions have been completed, otherwise results are  UNDEFINED ."

group d:0xC0500190++0x03
    line.long 0x00 "TILER_PWRON_LO,TILER_PWRON_LO"
        hexmask.long 0x00 0.--31. 1. " TILER_PWRON_LO            ,   Requests that tiler units are to be powered on. This register should only be written when all previous power transitions have been completed, otherwise results are  UNDEFINED ."

group d:0xC0500194++0x03
    line.long 0x00 "TILER_PWRON_HI,TILER_PWRON_HI"
        hexmask.long 0x00 0.--31. 1. " TILER_PWRON_HI            ,   Requests that tiler units are to be powered on. This register should only be written when all previous power transitions have been completed, otherwise results are  UNDEFINED ."

group d:0xC05001A0++0x03
    line.long 0x00 "L2_PWRON_LO,L2_PWRON_LO"
        hexmask.long 0x00 0.--31. 1. " L2_PWRON_LO               ,   Requests that level 2 caches are to be powered on. This register should only be written when all previous power transitions have been completed, otherwise results are  UNDEFINED ."

group d:0xC05001A4++0x03
    line.long 0x00 "L2_PWRON_HI,L2_PWRON_HI"
        hexmask.long 0x00 0.--31. 1. " L2_PWRON_HI               ,   Requests that level 2 caches are to be powered on. This register should only be written when all previous power transitions have been completed, otherwise results are  UNDEFINED ."

group d:0xC05001C0++0x03
    line.long 0x00 "SHADER_PWROFF_LO,SHADER_PWROFF_LO"
        hexmask.long 0x00 0.--31. 1. " SHADER_PWROFF_LO          ,   Requests that shader cores are to be powered off. This register should only be written when all previous power transitions have been completed, otherwise results are  UNDEFINED . Power domains may contain multiple cores. In this case, a power domain must not be powered off until all cores within that domain are marked as powered off.        A core will therefore never be powered off 'implicitly' by powering down another core, but it may be kept powered if it shares a power domain with another active core.        It is therefore necessary to know the relationship between cores and power domains to determine the most appropriate set of cores to power down.  The relationship of cores to power domains is implementation dependent.         It often depends not only on the GPU model, but also on the details of system integration, and may vary across different system designs from the same vendor.        Please refer to implementation notes for your system to determine the mapping of cores to power domains.  Clarified power-off behavior for multi-core power domains. "

group d:0xC05001C4++0x03
    line.long 0x00 "SHADER_PWROFF_HI,SHADER_PWROFF_HI"
        hexmask.long 0x00 0.--31. 1. " SHADER_PWROFF_HI          ,   Requests that shader cores are to be powered off. This register should only be written when all previous power transitions have been completed, otherwise results are  UNDEFINED . Power domains may contain multiple cores. In this case, a power domain must not be powered off until all cores within that domain are marked as powered off.        A core will therefore never be powered off 'implicitly' by powering down another core, but it may be kept powered if it shares a power domain with another active core.        It is therefore necessary to know the relationship between cores and power domains to determine the most appropriate set of cores to power down.  The relationship of cores to power domains is implementation dependent.         It often depends not only on the GPU model, but also on the details of system integration, and may vary across different system designs from the same vendor.        Please refer to implementation notes for your system to determine the mapping of cores to power domains.  Clarified power-off behavior for multi-core power domains. "

group d:0xC05001D0++0x03
    line.long 0x00 "TILER_PWROFF_LO,TILER_PWROFF_LO"
        hexmask.long 0x00 0.--31. 1. " TILER_PWROFF_LO           ,   Requests that tiler units are to be powered off. This register should only be written when all previous power transitions have been completed, otherwise results are  UNDEFINED ."

group d:0xC05001D4++0x03
    line.long 0x00 "TILER_PWROFF_HI,TILER_PWROFF_HI"
        hexmask.long 0x00 0.--31. 1. " TILER_PWROFF_HI           ,   Requests that tiler units are to be powered off. This register should only be written when all previous power transitions have been completed, otherwise results are  UNDEFINED ."

group d:0xC05001E0++0x03
    line.long 0x00 "L2_PWROFF_LO,L2_PWROFF_LO"
        hexmask.long 0x00 0.--31. 1. " L2_PWROFF_LO              ,   Requests that level 2 caches are to be powered off. This register should only be written when all previous power transitions have been completed, otherwise results are  UNDEFINED ."

group d:0xC05001E4++0x03
    line.long 0x00 "L2_PWROFF_HI,L2_PWROFF_HI"
        hexmask.long 0x00 0.--31. 1. " L2_PWROFF_HI              ,   Requests that level 2 caches are to be powered off. This register should only be written when all previous power transitions have been completed, otherwise results are  UNDEFINED ."

group d:0xC0500200++0x03
    line.long 0x00 "SHADER_PWRTRANS_LO,SHADER_PWRTRANS_LO"
        hexmask.long 0x00 0.--31. 1. " SHADER_PWRTRANS_LO        ,   Indicates which shader cores are currently changing power state. "

group d:0xC0500204++0x03
    line.long 0x00 "SHADER_PWRTRANS_HI,SHADER_PWRTRANS_HI"
        hexmask.long 0x00 0.--31. 1. " SHADER_PWRTRANS_HI        ,   Indicates which shader cores are currently changing power state. "

group d:0xC0500210++0x03
    line.long 0x00 "TILER_PWRTRANS_LO,TILER_PWRTRANS_LO"
        hexmask.long 0x00 0.--31. 1. " TILER_PWRTRANS_LO         ,   Indicates which tiler units are currently changing power state. "

group d:0xC0500214++0x03
    line.long 0x00 "TILER_PWRTRANS_HI,TILER_PWRTRANS_HI"
        hexmask.long 0x00 0.--31. 1. " TILER_PWRTRANS_HI         ,   Indicates which tiler units are currently changing power state. "

group d:0xC0500220++0x03
    line.long 0x00 "L2_PWRTRANS_LO,L2_PWRTRANS_LO"
        hexmask.long 0x00 0.--31. 1. " L2_PWRTRANS_LO            ,   Indicates which level 2 caches are currently changing power state. "

group d:0xC0500224++0x03
    line.long 0x00 "L2_PWRTRANS_HI,L2_PWRTRANS_HI"
        hexmask.long 0x00 0.--31. 1. " L2_PWRTRANS_HI            ,   Indicates which level 2 caches are currently changing power state. "

group d:0xC0500240++0x03
    line.long 0x00 "SHADER_PWRACTIVE_LO,SHADER_PWRACTIVE_LO"
        hexmask.long 0x00 0.--31. 1. " SHADER_PWRACTIVE_LO       ,   Indicates which shader cores are currently active and processing data. "

group d:0xC0500244++0x03
    line.long 0x00 "SHADER_PWRACTIVE_HI,SHADER_PWRACTIVE_HI"
        hexmask.long 0x00 0.--31. 1. " SHADER_PWRACTIVE_HI       ,   Indicates which shader cores are currently active and processing data. "

group d:0xC0500250++0x03
    line.long 0x00 "TILER_PWRACTIVE_LO,TILER_PWRACTIVE_LO"
        hexmask.long 0x00 0.--31. 1. " TILER_PWRACTIVE_LO        ,   Indicates which tiler units are currently active and processing data. "

group d:0xC0500254++0x03
    line.long 0x00 "TILER_PWRACTIVE_HI,TILER_PWRACTIVE_HI"
        hexmask.long 0x00 0.--31. 1. " TILER_PWRACTIVE_HI        ,   Indicates which tiler units are currently active and processing data. "

group d:0xC0500260++0x03
    line.long 0x00 "L2_PWRACTIVE_LO,L2_PWRACTIVE_LO"
        hexmask.long 0x00 0.--31. 1. " L2_PWRACTIVE_LO           ,   Indicates which level 2 cache units are currently active and processing data. "

group d:0xC0500264++0x03
    line.long 0x00 "L2_PWRACTIVE_HI,L2_PWRACTIVE_HI"
        hexmask.long 0x00 0.--31. 1. " L2_PWRACTIVE_HI           ,   Indicates which level 2 cache units are currently active and processing data. "

group d:0xC0500300++0x03
    line.long 0x00 "COHERENCY_FEATURES,   The Bifrost GPUs may support multiple coherency protocols. This register contains one boolean value for each protocol supported. At least one coherency protocol must be supported.  Changed for MIDHARC-184 "
        hexmask.long 0x00 2.--30. 1. " Res72                     ,Res72"
        bitfld.long 0x00 31. "                                      no_coherency           ,   This bit is reserved to give a guaranteed zero that can be used to disable coherency.  Reserved a bit for 'no coherency' protocol in COHERENCY_FEATURES. " "0,1"
        bitfld.long 0x00 0. "                                             ACE_LITE             ,ACE_LITE" "false,true"
        bitfld.long 0x00 1. "                                         ACE                       ,ACE" "false,true"

group d:0xC0500304++0x03
    line.long 0x00 "COHERENCY_ENABLE,   This register contains an index indicating which coherency protocol should be enabled. The index values correspond to the bit numbers in the  COHERENCY_FEATURES register. At least one coherency protocol must be supported. If the indexed bit is 0, then coherency is disabled. The  no_coherency bit is reserved to give a guaranteed zero that can always be used to disable coherency. Changed for MIDHARC-184  Added behavior for 'no coherency' protocol in COHERENCY_ENABLE. "
        hexmask.long 0x00 0.--31. 1. " L2_CACHE_PROTOCOL_SELECT  ,L2_CACHE_PROTOCOL_SELECT"

group d:0xC0500400++0x03
    line.long 0x00 "GPU_USER_IN_0,   The Bifrost GPUs all allow vendors to specify up to 1024 user input signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_IN signals are connected to the GPU_USER_IN  n registers. The signals and registers are numbered consecutively from zero, and signal USER_IN[i] will appear at bit position [i % 32] in register GPU_USER_IN[i/32]."
        hexmask.long 0x00 0.--31. 1. " GPU_USER_IN_0             ,GPU_USER_IN_0"

group d:0xC0500404++0x03
    line.long 0x00 "GPU_USER_IN_1,   The Bifrost GPUs all allow vendors to specify up to 1024 user input signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_IN signals are connected to the GPU_USER_IN  n registers. The signals and registers are numbered consecutively from zero, and signal USER_IN[i] will appear at bit position [i % 32] in register GPU_USER_IN[i/32]."
        hexmask.long 0x00 0.--31. 1. " GPU_USER_IN_1             ,GPU_USER_IN_1"

group d:0xC0500408++0x03
    line.long 0x00 "GPU_USER_IN_2,   The Bifrost GPUs all allow vendors to specify up to 1024 user input signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_IN signals are connected to the GPU_USER_IN  n registers. The signals and registers are numbered consecutively from zero, and signal USER_IN[i] will appear at bit position [i % 32] in register GPU_USER_IN[i/32]."
        hexmask.long 0x00 0.--31. 1. " GPU_USER_IN_2             ,GPU_USER_IN_2"

group d:0xC050040C++0x03
    line.long 0x00 "GPU_USER_IN_3,   The Bifrost GPUs all allow vendors to specify up to 1024 user input signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_IN signals are connected to the GPU_USER_IN  n registers. The signals and registers are numbered consecutively from zero, and signal USER_IN[i] will appear at bit position [i % 32] in register GPU_USER_IN[i/32]."
        hexmask.long 0x00 0.--31. 1. " GPU_USER_IN_3             ,GPU_USER_IN_3"

group d:0xC0500410++0x03
    line.long 0x00 "GPU_USER_IN_4,   The Bifrost GPUs all allow vendors to specify up to 1024 user input signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_IN signals are connected to the GPU_USER_IN  n registers. The signals and registers are numbered consecutively from zero, and signal USER_IN[i] will appear at bit position [i % 32] in register GPU_USER_IN[i/32]."
        hexmask.long 0x00 0.--31. 1. " GPU_USER_IN_4             ,GPU_USER_IN_4"

group d:0xC0500414++0x03
    line.long 0x00 "GPU_USER_IN_5,   The Bifrost GPUs all allow vendors to specify up to 1024 user input signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_IN signals are connected to the GPU_USER_IN  n registers. The signals and registers are numbered consecutively from zero, and signal USER_IN[i] will appear at bit position [i % 32] in register GPU_USER_IN[i/32]."
        hexmask.long 0x00 0.--31. 1. " GPU_USER_IN_5             ,GPU_USER_IN_5"

group d:0xC0500418++0x03
    line.long 0x00 "GPU_USER_IN_6,   The Bifrost GPUs all allow vendors to specify up to 1024 user input signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_IN signals are connected to the GPU_USER_IN  n registers. The signals and registers are numbered consecutively from zero, and signal USER_IN[i] will appear at bit position [i % 32] in register GPU_USER_IN[i/32]."
        hexmask.long 0x00 0.--31. 1. " GPU_USER_IN_6             ,GPU_USER_IN_6"

group d:0xC050041C++0x03
    line.long 0x00 "GPU_USER_IN_7,   The Bifrost GPUs all allow vendors to specify up to 1024 user input signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_IN signals are connected to the GPU_USER_IN  n registers. The signals and registers are numbered consecutively from zero, and signal USER_IN[i] will appear at bit position [i % 32] in register GPU_USER_IN[i/32]."
        hexmask.long 0x00 0.--31. 1. " GPU_USER_IN_7             ,GPU_USER_IN_7"

group d:0xC0500420++0x03
    line.long 0x00 "GPU_USER_IN_8,   The Bifrost GPUs all allow vendors to specify up to 1024 user input signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_IN signals are connected to the GPU_USER_IN  n registers. The signals and registers are numbered consecutively from zero, and signal USER_IN[i] will appear at bit position [i % 32] in register GPU_USER_IN[i/32]."
        hexmask.long 0x00 0.--31. 1. " GPU_USER_IN_8             ,GPU_USER_IN_8"

group d:0xC0500424++0x03
    line.long 0x00 "GPU_USER_IN_9,   The Bifrost GPUs all allow vendors to specify up to 1024 user input signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_IN signals are connected to the GPU_USER_IN  n registers. The signals and registers are numbered consecutively from zero, and signal USER_IN[i] will appear at bit position [i % 32] in register GPU_USER_IN[i/32]."
        hexmask.long 0x00 0.--31. 1. " GPU_USER_IN_9             ,GPU_USER_IN_9"

group d:0xC0500428++0x03
    line.long 0x00 "GPU_USER_IN_10,   The Bifrost GPUs all allow vendors to specify up to 1024 user input signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_IN signals are connected to the GPU_USER_IN  n registers. The signals and registers are numbered consecutively from zero, and signal USER_IN[i] will appear at bit position [i % 32] in register GPU_USER_IN[i/32]."
        hexmask.long 0x00 0.--31. 1. " GPU_USER_IN_10            ,GPU_USER_IN_10"

group d:0xC050042C++0x03
    line.long 0x00 "GPU_USER_IN_11,   The Bifrost GPUs all allow vendors to specify up to 1024 user input signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_IN signals are connected to the GPU_USER_IN  n registers. The signals and registers are numbered consecutively from zero, and signal USER_IN[i] will appear at bit position [i % 32] in register GPU_USER_IN[i/32]."
        hexmask.long 0x00 0.--31. 1. " GPU_USER_IN_11            ,GPU_USER_IN_11"

group d:0xC0500430++0x03
    line.long 0x00 "GPU_USER_IN_12,   The Bifrost GPUs all allow vendors to specify up to 1024 user input signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_IN signals are connected to the GPU_USER_IN  n registers. The signals and registers are numbered consecutively from zero, and signal USER_IN[i] will appear at bit position [i % 32] in register GPU_USER_IN[i/32]."
        hexmask.long 0x00 0.--31. 1. " GPU_USER_IN_12            ,GPU_USER_IN_12"

group d:0xC0500434++0x03
    line.long 0x00 "GPU_USER_IN_13,   The Bifrost GPUs all allow vendors to specify up to 1024 user input signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_IN signals are connected to the GPU_USER_IN  n registers. The signals and registers are numbered consecutively from zero, and signal USER_IN[i] will appear at bit position [i % 32] in register GPU_USER_IN[i/32]."
        hexmask.long 0x00 0.--31. 1. " GPU_USER_IN_13            ,GPU_USER_IN_13"

group d:0xC0500438++0x03
    line.long 0x00 "GPU_USER_IN_14,   The Bifrost GPUs all allow vendors to specify up to 1024 user input signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_IN signals are connected to the GPU_USER_IN  n registers. The signals and registers are numbered consecutively from zero, and signal USER_IN[i] will appear at bit position [i % 32] in register GPU_USER_IN[i/32]."
        hexmask.long 0x00 0.--31. 1. " GPU_USER_IN_14            ,GPU_USER_IN_14"

group d:0xC050043C++0x03
    line.long 0x00 "GPU_USER_IN_15,   The Bifrost GPUs all allow vendors to specify up to 1024 user input signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_IN signals are connected to the GPU_USER_IN  n registers. The signals and registers are numbered consecutively from zero, and signal USER_IN[i] will appear at bit position [i % 32] in register GPU_USER_IN[i/32]."
        hexmask.long 0x00 0.--31. 1. " GPU_USER_IN_15            ,GPU_USER_IN_15"

group d:0xC0500440++0x03
    line.long 0x00 "GPU_USER_IN_16,   The Bifrost GPUs all allow vendors to specify up to 1024 user input signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_IN signals are connected to the GPU_USER_IN  n registers. The signals and registers are numbered consecutively from zero, and signal USER_IN[i] will appear at bit position [i % 32] in register GPU_USER_IN[i/32]."
        hexmask.long 0x00 0.--31. 1. " GPU_USER_IN_16            ,GPU_USER_IN_16"

group d:0xC0500444++0x03
    line.long 0x00 "GPU_USER_IN_17,   The Bifrost GPUs all allow vendors to specify up to 1024 user input signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_IN signals are connected to the GPU_USER_IN  n registers. The signals and registers are numbered consecutively from zero, and signal USER_IN[i] will appear at bit position [i % 32] in register GPU_USER_IN[i/32]."
        hexmask.long 0x00 0.--31. 1. " GPU_USER_IN_17            ,GPU_USER_IN_17"

group d:0xC0500448++0x03
    line.long 0x00 "GPU_USER_IN_18,   The Bifrost GPUs all allow vendors to specify up to 1024 user input signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_IN signals are connected to the GPU_USER_IN  n registers. The signals and registers are numbered consecutively from zero, and signal USER_IN[i] will appear at bit position [i % 32] in register GPU_USER_IN[i/32]."
        hexmask.long 0x00 0.--31. 1. " GPU_USER_IN_18            ,GPU_USER_IN_18"

group d:0xC050044C++0x03
    line.long 0x00 "GPU_USER_IN_19,   The Bifrost GPUs all allow vendors to specify up to 1024 user input signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_IN signals are connected to the GPU_USER_IN  n registers. The signals and registers are numbered consecutively from zero, and signal USER_IN[i] will appear at bit position [i % 32] in register GPU_USER_IN[i/32]."
        hexmask.long 0x00 0.--31. 1. " GPU_USER_IN_19            ,GPU_USER_IN_19"

group d:0xC0500450++0x03
    line.long 0x00 "GPU_USER_IN_20,   The Bifrost GPUs all allow vendors to specify up to 1024 user input signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_IN signals are connected to the GPU_USER_IN  n registers. The signals and registers are numbered consecutively from zero, and signal USER_IN[i] will appear at bit position [i % 32] in register GPU_USER_IN[i/32]."
        hexmask.long 0x00 0.--31. 1. " GPU_USER_IN_20            ,GPU_USER_IN_20"

group d:0xC0500454++0x03
    line.long 0x00 "GPU_USER_IN_21,   The Bifrost GPUs all allow vendors to specify up to 1024 user input signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_IN signals are connected to the GPU_USER_IN  n registers. The signals and registers are numbered consecutively from zero, and signal USER_IN[i] will appear at bit position [i % 32] in register GPU_USER_IN[i/32]."
        hexmask.long 0x00 0.--31. 1. " GPU_USER_IN_21            ,GPU_USER_IN_21"

group d:0xC0500458++0x03
    line.long 0x00 "GPU_USER_IN_22,   The Bifrost GPUs all allow vendors to specify up to 1024 user input signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_IN signals are connected to the GPU_USER_IN  n registers. The signals and registers are numbered consecutively from zero, and signal USER_IN[i] will appear at bit position [i % 32] in register GPU_USER_IN[i/32]."
        hexmask.long 0x00 0.--31. 1. " GPU_USER_IN_22            ,GPU_USER_IN_22"

group d:0xC050045C++0x03
    line.long 0x00 "GPU_USER_IN_23,   The Bifrost GPUs all allow vendors to specify up to 1024 user input signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_IN signals are connected to the GPU_USER_IN  n registers. The signals and registers are numbered consecutively from zero, and signal USER_IN[i] will appear at bit position [i % 32] in register GPU_USER_IN[i/32]."
        hexmask.long 0x00 0.--31. 1. " GPU_USER_IN_23            ,GPU_USER_IN_23"

group d:0xC0500460++0x03
    line.long 0x00 "GPU_USER_IN_24,   The Bifrost GPUs all allow vendors to specify up to 1024 user input signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_IN signals are connected to the GPU_USER_IN  n registers. The signals and registers are numbered consecutively from zero, and signal USER_IN[i] will appear at bit position [i % 32] in register GPU_USER_IN[i/32]."
        hexmask.long 0x00 0.--31. 1. " GPU_USER_IN_24            ,GPU_USER_IN_24"

group d:0xC0500464++0x03
    line.long 0x00 "GPU_USER_IN_25,   The Bifrost GPUs all allow vendors to specify up to 1024 user input signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_IN signals are connected to the GPU_USER_IN  n registers. The signals and registers are numbered consecutively from zero, and signal USER_IN[i] will appear at bit position [i % 32] in register GPU_USER_IN[i/32]."
        hexmask.long 0x00 0.--31. 1. " GPU_USER_IN_25            ,GPU_USER_IN_25"

group d:0xC0500468++0x03
    line.long 0x00 "GPU_USER_IN_26,   The Bifrost GPUs all allow vendors to specify up to 1024 user input signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_IN signals are connected to the GPU_USER_IN  n registers. The signals and registers are numbered consecutively from zero, and signal USER_IN[i] will appear at bit position [i % 32] in register GPU_USER_IN[i/32]."
        hexmask.long 0x00 0.--31. 1. " GPU_USER_IN_26            ,GPU_USER_IN_26"

group d:0xC050046C++0x03
    line.long 0x00 "GPU_USER_IN_27,   The Bifrost GPUs all allow vendors to specify up to 1024 user input signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_IN signals are connected to the GPU_USER_IN  n registers. The signals and registers are numbered consecutively from zero, and signal USER_IN[i] will appear at bit position [i % 32] in register GPU_USER_IN[i/32]."
        hexmask.long 0x00 0.--31. 1. " GPU_USER_IN_27            ,GPU_USER_IN_27"

group d:0xC0500470++0x03
    line.long 0x00 "GPU_USER_IN_28,   The Bifrost GPUs all allow vendors to specify up to 1024 user input signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_IN signals are connected to the GPU_USER_IN  n registers. The signals and registers are numbered consecutively from zero, and signal USER_IN[i] will appear at bit position [i % 32] in register GPU_USER_IN[i/32]."
        hexmask.long 0x00 0.--31. 1. " GPU_USER_IN_28            ,GPU_USER_IN_28"

group d:0xC0500474++0x03
    line.long 0x00 "GPU_USER_IN_29,   The Bifrost GPUs all allow vendors to specify up to 1024 user input signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_IN signals are connected to the GPU_USER_IN  n registers. The signals and registers are numbered consecutively from zero, and signal USER_IN[i] will appear at bit position [i % 32] in register GPU_USER_IN[i/32]."
        hexmask.long 0x00 0.--31. 1. " GPU_USER_IN_29            ,GPU_USER_IN_29"

group d:0xC0500478++0x03
    line.long 0x00 "GPU_USER_IN_30,   The Bifrost GPUs all allow vendors to specify up to 1024 user input signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_IN signals are connected to the GPU_USER_IN  n registers. The signals and registers are numbered consecutively from zero, and signal USER_IN[i] will appear at bit position [i % 32] in register GPU_USER_IN[i/32]."
        hexmask.long 0x00 0.--31. 1. " GPU_USER_IN_30            ,GPU_USER_IN_30"

group d:0xC050047C++0x03
    line.long 0x00 "GPU_USER_IN_31,   The Bifrost GPUs all allow vendors to specify up to 1024 user input signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_IN signals are connected to the GPU_USER_IN  n registers. The signals and registers are numbered consecutively from zero, and signal USER_IN[i] will appear at bit position [i % 32] in register GPU_USER_IN[i/32]."
        hexmask.long 0x00 0.--31. 1. " GPU_USER_IN_31            ,GPU_USER_IN_31"

group d:0xC0500500++0x03
    line.long 0x00 "GPU_USER_OUT_0,   The Bifrost GPUs all allow vendors to specify up to 1024 user output signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_OUT signals are connected to the GPU_USER_OUT  n registers. The signals and registers are numbered consecutively from zero, and signal USER_OUT[i] will appear at bit position [i % 32] in register GPU_USER_OUT[i/32]."
        hexmask.long 0x00 0.--31. 1. " GPU_USER_OUT_0            ,GPU_USER_OUT_0"

group d:0xC0500504++0x03
    line.long 0x00 "GPU_USER_OUT_1,   The Bifrost GPUs all allow vendors to specify up to 1024 user output signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_OUT signals are connected to the GPU_USER_OUT  n registers. The signals and registers are numbered consecutively from zero, and signal USER_OUT[i] will appear at bit position [i % 32] in register GPU_USER_OUT[i/32]."
        hexmask.long 0x00 0.--31. 1. " GPU_USER_OUT_1            ,GPU_USER_OUT_1"

group d:0xC0500508++0x03
    line.long 0x00 "GPU_USER_OUT_2,   The Bifrost GPUs all allow vendors to specify up to 1024 user output signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_OUT signals are connected to the GPU_USER_OUT  n registers. The signals and registers are numbered consecutively from zero, and signal USER_OUT[i] will appear at bit position [i % 32] in register GPU_USER_OUT[i/32]."
        hexmask.long 0x00 0.--31. 1. " GPU_USER_OUT_2            ,GPU_USER_OUT_2"

group d:0xC050050C++0x03
    line.long 0x00 "GPU_USER_OUT_3,   The Bifrost GPUs all allow vendors to specify up to 1024 user output signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_OUT signals are connected to the GPU_USER_OUT  n registers. The signals and registers are numbered consecutively from zero, and signal USER_OUT[i] will appear at bit position [i % 32] in register GPU_USER_OUT[i/32]."
        hexmask.long 0x00 0.--31. 1. " GPU_USER_OUT_3            ,GPU_USER_OUT_3"

group d:0xC0500510++0x03
    line.long 0x00 "GPU_USER_OUT_4,   The Bifrost GPUs all allow vendors to specify up to 1024 user output signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_OUT signals are connected to the GPU_USER_OUT  n registers. The signals and registers are numbered consecutively from zero, and signal USER_OUT[i] will appear at bit position [i % 32] in register GPU_USER_OUT[i/32]."
        hexmask.long 0x00 0.--31. 1. " GPU_USER_OUT_4            ,GPU_USER_OUT_4"

group d:0xC0500514++0x03
    line.long 0x00 "GPU_USER_OUT_5,   The Bifrost GPUs all allow vendors to specify up to 1024 user output signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_OUT signals are connected to the GPU_USER_OUT  n registers. The signals and registers are numbered consecutively from zero, and signal USER_OUT[i] will appear at bit position [i % 32] in register GPU_USER_OUT[i/32]."
        hexmask.long 0x00 0.--31. 1. " GPU_USER_OUT_5            ,GPU_USER_OUT_5"

group d:0xC0500518++0x03
    line.long 0x00 "GPU_USER_OUT_6,   The Bifrost GPUs all allow vendors to specify up to 1024 user output signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_OUT signals are connected to the GPU_USER_OUT  n registers. The signals and registers are numbered consecutively from zero, and signal USER_OUT[i] will appear at bit position [i % 32] in register GPU_USER_OUT[i/32]."
        hexmask.long 0x00 0.--31. 1. " GPU_USER_OUT_6            ,GPU_USER_OUT_6"

group d:0xC050051C++0x03
    line.long 0x00 "GPU_USER_OUT_7,   The Bifrost GPUs all allow vendors to specify up to 1024 user output signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_OUT signals are connected to the GPU_USER_OUT  n registers. The signals and registers are numbered consecutively from zero, and signal USER_OUT[i] will appear at bit position [i % 32] in register GPU_USER_OUT[i/32]."
        hexmask.long 0x00 0.--31. 1. " GPU_USER_OUT_7            ,GPU_USER_OUT_7"

group d:0xC0500520++0x03
    line.long 0x00 "GPU_USER_OUT_8,   The Bifrost GPUs all allow vendors to specify up to 1024 user output signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_OUT signals are connected to the GPU_USER_OUT  n registers. The signals and registers are numbered consecutively from zero, and signal USER_OUT[i] will appear at bit position [i % 32] in register GPU_USER_OUT[i/32]."
        hexmask.long 0x00 0.--31. 1. " GPU_USER_OUT_8            ,GPU_USER_OUT_8"

group d:0xC0500524++0x03
    line.long 0x00 "GPU_USER_OUT_9,   The Bifrost GPUs all allow vendors to specify up to 1024 user output signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_OUT signals are connected to the GPU_USER_OUT  n registers. The signals and registers are numbered consecutively from zero, and signal USER_OUT[i] will appear at bit position [i % 32] in register GPU_USER_OUT[i/32]."
        hexmask.long 0x00 0.--31. 1. " GPU_USER_OUT_9            ,GPU_USER_OUT_9"

group d:0xC0500528++0x03
    line.long 0x00 "GPU_USER_OUT_10,   The Bifrost GPUs all allow vendors to specify up to 1024 user output signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_OUT signals are connected to the GPU_USER_OUT  n registers. The signals and registers are numbered consecutively from zero, and signal USER_OUT[i] will appear at bit position [i % 32] in register GPU_USER_OUT[i/32]."
        hexmask.long 0x00 0.--31. 1. " GPU_USER_OUT_10           ,GPU_USER_OUT_10"

group d:0xC050052C++0x03
    line.long 0x00 "GPU_USER_OUT_11,   The Bifrost GPUs all allow vendors to specify up to 1024 user output signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_OUT signals are connected to the GPU_USER_OUT  n registers. The signals and registers are numbered consecutively from zero, and signal USER_OUT[i] will appear at bit position [i % 32] in register GPU_USER_OUT[i/32]."
        hexmask.long 0x00 0.--31. 1. " GPU_USER_OUT_11           ,GPU_USER_OUT_11"

group d:0xC0500530++0x03
    line.long 0x00 "GPU_USER_OUT_12,   The Bifrost GPUs all allow vendors to specify up to 1024 user output signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_OUT signals are connected to the GPU_USER_OUT  n registers. The signals and registers are numbered consecutively from zero, and signal USER_OUT[i] will appear at bit position [i % 32] in register GPU_USER_OUT[i/32]."
        hexmask.long 0x00 0.--31. 1. " GPU_USER_OUT_12           ,GPU_USER_OUT_12"

group d:0xC0500534++0x03
    line.long 0x00 "GPU_USER_OUT_13,   The Bifrost GPUs all allow vendors to specify up to 1024 user output signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_OUT signals are connected to the GPU_USER_OUT  n registers. The signals and registers are numbered consecutively from zero, and signal USER_OUT[i] will appear at bit position [i % 32] in register GPU_USER_OUT[i/32]."
        hexmask.long 0x00 0.--31. 1. " GPU_USER_OUT_13           ,GPU_USER_OUT_13"

group d:0xC0500538++0x03
    line.long 0x00 "GPU_USER_OUT_14,   The Bifrost GPUs all allow vendors to specify up to 1024 user output signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_OUT signals are connected to the GPU_USER_OUT  n registers. The signals and registers are numbered consecutively from zero, and signal USER_OUT[i] will appear at bit position [i % 32] in register GPU_USER_OUT[i/32]."
        hexmask.long 0x00 0.--31. 1. " GPU_USER_OUT_14           ,GPU_USER_OUT_14"

group d:0xC050053C++0x03
    line.long 0x00 "GPU_USER_OUT_15,   The Bifrost GPUs all allow vendors to specify up to 1024 user output signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_OUT signals are connected to the GPU_USER_OUT  n registers. The signals and registers are numbered consecutively from zero, and signal USER_OUT[i] will appear at bit position [i % 32] in register GPU_USER_OUT[i/32]."
        hexmask.long 0x00 0.--31. 1. " GPU_USER_OUT_15           ,GPU_USER_OUT_15"

group d:0xC0500540++0x03
    line.long 0x00 "GPU_USER_OUT_16,   The Bifrost GPUs all allow vendors to specify up to 1024 user output signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_OUT signals are connected to the GPU_USER_OUT  n registers. The signals and registers are numbered consecutively from zero, and signal USER_OUT[i] will appear at bit position [i % 32] in register GPU_USER_OUT[i/32]."
        hexmask.long 0x00 0.--31. 1. " GPU_USER_OUT_16           ,GPU_USER_OUT_16"

group d:0xC0500544++0x03
    line.long 0x00 "GPU_USER_OUT_17,   The Bifrost GPUs all allow vendors to specify up to 1024 user output signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_OUT signals are connected to the GPU_USER_OUT  n registers. The signals and registers are numbered consecutively from zero, and signal USER_OUT[i] will appear at bit position [i % 32] in register GPU_USER_OUT[i/32]."
        hexmask.long 0x00 0.--31. 1. " GPU_USER_OUT_17           ,GPU_USER_OUT_17"

group d:0xC0500548++0x03
    line.long 0x00 "GPU_USER_OUT_18,   The Bifrost GPUs all allow vendors to specify up to 1024 user output signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_OUT signals are connected to the GPU_USER_OUT  n registers. The signals and registers are numbered consecutively from zero, and signal USER_OUT[i] will appear at bit position [i % 32] in register GPU_USER_OUT[i/32]."
        hexmask.long 0x00 0.--31. 1. " GPU_USER_OUT_18           ,GPU_USER_OUT_18"

group d:0xC050054C++0x03
    line.long 0x00 "GPU_USER_OUT_19,   The Bifrost GPUs all allow vendors to specify up to 1024 user output signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_OUT signals are connected to the GPU_USER_OUT  n registers. The signals and registers are numbered consecutively from zero, and signal USER_OUT[i] will appear at bit position [i % 32] in register GPU_USER_OUT[i/32]."
        hexmask.long 0x00 0.--31. 1. " GPU_USER_OUT_19           ,GPU_USER_OUT_19"

group d:0xC0500550++0x03
    line.long 0x00 "GPU_USER_OUT_20,   The Bifrost GPUs all allow vendors to specify up to 1024 user output signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_OUT signals are connected to the GPU_USER_OUT  n registers. The signals and registers are numbered consecutively from zero, and signal USER_OUT[i] will appear at bit position [i % 32] in register GPU_USER_OUT[i/32]."
        hexmask.long 0x00 0.--31. 1. " GPU_USER_OUT_20           ,GPU_USER_OUT_20"

group d:0xC0500554++0x03
    line.long 0x00 "GPU_USER_OUT_21,   The Bifrost GPUs all allow vendors to specify up to 1024 user output signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_OUT signals are connected to the GPU_USER_OUT  n registers. The signals and registers are numbered consecutively from zero, and signal USER_OUT[i] will appear at bit position [i % 32] in register GPU_USER_OUT[i/32]."
        hexmask.long 0x00 0.--31. 1. " GPU_USER_OUT_21           ,GPU_USER_OUT_21"

group d:0xC0500558++0x03
    line.long 0x00 "GPU_USER_OUT_22,   The Bifrost GPUs all allow vendors to specify up to 1024 user output signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_OUT signals are connected to the GPU_USER_OUT  n registers. The signals and registers are numbered consecutively from zero, and signal USER_OUT[i] will appear at bit position [i % 32] in register GPU_USER_OUT[i/32]."
        hexmask.long 0x00 0.--31. 1. " GPU_USER_OUT_22           ,GPU_USER_OUT_22"

group d:0xC050055C++0x03
    line.long 0x00 "GPU_USER_OUT_23,   The Bifrost GPUs all allow vendors to specify up to 1024 user output signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_OUT signals are connected to the GPU_USER_OUT  n registers. The signals and registers are numbered consecutively from zero, and signal USER_OUT[i] will appear at bit position [i % 32] in register GPU_USER_OUT[i/32]."
        hexmask.long 0x00 0.--31. 1. " GPU_USER_OUT_23           ,GPU_USER_OUT_23"

group d:0xC0500560++0x03
    line.long 0x00 "GPU_USER_OUT_24,   The Bifrost GPUs all allow vendors to specify up to 1024 user output signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_OUT signals are connected to the GPU_USER_OUT  n registers. The signals and registers are numbered consecutively from zero, and signal USER_OUT[i] will appear at bit position [i % 32] in register GPU_USER_OUT[i/32]."
        hexmask.long 0x00 0.--31. 1. " GPU_USER_OUT_24           ,GPU_USER_OUT_24"

group d:0xC0500564++0x03
    line.long 0x00 "GPU_USER_OUT_25,   The Bifrost GPUs all allow vendors to specify up to 1024 user output signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_OUT signals are connected to the GPU_USER_OUT  n registers. The signals and registers are numbered consecutively from zero, and signal USER_OUT[i] will appear at bit position [i % 32] in register GPU_USER_OUT[i/32]."
        hexmask.long 0x00 0.--31. 1. " GPU_USER_OUT_25           ,GPU_USER_OUT_25"

group d:0xC0500568++0x03
    line.long 0x00 "GPU_USER_OUT_26,   The Bifrost GPUs all allow vendors to specify up to 1024 user output signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_OUT signals are connected to the GPU_USER_OUT  n registers. The signals and registers are numbered consecutively from zero, and signal USER_OUT[i] will appear at bit position [i % 32] in register GPU_USER_OUT[i/32]."
        hexmask.long 0x00 0.--31. 1. " GPU_USER_OUT_26           ,GPU_USER_OUT_26"

group d:0xC050056C++0x03
    line.long 0x00 "GPU_USER_OUT_27,   The Bifrost GPUs all allow vendors to specify up to 1024 user output signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_OUT signals are connected to the GPU_USER_OUT  n registers. The signals and registers are numbered consecutively from zero, and signal USER_OUT[i] will appear at bit position [i % 32] in register GPU_USER_OUT[i/32]."
        hexmask.long 0x00 0.--31. 1. " GPU_USER_OUT_27           ,GPU_USER_OUT_27"

group d:0xC0500570++0x03
    line.long 0x00 "GPU_USER_OUT_28,   The Bifrost GPUs all allow vendors to specify up to 1024 user output signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_OUT signals are connected to the GPU_USER_OUT  n registers. The signals and registers are numbered consecutively from zero, and signal USER_OUT[i] will appear at bit position [i % 32] in register GPU_USER_OUT[i/32]."
        hexmask.long 0x00 0.--31. 1. " GPU_USER_OUT_28           ,GPU_USER_OUT_28"

group d:0xC0500574++0x03
    line.long 0x00 "GPU_USER_OUT_29,   The Bifrost GPUs all allow vendors to specify up to 1024 user output signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_OUT signals are connected to the GPU_USER_OUT  n registers. The signals and registers are numbered consecutively from zero, and signal USER_OUT[i] will appear at bit position [i % 32] in register GPU_USER_OUT[i/32]."
        hexmask.long 0x00 0.--31. 1. " GPU_USER_OUT_29           ,GPU_USER_OUT_29"

group d:0xC0500578++0x03
    line.long 0x00 "GPU_USER_OUT_30,   The Bifrost GPUs all allow vendors to specify up to 1024 user output signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_OUT signals are connected to the GPU_USER_OUT  n registers. The signals and registers are numbered consecutively from zero, and signal USER_OUT[i] will appear at bit position [i % 32] in register GPU_USER_OUT[i/32]."
        hexmask.long 0x00 0.--31. 1. " GPU_USER_OUT_30           ,GPU_USER_OUT_30"

group d:0xC050057C++0x03
    line.long 0x00 "GPU_USER_OUT_31,   The Bifrost GPUs all allow vendors to specify up to 1024 user output signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_OUT signals are connected to the GPU_USER_OUT  n registers. The signals and registers are numbered consecutively from zero, and signal USER_OUT[i] will appear at bit position [i % 32] in register GPU_USER_OUT[i/32]."
        hexmask.long 0x00 0.--31. 1. " GPU_USER_OUT_31           ,GPU_USER_OUT_31"

width 19.

group d:0xC0501000++0x03
    line.long 0x00 "JOB_IRQ_RAWSTAT,   This register contains the raw unmasked interrupt status for job management.  Writing a 1 to a bit in this register will force that bit on. Writing a zero to a bit will have no effect. Use the JOB_IRQ_CLEAR register to clear interrupts. Changes to bits corresponding to job slots which are not physically present may be ignored.  See  ExceptionStatus for information on exception types and locations of additional data. JOB_DONE interrupts are generated for any job chain that completes with an exception type that indicates no fault. JOB_FAIL interrupts are generated for all other exception types, including SUSPEND."
        hexmask.long.word 0x00 0.--15. 1. " JOB_DONE         ,JOB_DONE"
        hexmask.long.word 0x00 16.--31. 1. "      JOB_FAIL        ,JOB_FAIL"

group d:0xC0501004++0x03
    line.long 0x00 "JOB_IRQ_CLEAR,   This register has the same layout as JOB_IRQ_RAWSTAT. Write a one to a bit in this register to clear the corresponding bit in JOB_IRQ_RAWSTAT. This also atomically takes a snapshot of the corresponding job slots state in the corresponding bits of JOB_IRQ_JS_STATE. "
        hexmask.long.word 0x00 0.--15. 1. " JOB_DONE         ,JOB_DONE"
        hexmask.long.word 0x00 16.--31. 1. "      JOB_FAIL        ,JOB_FAIL"

group d:0xC0501008++0x03
    line.long 0x00 "JOB_IRQ_MASK,   This register has the same layout as JOB_IRQ_RAWSTAT. Set each bit in this to one to enable the corresponding interrupt source, and to zero to disable it. "
        hexmask.long.word 0x00 0.--15. 1. " JOB_DONE         ,JOB_DONE"
        hexmask.long.word 0x00 16.--31. 1. "      JOB_FAIL        ,JOB_FAIL"

group d:0xC050100C++0x03
    line.long 0x00 "JOB_IRQ_STATUS,   This register has the same layout as JOB_IRQ_RAWSTAT. This register contains the result of anding together JOB_IRQ_RAWSTAT and JOB_IRQ_MASK. If any bits in this register are set, and the JOB_IRQ_THROTTLE counter is zero, then the external job control interrupt line is asserted, signaling an interrupt request to the CPU. "
        hexmask.long.word 0x00 0.--15. 1. " JOB_DONE         ,JOB_DONE"
        hexmask.long.word 0x00 16.--31. 1. "      JOB_FAIL        ,JOB_FAIL"

group d:0xC0501010++0x03
    line.long 0x00 "JOB_IRQ_JS_STATE,   This register contains an instantaneous snapshot of the state of the job chains, and is updated atomically in the same clock cycle as the interrupt flags are cleared (using JOB_IRQ_CLEAR).  If either bit JOB_ACTIVE[n] or JOB_NEXT_ACTIVE[n] is set in the value written to JOB_IRQ_CLEAR, then job slot  n is sampled on the same clock cycle, and both bits JOB_ACTIVE[n] and JOB_NEXT_ACTIVE[n] are updated in this register."
        hexmask.long.word 0x00 0.--15. 1. " JOB_ACTIVE       ,JOB_ACTIVE"
        hexmask.long.word 0x00 16.--31. 1. "      JOB_NEXT_ACTIVE ,JOB_NEXT_ACTIVE"

group d:0xC0501014++0x03
    line.long 0x00 "JOB_IRQ_THROTTLE,   This register is used to suppress Job Done interrupts for a set amount of time. This allows software to throttle the interrupt load that the rest of the system is exposed to. "
        hexmask.long 0x00 0.--31. 1. " JOB_IRQ_THROTTLE ,   Writing a value to the register sets the value of a counter, which continuously counts down at the GPU clock frequency. Reading this register will return the current value of the counter.  While the counter is non-zero, no Job Done interrupts are generated. In this state, the GPU is considered to be active for power management purposes, so that the final interrupt will always be generated correctly, even if the core is being powered down.  The counter stops once it has counted down to zero, and must be reset by the driver. This is commonly done as part of the interrupt service routine. "

group d:0xC0501020++0x03
    line.long 0x00 "EVENT_IRQ_RAWSTAT,   This register contains the raw unmasked interrupt status for job event management.  Writing a 1 to a bit in this register will force that bit on. Writing a zero to a bit will have no effect. Use the EVENT_IRQ_CLEAR register to clear interrupts. Changes to bits corresponding to job slots which are not physically present may be ignored.  This is a separate interrupt from job status interrupts, and is triggered by use of  DOORBELL event-generating instructions in the shaders. Added registers for handling job events and their corresponding interrupts. "
        hexmask.long.word 0x00 16.--31. 1. " Res73            ,Res73"
        hexmask.long.word 0x00 0.--15. 1. "      EVENT_DONE      ,EVENT_DONE"

group d:0xC0501024++0x03
    line.long 0x00 "EVENT_IRQ_CLEAR,   This register has the same layout as EVENT_IRQ_RAWSTAT. Write a one to a bit in this register to clear the corresponding bit in EVENT_IRQ_RAWSTAT. "
        hexmask.long.word 0x00 16.--31. 1. " Res74            ,Res74"
        hexmask.long.word 0x00 0.--15. 1. "      EVENT_DONE      ,EVENT_DONE"

group d:0xC0501028++0x03
    line.long 0x00 "EVENT_IRQ_MASK,   This register has the same layout as EVENT_IRQ_RAWSTAT. Set each bit in this to one to enable the corresponding interrupt source, and to zero to disable it. "
        hexmask.long.word 0x00 16.--31. 1. " Res75            ,Res75"
        hexmask.long.word 0x00 0.--15. 1. "      EVENT_DONE      ,EVENT_DONE"

group d:0xC050102C++0x03
    line.long 0x00 "EVENT_IRQ_STATUS,   This register has the same layout as EVENT_IRQ_RAWSTAT. This register contains the result of anding together EVENT_IRQ_RAWSTAT and EVENT_IRQ_MASK. If any bits in this register are set, and the JOB_IRQ_THROTTLE counter is zero, then the external job control interrupt line is asserted, signaling an interrupt request to the CPU. "
        hexmask.long.word 0x00 16.--31. 1. " Res76            ,Res76"
        hexmask.long.word 0x00 0.--15. 1. "      EVENT_DONE      ,EVENT_DONE"

width 22.

group d:0xC0501800++0x03
    line.long 0x00 "JS0_HEAD_LO,   These registers exist for each supported job slot, with the prefix JS  n . To start a job chain, write the address to the first job descriptor into the JS  n _HEAD_NEXT register and write a START command to the JS n _COMMAND_NEXT register. When read, this register reflects the current position in the job chain. When the Job Manager has finished issuing tasks for a job, it will go on to the next job in the job chain, and update JS  n _HEAD. A job will disappear from JS  n _HEAD before it has finished processing all its tasks. See JS n _TAIL for how to discover this. Jobs newer than JS  n _HEAD may have been prefetched from memory, but will not yet have started processing. After an error, JS  n _HEAD contains the address of the first job (chronologically) that failed. The status registers contain the state of this job. If the GPU is in protected mode, this register will read as zero. "
        hexmask.long 0x00 0.--31. 1. " JS0HEAD_LO             ,   This register contains the address of the current job descriptor. The address is a virtual address in the address space specified by the ADDRESS_SPACE field in the JS  n _CONFIG register."

group d:0xC0501804++0x03
    line.long 0x00 "JS0_HEAD_HI,   These registers exist for each supported job slot, with the prefix JS  n . To start a job chain, write the address to the first job descriptor into the JS  n _HEAD_NEXT register and write a START command to the JS n _COMMAND_NEXT register. When read, this register reflects the current position in the job chain. When the Job Manager has finished issuing tasks for a job, it will go on to the next job in the job chain, and update JS  n _HEAD. A job will disappear from JS  n _HEAD before it has finished processing all its tasks. See JS n _TAIL for how to discover this. Jobs newer than JS  n _HEAD may have been prefetched from memory, but will not yet have started processing. After an error, JS  n _HEAD contains the address of the first job (chronologically) that failed. The status registers contain the state of this job. If the GPU is in protected mode, this register will read as zero. "
        hexmask.long 0x00 0.--31. 1. " JS0HEAD_HI             ,   This register contains the address of the current job descriptor. The address is a virtual address in the address space specified by the ADDRESS_SPACE field in the JS  n _CONFIG register."

group d:0xC0501808++0x03
    line.long 0x00 "JS0_TAIL_LO,   If the GPU is in protected mode, this register will read as zero. "
        hexmask.long 0x00 0.--31. 1. " JS0TAIL_LO             ,   This register contains the address of the oldest job that has finished issuing tasks, but is still running. The address is a virtual address in the address space specified by the ADDRESS_SPACE field in the JS  n _CONFIG register. All the jobs in a job chain from JS  n _TAIL to JS n _HEAD are in some way active in the GPU. Jobs older than JS n _TAIL are fully completed. Note that the value in the JS  n _TAIL register is updated when a new job starts. Therefore, this value is only valid while the JS n _STATUS register has the value ACTIVE. After an error, JS  n _TAIL contains the address of the first job in the chain that is not known to be successfully complete. Other jobs after this point may have completed successfully, but all jobs prior to this point are guaranteed have completed.       In order to simplfy implementation of this feature, the position reported in JS n _TAIL is allowed to be conservative. However, scanning from this point forward in the chain will always be sufficient to identify all failing jobs."

group d:0xC050180C++0x03
    line.long 0x00 "JS0_TAIL_HI,   If the GPU is in protected mode, this register will read as zero. "
        hexmask.long 0x00 0.--31. 1. " JS0TAIL_HI             ,   This register contains the address of the oldest job that has finished issuing tasks, but is still running. The address is a virtual address in the address space specified by the ADDRESS_SPACE field in the JS  n _CONFIG register. All the jobs in a job chain from JS  n _TAIL to JS n _HEAD are in some way active in the GPU. Jobs older than JS n _TAIL are fully completed. Note that the value in the JS  n _TAIL register is updated when a new job starts. Therefore, this value is only valid while the JS n _STATUS register has the value ACTIVE. After an error, JS  n _TAIL contains the address of the first job in the chain that is not known to be successfully complete. Other jobs after this point may have completed successfully, but all jobs prior to this point are guaranteed have completed.       In order to simplfy implementation of this feature, the position reported in JS n _TAIL is allowed to be conservative. However, scanning from this point forward in the chain will always be sufficient to identify all failing jobs."

group d:0xC0501810++0x03
    line.long 0x00 "JS0_AFFINITY_LO,   This register contains the current core affinity mask for this job slot. Only cores covered by the affinity mask are eligible for running tasks on. The mask is anded with the *_READY masks, and the resulting ones are the cores that can be used.  The affinity value is constant over a job chain. If you need to change affinity between jobs, then they must be split into separate job chains.See also JS  n _XAFFINITY"
        hexmask.long 0x00 0.--31. 1. " JS0AFFINITY_LO         ,JS0AFFINITY_LO"

group d:0xC0501814++0x03
    line.long 0x00 "JS0_AFFINITY_HI,   This register contains the current core affinity mask for this job slot. Only cores covered by the affinity mask are eligible for running tasks on. The mask is anded with the *_READY masks, and the resulting ones are the cores that can be used.  The affinity value is constant over a job chain. If you need to change affinity between jobs, then they must be split into separate job chains.See also JS  n _XAFFINITY"
        hexmask.long 0x00 0.--31. 1. " JS0AFFINITY_HI         ,JS0AFFINITY_HI"

group d:0xC0501818++0x03
    line.long 0x00 "JS0_CONFIG,   The job slot configuration register contains various configuration options for the jobs running in this job slot. "
        bitfld.long 0x00 4.--7. " Res77                  ,Res77" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        hexmask.long.word 0x00 20.--31. 1. "        Res78                        ,Res78"
        bitfld.long 0x00 0.--3. "                                 ADDRESS_SPACE ,   This is the ID of the address space to use for execution of all the jobs in this job chain.       Address space configuration values are read from the AS  n registers.       Specifying an address space that is not supported (i.e. the corresponding bit in AS_PRESENT is 0) may result in UNDEFINED behavior." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 11. "                                   JOB_CHAIN_FLAG ,   The JOB_CHAIN_FLAG is set and read by software, and is used to disambiguate short-running job chains. It has no effect on the execution of a job, but is transferred intact from the JS  n _CONFIG_NEXT register to the JS n _CONFIG register when a job starts." "0,1"
        textline "                                "
        bitfld.long 0x00 16.--19. "THREAD_PRI             ,   The thread priority is ordered so that high values will cause threads to be issued faster. Priority values are relative to the other jobs running  if no other jobs are issuing threads, this job will never be throttled even with low priorities.  How the priority values affect issue rates from different slots is implementation dependent. " "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 8.--9. "        START_FLUSH                  ,   Before the job chain is started, the selected action is applied to all caches except the tiler cache.  Clarified that cache flush behavior for Mimir deviates from spec.  In this implementation (MIMIR), this behavior is not fully implemented.         Any non-zero value in this field will cause both a clean  and an invalidate for the read-write caches.         If the value is 3, then the read-only caches are also invalidated, as specified.         The flush command goes to all GPU cores enabled in the affinity mask, and the L2 cache." "NO_ACTION:  No action is performed ,CLEAN,2,INVALIDATE"
        bitfld.long 0x00 12.--13. "  END_FLUSH     ,   After the job chain is finished, the selected action is applied to all caches including the tiler cache. This happens when the job chain ends with a success code, or a fault code other than JOB_CONFIG_FAULT or JOB_POWER_FAULT. In the case of JOB_CONFIG_FAULT and JOB_POWER_FAULT, the job chain could not even start and so no cache flush on end takes place.  Clarified that cache flush behavior for Mimir deviates from spec.  In this implementation (MIMIR), this behavior is not fully implemented.         The flush command goes only to the L2 cache. The tiler cache is not affected.         Any non-zero value in this field will cause both a clean  and an invalidate." "NO_ACTION:  No action is performed ,CLEAN,2,INVALIDATE"
        bitfld.long 0x00 10. "  START_MMU      ,START_MMU" "false:  No MMU actions ,true"
        textline "                                "
        bitfld.long 0x00 14. "ENABLE_FLUSH_REDUCTION ,   When operating in 'cache flush reduction' mode, each job chain has an associated ID which is used to identify cache flushes.  This ID is a sequential 32-bit value. When the job manager is asked to perform a suppressable flush, it compares the job chain flush ID with the latest flush ID. If the job chain ID is greater than the latest flush, then a flush is performed. Otherwise, the flush  may be suppressed. Not all flushes can be suppressed, and not all suppressable flushes may be suppressed in any particular hardware implementation. In particular:    A CLEAN_INVALIDATE operation can replace a CLEAN, but not the other way around.  A CLEAN_INVALIDATE operation can be suppressed at the start of a job chain.  A CLEAN or CLEAN_INVALIDATE operation at the end of a job chain cannot be suppressed in the general case.  If software can guarantee that it will not read the result of a job chain until another job chain has been completed, then this is a case where the CLEAN or CLEAN_INVALIDATE operation at the end of a job chain could be suppressed. It is, however, simpler for software to signal this guarantee by simply not enabling the end-of-chain cache flush at all.  Explicit cache flush jobs are assumed to have been placed into the job chain for a reason, and are therefore not suppressed.  Clarified cache flush reduction  Added cache flush reduction " "false,true"
        bitfld.long 0x00 15. "     DISABLE_DESCRIPTOR_WRITEBACK ,   Normally, the status of each job in the job chain is written back as it is completed. This flag allows software to suppress that mechanism in cases where it is not required. Regardless of the setting of this flag, a job slot's  STATUS register is always updated on completion of its job chain. One of the reasons for writing back the status to the job descriptors is to guard against infinite loops in job chains. If this flag is set, then that protection is disabled and additional steps should be taken to detect and mitigate infinite loops.  Added  DISABLE_DESCRIPTOR_WRITEBACK flag to job slot CONFIG register." "false,true"

group d:0xC050181C++0x03
    line.long 0x00 "JS0_XAFFINITY,   Additional affinity information for job slot  n exists in this register. Only resources covered by the affinity mask are eligible for receiving commands. The mask is anded with the appropriate bits from the TILER_PRESENT and L2_PRESENT masks, and the resulting ones are the resources that can be used.  The affinity value is constant over a job chain. If you need to change affinity between jobs, then they must be split into separate job chains. "
        hexmask.long.byte 0x00 1.--7. 1. " Res79                  ,Res79"
        bitfld.long 0x00 0. "        XAFFINITY_ENABLE             ,XAFFINITY_ENABLE" "false,true:  This register is enabled. "
        hexmask.long.byte 0x00 8.--15. 1. "    TILER_ENABLE  ,   This field selects which tilers receive commands such as cache flushes and tiler jobs. "
        hexmask.long.word 0x00 16.--31. 1. "                                   CACHE_ENABLE   ,   This field selects which level 2 caches receive commands such as cache flushes and tiler jobs. "

group d:0xC0501820++0x03
    line.long 0x00 "JS0_COMMAND,   Writing values to this register will control the job currently running in job slot  n . When the Job Manager encounters the end of a job chain, an interrupt is generated and (if appropriate) the contents of the next registers are transferred to the current registers, allowing immediate execution of a new job chain.  Jobs can be started only by writing to the JS  n _COMMAND_NEXT register, not this register, as this process depends on reliable transfer of the other values describing the job. A soft stop requests that no more tasks are issued for a job, and once all running tasks are finished, the job state is written to memory and the job suspended. It is possible to recover from this state and continue the job.  A hard stop simply aborts all running tasks for a job. No attempt is made to finish, write partial results, or save state. It will not be possible to resume a job after a hard stop, although it may be possible to restart it from scratch if it does not write to its own inputs. To do this, the driver must set the job status to STOPPED and also set the restart index to 0.  The conditional versions of SOFT_STOP and HARD_STOP are designed to eliminate race conditions when checking the JOB_CHAIN_FLAG, which is in the JS  n _CONFIG register. The stop command is only issued if the current state of the flag matches the value in the command name. If it does not match, then the command is treated like a NOP and nothing happens."
        hexmask.long 0x00 0.--31. 1. " JS0COMMAND             ,   Added SUSPEND and RESUME commands to job chain  COMMAND register."

group d:0xC0501824++0x03
    line.long 0x00 "JS0_STATUS,   This register indicates the status of the job chain running in this job slot.  During typical operation, the status starts in state  NOT_STARTED , then switches to ACTIVE during job chain execution, and on completion the status will change to either DONE for successful execution, or another exception code if an error occurred. Corrected description of job slot STATUS register  If the GPU is in protected mode, this register will read as zero. "
        hexmask.long.tbyte 0x00 8.--31. 1. " Res80                  ,Res80"
        hexmask.long.byte 0x00 0.--7. 1. "    EXCEPTION_TYPE               ,   Added new MMU exception types.  Changed INTERRUPTED exception type to SUSPENDED.  Added exception types for new events EUREKA and KABOOM.  Removed aliases for OK - used to also be called IDLE and NOT_STARTED.  Documented that a KABOOM instruction will cause other jobs to hard-stop.  Removed OUT_OF_MEMORY_AFBC error as it can only occur with non-sparse allocation (now removed).  Removed INSTR_TYPE_MISMATCH, INSTR_OPERAND_FAULT, INSTR_TLS_FAULT, INSTR_ALIGN_FAULT; added IMPRECISE_FAULT (0x5B).  Split SHAREABILITY_FAULT into GPU_SHAREABILITY_FAULT, SYSTEM_SHAREABILITY_FAULT and GPU_CACHEABILITY_FAULT. "

group d:0xC0501830++0x03
    line.long 0x00 "JS0_FLUSH_ID,   This register contains the current cache flush ID for this job slot. "
        hexmask.long 0x00 0.--31. 1. " JS0FLUSH_ID            ,   When operating in 'cache flush reduction' mode, each job chain has an associated ID which is used to identify cache flushes.  This ID is a sequential 32-bit value. When the job manager is asked to perform a flush, it compares the job chain flush ID with the latest flush ID. If the job chain ID is greater than the latest flush, then a flush is performed.  Care must be taken in the overflow case. If the software setting up the ID detects that an overflow may occur, the job chain should be tagged with the maximum value of the  LATEST_FLUSH register. This ensures that flushes are correctly performed, at the possible cost of a few redundant flushes. Added cache flush reduction "

group d:0xC0501834++0x03
    line.long 0x00 "JS0_EVENT_0,   This register is used to accumulate events for job chains where the job chain disambiguation bit is 0.  Added event registers to job slots. "
        hexmask.long 0x00 0.--31. 1. " JS0EVENT_0             ,JS0EVENT_0"

group d:0xC0501838++0x03
    line.long 0x00 "JS0_EVENT_1,   This register is used to accumulate events for job chains where the job chain disambiguation bit is 1. "
        hexmask.long 0x00 0.--31. 1. " JS0EVENT_1             ,JS0EVENT_1"

group d:0xC050183C++0x03
    line.long 0x00 "JS0_EVENT_MASK,   This register is the current event mask. "
        hexmask.long 0x00 0.--31. 1. " JS0EVENT_MASK          ,JS0EVENT_MASK"

group d:0xC0501840++0x03
    line.long 0x00 "JS0_HEAD_NEXT_LO,   This register contains the value to be transferred into the JS  n _HEAD register when the next job chain starts. See COMMAND_NEXT for details."
        hexmask.long 0x00 0.--31. 1. " JS0HEAD_NEXT_LO        ,   This register contains the address of the current job descriptor. The address is a virtual address in the address space specified by the ADDRESS_SPACE field in the JS  n _CONFIG register."

group d:0xC0501844++0x03
    line.long 0x00 "JS0_HEAD_NEXT_HI,   This register contains the value to be transferred into the JS  n _HEAD register when the next job chain starts. See COMMAND_NEXT for details."
        hexmask.long 0x00 0.--31. 1. " JS0HEAD_NEXT_HI        ,   This register contains the address of the current job descriptor. The address is a virtual address in the address space specified by the ADDRESS_SPACE field in the JS  n _CONFIG register."

group d:0xC0501850++0x03
    line.long 0x00 "JS0_AFFINITY_NEXT_LO,   This register contains the value to be transferred into the JS  n _AFFINITY register when the next job chain starts. See COMMAND_NEXT for details."
        hexmask.long 0x00 0.--31. 1. " JS0AFFINITY_NEXT_LO    ,JS0AFFINITY_NEXT_LO"

group d:0xC0501854++0x03
    line.long 0x00 "JS0_AFFINITY_NEXT_HI,   This register contains the value to be transferred into the JS  n _AFFINITY register when the next job chain starts. See COMMAND_NEXT for details."
        hexmask.long 0x00 0.--31. 1. " JS0AFFINITY_NEXT_HI    ,JS0AFFINITY_NEXT_HI"

group d:0xC0501858++0x03
    line.long 0x00 "JS0_CONFIG_NEXT,   This register contains the value to be transferred into the JS  n _CONFIG register when the next job chain starts. See COMMAND_NEXT for details."
        bitfld.long 0x00 4.--7. " Res81                  ,Res81" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        hexmask.long.word 0x00 20.--31. 1. "        Res82                        ,Res82"
        bitfld.long 0x00 0.--3. "                                 ADDRESS_SPACE ,   This is the ID of the address space to use for execution of all the jobs in this job chain.       Address space configuration values are read from the AS  n registers.       Specifying an address space that is not supported (i.e. the corresponding bit in AS_PRESENT is 0) may result in UNDEFINED behavior." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 11. "                                   JOB_CHAIN_FLAG ,   The JOB_CHAIN_FLAG is set and read by software, and is used to disambiguate short-running job chains. It has no effect on the execution of a job, but is transferred intact from the JS  n _CONFIG_NEXT register to the JS n _CONFIG register when a job starts." "0,1"
        textline "                                "
        bitfld.long 0x00 16.--19. "THREAD_PRI             ,   The thread priority is ordered so that high values will cause threads to be issued faster. Priority values are relative to the other jobs running  if no other jobs are issuing threads, this job will never be throttled even with low priorities.  How the priority values affect issue rates from different slots is implementation dependent. " "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 8.--9. "        START_FLUSH                  ,   Before the job chain is started, the selected action is applied to all caches except the tiler cache.  Clarified that cache flush behavior for Mimir deviates from spec.  In this implementation (MIMIR), this behavior is not fully implemented.         Any non-zero value in this field will cause both a clean  and an invalidate for the read-write caches.         If the value is 3, then the read-only caches are also invalidated, as specified.         The flush command goes to all GPU cores enabled in the affinity mask, and the L2 cache." "NO_ACTION:  No action is performed ,CLEAN,2,INVALIDATE"
        bitfld.long 0x00 12.--13. "  END_FLUSH     ,   After the job chain is finished, the selected action is applied to all caches including the tiler cache. This happens when the job chain ends with a success code, or a fault code other than JOB_CONFIG_FAULT or JOB_POWER_FAULT. In the case of JOB_CONFIG_FAULT and JOB_POWER_FAULT, the job chain could not even start and so no cache flush on end takes place.  Clarified that cache flush behavior for Mimir deviates from spec.  In this implementation (MIMIR), this behavior is not fully implemented.         The flush command goes only to the L2 cache. The tiler cache is not affected.         Any non-zero value in this field will cause both a clean  and an invalidate." "NO_ACTION:  No action is performed ,CLEAN,2,INVALIDATE"
        bitfld.long 0x00 10. "  START_MMU      ,START_MMU" "false:  No MMU actions ,true"
        textline "                                "
        bitfld.long 0x00 14. "ENABLE_FLUSH_REDUCTION ,   When operating in 'cache flush reduction' mode, each job chain has an associated ID which is used to identify cache flushes.  This ID is a sequential 32-bit value. When the job manager is asked to perform a suppressable flush, it compares the job chain flush ID with the latest flush ID. If the job chain ID is greater than the latest flush, then a flush is performed. Otherwise, the flush  may be suppressed. Not all flushes can be suppressed, and not all suppressable flushes may be suppressed in any particular hardware implementation. In particular:    A CLEAN_INVALIDATE operation can replace a CLEAN, but not the other way around.  A CLEAN_INVALIDATE operation can be suppressed at the start of a job chain.  A CLEAN or CLEAN_INVALIDATE operation at the end of a job chain cannot be suppressed in the general case.  If software can guarantee that it will not read the result of a job chain until another job chain has been completed, then this is a case where the CLEAN or CLEAN_INVALIDATE operation at the end of a job chain could be suppressed. It is, however, simpler for software to signal this guarantee by simply not enabling the end-of-chain cache flush at all.  Explicit cache flush jobs are assumed to have been placed into the job chain for a reason, and are therefore not suppressed.  Clarified cache flush reduction  Added cache flush reduction " "false,true"
        bitfld.long 0x00 15. "     DISABLE_DESCRIPTOR_WRITEBACK ,   Normally, the status of each job in the job chain is written back as it is completed. This flag allows software to suppress that mechanism in cases where it is not required. Regardless of the setting of this flag, a job slot's  STATUS register is always updated on completion of its job chain. One of the reasons for writing back the status to the job descriptors is to guard against infinite loops in job chains. If this flag is set, then that protection is disabled and additional steps should be taken to detect and mitigate infinite loops.  Added  DISABLE_DESCRIPTOR_WRITEBACK flag to job slot CONFIG register." "false,true"

group d:0xC050185C++0x03
    line.long 0x00 "JS0_XAFFINITY_NEXT,   This register contains the value to be transferred into the JS  n _XAFFINITY register when the next job chain starts. See COMMAND_NEXT for details."
        hexmask.long.byte 0x00 1.--7. 1. " Res83                  ,Res83"
        bitfld.long 0x00 0. "        XAFFINITY_ENABLE             ,XAFFINITY_ENABLE" "false,true:  This register is enabled. "
        hexmask.long.byte 0x00 8.--15. 1. "    TILER_ENABLE  ,   This field selects which tilers receive commands such as cache flushes and tiler jobs. "
        hexmask.long.word 0x00 16.--31. 1. "                                   CACHE_ENABLE   ,   This field selects which level 2 caches receive commands such as cache flushes and tiler jobs. "

group d:0xC0501860++0x03
    line.long 0x00 "JS0_COMMAND_NEXT,   When the current job chain is completed, if there are no unacknowledged errors from the previous job chain, and this register is not set to NOP,      then the contents of the *_NEXT registers are transferred to the corresponding current * registers. This allows software to construct job chains one ahead and maintain throughput.  When the values are transferred, the JS  n _COMMAND_NEXT register is cleared, indicating a NOP. The register is then ready to accept a new command. The JS n _HEAD_NEXT register is also cleared at the same time. The state of the current job can be determined using JS n _STATUS. In order to prevent new chains being transferred in a half-completed state, data is transferred only when a START command is present in the JS  n _COMMAND_NEXT register. Therefore, software should initialize the other _NEXT registers first, and only write a START command to the JS n _COMMAND_NEXT register when the data for the next job is complete. If there is no job running in slot n when START is written to JS  n _COMMAND_NEXT, the next data is transferred immediately.      If the next command value is anything except START, nothing happens. To stop jobs, write STOP commands to the JS  n _COMMAND register instead. If any status is returned from a job in the previous job chain other than DONE, the JOB_FAIL_  n bit for this job chain is set in the JOB_IRQ_RAWSTAT register, and the next job chain is not started. This allows software to retrieve the current register values. Software must indicate that it is ready to proceed by clearing the error interrupt bit, at which point the next job chain may be started."
        hexmask.long 0x00 0.--31. 1. " JS0COMMAND_NEXT        ,   Added SUSPEND and RESUME commands to job chain  COMMAND register."

group d:0xC0501870++0x03
    line.long 0x00 "JS0_FLUSH_ID_NEXT,   This register contains the value to be transferred into the JS  n _FLUSH_ID register when the next job chain starts. See FLUSH_ID for details."
        hexmask.long 0x00 0.--31. 1. " JS0FLUSH_ID_NEXT       ,   When operating in 'cache flush reduction' mode, each job chain has an associated ID which is used to identify cache flushes.  This ID is a sequential 32-bit value. When the job manager is asked to perform a flush, it compares the job chain flush ID with the latest flush ID. If the job chain ID is greater than the latest flush, then a flush is performed.  Care must be taken in the overflow case. If the software setting up the ID detects that an overflow may occur, the job chain should be tagged with the maximum value of the  LATEST_FLUSH register. This ensures that flushes are correctly performed, at the possible cost of a few redundant flushes. Added cache flush reduction "

group d:0xC050187C++0x03
    line.long 0x00 "JS0_EVENT_MASK_NEXT,   This register contains the value to be transferred into the JS  n _EVENT_MASK register when the next job chain starts. See EVENT_MASK for details."
        hexmask.long 0x00 0.--31. 1. " JS0EVENT_MASK_NEXT     ,JS0EVENT_MASK_NEXT"

width 22.

group d:0xC0501880++0x03
    line.long 0x00 "JS1_HEAD_LO,   These registers exist for each supported job slot, with the prefix JS  n . To start a job chain, write the address to the first job descriptor into the JS  n _HEAD_NEXT register and write a START command to the JS n _COMMAND_NEXT register. When read, this register reflects the current position in the job chain. When the Job Manager has finished issuing tasks for a job, it will go on to the next job in the job chain, and update JS  n _HEAD. A job will disappear from JS  n _HEAD before it has finished processing all its tasks. See JS n _TAIL for how to discover this. Jobs newer than JS  n _HEAD may have been prefetched from memory, but will not yet have started processing. After an error, JS  n _HEAD contains the address of the first job (chronologically) that failed. The status registers contain the state of this job. If the GPU is in protected mode, this register will read as zero. "
        hexmask.long 0x00 0.--31. 1. " JS1HEAD_LO             ,   This register contains the address of the current job descriptor. The address is a virtual address in the address space specified by the ADDRESS_SPACE field in the JS  n _CONFIG register."

group d:0xC0501884++0x03
    line.long 0x00 "JS1_HEAD_HI,   These registers exist for each supported job slot, with the prefix JS  n . To start a job chain, write the address to the first job descriptor into the JS  n _HEAD_NEXT register and write a START command to the JS n _COMMAND_NEXT register. When read, this register reflects the current position in the job chain. When the Job Manager has finished issuing tasks for a job, it will go on to the next job in the job chain, and update JS  n _HEAD. A job will disappear from JS  n _HEAD before it has finished processing all its tasks. See JS n _TAIL for how to discover this. Jobs newer than JS  n _HEAD may have been prefetched from memory, but will not yet have started processing. After an error, JS  n _HEAD contains the address of the first job (chronologically) that failed. The status registers contain the state of this job. If the GPU is in protected mode, this register will read as zero. "
        hexmask.long 0x00 0.--31. 1. " JS1HEAD_HI             ,   This register contains the address of the current job descriptor. The address is a virtual address in the address space specified by the ADDRESS_SPACE field in the JS  n _CONFIG register."

group d:0xC0501888++0x03
    line.long 0x00 "JS1_TAIL_LO,   If the GPU is in protected mode, this register will read as zero. "
        hexmask.long 0x00 0.--31. 1. " JS1TAIL_LO             ,   This register contains the address of the oldest job that has finished issuing tasks, but is still running. The address is a virtual address in the address space specified by the ADDRESS_SPACE field in the JS  n _CONFIG register. All the jobs in a job chain from JS  n _TAIL to JS n _HEAD are in some way active in the GPU. Jobs older than JS n _TAIL are fully completed. Note that the value in the JS  n _TAIL register is updated when a new job starts. Therefore, this value is only valid while the JS n _STATUS register has the value ACTIVE. After an error, JS  n _TAIL contains the address of the first job in the chain that is not known to be successfully complete. Other jobs after this point may have completed successfully, but all jobs prior to this point are guaranteed have completed.       In order to simplfy implementation of this feature, the position reported in JS n _TAIL is allowed to be conservative. However, scanning from this point forward in the chain will always be sufficient to identify all failing jobs."

group d:0xC050188C++0x03
    line.long 0x00 "JS1_TAIL_HI,   If the GPU is in protected mode, this register will read as zero. "
        hexmask.long 0x00 0.--31. 1. " JS1TAIL_HI             ,   This register contains the address of the oldest job that has finished issuing tasks, but is still running. The address is a virtual address in the address space specified by the ADDRESS_SPACE field in the JS  n _CONFIG register. All the jobs in a job chain from JS  n _TAIL to JS n _HEAD are in some way active in the GPU. Jobs older than JS n _TAIL are fully completed. Note that the value in the JS  n _TAIL register is updated when a new job starts. Therefore, this value is only valid while the JS n _STATUS register has the value ACTIVE. After an error, JS  n _TAIL contains the address of the first job in the chain that is not known to be successfully complete. Other jobs after this point may have completed successfully, but all jobs prior to this point are guaranteed have completed.       In order to simplfy implementation of this feature, the position reported in JS n _TAIL is allowed to be conservative. However, scanning from this point forward in the chain will always be sufficient to identify all failing jobs."

group d:0xC0501890++0x03
    line.long 0x00 "JS1_AFFINITY_LO,   This register contains the current core affinity mask for this job slot. Only cores covered by the affinity mask are eligible for running tasks on. The mask is anded with the *_READY masks, and the resulting ones are the cores that can be used.  The affinity value is constant over a job chain. If you need to change affinity between jobs, then they must be split into separate job chains.See also JS  n _XAFFINITY"
        hexmask.long 0x00 0.--31. 1. " JS1AFFINITY_LO         ,JS1AFFINITY_LO"

group d:0xC0501894++0x03
    line.long 0x00 "JS1_AFFINITY_HI,   This register contains the current core affinity mask for this job slot. Only cores covered by the affinity mask are eligible for running tasks on. The mask is anded with the *_READY masks, and the resulting ones are the cores that can be used.  The affinity value is constant over a job chain. If you need to change affinity between jobs, then they must be split into separate job chains.See also JS  n _XAFFINITY"
        hexmask.long 0x00 0.--31. 1. " JS1AFFINITY_HI         ,JS1AFFINITY_HI"

group d:0xC0501898++0x03
    line.long 0x00 "JS1_CONFIG,   The job slot configuration register contains various configuration options for the jobs running in this job slot. "
        bitfld.long 0x00 4.--7. " Res84                  ,Res84" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        hexmask.long.word 0x00 20.--31. 1. "        Res85                        ,Res85"
        bitfld.long 0x00 0.--3. "                                 ADDRESS_SPACE ,   This is the ID of the address space to use for execution of all the jobs in this job chain.       Address space configuration values are read from the AS  n registers.       Specifying an address space that is not supported (i.e. the corresponding bit in AS_PRESENT is 0) may result in UNDEFINED behavior." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 11. "                                   JOB_CHAIN_FLAG ,   The JOB_CHAIN_FLAG is set and read by software, and is used to disambiguate short-running job chains. It has no effect on the execution of a job, but is transferred intact from the JS  n _CONFIG_NEXT register to the JS n _CONFIG register when a job starts." "0,1"
        textline "                                "
        bitfld.long 0x00 16.--19. "THREAD_PRI             ,   The thread priority is ordered so that high values will cause threads to be issued faster. Priority values are relative to the other jobs running  if no other jobs are issuing threads, this job will never be throttled even with low priorities.  How the priority values affect issue rates from different slots is implementation dependent. " "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 8.--9. "        START_FLUSH                  ,   Before the job chain is started, the selected action is applied to all caches except the tiler cache.  Clarified that cache flush behavior for Mimir deviates from spec.  In this implementation (MIMIR), this behavior is not fully implemented.         Any non-zero value in this field will cause both a clean  and an invalidate for the read-write caches.         If the value is 3, then the read-only caches are also invalidated, as specified.         The flush command goes to all GPU cores enabled in the affinity mask, and the L2 cache." "NO_ACTION:  No action is performed ,CLEAN,2,INVALIDATE"
        bitfld.long 0x00 12.--13. "  END_FLUSH     ,   After the job chain is finished, the selected action is applied to all caches including the tiler cache. This happens when the job chain ends with a success code, or a fault code other than JOB_CONFIG_FAULT or JOB_POWER_FAULT. In the case of JOB_CONFIG_FAULT and JOB_POWER_FAULT, the job chain could not even start and so no cache flush on end takes place.  Clarified that cache flush behavior for Mimir deviates from spec.  In this implementation (MIMIR), this behavior is not fully implemented.         The flush command goes only to the L2 cache. The tiler cache is not affected.         Any non-zero value in this field will cause both a clean  and an invalidate." "NO_ACTION:  No action is performed ,CLEAN,2,INVALIDATE"
        bitfld.long 0x00 10. "  START_MMU      ,START_MMU" "false:  No MMU actions ,true"
        textline "                                "
        bitfld.long 0x00 14. "ENABLE_FLUSH_REDUCTION ,   When operating in 'cache flush reduction' mode, each job chain has an associated ID which is used to identify cache flushes.  This ID is a sequential 32-bit value. When the job manager is asked to perform a suppressable flush, it compares the job chain flush ID with the latest flush ID. If the job chain ID is greater than the latest flush, then a flush is performed. Otherwise, the flush  may be suppressed. Not all flushes can be suppressed, and not all suppressable flushes may be suppressed in any particular hardware implementation. In particular:    A CLEAN_INVALIDATE operation can replace a CLEAN, but not the other way around.  A CLEAN_INVALIDATE operation can be suppressed at the start of a job chain.  A CLEAN or CLEAN_INVALIDATE operation at the end of a job chain cannot be suppressed in the general case.  If software can guarantee that it will not read the result of a job chain until another job chain has been completed, then this is a case where the CLEAN or CLEAN_INVALIDATE operation at the end of a job chain could be suppressed. It is, however, simpler for software to signal this guarantee by simply not enabling the end-of-chain cache flush at all.  Explicit cache flush jobs are assumed to have been placed into the job chain for a reason, and are therefore not suppressed.  Clarified cache flush reduction  Added cache flush reduction " "false,true"
        bitfld.long 0x00 15. "     DISABLE_DESCRIPTOR_WRITEBACK ,   Normally, the status of each job in the job chain is written back as it is completed. This flag allows software to suppress that mechanism in cases where it is not required. Regardless of the setting of this flag, a job slot's  STATUS register is always updated on completion of its job chain. One of the reasons for writing back the status to the job descriptors is to guard against infinite loops in job chains. If this flag is set, then that protection is disabled and additional steps should be taken to detect and mitigate infinite loops.  Added  DISABLE_DESCRIPTOR_WRITEBACK flag to job slot CONFIG register." "false,true"

group d:0xC050189C++0x03
    line.long 0x00 "JS1_XAFFINITY,   Additional affinity information for job slot  n exists in this register. Only resources covered by the affinity mask are eligible for receiving commands. The mask is anded with the appropriate bits from the TILER_PRESENT and L2_PRESENT masks, and the resulting ones are the resources that can be used.  The affinity value is constant over a job chain. If you need to change affinity between jobs, then they must be split into separate job chains. "
        hexmask.long.byte 0x00 1.--7. 1. " Res86                  ,Res86"
        bitfld.long 0x00 0. "        XAFFINITY_ENABLE             ,XAFFINITY_ENABLE" "false,true:  This register is enabled. "
        hexmask.long.byte 0x00 8.--15. 1. "    TILER_ENABLE  ,   This field selects which tilers receive commands such as cache flushes and tiler jobs. "
        hexmask.long.word 0x00 16.--31. 1. "                                   CACHE_ENABLE   ,   This field selects which level 2 caches receive commands such as cache flushes and tiler jobs. "

group d:0xC05018A0++0x03
    line.long 0x00 "JS1_COMMAND,   Writing values to this register will control the job currently running in job slot  n . When the Job Manager encounters the end of a job chain, an interrupt is generated and (if appropriate) the contents of the next registers are transferred to the current registers, allowing immediate execution of a new job chain.  Jobs can be started only by writing to the JS  n _COMMAND_NEXT register, not this register, as this process depends on reliable transfer of the other values describing the job. A soft stop requests that no more tasks are issued for a job, and once all running tasks are finished, the job state is written to memory and the job suspended. It is possible to recover from this state and continue the job.  A hard stop simply aborts all running tasks for a job. No attempt is made to finish, write partial results, or save state. It will not be possible to resume a job after a hard stop, although it may be possible to restart it from scratch if it does not write to its own inputs. To do this, the driver must set the job status to STOPPED and also set the restart index to 0.  The conditional versions of SOFT_STOP and HARD_STOP are designed to eliminate race conditions when checking the JOB_CHAIN_FLAG, which is in the JS  n _CONFIG register. The stop command is only issued if the current state of the flag matches the value in the command name. If it does not match, then the command is treated like a NOP and nothing happens."
        hexmask.long 0x00 0.--31. 1. " JS1COMMAND             ,   Added SUSPEND and RESUME commands to job chain  COMMAND register."

group d:0xC05018A4++0x03
    line.long 0x00 "JS1_STATUS,   This register indicates the status of the job chain running in this job slot.  During typical operation, the status starts in state  NOT_STARTED , then switches to ACTIVE during job chain execution, and on completion the status will change to either DONE for successful execution, or another exception code if an error occurred. Corrected description of job slot STATUS register  If the GPU is in protected mode, this register will read as zero. "
        hexmask.long.tbyte 0x00 8.--31. 1. " Res87                  ,Res87"
        hexmask.long.byte 0x00 0.--7. 1. "    EXCEPTION_TYPE               ,   Added new MMU exception types.  Changed INTERRUPTED exception type to SUSPENDED.  Added exception types for new events EUREKA and KABOOM.  Removed aliases for OK - used to also be called IDLE and NOT_STARTED.  Documented that a KABOOM instruction will cause other jobs to hard-stop.  Removed OUT_OF_MEMORY_AFBC error as it can only occur with non-sparse allocation (now removed).  Removed INSTR_TYPE_MISMATCH, INSTR_OPERAND_FAULT, INSTR_TLS_FAULT, INSTR_ALIGN_FAULT; added IMPRECISE_FAULT (0x5B).  Split SHAREABILITY_FAULT into GPU_SHAREABILITY_FAULT, SYSTEM_SHAREABILITY_FAULT and GPU_CACHEABILITY_FAULT. "

group d:0xC05018B0++0x03
    line.long 0x00 "JS1_FLUSH_ID,   This register contains the current cache flush ID for this job slot. "
        hexmask.long 0x00 0.--31. 1. " JS1FLUSH_ID            ,   When operating in 'cache flush reduction' mode, each job chain has an associated ID which is used to identify cache flushes.  This ID is a sequential 32-bit value. When the job manager is asked to perform a flush, it compares the job chain flush ID with the latest flush ID. If the job chain ID is greater than the latest flush, then a flush is performed.  Care must be taken in the overflow case. If the software setting up the ID detects that an overflow may occur, the job chain should be tagged with the maximum value of the  LATEST_FLUSH register. This ensures that flushes are correctly performed, at the possible cost of a few redundant flushes. Added cache flush reduction "

group d:0xC05018B4++0x03
    line.long 0x00 "JS1_EVENT_0,   This register is used to accumulate events for job chains where the job chain disambiguation bit is 0.  Added event registers to job slots. "
        hexmask.long 0x00 0.--31. 1. " JS1EVENT_0             ,JS1EVENT_0"

group d:0xC05018B8++0x03
    line.long 0x00 "JS1_EVENT_1,   This register is used to accumulate events for job chains where the job chain disambiguation bit is 1. "
        hexmask.long 0x00 0.--31. 1. " JS1EVENT_1             ,JS1EVENT_1"

group d:0xC05018BC++0x03
    line.long 0x00 "JS1_EVENT_MASK,   This register is the current event mask. "
        hexmask.long 0x00 0.--31. 1. " JS1EVENT_MASK          ,JS1EVENT_MASK"

group d:0xC05018C0++0x03
    line.long 0x00 "JS1_HEAD_NEXT_LO,   This register contains the value to be transferred into the JS  n _HEAD register when the next job chain starts. See COMMAND_NEXT for details."
        hexmask.long 0x00 0.--31. 1. " JS1HEAD_NEXT_LO        ,   This register contains the address of the current job descriptor. The address is a virtual address in the address space specified by the ADDRESS_SPACE field in the JS  n _CONFIG register."

group d:0xC05018C4++0x03
    line.long 0x00 "JS1_HEAD_NEXT_HI,   This register contains the value to be transferred into the JS  n _HEAD register when the next job chain starts. See COMMAND_NEXT for details."
        hexmask.long 0x00 0.--31. 1. " JS1HEAD_NEXT_HI        ,   This register contains the address of the current job descriptor. The address is a virtual address in the address space specified by the ADDRESS_SPACE field in the JS  n _CONFIG register."

group d:0xC05018D0++0x03
    line.long 0x00 "JS1_AFFINITY_NEXT_LO,   This register contains the value to be transferred into the JS  n _AFFINITY register when the next job chain starts. See COMMAND_NEXT for details."
        hexmask.long 0x00 0.--31. 1. " JS1AFFINITY_NEXT_LO    ,JS1AFFINITY_NEXT_LO"

group d:0xC05018D4++0x03
    line.long 0x00 "JS1_AFFINITY_NEXT_HI,   This register contains the value to be transferred into the JS  n _AFFINITY register when the next job chain starts. See COMMAND_NEXT for details."
        hexmask.long 0x00 0.--31. 1. " JS1AFFINITY_NEXT_HI    ,JS1AFFINITY_NEXT_HI"

group d:0xC05018D8++0x03
    line.long 0x00 "JS1_CONFIG_NEXT,   This register contains the value to be transferred into the JS  n _CONFIG register when the next job chain starts. See COMMAND_NEXT for details."
        bitfld.long 0x00 4.--7. " Res88                  ,Res88" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        hexmask.long.word 0x00 20.--31. 1. "        Res89                        ,Res89"
        bitfld.long 0x00 0.--3. "                                 ADDRESS_SPACE ,   This is the ID of the address space to use for execution of all the jobs in this job chain.       Address space configuration values are read from the AS  n registers.       Specifying an address space that is not supported (i.e. the corresponding bit in AS_PRESENT is 0) may result in UNDEFINED behavior." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 11. "                                   JOB_CHAIN_FLAG ,   The JOB_CHAIN_FLAG is set and read by software, and is used to disambiguate short-running job chains. It has no effect on the execution of a job, but is transferred intact from the JS  n _CONFIG_NEXT register to the JS n _CONFIG register when a job starts." "0,1"
        textline "                                "
        bitfld.long 0x00 16.--19. "THREAD_PRI             ,   The thread priority is ordered so that high values will cause threads to be issued faster. Priority values are relative to the other jobs running  if no other jobs are issuing threads, this job will never be throttled even with low priorities.  How the priority values affect issue rates from different slots is implementation dependent. " "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 8.--9. "        START_FLUSH                  ,   Before the job chain is started, the selected action is applied to all caches except the tiler cache.  Clarified that cache flush behavior for Mimir deviates from spec.  In this implementation (MIMIR), this behavior is not fully implemented.         Any non-zero value in this field will cause both a clean  and an invalidate for the read-write caches.         If the value is 3, then the read-only caches are also invalidated, as specified.         The flush command goes to all GPU cores enabled in the affinity mask, and the L2 cache." "NO_ACTION:  No action is performed ,CLEAN,2,INVALIDATE"
        bitfld.long 0x00 12.--13. "  END_FLUSH     ,   After the job chain is finished, the selected action is applied to all caches including the tiler cache. This happens when the job chain ends with a success code, or a fault code other than JOB_CONFIG_FAULT or JOB_POWER_FAULT. In the case of JOB_CONFIG_FAULT and JOB_POWER_FAULT, the job chain could not even start and so no cache flush on end takes place.  Clarified that cache flush behavior for Mimir deviates from spec.  In this implementation (MIMIR), this behavior is not fully implemented.         The flush command goes only to the L2 cache. The tiler cache is not affected.         Any non-zero value in this field will cause both a clean  and an invalidate." "NO_ACTION:  No action is performed ,CLEAN,2,INVALIDATE"
        bitfld.long 0x00 10. "  START_MMU      ,START_MMU" "false:  No MMU actions ,true"
        textline "                                "
        bitfld.long 0x00 14. "ENABLE_FLUSH_REDUCTION ,   When operating in 'cache flush reduction' mode, each job chain has an associated ID which is used to identify cache flushes.  This ID is a sequential 32-bit value. When the job manager is asked to perform a suppressable flush, it compares the job chain flush ID with the latest flush ID. If the job chain ID is greater than the latest flush, then a flush is performed. Otherwise, the flush  may be suppressed. Not all flushes can be suppressed, and not all suppressable flushes may be suppressed in any particular hardware implementation. In particular:    A CLEAN_INVALIDATE operation can replace a CLEAN, but not the other way around.  A CLEAN_INVALIDATE operation can be suppressed at the start of a job chain.  A CLEAN or CLEAN_INVALIDATE operation at the end of a job chain cannot be suppressed in the general case.  If software can guarantee that it will not read the result of a job chain until another job chain has been completed, then this is a case where the CLEAN or CLEAN_INVALIDATE operation at the end of a job chain could be suppressed. It is, however, simpler for software to signal this guarantee by simply not enabling the end-of-chain cache flush at all.  Explicit cache flush jobs are assumed to have been placed into the job chain for a reason, and are therefore not suppressed.  Clarified cache flush reduction  Added cache flush reduction " "false,true"
        bitfld.long 0x00 15. "     DISABLE_DESCRIPTOR_WRITEBACK ,   Normally, the status of each job in the job chain is written back as it is completed. This flag allows software to suppress that mechanism in cases where it is not required. Regardless of the setting of this flag, a job slot's  STATUS register is always updated on completion of its job chain. One of the reasons for writing back the status to the job descriptors is to guard against infinite loops in job chains. If this flag is set, then that protection is disabled and additional steps should be taken to detect and mitigate infinite loops.  Added  DISABLE_DESCRIPTOR_WRITEBACK flag to job slot CONFIG register." "false,true"

group d:0xC05018DC++0x03
    line.long 0x00 "JS1_XAFFINITY_NEXT,   This register contains the value to be transferred into the JS  n _XAFFINITY register when the next job chain starts. See COMMAND_NEXT for details."
        hexmask.long.byte 0x00 1.--7. 1. " Res90                  ,Res90"
        bitfld.long 0x00 0. "        XAFFINITY_ENABLE             ,XAFFINITY_ENABLE" "false,true:  This register is enabled. "
        hexmask.long.byte 0x00 8.--15. 1. "    TILER_ENABLE  ,   This field selects which tilers receive commands such as cache flushes and tiler jobs. "
        hexmask.long.word 0x00 16.--31. 1. "                                   CACHE_ENABLE   ,   This field selects which level 2 caches receive commands such as cache flushes and tiler jobs. "

group d:0xC05018E0++0x03
    line.long 0x00 "JS1_COMMAND_NEXT,   When the current job chain is completed, if there are no unacknowledged errors from the previous job chain, and this register is not set to NOP,      then the contents of the *_NEXT registers are transferred to the corresponding current * registers. This allows software to construct job chains one ahead and maintain throughput.  When the values are transferred, the JS  n _COMMAND_NEXT register is cleared, indicating a NOP. The register is then ready to accept a new command. The JS n _HEAD_NEXT register is also cleared at the same time. The state of the current job can be determined using JS n _STATUS. In order to prevent new chains being transferred in a half-completed state, data is transferred only when a START command is present in the JS  n _COMMAND_NEXT register. Therefore, software should initialize the other _NEXT registers first, and only write a START command to the JS n _COMMAND_NEXT register when the data for the next job is complete. If there is no job running in slot n when START is written to JS  n _COMMAND_NEXT, the next data is transferred immediately.      If the next command value is anything except START, nothing happens. To stop jobs, write STOP commands to the JS  n _COMMAND register instead. If any status is returned from a job in the previous job chain other than DONE, the JOB_FAIL_  n bit for this job chain is set in the JOB_IRQ_RAWSTAT register, and the next job chain is not started. This allows software to retrieve the current register values. Software must indicate that it is ready to proceed by clearing the error interrupt bit, at which point the next job chain may be started."
        hexmask.long 0x00 0.--31. 1. " JS1COMMAND_NEXT        ,   Added SUSPEND and RESUME commands to job chain  COMMAND register."

group d:0xC05018F0++0x03
    line.long 0x00 "JS1_FLUSH_ID_NEXT,   This register contains the value to be transferred into the JS  n _FLUSH_ID register when the next job chain starts. See FLUSH_ID for details."
        hexmask.long 0x00 0.--31. 1. " JS1FLUSH_ID_NEXT       ,   When operating in 'cache flush reduction' mode, each job chain has an associated ID which is used to identify cache flushes.  This ID is a sequential 32-bit value. When the job manager is asked to perform a flush, it compares the job chain flush ID with the latest flush ID. If the job chain ID is greater than the latest flush, then a flush is performed.  Care must be taken in the overflow case. If the software setting up the ID detects that an overflow may occur, the job chain should be tagged with the maximum value of the  LATEST_FLUSH register. This ensures that flushes are correctly performed, at the possible cost of a few redundant flushes. Added cache flush reduction "

group d:0xC05018FC++0x03
    line.long 0x00 "JS1_EVENT_MASK_NEXT,   This register contains the value to be transferred into the JS  n _EVENT_MASK register when the next job chain starts. See EVENT_MASK for details."
        hexmask.long 0x00 0.--31. 1. " JS1EVENT_MASK_NEXT     ,JS1EVENT_MASK_NEXT"

width 22.

group d:0xC0501900++0x03
    line.long 0x00 "JS2_HEAD_LO,   These registers exist for each supported job slot, with the prefix JS  n . To start a job chain, write the address to the first job descriptor into the JS  n _HEAD_NEXT register and write a START command to the JS n _COMMAND_NEXT register. When read, this register reflects the current position in the job chain. When the Job Manager has finished issuing tasks for a job, it will go on to the next job in the job chain, and update JS  n _HEAD. A job will disappear from JS  n _HEAD before it has finished processing all its tasks. See JS n _TAIL for how to discover this. Jobs newer than JS  n _HEAD may have been prefetched from memory, but will not yet have started processing. After an error, JS  n _HEAD contains the address of the first job (chronologically) that failed. The status registers contain the state of this job. If the GPU is in protected mode, this register will read as zero. "
        hexmask.long 0x00 0.--31. 1. " JS2HEAD_LO             ,   This register contains the address of the current job descriptor. The address is a virtual address in the address space specified by the ADDRESS_SPACE field in the JS  n _CONFIG register."

group d:0xC0501904++0x03
    line.long 0x00 "JS2_HEAD_HI,   These registers exist for each supported job slot, with the prefix JS  n . To start a job chain, write the address to the first job descriptor into the JS  n _HEAD_NEXT register and write a START command to the JS n _COMMAND_NEXT register. When read, this register reflects the current position in the job chain. When the Job Manager has finished issuing tasks for a job, it will go on to the next job in the job chain, and update JS  n _HEAD. A job will disappear from JS  n _HEAD before it has finished processing all its tasks. See JS n _TAIL for how to discover this. Jobs newer than JS  n _HEAD may have been prefetched from memory, but will not yet have started processing. After an error, JS  n _HEAD contains the address of the first job (chronologically) that failed. The status registers contain the state of this job. If the GPU is in protected mode, this register will read as zero. "
        hexmask.long 0x00 0.--31. 1. " JS2HEAD_HI             ,   This register contains the address of the current job descriptor. The address is a virtual address in the address space specified by the ADDRESS_SPACE field in the JS  n _CONFIG register."

group d:0xC0501908++0x03
    line.long 0x00 "JS2_TAIL_LO,   If the GPU is in protected mode, this register will read as zero. "
        hexmask.long 0x00 0.--31. 1. " JS2TAIL_LO             ,   This register contains the address of the oldest job that has finished issuing tasks, but is still running. The address is a virtual address in the address space specified by the ADDRESS_SPACE field in the JS  n _CONFIG register. All the jobs in a job chain from JS  n _TAIL to JS n _HEAD are in some way active in the GPU. Jobs older than JS n _TAIL are fully completed. Note that the value in the JS  n _TAIL register is updated when a new job starts. Therefore, this value is only valid while the JS n _STATUS register has the value ACTIVE. After an error, JS  n _TAIL contains the address of the first job in the chain that is not known to be successfully complete. Other jobs after this point may have completed successfully, but all jobs prior to this point are guaranteed have completed.       In order to simplfy implementation of this feature, the position reported in JS n _TAIL is allowed to be conservative. However, scanning from this point forward in the chain will always be sufficient to identify all failing jobs."

group d:0xC050190C++0x03
    line.long 0x00 "JS2_TAIL_HI,   If the GPU is in protected mode, this register will read as zero. "
        hexmask.long 0x00 0.--31. 1. " JS2TAIL_HI             ,   This register contains the address of the oldest job that has finished issuing tasks, but is still running. The address is a virtual address in the address space specified by the ADDRESS_SPACE field in the JS  n _CONFIG register. All the jobs in a job chain from JS  n _TAIL to JS n _HEAD are in some way active in the GPU. Jobs older than JS n _TAIL are fully completed. Note that the value in the JS  n _TAIL register is updated when a new job starts. Therefore, this value is only valid while the JS n _STATUS register has the value ACTIVE. After an error, JS  n _TAIL contains the address of the first job in the chain that is not known to be successfully complete. Other jobs after this point may have completed successfully, but all jobs prior to this point are guaranteed have completed.       In order to simplfy implementation of this feature, the position reported in JS n _TAIL is allowed to be conservative. However, scanning from this point forward in the chain will always be sufficient to identify all failing jobs."

group d:0xC0501910++0x03
    line.long 0x00 "JS2_AFFINITY_LO,   This register contains the current core affinity mask for this job slot. Only cores covered by the affinity mask are eligible for running tasks on. The mask is anded with the *_READY masks, and the resulting ones are the cores that can be used.  The affinity value is constant over a job chain. If you need to change affinity between jobs, then they must be split into separate job chains.See also JS  n _XAFFINITY"
        hexmask.long 0x00 0.--31. 1. " JS2AFFINITY_LO         ,JS2AFFINITY_LO"

group d:0xC0501914++0x03
    line.long 0x00 "JS2_AFFINITY_HI,   This register contains the current core affinity mask for this job slot. Only cores covered by the affinity mask are eligible for running tasks on. The mask is anded with the *_READY masks, and the resulting ones are the cores that can be used.  The affinity value is constant over a job chain. If you need to change affinity between jobs, then they must be split into separate job chains.See also JS  n _XAFFINITY"
        hexmask.long 0x00 0.--31. 1. " JS2AFFINITY_HI         ,JS2AFFINITY_HI"

group d:0xC0501918++0x03
    line.long 0x00 "JS2_CONFIG,   The job slot configuration register contains various configuration options for the jobs running in this job slot. "
        bitfld.long 0x00 4.--7. " Res91                  ,Res91" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        hexmask.long.word 0x00 20.--31. 1. "        Res92                        ,Res92"
        bitfld.long 0x00 0.--3. "                                 ADDRESS_SPACE ,   This is the ID of the address space to use for execution of all the jobs in this job chain.       Address space configuration values are read from the AS  n registers.       Specifying an address space that is not supported (i.e. the corresponding bit in AS_PRESENT is 0) may result in UNDEFINED behavior." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 11. "                                   JOB_CHAIN_FLAG ,   The JOB_CHAIN_FLAG is set and read by software, and is used to disambiguate short-running job chains. It has no effect on the execution of a job, but is transferred intact from the JS  n _CONFIG_NEXT register to the JS n _CONFIG register when a job starts." "0,1"
        textline "                                "
        bitfld.long 0x00 16.--19. "THREAD_PRI             ,   The thread priority is ordered so that high values will cause threads to be issued faster. Priority values are relative to the other jobs running  if no other jobs are issuing threads, this job will never be throttled even with low priorities.  How the priority values affect issue rates from different slots is implementation dependent. " "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 8.--9. "        START_FLUSH                  ,   Before the job chain is started, the selected action is applied to all caches except the tiler cache.  Clarified that cache flush behavior for Mimir deviates from spec.  In this implementation (MIMIR), this behavior is not fully implemented.         Any non-zero value in this field will cause both a clean  and an invalidate for the read-write caches.         If the value is 3, then the read-only caches are also invalidated, as specified.         The flush command goes to all GPU cores enabled in the affinity mask, and the L2 cache." "NO_ACTION:  No action is performed ,CLEAN,2,INVALIDATE"
        bitfld.long 0x00 12.--13. "  END_FLUSH     ,   After the job chain is finished, the selected action is applied to all caches including the tiler cache. This happens when the job chain ends with a success code, or a fault code other than JOB_CONFIG_FAULT or JOB_POWER_FAULT. In the case of JOB_CONFIG_FAULT and JOB_POWER_FAULT, the job chain could not even start and so no cache flush on end takes place.  Clarified that cache flush behavior for Mimir deviates from spec.  In this implementation (MIMIR), this behavior is not fully implemented.         The flush command goes only to the L2 cache. The tiler cache is not affected.         Any non-zero value in this field will cause both a clean  and an invalidate." "NO_ACTION:  No action is performed ,CLEAN,2,INVALIDATE"
        bitfld.long 0x00 10. "  START_MMU      ,START_MMU" "false:  No MMU actions ,true"
        textline "                                "
        bitfld.long 0x00 14. "ENABLE_FLUSH_REDUCTION ,   When operating in 'cache flush reduction' mode, each job chain has an associated ID which is used to identify cache flushes.  This ID is a sequential 32-bit value. When the job manager is asked to perform a suppressable flush, it compares the job chain flush ID with the latest flush ID. If the job chain ID is greater than the latest flush, then a flush is performed. Otherwise, the flush  may be suppressed. Not all flushes can be suppressed, and not all suppressable flushes may be suppressed in any particular hardware implementation. In particular:    A CLEAN_INVALIDATE operation can replace a CLEAN, but not the other way around.  A CLEAN_INVALIDATE operation can be suppressed at the start of a job chain.  A CLEAN or CLEAN_INVALIDATE operation at the end of a job chain cannot be suppressed in the general case.  If software can guarantee that it will not read the result of a job chain until another job chain has been completed, then this is a case where the CLEAN or CLEAN_INVALIDATE operation at the end of a job chain could be suppressed. It is, however, simpler for software to signal this guarantee by simply not enabling the end-of-chain cache flush at all.  Explicit cache flush jobs are assumed to have been placed into the job chain for a reason, and are therefore not suppressed.  Clarified cache flush reduction  Added cache flush reduction " "false,true"
        bitfld.long 0x00 15. "     DISABLE_DESCRIPTOR_WRITEBACK ,   Normally, the status of each job in the job chain is written back as it is completed. This flag allows software to suppress that mechanism in cases where it is not required. Regardless of the setting of this flag, a job slot's  STATUS register is always updated on completion of its job chain. One of the reasons for writing back the status to the job descriptors is to guard against infinite loops in job chains. If this flag is set, then that protection is disabled and additional steps should be taken to detect and mitigate infinite loops.  Added  DISABLE_DESCRIPTOR_WRITEBACK flag to job slot CONFIG register." "false,true"

group d:0xC050191C++0x03
    line.long 0x00 "JS2_XAFFINITY,   Additional affinity information for job slot  n exists in this register. Only resources covered by the affinity mask are eligible for receiving commands. The mask is anded with the appropriate bits from the TILER_PRESENT and L2_PRESENT masks, and the resulting ones are the resources that can be used.  The affinity value is constant over a job chain. If you need to change affinity between jobs, then they must be split into separate job chains. "
        hexmask.long.byte 0x00 1.--7. 1. " Res93                  ,Res93"
        bitfld.long 0x00 0. "        XAFFINITY_ENABLE             ,XAFFINITY_ENABLE" "false,true:  This register is enabled. "
        hexmask.long.byte 0x00 8.--15. 1. "    TILER_ENABLE  ,   This field selects which tilers receive commands such as cache flushes and tiler jobs. "
        hexmask.long.word 0x00 16.--31. 1. "                                   CACHE_ENABLE   ,   This field selects which level 2 caches receive commands such as cache flushes and tiler jobs. "

group d:0xC0501920++0x03
    line.long 0x00 "JS2_COMMAND,   Writing values to this register will control the job currently running in job slot  n . When the Job Manager encounters the end of a job chain, an interrupt is generated and (if appropriate) the contents of the next registers are transferred to the current registers, allowing immediate execution of a new job chain.  Jobs can be started only by writing to the JS  n _COMMAND_NEXT register, not this register, as this process depends on reliable transfer of the other values describing the job. A soft stop requests that no more tasks are issued for a job, and once all running tasks are finished, the job state is written to memory and the job suspended. It is possible to recover from this state and continue the job.  A hard stop simply aborts all running tasks for a job. No attempt is made to finish, write partial results, or save state. It will not be possible to resume a job after a hard stop, although it may be possible to restart it from scratch if it does not write to its own inputs. To do this, the driver must set the job status to STOPPED and also set the restart index to 0.  The conditional versions of SOFT_STOP and HARD_STOP are designed to eliminate race conditions when checking the JOB_CHAIN_FLAG, which is in the JS  n _CONFIG register. The stop command is only issued if the current state of the flag matches the value in the command name. If it does not match, then the command is treated like a NOP and nothing happens."
        hexmask.long 0x00 0.--31. 1. " JS2COMMAND             ,   Added SUSPEND and RESUME commands to job chain  COMMAND register."

group d:0xC0501924++0x03
    line.long 0x00 "JS2_STATUS,   This register indicates the status of the job chain running in this job slot.  During typical operation, the status starts in state  NOT_STARTED , then switches to ACTIVE during job chain execution, and on completion the status will change to either DONE for successful execution, or another exception code if an error occurred. Corrected description of job slot STATUS register  If the GPU is in protected mode, this register will read as zero. "
        hexmask.long.tbyte 0x00 8.--31. 1. " Res94                  ,Res94"
        hexmask.long.byte 0x00 0.--7. 1. "    EXCEPTION_TYPE               ,   Added new MMU exception types.  Changed INTERRUPTED exception type to SUSPENDED.  Added exception types for new events EUREKA and KABOOM.  Removed aliases for OK - used to also be called IDLE and NOT_STARTED.  Documented that a KABOOM instruction will cause other jobs to hard-stop.  Removed OUT_OF_MEMORY_AFBC error as it can only occur with non-sparse allocation (now removed).  Removed INSTR_TYPE_MISMATCH, INSTR_OPERAND_FAULT, INSTR_TLS_FAULT, INSTR_ALIGN_FAULT; added IMPRECISE_FAULT (0x5B).  Split SHAREABILITY_FAULT into GPU_SHAREABILITY_FAULT, SYSTEM_SHAREABILITY_FAULT and GPU_CACHEABILITY_FAULT. "

group d:0xC0501930++0x03
    line.long 0x00 "JS2_FLUSH_ID,   This register contains the current cache flush ID for this job slot. "
        hexmask.long 0x00 0.--31. 1. " JS2FLUSH_ID            ,   When operating in 'cache flush reduction' mode, each job chain has an associated ID which is used to identify cache flushes.  This ID is a sequential 32-bit value. When the job manager is asked to perform a flush, it compares the job chain flush ID with the latest flush ID. If the job chain ID is greater than the latest flush, then a flush is performed.  Care must be taken in the overflow case. If the software setting up the ID detects that an overflow may occur, the job chain should be tagged with the maximum value of the  LATEST_FLUSH register. This ensures that flushes are correctly performed, at the possible cost of a few redundant flushes. Added cache flush reduction "

group d:0xC0501934++0x03
    line.long 0x00 "JS2_EVENT_0,   This register is used to accumulate events for job chains where the job chain disambiguation bit is 0.  Added event registers to job slots. "
        hexmask.long 0x00 0.--31. 1. " JS2EVENT_0             ,JS2EVENT_0"

group d:0xC0501938++0x03
    line.long 0x00 "JS2_EVENT_1,   This register is used to accumulate events for job chains where the job chain disambiguation bit is 1. "
        hexmask.long 0x00 0.--31. 1. " JS2EVENT_1             ,JS2EVENT_1"

group d:0xC050193C++0x03
    line.long 0x00 "JS2_EVENT_MASK,   This register is the current event mask. "
        hexmask.long 0x00 0.--31. 1. " JS2EVENT_MASK          ,JS2EVENT_MASK"

group d:0xC0501940++0x03
    line.long 0x00 "JS2_HEAD_NEXT_LO,   This register contains the value to be transferred into the JS  n _HEAD register when the next job chain starts. See COMMAND_NEXT for details."
        hexmask.long 0x00 0.--31. 1. " JS2HEAD_NEXT_LO        ,   This register contains the address of the current job descriptor. The address is a virtual address in the address space specified by the ADDRESS_SPACE field in the JS  n _CONFIG register."

group d:0xC0501944++0x03
    line.long 0x00 "JS2_HEAD_NEXT_HI,   This register contains the value to be transferred into the JS  n _HEAD register when the next job chain starts. See COMMAND_NEXT for details."
        hexmask.long 0x00 0.--31. 1. " JS2HEAD_NEXT_HI        ,   This register contains the address of the current job descriptor. The address is a virtual address in the address space specified by the ADDRESS_SPACE field in the JS  n _CONFIG register."

group d:0xC0501950++0x03
    line.long 0x00 "JS2_AFFINITY_NEXT_LO,   This register contains the value to be transferred into the JS  n _AFFINITY register when the next job chain starts. See COMMAND_NEXT for details."
        hexmask.long 0x00 0.--31. 1. " JS2AFFINITY_NEXT_LO    ,JS2AFFINITY_NEXT_LO"

group d:0xC0501954++0x03
    line.long 0x00 "JS2_AFFINITY_NEXT_HI,   This register contains the value to be transferred into the JS  n _AFFINITY register when the next job chain starts. See COMMAND_NEXT for details."
        hexmask.long 0x00 0.--31. 1. " JS2AFFINITY_NEXT_HI    ,JS2AFFINITY_NEXT_HI"

group d:0xC0501958++0x03
    line.long 0x00 "JS2_CONFIG_NEXT,   This register contains the value to be transferred into the JS  n _CONFIG register when the next job chain starts. See COMMAND_NEXT for details."
        bitfld.long 0x00 4.--7. " Res95                  ,Res95" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        hexmask.long.word 0x00 20.--31. 1. "        Res96                        ,Res96"
        bitfld.long 0x00 0.--3. "                                 ADDRESS_SPACE ,   This is the ID of the address space to use for execution of all the jobs in this job chain.       Address space configuration values are read from the AS  n registers.       Specifying an address space that is not supported (i.e. the corresponding bit in AS_PRESENT is 0) may result in UNDEFINED behavior." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 11. "                                   JOB_CHAIN_FLAG ,   The JOB_CHAIN_FLAG is set and read by software, and is used to disambiguate short-running job chains. It has no effect on the execution of a job, but is transferred intact from the JS  n _CONFIG_NEXT register to the JS n _CONFIG register when a job starts." "0,1"
        textline "                                "
        bitfld.long 0x00 16.--19. "THREAD_PRI             ,   The thread priority is ordered so that high values will cause threads to be issued faster. Priority values are relative to the other jobs running  if no other jobs are issuing threads, this job will never be throttled even with low priorities.  How the priority values affect issue rates from different slots is implementation dependent. " "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 8.--9. "        START_FLUSH                  ,   Before the job chain is started, the selected action is applied to all caches except the tiler cache.  Clarified that cache flush behavior for Mimir deviates from spec.  In this implementation (MIMIR), this behavior is not fully implemented.         Any non-zero value in this field will cause both a clean  and an invalidate for the read-write caches.         If the value is 3, then the read-only caches are also invalidated, as specified.         The flush command goes to all GPU cores enabled in the affinity mask, and the L2 cache." "NO_ACTION:  No action is performed ,CLEAN,2,INVALIDATE"
        bitfld.long 0x00 12.--13. "  END_FLUSH     ,   After the job chain is finished, the selected action is applied to all caches including the tiler cache. This happens when the job chain ends with a success code, or a fault code other than JOB_CONFIG_FAULT or JOB_POWER_FAULT. In the case of JOB_CONFIG_FAULT and JOB_POWER_FAULT, the job chain could not even start and so no cache flush on end takes place.  Clarified that cache flush behavior for Mimir deviates from spec.  In this implementation (MIMIR), this behavior is not fully implemented.         The flush command goes only to the L2 cache. The tiler cache is not affected.         Any non-zero value in this field will cause both a clean  and an invalidate." "NO_ACTION:  No action is performed ,CLEAN,2,INVALIDATE"
        bitfld.long 0x00 10. "  START_MMU      ,START_MMU" "false:  No MMU actions ,true"
        textline "                                "
        bitfld.long 0x00 14. "ENABLE_FLUSH_REDUCTION ,   When operating in 'cache flush reduction' mode, each job chain has an associated ID which is used to identify cache flushes.  This ID is a sequential 32-bit value. When the job manager is asked to perform a suppressable flush, it compares the job chain flush ID with the latest flush ID. If the job chain ID is greater than the latest flush, then a flush is performed. Otherwise, the flush  may be suppressed. Not all flushes can be suppressed, and not all suppressable flushes may be suppressed in any particular hardware implementation. In particular:    A CLEAN_INVALIDATE operation can replace a CLEAN, but not the other way around.  A CLEAN_INVALIDATE operation can be suppressed at the start of a job chain.  A CLEAN or CLEAN_INVALIDATE operation at the end of a job chain cannot be suppressed in the general case.  If software can guarantee that it will not read the result of a job chain until another job chain has been completed, then this is a case where the CLEAN or CLEAN_INVALIDATE operation at the end of a job chain could be suppressed. It is, however, simpler for software to signal this guarantee by simply not enabling the end-of-chain cache flush at all.  Explicit cache flush jobs are assumed to have been placed into the job chain for a reason, and are therefore not suppressed.  Clarified cache flush reduction  Added cache flush reduction " "false,true"
        bitfld.long 0x00 15. "     DISABLE_DESCRIPTOR_WRITEBACK ,   Normally, the status of each job in the job chain is written back as it is completed. This flag allows software to suppress that mechanism in cases where it is not required. Regardless of the setting of this flag, a job slot's  STATUS register is always updated on completion of its job chain. One of the reasons for writing back the status to the job descriptors is to guard against infinite loops in job chains. If this flag is set, then that protection is disabled and additional steps should be taken to detect and mitigate infinite loops.  Added  DISABLE_DESCRIPTOR_WRITEBACK flag to job slot CONFIG register." "false,true"

group d:0xC050195C++0x03
    line.long 0x00 "JS2_XAFFINITY_NEXT,   This register contains the value to be transferred into the JS  n _XAFFINITY register when the next job chain starts. See COMMAND_NEXT for details."
        hexmask.long.byte 0x00 1.--7. 1. " Res97                  ,Res97"
        bitfld.long 0x00 0. "        XAFFINITY_ENABLE             ,XAFFINITY_ENABLE" "false,true:  This register is enabled. "
        hexmask.long.byte 0x00 8.--15. 1. "    TILER_ENABLE  ,   This field selects which tilers receive commands such as cache flushes and tiler jobs. "
        hexmask.long.word 0x00 16.--31. 1. "                                   CACHE_ENABLE   ,   This field selects which level 2 caches receive commands such as cache flushes and tiler jobs. "

group d:0xC0501960++0x03
    line.long 0x00 "JS2_COMMAND_NEXT,   When the current job chain is completed, if there are no unacknowledged errors from the previous job chain, and this register is not set to NOP,      then the contents of the *_NEXT registers are transferred to the corresponding current * registers. This allows software to construct job chains one ahead and maintain throughput.  When the values are transferred, the JS  n _COMMAND_NEXT register is cleared, indicating a NOP. The register is then ready to accept a new command. The JS n _HEAD_NEXT register is also cleared at the same time. The state of the current job can be determined using JS n _STATUS. In order to prevent new chains being transferred in a half-completed state, data is transferred only when a START command is present in the JS  n _COMMAND_NEXT register. Therefore, software should initialize the other _NEXT registers first, and only write a START command to the JS n _COMMAND_NEXT register when the data for the next job is complete. If there is no job running in slot n when START is written to JS  n _COMMAND_NEXT, the next data is transferred immediately.      If the next command value is anything except START, nothing happens. To stop jobs, write STOP commands to the JS  n _COMMAND register instead. If any status is returned from a job in the previous job chain other than DONE, the JOB_FAIL_  n bit for this job chain is set in the JOB_IRQ_RAWSTAT register, and the next job chain is not started. This allows software to retrieve the current register values. Software must indicate that it is ready to proceed by clearing the error interrupt bit, at which point the next job chain may be started."
        hexmask.long 0x00 0.--31. 1. " JS2COMMAND_NEXT        ,   Added SUSPEND and RESUME commands to job chain  COMMAND register."

group d:0xC0501970++0x03
    line.long 0x00 "JS2_FLUSH_ID_NEXT,   This register contains the value to be transferred into the JS  n _FLUSH_ID register when the next job chain starts. See FLUSH_ID for details."
        hexmask.long 0x00 0.--31. 1. " JS2FLUSH_ID_NEXT       ,   When operating in 'cache flush reduction' mode, each job chain has an associated ID which is used to identify cache flushes.  This ID is a sequential 32-bit value. When the job manager is asked to perform a flush, it compares the job chain flush ID with the latest flush ID. If the job chain ID is greater than the latest flush, then a flush is performed.  Care must be taken in the overflow case. If the software setting up the ID detects that an overflow may occur, the job chain should be tagged with the maximum value of the  LATEST_FLUSH register. This ensures that flushes are correctly performed, at the possible cost of a few redundant flushes. Added cache flush reduction "

group d:0xC050197C++0x03
    line.long 0x00 "JS2_EVENT_MASK_NEXT,   This register contains the value to be transferred into the JS  n _EVENT_MASK register when the next job chain starts. See EVENT_MASK for details."
        hexmask.long 0x00 0.--31. 1. " JS2EVENT_MASK_NEXT     ,JS2EVENT_MASK_NEXT"

width 20.

group d:0xC0502000++0x03
    line.long 0x00 "ST1MMU_IRQ_RAWSTAT,   This register contains the raw unmasked interrupt sources for MMU status and exception handling.  Writing to this register may force bits on, but will not clear them.      The new state for a bit corresponding to an existing address space is the logical OR of the previous state and the written value, except     that bits corresponding to address spaces which do not exist will ignore writes and consistently read 0.  Writing a zero to a bit will have no effect. Use the IRQ_CLEAR register to clear interrupts.  Clarified that bits in MMU IRQ_RAWSTAT are dependent on existence of address spaces. "
        hexmask.long.word 0x00 0.--15. 1. " PAGE_FAULT ,PAGE_FAULT"
        hexmask.long.word 0x00 16.--31. 1. "  BUS_ERROR ,BUS_ERROR"

group d:0xC0502004++0x03
    line.long 0x00 "ST1MMU_IRQ_CLEAR,   This register has the same layout as  IRQ_RAWSTAT . Write a one to a bit in this register to clear the corresponding bit in IRQ_RAWSTAT. As for  IRQ_RAWSTAT , bits corresponding to address spaces which do not exist will ignore writes and consistently read 0."
        hexmask.long.word 0x00 0.--15. 1. " PAGE_FAULT ,PAGE_FAULT"
        hexmask.long.word 0x00 16.--31. 1. "  BUS_ERROR ,BUS_ERROR"

group d:0xC0502008++0x03
    line.long 0x00 "ST1MMU_IRQ_MASK,   This register has the same layout as  IRQ_RAWSTAT . Set each bit in this to one to enable the corresponding interrupt source, and to zero to disable it. As for  IRQ_RAWSTAT , bits corresponding to address spaces which do not exist will ignore writes and consistently read 0."
        hexmask.long.word 0x00 0.--15. 1. " PAGE_FAULT ,PAGE_FAULT"
        hexmask.long.word 0x00 16.--31. 1. "  BUS_ERROR ,BUS_ERROR"

group d:0xC050200C++0x03
    line.long 0x00 "ST1MMU_IRQ_STATUS,   This register has the same layout as  IRQ_RAWSTAT . This register contains the result of anding together IRQ_RAWSTAT and IRQ_MASK. If any bits in this register are set, the external GPU control interrupt line is asserted, signaling an interrupt request to the CPU."
        hexmask.long.word 0x00 0.--15. 1. " PAGE_FAULT ,PAGE_FAULT"
        hexmask.long.word 0x00 16.--31. 1. "  BUS_ERROR ,BUS_ERROR"

width 27.

group d:0xC0502400++0x03
    line.long 0x00 "ST1MMUAS0_TRANSTAB_LO,   This register contains the address of the base level of the translation table, together with some related flags.  Details on the layout of the page tables, and the address translation process, can be found in the section  Memory Management Unit ."
        bitfld.long 0x00 0.--3. " Res98                    ,Res98" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        hexmask.long 0x00 4.--31. 1. "           ST1MMUAS0TRANSTAB_LO   ,   This field contains the address of the top level of a page table structure. This must be 16-byte-aligned, so address bits [3:0] are assumed to be zero.  For a stage 1 page table, this will be an intermediate physical address, and for stage 2 it will be a physical address. The number of actual translated address bits is stored in  OUTA_BITS . The unused high bits must be set to 0. Changed alignment text for TRANSTAB.BASE  TRANSTAB.BASE pointer is a physical (or intermediate) address "

group d:0xC0502404++0x03
    line.long 0x00 "ST1MMUAS0_TRANSTAB_HI,   This register contains the address of the base level of the translation table, together with some related flags.  Details on the layout of the page tables, and the address translation process, can be found in the section  Memory Management Unit ."
        hexmask.long 0x00 0.--31. 1. " ST1MMUAS0TRANSTAB_HI     ,   This field contains the address of the top level of a page table structure. This must be 16-byte-aligned, so address bits [3:0] are assumed to be zero.  For a stage 1 page table, this will be an intermediate physical address, and for stage 2 it will be a physical address. The number of actual translated address bits is stored in  OUTA_BITS . The unused high bits must be set to 0. Changed alignment text for TRANSTAB.BASE  TRANSTAB.BASE pointer is a physical (or intermediate) address "

group d:0xC0502408++0x03
    line.long 0x00 "ST1MMUAS0_MEMATTR_LO,"
        bitfld.long 0x00 0.--3. " ATTRIBUTE0               ,   This field specifies the memory attributes for memory type index 0. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 4.--7. "       ATTRIBUTE1             ,   This field specifies the memory attributes for memory type index 1. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 8.--11. "         ATTRIBUTE2           ,   This field specifies the memory attributes for memory type index 2. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 12.--15. "           ATTRIBUTE3       ,   This field specifies the memory attributes for memory type index 3. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        textline "                                     "
        bitfld.long 0x00 16.--19. "ATTRIBUTE4               ,   This field specifies the memory attributes for memory type index 4. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 20.--23. "       ATTRIBUTE5             ,   This field specifies the memory attributes for memory type index 5. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 24.--27. "         ATTRIBUTE6           ,   This field specifies the memory attributes for memory type index 6. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 28.--31. "           ATTRIBUTE7       ,   This field specifies the memory attributes for memory type index 7. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"

group d:0xC050240C++0x03
    line.long 0x00 "ST1MMUAS0_MEMATTR_HI,"
        bitfld.long 0x00 0.--3. " ATTRIBUTE8               ,   This field specifies the memory attributes for memory type index 8. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 4.--7. "       ATTRIBUTE9             ,   This field specifies the memory attributes for memory type index 9. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 8.--11. "         ATTRIBUTE10          ,   This field specifies the memory attributes for memory type index 10. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 12.--15. "           ATTRIBUTE11      ,   This field specifies the memory attributes for memory type index 11. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        textline "                                     "
        bitfld.long 0x00 16.--19. "ATTRIBUTE12              ,   This field specifies the memory attributes for memory type index 12. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 20.--23. "       ATTRIBUTE13            ,   This field specifies the memory attributes for memory type index 13. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 24.--27. "         ATTRIBUTE14          ,   This field specifies the memory attributes for memory type index 14. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 28.--31. "           ATTRIBUTE15      ,   This field specifies the memory attributes for memory type index 15. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"

group d:0xC0502410++0x03
    line.long 0x00 "ST1MMUAS0_LOCKADDR_LO,   This register tells the MMU to lock a region of virtual memory. All page mappings within this region must be flushed, and no translation requests within this region can complete or fault before the area is unlocked.  Only one region can be locked at a time.  As only 32 bits of the register can be written to at a time, no changes are issued until the LOCK command is written to the COMMAND register. "
        hexmask.long.byte 0x00 6.--11. 1. " Res99                    ,Res99"
        hexmask.long.byte 0x00 0.--5. 1. "           LOCKADDR_SIZE          ,   This field contains the log  2 of the size of the region to lock, minus 1. Only values in the range 11 to 63 are valid values for this field, corresponding to region sizes of 4KB up to the entire address space. Values in the range 0 to 10 result in UNDEFINED behavior and should not be used."
        hexmask.long.tbyte 0x00 12.--31. 1. "             ST1MMUAS0LOCKADDR_LO ,   This field contains the lowest address in the region to be locked. The address is a virtual address in this address space.  Only the upper bits of the address are used. The address is aligned to a multiple of the region size, so a variable number of low-order bits are ignored, depending on the selected region size. It is recommended that software ensures that these low bits in the address are cleared, to avoid confusion. "

group d:0xC0502414++0x03
    line.long 0x00 "ST1MMUAS0_LOCKADDR_HI,   This register tells the MMU to lock a region of virtual memory. All page mappings within this region must be flushed, and no translation requests within this region can complete or fault before the area is unlocked.  Only one region can be locked at a time.  As only 32 bits of the register can be written to at a time, no changes are issued until the LOCK command is written to the COMMAND register. "
        hexmask.long 0x00 0.--31. 1. " ST1MMUAS0LOCKADDR_HI     ,   This field contains the lowest address in the region to be locked. The address is a virtual address in this address space.  Only the upper bits of the address are used. The address is aligned to a multiple of the region size, so a variable number of low-order bits are ignored, depending on the selected region size. It is recommended that software ensures that these low bits in the address are cleared, to avoid confusion. "

group d:0xC0502418++0x03
    line.long 0x00 "ST1MMUAS0_COMMAND,   MMU commands are issued by writing to this register. Any command written to an address space while the corresponding STATUS.AS_ACTIVE flag is set will be ignored.  In general an MMU command only applies to the address space it is submitted to. However a command that invalidates the MMU cache may invalidate the whole MMU cache rather than only those entries specific to one address space. "
        hexmask.long 0x00 0.--31. 1. " ST1MMUAS0COMMAND         ,ST1MMUAS0COMMAND"

group d:0xC050241C++0x03
    line.long 0x00 "ST1MMUAS0_FAULTSTATUS,   This register contains extended status information after a fault. If read before a fault occurs, its contents are the reset value, 0, which indicates no fault.       If multiple faults occur before the first is handled, the subsequent faults are ignored. They may fault again after handling the first one.  If the GPU is in protected mode, this register is not updated, and MMU faults are ignored.        They are not fatal but will halt the GPU until the MMU address space is updated.        However, no fault information wil be visible in this case.  Changed access type of MMU_FAULTSTATUS register when in protected mode. "
        hexmask.long.byte 0x00 10.--15. 1. " Res100                   ,Res100"
        hexmask.long.word 0x00 16.--31. 1. "           SOURCE_ID              ,   This field contains an implementation-defined ID that supplies additional data about the source of the fault. For example, it may be the ID of the internal bus master that issued the request that faulted. This makes it possible to distinguish between the job manager, the texture unit and the load/store unit. Another example might be an indication of the type of an invalid data structure. The values in this field are implementation defined. "
        hexmask.long.byte 0x00 0.--7. 1. "           EXCEPTION_TYPE       ,   This field indicates the type of exception that caused the fault. "
        bitfld.long 0x00 8.--9. "               ACCESS_TYPE      ,   This field contains the direction of data transfer that caused the fault, if known.  For the purposes of error reporting, atomic transactions act like a read followed by a write, so denying either permission will result in the atomic transaction failing, and the exceptions ACCESS_TYPE field will be set to 'atomic'. " "atomic,execute:  An execute transaction. ,read:  A read transaction. ,write:  A write transaction. "

group d:0xC0502420++0x03
    line.long 0x00 "ST1MMUAS0_FAULTADDRESS_LO,   This register contains information about the cause of a page fault or bus error. "
        hexmask.long 0x00 0.--31. 1. " ST1MMUAS0FAULTADDRESS_LO ,   This field contains the virtual address (in this address space) of the access that caused the fault.  Additional information about the fault is also available in the FAULTSTATUS register.  If multiple faults occur before the first is handled, the subsequent faults are ignored. They may fault again after handling the first one. "

group d:0xC0502424++0x03
    line.long 0x00 "ST1MMUAS0_FAULTADDRESS_HI,   This register contains information about the cause of a page fault or bus error. "
        hexmask.long 0x00 0.--31. 1. " ST1MMUAS0FAULTADDRESS_HI ,   This field contains the virtual address (in this address space) of the access that caused the fault.  Additional information about the fault is also available in the FAULTSTATUS register.  If multiple faults occur before the first is handled, the subsequent faults are ignored. They may fault again after handling the first one. "

group d:0xC0502428++0x03
    line.long 0x00 "ST1MMUAS0_STATUS,   This register contains dynamic status information about this address space. "
        hexmask.long 0x00 1.--31. 1. " Res101                   ,Res101"
        bitfld.long 0x00 0. "     AS_ACTIVE              ,   This flag is set while a MMU_UPDATE, LOCK, UNLOCK, FLUSH_PT or FLUSH_MEM command is active on this address space. This allows software to safely verify that the address space is in a consistent state after reconfiguring the MMU page tables.  If a new command is written to the corresponding COMMAND register while the AS_ACTIVE bit is set, then the command is ignored. " "false,true"

group d:0xC0502430++0x03
    line.long 0x00 "ST1MMUAS0_TRANSCFG_LO,ST1MMUAS0_TRANSCFG_LO"
        bitfld.long 0x00 4.--5. " Res102                   ,Res102" "0,1,2,3"
        bitfld.long 0x00 11.--13. "            Res103                 ,Res103" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 19.--21. "              Res104               ,Res104" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 23. "                Res105           ,Res105" "0,1"
        textline "                                     "
        bitfld.long 0x00 26.--27. "Res106                   ,Res106" "0,1,2,3"
        bitfld.long 0x00 31. "            Res107                 ,Res107" "0,1"
        bitfld.long 0x00 6.--10. "              INA_BITS             ,   This field allows the system software to restrict the range of input addresses accepted by this translation stage. This is used in conjunction with the hardware limits to determine the valid address range as follows:  INA_BITS_VALID = min(HW_INA_BITS, 55-INA_BITS)  If the input address is outside the range (0, 2  INA_BITS_VALID -1), then a TRANSLATION_FAULT error is generated." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"
        bitfld.long 0x00 14.--18. "               OUTA_BITS        ,   This field allows the system software to restrict the range of output addresses generated by this translation stage. This is used in conjunction with the hardware limits to determine the valid address range as follows:  OUTA_BITS_VALID = min(HW_OUTA_BITS, 55-OUTA_BITS)  If the translated output address is outside the range (0, 2  OUTA_BITS_VALID -1), then a TRANSLATION_FAULT error is generated." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"
        textline "                                     "
        bitfld.long 0x00 0.--3. "MODE                     ,   This field controls the overall operation of the MMU. There are some differences between stage 1 and stage 2.  Execute permissions for a page are evaluated as follows (PTE.&lt;W|R|X> refers to page table entry permissions resolved for hierarchical permissions (if applicable):  EXECUTE_ALLOWED = !((TRANSCFG.WXN &amp; !PTE.W) | (TRANSCFG.XREADABLE &amp; !PTE.R) | (!TRANSCFG.XREADABLE &amp; !PTE.X)) " "LEGACY,UNMAPPED,IDENTITY,3,4,5,AARCH64_4K,7,AARCH64_64K,9,10,11,12,13,14,15"
        bitfld.long 0x00 24.--25. "  PTW_MEMATTR            ,   Memory attributes for page table walks. The allowed values are compatible with the values allowed for  MEMORY_TYPE . For outer cache transactions, the desired attributes for the transaction will be decided by the bus master and communicated to the memory system using signals on the bus.  Changed allowed values for TRANSCFG.PTW_MEMATTR. " "0,NON_CACHEABLE,WRITE_BACK,3"
        bitfld.long 0x00 28.--29. "  PTW_SH               ,   This field specifies the shareability for the page table walks. This is the same encoding as used for ARMv8 page tables. " "non_shareable,1,outer_shareable,inner_shareable"
        bitfld.long 0x00 30. "  R_ALLOCATE       ,   This field sets the inner read allocation hint for the page table walks. This is the same encoding as used for ARMv8 page tables. " "no_read_allocate,read_allocate"
        textline "                                     "
        bitfld.long 0x00 22. "SL_CONCAT_EN             ,   If set then the page table walk starting level will be increased if possible by concatenating up to 16 tables in the starting level. " "false,true"

group d:0xC0502434++0x03
    line.long 0x00 "ST1MMUAS0_TRANSCFG_HI,ST1MMUAS0_TRANSCFG_HI"
        bitfld.long 0x00 0. " Res108                   ,Res108" "0,1"
        hexmask.long 0x00 5.--31. 1. "            Res109                 ,Res109"
        bitfld.long 0x00 1. "       DISABLE_HIER_AP      ,   This flag only has an effect on stage 1 of translation. It is ignored for stage 2. Note the inverted logic - the flag must be set to  dis able hierarchical access permissions." "false,true"
        bitfld.long 0x00 2. "            DISABLE_AF_FAULT ,   This flag can be used to disable access fault checking when in one of AARCH64 modes. " "false,true"
        textline "                                     "
        bitfld.long 0x00 3. "WXN                      ,   This flag can be used to disable all writes to executable pages, overriding access permissions specified in the page table. " "false,true"
        bitfld.long 0x00 4. "        XREADABLE              ,   This flag can be used to enable execution on all readable pages, overriding access permissions specified in the page table. " "false,true"

group d:0xC0502438++0x03
    line.long 0x00 "ST1MMUAS0_FAULTEXTRA_LO,   This register contains additional information about the cause of a page fault or bus error. "
        hexmask.long 0x00 0.--31. 1. " ST1MMUAS0FAULTEXTRA_LO   ,   This field contains the virtual address (in this address space) of the access that caused the fault.  Additional information about the fault is also available in the  FAULTSTATUS and FAULTADDRESS registers. If multiple faults occur before the first is handled, the subsequent faults are ignored. They may fault again after handling the first one.  Fixed duplicate state name in FAULT_ADDRESS - exposes previously hidden field S2FS1WALK. "

group d:0xC050243C++0x03
    line.long 0x00 "ST1MMUAS0_FAULTEXTRA_HI,   This register contains additional information about the cause of a page fault or bus error. "
        hexmask.long.word 0x00 16.--30. 1. " Res110                   ,Res110"
        hexmask.long.word 0x00 0.--15. 1. "         ST1MMUAS0FAULTEXTRA_HI ,   This field contains the virtual address (in this address space) of the access that caused the fault.  Additional information about the fault is also available in the  FAULTSTATUS and FAULTADDRESS registers. If multiple faults occur before the first is handled, the subsequent faults are ignored. They may fault again after handling the first one.  Fixed duplicate state name in FAULT_ADDRESS - exposes previously hidden field S2FS1WALK. "
        bitfld.long 0x00 31. "           S2FS1WALK            ,S2FS1WALK" "stage2,stage1"

width 27.

group d:0xC0502440++0x03
    line.long 0x00 "ST1MMUAS1_TRANSTAB_LO,   This register contains the address of the base level of the translation table, together with some related flags.  Details on the layout of the page tables, and the address translation process, can be found in the section  Memory Management Unit ."
        bitfld.long 0x00 0.--3. " Res111                   ,Res111" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        hexmask.long 0x00 4.--31. 1. "           ST1MMUAS1TRANSTAB_LO   ,   This field contains the address of the top level of a page table structure. This must be 16-byte-aligned, so address bits [3:0] are assumed to be zero.  For a stage 1 page table, this will be an intermediate physical address, and for stage 2 it will be a physical address. The number of actual translated address bits is stored in  OUTA_BITS . The unused high bits must be set to 0. Changed alignment text for TRANSTAB.BASE  TRANSTAB.BASE pointer is a physical (or intermediate) address "

group d:0xC0502444++0x03
    line.long 0x00 "ST1MMUAS1_TRANSTAB_HI,   This register contains the address of the base level of the translation table, together with some related flags.  Details on the layout of the page tables, and the address translation process, can be found in the section  Memory Management Unit ."
        hexmask.long 0x00 0.--31. 1. " ST1MMUAS1TRANSTAB_HI     ,   This field contains the address of the top level of a page table structure. This must be 16-byte-aligned, so address bits [3:0] are assumed to be zero.  For a stage 1 page table, this will be an intermediate physical address, and for stage 2 it will be a physical address. The number of actual translated address bits is stored in  OUTA_BITS . The unused high bits must be set to 0. Changed alignment text for TRANSTAB.BASE  TRANSTAB.BASE pointer is a physical (or intermediate) address "

group d:0xC0502448++0x03
    line.long 0x00 "ST1MMUAS1_MEMATTR_LO,"
        bitfld.long 0x00 0.--3. " ATTRIBUTE0               ,   This field specifies the memory attributes for memory type index 0. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 4.--7. "       ATTRIBUTE1             ,   This field specifies the memory attributes for memory type index 1. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 8.--11. "         ATTRIBUTE2           ,   This field specifies the memory attributes for memory type index 2. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 12.--15. "           ATTRIBUTE3       ,   This field specifies the memory attributes for memory type index 3. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        textline "                                     "
        bitfld.long 0x00 16.--19. "ATTRIBUTE4               ,   This field specifies the memory attributes for memory type index 4. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 20.--23. "       ATTRIBUTE5             ,   This field specifies the memory attributes for memory type index 5. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 24.--27. "         ATTRIBUTE6           ,   This field specifies the memory attributes for memory type index 6. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 28.--31. "           ATTRIBUTE7       ,   This field specifies the memory attributes for memory type index 7. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"

group d:0xC050244C++0x03
    line.long 0x00 "ST1MMUAS1_MEMATTR_HI,"
        bitfld.long 0x00 0.--3. " ATTRIBUTE8               ,   This field specifies the memory attributes for memory type index 8. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 4.--7. "       ATTRIBUTE9             ,   This field specifies the memory attributes for memory type index 9. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 8.--11. "         ATTRIBUTE10          ,   This field specifies the memory attributes for memory type index 10. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 12.--15. "           ATTRIBUTE11      ,   This field specifies the memory attributes for memory type index 11. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        textline "                                     "
        bitfld.long 0x00 16.--19. "ATTRIBUTE12              ,   This field specifies the memory attributes for memory type index 12. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 20.--23. "       ATTRIBUTE13            ,   This field specifies the memory attributes for memory type index 13. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 24.--27. "         ATTRIBUTE14          ,   This field specifies the memory attributes for memory type index 14. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 28.--31. "           ATTRIBUTE15      ,   This field specifies the memory attributes for memory type index 15. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"

group d:0xC0502450++0x03
    line.long 0x00 "ST1MMUAS1_LOCKADDR_LO,   This register tells the MMU to lock a region of virtual memory. All page mappings within this region must be flushed, and no translation requests within this region can complete or fault before the area is unlocked.  Only one region can be locked at a time.  As only 32 bits of the register can be written to at a time, no changes are issued until the LOCK command is written to the COMMAND register. "
        hexmask.long.byte 0x00 6.--11. 1. " Res112                   ,Res112"
        hexmask.long.byte 0x00 0.--5. 1. "           LOCKADDR_SIZE          ,   This field contains the log  2 of the size of the region to lock, minus 1. Only values in the range 11 to 63 are valid values for this field, corresponding to region sizes of 4KB up to the entire address space. Values in the range 0 to 10 result in UNDEFINED behavior and should not be used."
        hexmask.long.tbyte 0x00 12.--31. 1. "             ST1MMUAS1LOCKADDR_LO ,   This field contains the lowest address in the region to be locked. The address is a virtual address in this address space.  Only the upper bits of the address are used. The address is aligned to a multiple of the region size, so a variable number of low-order bits are ignored, depending on the selected region size. It is recommended that software ensures that these low bits in the address are cleared, to avoid confusion. "

group d:0xC0502454++0x03
    line.long 0x00 "ST1MMUAS1_LOCKADDR_HI,   This register tells the MMU to lock a region of virtual memory. All page mappings within this region must be flushed, and no translation requests within this region can complete or fault before the area is unlocked.  Only one region can be locked at a time.  As only 32 bits of the register can be written to at a time, no changes are issued until the LOCK command is written to the COMMAND register. "
        hexmask.long 0x00 0.--31. 1. " ST1MMUAS1LOCKADDR_HI     ,   This field contains the lowest address in the region to be locked. The address is a virtual address in this address space.  Only the upper bits of the address are used. The address is aligned to a multiple of the region size, so a variable number of low-order bits are ignored, depending on the selected region size. It is recommended that software ensures that these low bits in the address are cleared, to avoid confusion. "

group d:0xC0502458++0x03
    line.long 0x00 "ST1MMUAS1_COMMAND,   MMU commands are issued by writing to this register. Any command written to an address space while the corresponding STATUS.AS_ACTIVE flag is set will be ignored.  In general an MMU command only applies to the address space it is submitted to. However a command that invalidates the MMU cache may invalidate the whole MMU cache rather than only those entries specific to one address space. "
        hexmask.long 0x00 0.--31. 1. " ST1MMUAS1COMMAND         ,ST1MMUAS1COMMAND"

group d:0xC050245C++0x03
    line.long 0x00 "ST1MMUAS1_FAULTSTATUS,   This register contains extended status information after a fault. If read before a fault occurs, its contents are the reset value, 0, which indicates no fault.       If multiple faults occur before the first is handled, the subsequent faults are ignored. They may fault again after handling the first one.  If the GPU is in protected mode, this register is not updated, and MMU faults are ignored.        They are not fatal but will halt the GPU until the MMU address space is updated.        However, no fault information wil be visible in this case.  Changed access type of MMU_FAULTSTATUS register when in protected mode. "
        hexmask.long.byte 0x00 10.--15. 1. " Res113                   ,Res113"
        hexmask.long.word 0x00 16.--31. 1. "           SOURCE_ID              ,   This field contains an implementation-defined ID that supplies additional data about the source of the fault. For example, it may be the ID of the internal bus master that issued the request that faulted. This makes it possible to distinguish between the job manager, the texture unit and the load/store unit. Another example might be an indication of the type of an invalid data structure. The values in this field are implementation defined. "
        hexmask.long.byte 0x00 0.--7. 1. "           EXCEPTION_TYPE       ,   This field indicates the type of exception that caused the fault. "
        bitfld.long 0x00 8.--9. "               ACCESS_TYPE      ,   This field contains the direction of data transfer that caused the fault, if known.  For the purposes of error reporting, atomic transactions act like a read followed by a write, so denying either permission will result in the atomic transaction failing, and the exceptions ACCESS_TYPE field will be set to 'atomic'. " "atomic,execute:  An execute transaction. ,read:  A read transaction. ,write:  A write transaction. "

group d:0xC0502460++0x03
    line.long 0x00 "ST1MMUAS1_FAULTADDRESS_LO,   This register contains information about the cause of a page fault or bus error. "
        hexmask.long 0x00 0.--31. 1. " ST1MMUAS1FAULTADDRESS_LO ,   This field contains the virtual address (in this address space) of the access that caused the fault.  Additional information about the fault is also available in the FAULTSTATUS register.  If multiple faults occur before the first is handled, the subsequent faults are ignored. They may fault again after handling the first one. "

group d:0xC0502464++0x03
    line.long 0x00 "ST1MMUAS1_FAULTADDRESS_HI,   This register contains information about the cause of a page fault or bus error. "
        hexmask.long 0x00 0.--31. 1. " ST1MMUAS1FAULTADDRESS_HI ,   This field contains the virtual address (in this address space) of the access that caused the fault.  Additional information about the fault is also available in the FAULTSTATUS register.  If multiple faults occur before the first is handled, the subsequent faults are ignored. They may fault again after handling the first one. "

group d:0xC0502468++0x03
    line.long 0x00 "ST1MMUAS1_STATUS,   This register contains dynamic status information about this address space. "
        hexmask.long 0x00 1.--31. 1. " Res114                   ,Res114"
        bitfld.long 0x00 0. "     AS_ACTIVE              ,   This flag is set while a MMU_UPDATE, LOCK, UNLOCK, FLUSH_PT or FLUSH_MEM command is active on this address space. This allows software to safely verify that the address space is in a consistent state after reconfiguring the MMU page tables.  If a new command is written to the corresponding COMMAND register while the AS_ACTIVE bit is set, then the command is ignored. " "false,true"

group d:0xC0502470++0x03
    line.long 0x00 "ST1MMUAS1_TRANSCFG_LO,ST1MMUAS1_TRANSCFG_LO"
        bitfld.long 0x00 4.--5. " Res115                   ,Res115" "0,1,2,3"
        bitfld.long 0x00 11.--13. "            Res116                 ,Res116" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 19.--21. "              Res117               ,Res117" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 23. "                Res118           ,Res118" "0,1"
        textline "                                     "
        bitfld.long 0x00 26.--27. "Res119                   ,Res119" "0,1,2,3"
        bitfld.long 0x00 31. "            Res120                 ,Res120" "0,1"
        bitfld.long 0x00 6.--10. "              INA_BITS             ,   This field allows the system software to restrict the range of input addresses accepted by this translation stage. This is used in conjunction with the hardware limits to determine the valid address range as follows:  INA_BITS_VALID = min(HW_INA_BITS, 55-INA_BITS)  If the input address is outside the range (0, 2  INA_BITS_VALID -1), then a TRANSLATION_FAULT error is generated." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"
        bitfld.long 0x00 14.--18. "               OUTA_BITS        ,   This field allows the system software to restrict the range of output addresses generated by this translation stage. This is used in conjunction with the hardware limits to determine the valid address range as follows:  OUTA_BITS_VALID = min(HW_OUTA_BITS, 55-OUTA_BITS)  If the translated output address is outside the range (0, 2  OUTA_BITS_VALID -1), then a TRANSLATION_FAULT error is generated." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"
        textline "                                     "
        bitfld.long 0x00 0.--3. "MODE                     ,   This field controls the overall operation of the MMU. There are some differences between stage 1 and stage 2.  Execute permissions for a page are evaluated as follows (PTE.&lt;W|R|X> refers to page table entry permissions resolved for hierarchical permissions (if applicable):  EXECUTE_ALLOWED = !((TRANSCFG.WXN &amp; !PTE.W) | (TRANSCFG.XREADABLE &amp; !PTE.R) | (!TRANSCFG.XREADABLE &amp; !PTE.X)) " "LEGACY,UNMAPPED,IDENTITY,3,4,5,AARCH64_4K,7,AARCH64_64K,9,10,11,12,13,14,15"
        bitfld.long 0x00 24.--25. "  PTW_MEMATTR            ,   Memory attributes for page table walks. The allowed values are compatible with the values allowed for  MEMORY_TYPE . For outer cache transactions, the desired attributes for the transaction will be decided by the bus master and communicated to the memory system using signals on the bus.  Changed allowed values for TRANSCFG.PTW_MEMATTR. " "0,NON_CACHEABLE,WRITE_BACK,3"
        bitfld.long 0x00 28.--29. "  PTW_SH               ,   This field specifies the shareability for the page table walks. This is the same encoding as used for ARMv8 page tables. " "non_shareable,1,outer_shareable,inner_shareable"
        bitfld.long 0x00 30. "  R_ALLOCATE       ,   This field sets the inner read allocation hint for the page table walks. This is the same encoding as used for ARMv8 page tables. " "no_read_allocate,read_allocate"
        textline "                                     "
        bitfld.long 0x00 22. "SL_CONCAT_EN             ,   If set then the page table walk starting level will be increased if possible by concatenating up to 16 tables in the starting level. " "false,true"

group d:0xC0502474++0x03
    line.long 0x00 "ST1MMUAS1_TRANSCFG_HI,ST1MMUAS1_TRANSCFG_HI"
        bitfld.long 0x00 0. " Res121                   ,Res121" "0,1"
        hexmask.long 0x00 5.--31. 1. "            Res122                 ,Res122"
        bitfld.long 0x00 1. "       DISABLE_HIER_AP      ,   This flag only has an effect on stage 1 of translation. It is ignored for stage 2. Note the inverted logic - the flag must be set to  dis able hierarchical access permissions." "false,true"
        bitfld.long 0x00 2. "            DISABLE_AF_FAULT ,   This flag can be used to disable access fault checking when in one of AARCH64 modes. " "false,true"
        textline "                                     "
        bitfld.long 0x00 3. "WXN                      ,   This flag can be used to disable all writes to executable pages, overriding access permissions specified in the page table. " "false,true"
        bitfld.long 0x00 4. "        XREADABLE              ,   This flag can be used to enable execution on all readable pages, overriding access permissions specified in the page table. " "false,true"

group d:0xC0502478++0x03
    line.long 0x00 "ST1MMUAS1_FAULTEXTRA_LO,   This register contains additional information about the cause of a page fault or bus error. "
        hexmask.long 0x00 0.--31. 1. " ST1MMUAS1FAULTEXTRA_LO   ,   This field contains the virtual address (in this address space) of the access that caused the fault.  Additional information about the fault is also available in the  FAULTSTATUS and FAULTADDRESS registers. If multiple faults occur before the first is handled, the subsequent faults are ignored. They may fault again after handling the first one.  Fixed duplicate state name in FAULT_ADDRESS - exposes previously hidden field S2FS1WALK. "

group d:0xC050247C++0x03
    line.long 0x00 "ST1MMUAS1_FAULTEXTRA_HI,   This register contains additional information about the cause of a page fault or bus error. "
        hexmask.long.word 0x00 16.--30. 1. " Res123                   ,Res123"
        hexmask.long.word 0x00 0.--15. 1. "         ST1MMUAS1FAULTEXTRA_HI ,   This field contains the virtual address (in this address space) of the access that caused the fault.  Additional information about the fault is also available in the  FAULTSTATUS and FAULTADDRESS registers. If multiple faults occur before the first is handled, the subsequent faults are ignored. They may fault again after handling the first one.  Fixed duplicate state name in FAULT_ADDRESS - exposes previously hidden field S2FS1WALK. "
        bitfld.long 0x00 31. "           S2FS1WALK            ,S2FS1WALK" "stage2,stage1"

width 27.

group d:0xC0502480++0x03
    line.long 0x00 "ST1MMUAS2_TRANSTAB_LO,   This register contains the address of the base level of the translation table, together with some related flags.  Details on the layout of the page tables, and the address translation process, can be found in the section  Memory Management Unit ."
        bitfld.long 0x00 0.--3. " Res124                   ,Res124" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        hexmask.long 0x00 4.--31. 1. "           ST1MMUAS2TRANSTAB_LO   ,   This field contains the address of the top level of a page table structure. This must be 16-byte-aligned, so address bits [3:0] are assumed to be zero.  For a stage 1 page table, this will be an intermediate physical address, and for stage 2 it will be a physical address. The number of actual translated address bits is stored in  OUTA_BITS . The unused high bits must be set to 0. Changed alignment text for TRANSTAB.BASE  TRANSTAB.BASE pointer is a physical (or intermediate) address "

group d:0xC0502484++0x03
    line.long 0x00 "ST1MMUAS2_TRANSTAB_HI,   This register contains the address of the base level of the translation table, together with some related flags.  Details on the layout of the page tables, and the address translation process, can be found in the section  Memory Management Unit ."
        hexmask.long 0x00 0.--31. 1. " ST1MMUAS2TRANSTAB_HI     ,   This field contains the address of the top level of a page table structure. This must be 16-byte-aligned, so address bits [3:0] are assumed to be zero.  For a stage 1 page table, this will be an intermediate physical address, and for stage 2 it will be a physical address. The number of actual translated address bits is stored in  OUTA_BITS . The unused high bits must be set to 0. Changed alignment text for TRANSTAB.BASE  TRANSTAB.BASE pointer is a physical (or intermediate) address "

group d:0xC0502488++0x03
    line.long 0x00 "ST1MMUAS2_MEMATTR_LO,"
        bitfld.long 0x00 0.--3. " ATTRIBUTE0               ,   This field specifies the memory attributes for memory type index 0. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 4.--7. "       ATTRIBUTE1             ,   This field specifies the memory attributes for memory type index 1. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 8.--11. "         ATTRIBUTE2           ,   This field specifies the memory attributes for memory type index 2. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 12.--15. "           ATTRIBUTE3       ,   This field specifies the memory attributes for memory type index 3. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        textline "                                     "
        bitfld.long 0x00 16.--19. "ATTRIBUTE4               ,   This field specifies the memory attributes for memory type index 4. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 20.--23. "       ATTRIBUTE5             ,   This field specifies the memory attributes for memory type index 5. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 24.--27. "         ATTRIBUTE6           ,   This field specifies the memory attributes for memory type index 6. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 28.--31. "           ATTRIBUTE7       ,   This field specifies the memory attributes for memory type index 7. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"

group d:0xC050248C++0x03
    line.long 0x00 "ST1MMUAS2_MEMATTR_HI,"
        bitfld.long 0x00 0.--3. " ATTRIBUTE8               ,   This field specifies the memory attributes for memory type index 8. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 4.--7. "       ATTRIBUTE9             ,   This field specifies the memory attributes for memory type index 9. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 8.--11. "         ATTRIBUTE10          ,   This field specifies the memory attributes for memory type index 10. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 12.--15. "           ATTRIBUTE11      ,   This field specifies the memory attributes for memory type index 11. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        textline "                                     "
        bitfld.long 0x00 16.--19. "ATTRIBUTE12              ,   This field specifies the memory attributes for memory type index 12. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 20.--23. "       ATTRIBUTE13            ,   This field specifies the memory attributes for memory type index 13. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 24.--27. "         ATTRIBUTE14          ,   This field specifies the memory attributes for memory type index 14. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 28.--31. "           ATTRIBUTE15      ,   This field specifies the memory attributes for memory type index 15. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"

group d:0xC0502490++0x03
    line.long 0x00 "ST1MMUAS2_LOCKADDR_LO,   This register tells the MMU to lock a region of virtual memory. All page mappings within this region must be flushed, and no translation requests within this region can complete or fault before the area is unlocked.  Only one region can be locked at a time.  As only 32 bits of the register can be written to at a time, no changes are issued until the LOCK command is written to the COMMAND register. "
        hexmask.long.byte 0x00 6.--11. 1. " Res125                   ,Res125"
        hexmask.long.byte 0x00 0.--5. 1. "           LOCKADDR_SIZE          ,   This field contains the log  2 of the size of the region to lock, minus 1. Only values in the range 11 to 63 are valid values for this field, corresponding to region sizes of 4KB up to the entire address space. Values in the range 0 to 10 result in UNDEFINED behavior and should not be used."
        hexmask.long.tbyte 0x00 12.--31. 1. "             ST1MMUAS2LOCKADDR_LO ,   This field contains the lowest address in the region to be locked. The address is a virtual address in this address space.  Only the upper bits of the address are used. The address is aligned to a multiple of the region size, so a variable number of low-order bits are ignored, depending on the selected region size. It is recommended that software ensures that these low bits in the address are cleared, to avoid confusion. "

group d:0xC0502494++0x03
    line.long 0x00 "ST1MMUAS2_LOCKADDR_HI,   This register tells the MMU to lock a region of virtual memory. All page mappings within this region must be flushed, and no translation requests within this region can complete or fault before the area is unlocked.  Only one region can be locked at a time.  As only 32 bits of the register can be written to at a time, no changes are issued until the LOCK command is written to the COMMAND register. "
        hexmask.long 0x00 0.--31. 1. " ST1MMUAS2LOCKADDR_HI     ,   This field contains the lowest address in the region to be locked. The address is a virtual address in this address space.  Only the upper bits of the address are used. The address is aligned to a multiple of the region size, so a variable number of low-order bits are ignored, depending on the selected region size. It is recommended that software ensures that these low bits in the address are cleared, to avoid confusion. "

group d:0xC0502498++0x03
    line.long 0x00 "ST1MMUAS2_COMMAND,   MMU commands are issued by writing to this register. Any command written to an address space while the corresponding STATUS.AS_ACTIVE flag is set will be ignored.  In general an MMU command only applies to the address space it is submitted to. However a command that invalidates the MMU cache may invalidate the whole MMU cache rather than only those entries specific to one address space. "
        hexmask.long 0x00 0.--31. 1. " ST1MMUAS2COMMAND         ,ST1MMUAS2COMMAND"

group d:0xC050249C++0x03
    line.long 0x00 "ST1MMUAS2_FAULTSTATUS,   This register contains extended status information after a fault. If read before a fault occurs, its contents are the reset value, 0, which indicates no fault.       If multiple faults occur before the first is handled, the subsequent faults are ignored. They may fault again after handling the first one.  If the GPU is in protected mode, this register is not updated, and MMU faults are ignored.        They are not fatal but will halt the GPU until the MMU address space is updated.        However, no fault information wil be visible in this case.  Changed access type of MMU_FAULTSTATUS register when in protected mode. "
        hexmask.long.byte 0x00 10.--15. 1. " Res126                   ,Res126"
        hexmask.long.word 0x00 16.--31. 1. "           SOURCE_ID              ,   This field contains an implementation-defined ID that supplies additional data about the source of the fault. For example, it may be the ID of the internal bus master that issued the request that faulted. This makes it possible to distinguish between the job manager, the texture unit and the load/store unit. Another example might be an indication of the type of an invalid data structure. The values in this field are implementation defined. "
        hexmask.long.byte 0x00 0.--7. 1. "           EXCEPTION_TYPE       ,   This field indicates the type of exception that caused the fault. "
        bitfld.long 0x00 8.--9. "               ACCESS_TYPE      ,   This field contains the direction of data transfer that caused the fault, if known.  For the purposes of error reporting, atomic transactions act like a read followed by a write, so denying either permission will result in the atomic transaction failing, and the exceptions ACCESS_TYPE field will be set to 'atomic'. " "atomic,execute:  An execute transaction. ,read:  A read transaction. ,write:  A write transaction. "

group d:0xC05024A0++0x03
    line.long 0x00 "ST1MMUAS2_FAULTADDRESS_LO,   This register contains information about the cause of a page fault or bus error. "
        hexmask.long 0x00 0.--31. 1. " ST1MMUAS2FAULTADDRESS_LO ,   This field contains the virtual address (in this address space) of the access that caused the fault.  Additional information about the fault is also available in the FAULTSTATUS register.  If multiple faults occur before the first is handled, the subsequent faults are ignored. They may fault again after handling the first one. "

group d:0xC05024A4++0x03
    line.long 0x00 "ST1MMUAS2_FAULTADDRESS_HI,   This register contains information about the cause of a page fault or bus error. "
        hexmask.long 0x00 0.--31. 1. " ST1MMUAS2FAULTADDRESS_HI ,   This field contains the virtual address (in this address space) of the access that caused the fault.  Additional information about the fault is also available in the FAULTSTATUS register.  If multiple faults occur before the first is handled, the subsequent faults are ignored. They may fault again after handling the first one. "

group d:0xC05024A8++0x03
    line.long 0x00 "ST1MMUAS2_STATUS,   This register contains dynamic status information about this address space. "
        hexmask.long 0x00 1.--31. 1. " Res127                   ,Res127"
        bitfld.long 0x00 0. "     AS_ACTIVE              ,   This flag is set while a MMU_UPDATE, LOCK, UNLOCK, FLUSH_PT or FLUSH_MEM command is active on this address space. This allows software to safely verify that the address space is in a consistent state after reconfiguring the MMU page tables.  If a new command is written to the corresponding COMMAND register while the AS_ACTIVE bit is set, then the command is ignored. " "false,true"

group d:0xC05024B0++0x03
    line.long 0x00 "ST1MMUAS2_TRANSCFG_LO,ST1MMUAS2_TRANSCFG_LO"
        bitfld.long 0x00 4.--5. " Res128                   ,Res128" "0,1,2,3"
        bitfld.long 0x00 11.--13. "            Res129                 ,Res129" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 19.--21. "              Res130               ,Res130" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 23. "                Res131           ,Res131" "0,1"
        textline "                                     "
        bitfld.long 0x00 26.--27. "Res132                   ,Res132" "0,1,2,3"
        bitfld.long 0x00 31. "            Res133                 ,Res133" "0,1"
        bitfld.long 0x00 6.--10. "              INA_BITS             ,   This field allows the system software to restrict the range of input addresses accepted by this translation stage. This is used in conjunction with the hardware limits to determine the valid address range as follows:  INA_BITS_VALID = min(HW_INA_BITS, 55-INA_BITS)  If the input address is outside the range (0, 2  INA_BITS_VALID -1), then a TRANSLATION_FAULT error is generated." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"
        bitfld.long 0x00 14.--18. "               OUTA_BITS        ,   This field allows the system software to restrict the range of output addresses generated by this translation stage. This is used in conjunction with the hardware limits to determine the valid address range as follows:  OUTA_BITS_VALID = min(HW_OUTA_BITS, 55-OUTA_BITS)  If the translated output address is outside the range (0, 2  OUTA_BITS_VALID -1), then a TRANSLATION_FAULT error is generated." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"
        textline "                                     "
        bitfld.long 0x00 0.--3. "MODE                     ,   This field controls the overall operation of the MMU. There are some differences between stage 1 and stage 2.  Execute permissions for a page are evaluated as follows (PTE.&lt;W|R|X> refers to page table entry permissions resolved for hierarchical permissions (if applicable):  EXECUTE_ALLOWED = !((TRANSCFG.WXN &amp; !PTE.W) | (TRANSCFG.XREADABLE &amp; !PTE.R) | (!TRANSCFG.XREADABLE &amp; !PTE.X)) " "LEGACY,UNMAPPED,IDENTITY,3,4,5,AARCH64_4K,7,AARCH64_64K,9,10,11,12,13,14,15"
        bitfld.long 0x00 24.--25. "  PTW_MEMATTR            ,   Memory attributes for page table walks. The allowed values are compatible with the values allowed for  MEMORY_TYPE . For outer cache transactions, the desired attributes for the transaction will be decided by the bus master and communicated to the memory system using signals on the bus.  Changed allowed values for TRANSCFG.PTW_MEMATTR. " "0,NON_CACHEABLE,WRITE_BACK,3"
        bitfld.long 0x00 28.--29. "  PTW_SH               ,   This field specifies the shareability for the page table walks. This is the same encoding as used for ARMv8 page tables. " "non_shareable,1,outer_shareable,inner_shareable"
        bitfld.long 0x00 30. "  R_ALLOCATE       ,   This field sets the inner read allocation hint for the page table walks. This is the same encoding as used for ARMv8 page tables. " "no_read_allocate,read_allocate"
        textline "                                     "
        bitfld.long 0x00 22. "SL_CONCAT_EN             ,   If set then the page table walk starting level will be increased if possible by concatenating up to 16 tables in the starting level. " "false,true"

group d:0xC05024B4++0x03
    line.long 0x00 "ST1MMUAS2_TRANSCFG_HI,ST1MMUAS2_TRANSCFG_HI"
        bitfld.long 0x00 0. " Res134                   ,Res134" "0,1"
        hexmask.long 0x00 5.--31. 1. "            Res135                 ,Res135"
        bitfld.long 0x00 1. "       DISABLE_HIER_AP      ,   This flag only has an effect on stage 1 of translation. It is ignored for stage 2. Note the inverted logic - the flag must be set to  dis able hierarchical access permissions." "false,true"
        bitfld.long 0x00 2. "            DISABLE_AF_FAULT ,   This flag can be used to disable access fault checking when in one of AARCH64 modes. " "false,true"
        textline "                                     "
        bitfld.long 0x00 3. "WXN                      ,   This flag can be used to disable all writes to executable pages, overriding access permissions specified in the page table. " "false,true"
        bitfld.long 0x00 4. "        XREADABLE              ,   This flag can be used to enable execution on all readable pages, overriding access permissions specified in the page table. " "false,true"

group d:0xC05024B8++0x03
    line.long 0x00 "ST1MMUAS2_FAULTEXTRA_LO,   This register contains additional information about the cause of a page fault or bus error. "
        hexmask.long 0x00 0.--31. 1. " ST1MMUAS2FAULTEXTRA_LO   ,   This field contains the virtual address (in this address space) of the access that caused the fault.  Additional information about the fault is also available in the  FAULTSTATUS and FAULTADDRESS registers. If multiple faults occur before the first is handled, the subsequent faults are ignored. They may fault again after handling the first one.  Fixed duplicate state name in FAULT_ADDRESS - exposes previously hidden field S2FS1WALK. "

group d:0xC05024BC++0x03
    line.long 0x00 "ST1MMUAS2_FAULTEXTRA_HI,   This register contains additional information about the cause of a page fault or bus error. "
        hexmask.long.word 0x00 16.--30. 1. " Res136                   ,Res136"
        hexmask.long.word 0x00 0.--15. 1. "         ST1MMUAS2FAULTEXTRA_HI ,   This field contains the virtual address (in this address space) of the access that caused the fault.  Additional information about the fault is also available in the  FAULTSTATUS and FAULTADDRESS registers. If multiple faults occur before the first is handled, the subsequent faults are ignored. They may fault again after handling the first one.  Fixed duplicate state name in FAULT_ADDRESS - exposes previously hidden field S2FS1WALK. "
        bitfld.long 0x00 31. "           S2FS1WALK            ,S2FS1WALK" "stage2,stage1"

width 27.

group d:0xC05024C0++0x03
    line.long 0x00 "ST1MMUAS3_TRANSTAB_LO,   This register contains the address of the base level of the translation table, together with some related flags.  Details on the layout of the page tables, and the address translation process, can be found in the section  Memory Management Unit ."
        bitfld.long 0x00 0.--3. " Res137                   ,Res137" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        hexmask.long 0x00 4.--31. 1. "           ST1MMUAS3TRANSTAB_LO   ,   This field contains the address of the top level of a page table structure. This must be 16-byte-aligned, so address bits [3:0] are assumed to be zero.  For a stage 1 page table, this will be an intermediate physical address, and for stage 2 it will be a physical address. The number of actual translated address bits is stored in  OUTA_BITS . The unused high bits must be set to 0. Changed alignment text for TRANSTAB.BASE  TRANSTAB.BASE pointer is a physical (or intermediate) address "

group d:0xC05024C4++0x03
    line.long 0x00 "ST1MMUAS3_TRANSTAB_HI,   This register contains the address of the base level of the translation table, together with some related flags.  Details on the layout of the page tables, and the address translation process, can be found in the section  Memory Management Unit ."
        hexmask.long 0x00 0.--31. 1. " ST1MMUAS3TRANSTAB_HI     ,   This field contains the address of the top level of a page table structure. This must be 16-byte-aligned, so address bits [3:0] are assumed to be zero.  For a stage 1 page table, this will be an intermediate physical address, and for stage 2 it will be a physical address. The number of actual translated address bits is stored in  OUTA_BITS . The unused high bits must be set to 0. Changed alignment text for TRANSTAB.BASE  TRANSTAB.BASE pointer is a physical (or intermediate) address "

group d:0xC05024C8++0x03
    line.long 0x00 "ST1MMUAS3_MEMATTR_LO,"
        bitfld.long 0x00 0.--3. " ATTRIBUTE0               ,   This field specifies the memory attributes for memory type index 0. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 4.--7. "       ATTRIBUTE1             ,   This field specifies the memory attributes for memory type index 1. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 8.--11. "         ATTRIBUTE2           ,   This field specifies the memory attributes for memory type index 2. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 12.--15. "           ATTRIBUTE3       ,   This field specifies the memory attributes for memory type index 3. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        textline "                                     "
        bitfld.long 0x00 16.--19. "ATTRIBUTE4               ,   This field specifies the memory attributes for memory type index 4. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 20.--23. "       ATTRIBUTE5             ,   This field specifies the memory attributes for memory type index 5. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 24.--27. "         ATTRIBUTE6           ,   This field specifies the memory attributes for memory type index 6. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 28.--31. "           ATTRIBUTE7       ,   This field specifies the memory attributes for memory type index 7. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"

group d:0xC05024CC++0x03
    line.long 0x00 "ST1MMUAS3_MEMATTR_HI,"
        bitfld.long 0x00 0.--3. " ATTRIBUTE8               ,   This field specifies the memory attributes for memory type index 8. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 4.--7. "       ATTRIBUTE9             ,   This field specifies the memory attributes for memory type index 9. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 8.--11. "         ATTRIBUTE10          ,   This field specifies the memory attributes for memory type index 10. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 12.--15. "           ATTRIBUTE11      ,   This field specifies the memory attributes for memory type index 11. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        textline "                                     "
        bitfld.long 0x00 16.--19. "ATTRIBUTE12              ,   This field specifies the memory attributes for memory type index 12. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 20.--23. "       ATTRIBUTE13            ,   This field specifies the memory attributes for memory type index 13. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 24.--27. "         ATTRIBUTE14          ,   This field specifies the memory attributes for memory type index 14. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 28.--31. "           ATTRIBUTE15      ,   This field specifies the memory attributes for memory type index 15. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"

group d:0xC05024D0++0x03
    line.long 0x00 "ST1MMUAS3_LOCKADDR_LO,   This register tells the MMU to lock a region of virtual memory. All page mappings within this region must be flushed, and no translation requests within this region can complete or fault before the area is unlocked.  Only one region can be locked at a time.  As only 32 bits of the register can be written to at a time, no changes are issued until the LOCK command is written to the COMMAND register. "
        hexmask.long.byte 0x00 6.--11. 1. " Res138                   ,Res138"
        hexmask.long.byte 0x00 0.--5. 1. "           LOCKADDR_SIZE          ,   This field contains the log  2 of the size of the region to lock, minus 1. Only values in the range 11 to 63 are valid values for this field, corresponding to region sizes of 4KB up to the entire address space. Values in the range 0 to 10 result in UNDEFINED behavior and should not be used."
        hexmask.long.tbyte 0x00 12.--31. 1. "             ST1MMUAS3LOCKADDR_LO ,   This field contains the lowest address in the region to be locked. The address is a virtual address in this address space.  Only the upper bits of the address are used. The address is aligned to a multiple of the region size, so a variable number of low-order bits are ignored, depending on the selected region size. It is recommended that software ensures that these low bits in the address are cleared, to avoid confusion. "

group d:0xC05024D4++0x03
    line.long 0x00 "ST1MMUAS3_LOCKADDR_HI,   This register tells the MMU to lock a region of virtual memory. All page mappings within this region must be flushed, and no translation requests within this region can complete or fault before the area is unlocked.  Only one region can be locked at a time.  As only 32 bits of the register can be written to at a time, no changes are issued until the LOCK command is written to the COMMAND register. "
        hexmask.long 0x00 0.--31. 1. " ST1MMUAS3LOCKADDR_HI     ,   This field contains the lowest address in the region to be locked. The address is a virtual address in this address space.  Only the upper bits of the address are used. The address is aligned to a multiple of the region size, so a variable number of low-order bits are ignored, depending on the selected region size. It is recommended that software ensures that these low bits in the address are cleared, to avoid confusion. "

group d:0xC05024D8++0x03
    line.long 0x00 "ST1MMUAS3_COMMAND,   MMU commands are issued by writing to this register. Any command written to an address space while the corresponding STATUS.AS_ACTIVE flag is set will be ignored.  In general an MMU command only applies to the address space it is submitted to. However a command that invalidates the MMU cache may invalidate the whole MMU cache rather than only those entries specific to one address space. "
        hexmask.long 0x00 0.--31. 1. " ST1MMUAS3COMMAND         ,ST1MMUAS3COMMAND"

group d:0xC05024DC++0x03
    line.long 0x00 "ST1MMUAS3_FAULTSTATUS,   This register contains extended status information after a fault. If read before a fault occurs, its contents are the reset value, 0, which indicates no fault.       If multiple faults occur before the first is handled, the subsequent faults are ignored. They may fault again after handling the first one.  If the GPU is in protected mode, this register is not updated, and MMU faults are ignored.        They are not fatal but will halt the GPU until the MMU address space is updated.        However, no fault information wil be visible in this case.  Changed access type of MMU_FAULTSTATUS register when in protected mode. "
        hexmask.long.byte 0x00 10.--15. 1. " Res139                   ,Res139"
        hexmask.long.word 0x00 16.--31. 1. "           SOURCE_ID              ,   This field contains an implementation-defined ID that supplies additional data about the source of the fault. For example, it may be the ID of the internal bus master that issued the request that faulted. This makes it possible to distinguish between the job manager, the texture unit and the load/store unit. Another example might be an indication of the type of an invalid data structure. The values in this field are implementation defined. "
        hexmask.long.byte 0x00 0.--7. 1. "           EXCEPTION_TYPE       ,   This field indicates the type of exception that caused the fault. "
        bitfld.long 0x00 8.--9. "               ACCESS_TYPE      ,   This field contains the direction of data transfer that caused the fault, if known.  For the purposes of error reporting, atomic transactions act like a read followed by a write, so denying either permission will result in the atomic transaction failing, and the exceptions ACCESS_TYPE field will be set to 'atomic'. " "atomic,execute:  An execute transaction. ,read:  A read transaction. ,write:  A write transaction. "

group d:0xC05024E0++0x03
    line.long 0x00 "ST1MMUAS3_FAULTADDRESS_LO,   This register contains information about the cause of a page fault or bus error. "
        hexmask.long 0x00 0.--31. 1. " ST1MMUAS3FAULTADDRESS_LO ,   This field contains the virtual address (in this address space) of the access that caused the fault.  Additional information about the fault is also available in the FAULTSTATUS register.  If multiple faults occur before the first is handled, the subsequent faults are ignored. They may fault again after handling the first one. "

group d:0xC05024E4++0x03
    line.long 0x00 "ST1MMUAS3_FAULTADDRESS_HI,   This register contains information about the cause of a page fault or bus error. "
        hexmask.long 0x00 0.--31. 1. " ST1MMUAS3FAULTADDRESS_HI ,   This field contains the virtual address (in this address space) of the access that caused the fault.  Additional information about the fault is also available in the FAULTSTATUS register.  If multiple faults occur before the first is handled, the subsequent faults are ignored. They may fault again after handling the first one. "

group d:0xC05024E8++0x03
    line.long 0x00 "ST1MMUAS3_STATUS,   This register contains dynamic status information about this address space. "
        hexmask.long 0x00 1.--31. 1. " Res140                   ,Res140"
        bitfld.long 0x00 0. "     AS_ACTIVE              ,   This flag is set while a MMU_UPDATE, LOCK, UNLOCK, FLUSH_PT or FLUSH_MEM command is active on this address space. This allows software to safely verify that the address space is in a consistent state after reconfiguring the MMU page tables.  If a new command is written to the corresponding COMMAND register while the AS_ACTIVE bit is set, then the command is ignored. " "false,true"

group d:0xC05024F0++0x03
    line.long 0x00 "ST1MMUAS3_TRANSCFG_LO,ST1MMUAS3_TRANSCFG_LO"
        bitfld.long 0x00 4.--5. " Res141                   ,Res141" "0,1,2,3"
        bitfld.long 0x00 11.--13. "            Res142                 ,Res142" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 19.--21. "              Res143               ,Res143" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 23. "                Res144           ,Res144" "0,1"
        textline "                                     "
        bitfld.long 0x00 26.--27. "Res145                   ,Res145" "0,1,2,3"
        bitfld.long 0x00 31. "            Res146                 ,Res146" "0,1"
        bitfld.long 0x00 6.--10. "              INA_BITS             ,   This field allows the system software to restrict the range of input addresses accepted by this translation stage. This is used in conjunction with the hardware limits to determine the valid address range as follows:  INA_BITS_VALID = min(HW_INA_BITS, 55-INA_BITS)  If the input address is outside the range (0, 2  INA_BITS_VALID -1), then a TRANSLATION_FAULT error is generated." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"
        bitfld.long 0x00 14.--18. "               OUTA_BITS        ,   This field allows the system software to restrict the range of output addresses generated by this translation stage. This is used in conjunction with the hardware limits to determine the valid address range as follows:  OUTA_BITS_VALID = min(HW_OUTA_BITS, 55-OUTA_BITS)  If the translated output address is outside the range (0, 2  OUTA_BITS_VALID -1), then a TRANSLATION_FAULT error is generated." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"
        textline "                                     "
        bitfld.long 0x00 0.--3. "MODE                     ,   This field controls the overall operation of the MMU. There are some differences between stage 1 and stage 2.  Execute permissions for a page are evaluated as follows (PTE.&lt;W|R|X> refers to page table entry permissions resolved for hierarchical permissions (if applicable):  EXECUTE_ALLOWED = !((TRANSCFG.WXN &amp; !PTE.W) | (TRANSCFG.XREADABLE &amp; !PTE.R) | (!TRANSCFG.XREADABLE &amp; !PTE.X)) " "LEGACY,UNMAPPED,IDENTITY,3,4,5,AARCH64_4K,7,AARCH64_64K,9,10,11,12,13,14,15"
        bitfld.long 0x00 24.--25. "  PTW_MEMATTR            ,   Memory attributes for page table walks. The allowed values are compatible with the values allowed for  MEMORY_TYPE . For outer cache transactions, the desired attributes for the transaction will be decided by the bus master and communicated to the memory system using signals on the bus.  Changed allowed values for TRANSCFG.PTW_MEMATTR. " "0,NON_CACHEABLE,WRITE_BACK,3"
        bitfld.long 0x00 28.--29. "  PTW_SH               ,   This field specifies the shareability for the page table walks. This is the same encoding as used for ARMv8 page tables. " "non_shareable,1,outer_shareable,inner_shareable"
        bitfld.long 0x00 30. "  R_ALLOCATE       ,   This field sets the inner read allocation hint for the page table walks. This is the same encoding as used for ARMv8 page tables. " "no_read_allocate,read_allocate"
        textline "                                     "
        bitfld.long 0x00 22. "SL_CONCAT_EN             ,   If set then the page table walk starting level will be increased if possible by concatenating up to 16 tables in the starting level. " "false,true"

group d:0xC05024F4++0x03
    line.long 0x00 "ST1MMUAS3_TRANSCFG_HI,ST1MMUAS3_TRANSCFG_HI"
        bitfld.long 0x00 0. " Res147                   ,Res147" "0,1"
        hexmask.long 0x00 5.--31. 1. "            Res148                 ,Res148"
        bitfld.long 0x00 1. "       DISABLE_HIER_AP      ,   This flag only has an effect on stage 1 of translation. It is ignored for stage 2. Note the inverted logic - the flag must be set to  dis able hierarchical access permissions." "false,true"
        bitfld.long 0x00 2. "            DISABLE_AF_FAULT ,   This flag can be used to disable access fault checking when in one of AARCH64 modes. " "false,true"
        textline "                                     "
        bitfld.long 0x00 3. "WXN                      ,   This flag can be used to disable all writes to executable pages, overriding access permissions specified in the page table. " "false,true"
        bitfld.long 0x00 4. "        XREADABLE              ,   This flag can be used to enable execution on all readable pages, overriding access permissions specified in the page table. " "false,true"

group d:0xC05024F8++0x03
    line.long 0x00 "ST1MMUAS3_FAULTEXTRA_LO,   This register contains additional information about the cause of a page fault or bus error. "
        hexmask.long 0x00 0.--31. 1. " ST1MMUAS3FAULTEXTRA_LO   ,   This field contains the virtual address (in this address space) of the access that caused the fault.  Additional information about the fault is also available in the  FAULTSTATUS and FAULTADDRESS registers. If multiple faults occur before the first is handled, the subsequent faults are ignored. They may fault again after handling the first one.  Fixed duplicate state name in FAULT_ADDRESS - exposes previously hidden field S2FS1WALK. "

group d:0xC05024FC++0x03
    line.long 0x00 "ST1MMUAS3_FAULTEXTRA_HI,   This register contains additional information about the cause of a page fault or bus error. "
        hexmask.long.word 0x00 16.--30. 1. " Res149                   ,Res149"
        hexmask.long.word 0x00 0.--15. 1. "         ST1MMUAS3FAULTEXTRA_HI ,   This field contains the virtual address (in this address space) of the access that caused the fault.  Additional information about the fault is also available in the  FAULTSTATUS and FAULTADDRESS registers. If multiple faults occur before the first is handled, the subsequent faults are ignored. They may fault again after handling the first one.  Fixed duplicate state name in FAULT_ADDRESS - exposes previously hidden field S2FS1WALK. "
        bitfld.long 0x00 31. "           S2FS1WALK            ,S2FS1WALK" "stage2,stage1"

width 27.

group d:0xC0502500++0x03
    line.long 0x00 "ST1MMUAS4_TRANSTAB_LO,   This register contains the address of the base level of the translation table, together with some related flags.  Details on the layout of the page tables, and the address translation process, can be found in the section  Memory Management Unit ."
        bitfld.long 0x00 0.--3. " Res150                   ,Res150" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        hexmask.long 0x00 4.--31. 1. "           ST1MMUAS4TRANSTAB_LO   ,   This field contains the address of the top level of a page table structure. This must be 16-byte-aligned, so address bits [3:0] are assumed to be zero.  For a stage 1 page table, this will be an intermediate physical address, and for stage 2 it will be a physical address. The number of actual translated address bits is stored in  OUTA_BITS . The unused high bits must be set to 0. Changed alignment text for TRANSTAB.BASE  TRANSTAB.BASE pointer is a physical (or intermediate) address "

group d:0xC0502504++0x03
    line.long 0x00 "ST1MMUAS4_TRANSTAB_HI,   This register contains the address of the base level of the translation table, together with some related flags.  Details on the layout of the page tables, and the address translation process, can be found in the section  Memory Management Unit ."
        hexmask.long 0x00 0.--31. 1. " ST1MMUAS4TRANSTAB_HI     ,   This field contains the address of the top level of a page table structure. This must be 16-byte-aligned, so address bits [3:0] are assumed to be zero.  For a stage 1 page table, this will be an intermediate physical address, and for stage 2 it will be a physical address. The number of actual translated address bits is stored in  OUTA_BITS . The unused high bits must be set to 0. Changed alignment text for TRANSTAB.BASE  TRANSTAB.BASE pointer is a physical (or intermediate) address "

group d:0xC0502508++0x03
    line.long 0x00 "ST1MMUAS4_MEMATTR_LO,"
        bitfld.long 0x00 0.--3. " ATTRIBUTE0               ,   This field specifies the memory attributes for memory type index 0. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 4.--7. "       ATTRIBUTE1             ,   This field specifies the memory attributes for memory type index 1. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 8.--11. "         ATTRIBUTE2           ,   This field specifies the memory attributes for memory type index 2. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 12.--15. "           ATTRIBUTE3       ,   This field specifies the memory attributes for memory type index 3. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        textline "                                     "
        bitfld.long 0x00 16.--19. "ATTRIBUTE4               ,   This field specifies the memory attributes for memory type index 4. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 20.--23. "       ATTRIBUTE5             ,   This field specifies the memory attributes for memory type index 5. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 24.--27. "         ATTRIBUTE6           ,   This field specifies the memory attributes for memory type index 6. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 28.--31. "           ATTRIBUTE7       ,   This field specifies the memory attributes for memory type index 7. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"

group d:0xC050250C++0x03
    line.long 0x00 "ST1MMUAS4_MEMATTR_HI,"
        bitfld.long 0x00 0.--3. " ATTRIBUTE8               ,   This field specifies the memory attributes for memory type index 8. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 4.--7. "       ATTRIBUTE9             ,   This field specifies the memory attributes for memory type index 9. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 8.--11. "         ATTRIBUTE10          ,   This field specifies the memory attributes for memory type index 10. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 12.--15. "           ATTRIBUTE11      ,   This field specifies the memory attributes for memory type index 11. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        textline "                                     "
        bitfld.long 0x00 16.--19. "ATTRIBUTE12              ,   This field specifies the memory attributes for memory type index 12. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 20.--23. "       ATTRIBUTE13            ,   This field specifies the memory attributes for memory type index 13. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 24.--27. "         ATTRIBUTE14          ,   This field specifies the memory attributes for memory type index 14. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 28.--31. "           ATTRIBUTE15      ,   This field specifies the memory attributes for memory type index 15. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"

group d:0xC0502510++0x03
    line.long 0x00 "ST1MMUAS4_LOCKADDR_LO,   This register tells the MMU to lock a region of virtual memory. All page mappings within this region must be flushed, and no translation requests within this region can complete or fault before the area is unlocked.  Only one region can be locked at a time.  As only 32 bits of the register can be written to at a time, no changes are issued until the LOCK command is written to the COMMAND register. "
        hexmask.long.byte 0x00 6.--11. 1. " Res151                   ,Res151"
        hexmask.long.byte 0x00 0.--5. 1. "           LOCKADDR_SIZE          ,   This field contains the log  2 of the size of the region to lock, minus 1. Only values in the range 11 to 63 are valid values for this field, corresponding to region sizes of 4KB up to the entire address space. Values in the range 0 to 10 result in UNDEFINED behavior and should not be used."
        hexmask.long.tbyte 0x00 12.--31. 1. "             ST1MMUAS4LOCKADDR_LO ,   This field contains the lowest address in the region to be locked. The address is a virtual address in this address space.  Only the upper bits of the address are used. The address is aligned to a multiple of the region size, so a variable number of low-order bits are ignored, depending on the selected region size. It is recommended that software ensures that these low bits in the address are cleared, to avoid confusion. "

group d:0xC0502514++0x03
    line.long 0x00 "ST1MMUAS4_LOCKADDR_HI,   This register tells the MMU to lock a region of virtual memory. All page mappings within this region must be flushed, and no translation requests within this region can complete or fault before the area is unlocked.  Only one region can be locked at a time.  As only 32 bits of the register can be written to at a time, no changes are issued until the LOCK command is written to the COMMAND register. "
        hexmask.long 0x00 0.--31. 1. " ST1MMUAS4LOCKADDR_HI     ,   This field contains the lowest address in the region to be locked. The address is a virtual address in this address space.  Only the upper bits of the address are used. The address is aligned to a multiple of the region size, so a variable number of low-order bits are ignored, depending on the selected region size. It is recommended that software ensures that these low bits in the address are cleared, to avoid confusion. "

group d:0xC0502518++0x03
    line.long 0x00 "ST1MMUAS4_COMMAND,   MMU commands are issued by writing to this register. Any command written to an address space while the corresponding STATUS.AS_ACTIVE flag is set will be ignored.  In general an MMU command only applies to the address space it is submitted to. However a command that invalidates the MMU cache may invalidate the whole MMU cache rather than only those entries specific to one address space. "
        hexmask.long 0x00 0.--31. 1. " ST1MMUAS4COMMAND         ,ST1MMUAS4COMMAND"

group d:0xC050251C++0x03
    line.long 0x00 "ST1MMUAS4_FAULTSTATUS,   This register contains extended status information after a fault. If read before a fault occurs, its contents are the reset value, 0, which indicates no fault.       If multiple faults occur before the first is handled, the subsequent faults are ignored. They may fault again after handling the first one.  If the GPU is in protected mode, this register is not updated, and MMU faults are ignored.        They are not fatal but will halt the GPU until the MMU address space is updated.        However, no fault information wil be visible in this case.  Changed access type of MMU_FAULTSTATUS register when in protected mode. "
        hexmask.long.byte 0x00 10.--15. 1. " Res152                   ,Res152"
        hexmask.long.word 0x00 16.--31. 1. "           SOURCE_ID              ,   This field contains an implementation-defined ID that supplies additional data about the source of the fault. For example, it may be the ID of the internal bus master that issued the request that faulted. This makes it possible to distinguish between the job manager, the texture unit and the load/store unit. Another example might be an indication of the type of an invalid data structure. The values in this field are implementation defined. "
        hexmask.long.byte 0x00 0.--7. 1. "           EXCEPTION_TYPE       ,   This field indicates the type of exception that caused the fault. "
        bitfld.long 0x00 8.--9. "               ACCESS_TYPE      ,   This field contains the direction of data transfer that caused the fault, if known.  For the purposes of error reporting, atomic transactions act like a read followed by a write, so denying either permission will result in the atomic transaction failing, and the exceptions ACCESS_TYPE field will be set to 'atomic'. " "atomic,execute:  An execute transaction. ,read:  A read transaction. ,write:  A write transaction. "

group d:0xC0502520++0x03
    line.long 0x00 "ST1MMUAS4_FAULTADDRESS_LO,   This register contains information about the cause of a page fault or bus error. "
        hexmask.long 0x00 0.--31. 1. " ST1MMUAS4FAULTADDRESS_LO ,   This field contains the virtual address (in this address space) of the access that caused the fault.  Additional information about the fault is also available in the FAULTSTATUS register.  If multiple faults occur before the first is handled, the subsequent faults are ignored. They may fault again after handling the first one. "

group d:0xC0502524++0x03
    line.long 0x00 "ST1MMUAS4_FAULTADDRESS_HI,   This register contains information about the cause of a page fault or bus error. "
        hexmask.long 0x00 0.--31. 1. " ST1MMUAS4FAULTADDRESS_HI ,   This field contains the virtual address (in this address space) of the access that caused the fault.  Additional information about the fault is also available in the FAULTSTATUS register.  If multiple faults occur before the first is handled, the subsequent faults are ignored. They may fault again after handling the first one. "

group d:0xC0502528++0x03
    line.long 0x00 "ST1MMUAS4_STATUS,   This register contains dynamic status information about this address space. "
        hexmask.long 0x00 1.--31. 1. " Res153                   ,Res153"
        bitfld.long 0x00 0. "     AS_ACTIVE              ,   This flag is set while a MMU_UPDATE, LOCK, UNLOCK, FLUSH_PT or FLUSH_MEM command is active on this address space. This allows software to safely verify that the address space is in a consistent state after reconfiguring the MMU page tables.  If a new command is written to the corresponding COMMAND register while the AS_ACTIVE bit is set, then the command is ignored. " "false,true"

group d:0xC0502530++0x03
    line.long 0x00 "ST1MMUAS4_TRANSCFG_LO,ST1MMUAS4_TRANSCFG_LO"
        bitfld.long 0x00 4.--5. " Res154                   ,Res154" "0,1,2,3"
        bitfld.long 0x00 11.--13. "            Res155                 ,Res155" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 19.--21. "              Res156               ,Res156" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 23. "                Res157           ,Res157" "0,1"
        textline "                                     "
        bitfld.long 0x00 26.--27. "Res158                   ,Res158" "0,1,2,3"
        bitfld.long 0x00 31. "            Res159                 ,Res159" "0,1"
        bitfld.long 0x00 6.--10. "              INA_BITS             ,   This field allows the system software to restrict the range of input addresses accepted by this translation stage. This is used in conjunction with the hardware limits to determine the valid address range as follows:  INA_BITS_VALID = min(HW_INA_BITS, 55-INA_BITS)  If the input address is outside the range (0, 2  INA_BITS_VALID -1), then a TRANSLATION_FAULT error is generated." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"
        bitfld.long 0x00 14.--18. "               OUTA_BITS        ,   This field allows the system software to restrict the range of output addresses generated by this translation stage. This is used in conjunction with the hardware limits to determine the valid address range as follows:  OUTA_BITS_VALID = min(HW_OUTA_BITS, 55-OUTA_BITS)  If the translated output address is outside the range (0, 2  OUTA_BITS_VALID -1), then a TRANSLATION_FAULT error is generated." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"
        textline "                                     "
        bitfld.long 0x00 0.--3. "MODE                     ,   This field controls the overall operation of the MMU. There are some differences between stage 1 and stage 2.  Execute permissions for a page are evaluated as follows (PTE.&lt;W|R|X> refers to page table entry permissions resolved for hierarchical permissions (if applicable):  EXECUTE_ALLOWED = !((TRANSCFG.WXN &amp; !PTE.W) | (TRANSCFG.XREADABLE &amp; !PTE.R) | (!TRANSCFG.XREADABLE &amp; !PTE.X)) " "LEGACY,UNMAPPED,IDENTITY,3,4,5,AARCH64_4K,7,AARCH64_64K,9,10,11,12,13,14,15"
        bitfld.long 0x00 24.--25. "  PTW_MEMATTR            ,   Memory attributes for page table walks. The allowed values are compatible with the values allowed for  MEMORY_TYPE . For outer cache transactions, the desired attributes for the transaction will be decided by the bus master and communicated to the memory system using signals on the bus.  Changed allowed values for TRANSCFG.PTW_MEMATTR. " "0,NON_CACHEABLE,WRITE_BACK,3"
        bitfld.long 0x00 28.--29. "  PTW_SH               ,   This field specifies the shareability for the page table walks. This is the same encoding as used for ARMv8 page tables. " "non_shareable,1,outer_shareable,inner_shareable"
        bitfld.long 0x00 30. "  R_ALLOCATE       ,   This field sets the inner read allocation hint for the page table walks. This is the same encoding as used for ARMv8 page tables. " "no_read_allocate,read_allocate"
        textline "                                     "
        bitfld.long 0x00 22. "SL_CONCAT_EN             ,   If set then the page table walk starting level will be increased if possible by concatenating up to 16 tables in the starting level. " "false,true"

group d:0xC0502534++0x03
    line.long 0x00 "ST1MMUAS4_TRANSCFG_HI,ST1MMUAS4_TRANSCFG_HI"
        bitfld.long 0x00 0. " Res160                   ,Res160" "0,1"
        hexmask.long 0x00 5.--31. 1. "            Res161                 ,Res161"
        bitfld.long 0x00 1. "       DISABLE_HIER_AP      ,   This flag only has an effect on stage 1 of translation. It is ignored for stage 2. Note the inverted logic - the flag must be set to  dis able hierarchical access permissions." "false,true"
        bitfld.long 0x00 2. "            DISABLE_AF_FAULT ,   This flag can be used to disable access fault checking when in one of AARCH64 modes. " "false,true"
        textline "                                     "
        bitfld.long 0x00 3. "WXN                      ,   This flag can be used to disable all writes to executable pages, overriding access permissions specified in the page table. " "false,true"
        bitfld.long 0x00 4. "        XREADABLE              ,   This flag can be used to enable execution on all readable pages, overriding access permissions specified in the page table. " "false,true"

group d:0xC0502538++0x03
    line.long 0x00 "ST1MMUAS4_FAULTEXTRA_LO,   This register contains additional information about the cause of a page fault or bus error. "
        hexmask.long 0x00 0.--31. 1. " ST1MMUAS4FAULTEXTRA_LO   ,   This field contains the virtual address (in this address space) of the access that caused the fault.  Additional information about the fault is also available in the  FAULTSTATUS and FAULTADDRESS registers. If multiple faults occur before the first is handled, the subsequent faults are ignored. They may fault again after handling the first one.  Fixed duplicate state name in FAULT_ADDRESS - exposes previously hidden field S2FS1WALK. "

group d:0xC050253C++0x03
    line.long 0x00 "ST1MMUAS4_FAULTEXTRA_HI,   This register contains additional information about the cause of a page fault or bus error. "
        hexmask.long.word 0x00 16.--30. 1. " Res162                   ,Res162"
        hexmask.long.word 0x00 0.--15. 1. "         ST1MMUAS4FAULTEXTRA_HI ,   This field contains the virtual address (in this address space) of the access that caused the fault.  Additional information about the fault is also available in the  FAULTSTATUS and FAULTADDRESS registers. If multiple faults occur before the first is handled, the subsequent faults are ignored. They may fault again after handling the first one.  Fixed duplicate state name in FAULT_ADDRESS - exposes previously hidden field S2FS1WALK. "
        bitfld.long 0x00 31. "           S2FS1WALK            ,S2FS1WALK" "stage2,stage1"

width 27.

group d:0xC0502540++0x03
    line.long 0x00 "ST1MMUAS5_TRANSTAB_LO,   This register contains the address of the base level of the translation table, together with some related flags.  Details on the layout of the page tables, and the address translation process, can be found in the section  Memory Management Unit ."
        bitfld.long 0x00 0.--3. " Res163                   ,Res163" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        hexmask.long 0x00 4.--31. 1. "           ST1MMUAS5TRANSTAB_LO   ,   This field contains the address of the top level of a page table structure. This must be 16-byte-aligned, so address bits [3:0] are assumed to be zero.  For a stage 1 page table, this will be an intermediate physical address, and for stage 2 it will be a physical address. The number of actual translated address bits is stored in  OUTA_BITS . The unused high bits must be set to 0. Changed alignment text for TRANSTAB.BASE  TRANSTAB.BASE pointer is a physical (or intermediate) address "

group d:0xC0502544++0x03
    line.long 0x00 "ST1MMUAS5_TRANSTAB_HI,   This register contains the address of the base level of the translation table, together with some related flags.  Details on the layout of the page tables, and the address translation process, can be found in the section  Memory Management Unit ."
        hexmask.long 0x00 0.--31. 1. " ST1MMUAS5TRANSTAB_HI     ,   This field contains the address of the top level of a page table structure. This must be 16-byte-aligned, so address bits [3:0] are assumed to be zero.  For a stage 1 page table, this will be an intermediate physical address, and for stage 2 it will be a physical address. The number of actual translated address bits is stored in  OUTA_BITS . The unused high bits must be set to 0. Changed alignment text for TRANSTAB.BASE  TRANSTAB.BASE pointer is a physical (or intermediate) address "

group d:0xC0502548++0x03
    line.long 0x00 "ST1MMUAS5_MEMATTR_LO,"
        bitfld.long 0x00 0.--3. " ATTRIBUTE0               ,   This field specifies the memory attributes for memory type index 0. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 4.--7. "       ATTRIBUTE1             ,   This field specifies the memory attributes for memory type index 1. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 8.--11. "         ATTRIBUTE2           ,   This field specifies the memory attributes for memory type index 2. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 12.--15. "           ATTRIBUTE3       ,   This field specifies the memory attributes for memory type index 3. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        textline "                                     "
        bitfld.long 0x00 16.--19. "ATTRIBUTE4               ,   This field specifies the memory attributes for memory type index 4. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 20.--23. "       ATTRIBUTE5             ,   This field specifies the memory attributes for memory type index 5. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 24.--27. "         ATTRIBUTE6           ,   This field specifies the memory attributes for memory type index 6. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 28.--31. "           ATTRIBUTE7       ,   This field specifies the memory attributes for memory type index 7. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"

group d:0xC050254C++0x03
    line.long 0x00 "ST1MMUAS5_MEMATTR_HI,"
        bitfld.long 0x00 0.--3. " ATTRIBUTE8               ,   This field specifies the memory attributes for memory type index 8. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 4.--7. "       ATTRIBUTE9             ,   This field specifies the memory attributes for memory type index 9. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 8.--11. "         ATTRIBUTE10          ,   This field specifies the memory attributes for memory type index 10. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 12.--15. "           ATTRIBUTE11      ,   This field specifies the memory attributes for memory type index 11. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        textline "                                     "
        bitfld.long 0x00 16.--19. "ATTRIBUTE12              ,   This field specifies the memory attributes for memory type index 12. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 20.--23. "       ATTRIBUTE13            ,   This field specifies the memory attributes for memory type index 13. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 24.--27. "         ATTRIBUTE14          ,   This field specifies the memory attributes for memory type index 14. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 28.--31. "           ATTRIBUTE15      ,   This field specifies the memory attributes for memory type index 15. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"

group d:0xC0502550++0x03
    line.long 0x00 "ST1MMUAS5_LOCKADDR_LO,   This register tells the MMU to lock a region of virtual memory. All page mappings within this region must be flushed, and no translation requests within this region can complete or fault before the area is unlocked.  Only one region can be locked at a time.  As only 32 bits of the register can be written to at a time, no changes are issued until the LOCK command is written to the COMMAND register. "
        hexmask.long.byte 0x00 6.--11. 1. " Res164                   ,Res164"
        hexmask.long.byte 0x00 0.--5. 1. "           LOCKADDR_SIZE          ,   This field contains the log  2 of the size of the region to lock, minus 1. Only values in the range 11 to 63 are valid values for this field, corresponding to region sizes of 4KB up to the entire address space. Values in the range 0 to 10 result in UNDEFINED behavior and should not be used."
        hexmask.long.tbyte 0x00 12.--31. 1. "             ST1MMUAS5LOCKADDR_LO ,   This field contains the lowest address in the region to be locked. The address is a virtual address in this address space.  Only the upper bits of the address are used. The address is aligned to a multiple of the region size, so a variable number of low-order bits are ignored, depending on the selected region size. It is recommended that software ensures that these low bits in the address are cleared, to avoid confusion. "

group d:0xC0502554++0x03
    line.long 0x00 "ST1MMUAS5_LOCKADDR_HI,   This register tells the MMU to lock a region of virtual memory. All page mappings within this region must be flushed, and no translation requests within this region can complete or fault before the area is unlocked.  Only one region can be locked at a time.  As only 32 bits of the register can be written to at a time, no changes are issued until the LOCK command is written to the COMMAND register. "
        hexmask.long 0x00 0.--31. 1. " ST1MMUAS5LOCKADDR_HI     ,   This field contains the lowest address in the region to be locked. The address is a virtual address in this address space.  Only the upper bits of the address are used. The address is aligned to a multiple of the region size, so a variable number of low-order bits are ignored, depending on the selected region size. It is recommended that software ensures that these low bits in the address are cleared, to avoid confusion. "

group d:0xC0502558++0x03
    line.long 0x00 "ST1MMUAS5_COMMAND,   MMU commands are issued by writing to this register. Any command written to an address space while the corresponding STATUS.AS_ACTIVE flag is set will be ignored.  In general an MMU command only applies to the address space it is submitted to. However a command that invalidates the MMU cache may invalidate the whole MMU cache rather than only those entries specific to one address space. "
        hexmask.long 0x00 0.--31. 1. " ST1MMUAS5COMMAND         ,ST1MMUAS5COMMAND"

group d:0xC050255C++0x03
    line.long 0x00 "ST1MMUAS5_FAULTSTATUS,   This register contains extended status information after a fault. If read before a fault occurs, its contents are the reset value, 0, which indicates no fault.       If multiple faults occur before the first is handled, the subsequent faults are ignored. They may fault again after handling the first one.  If the GPU is in protected mode, this register is not updated, and MMU faults are ignored.        They are not fatal but will halt the GPU until the MMU address space is updated.        However, no fault information wil be visible in this case.  Changed access type of MMU_FAULTSTATUS register when in protected mode. "
        hexmask.long.byte 0x00 10.--15. 1. " Res165                   ,Res165"
        hexmask.long.word 0x00 16.--31. 1. "           SOURCE_ID              ,   This field contains an implementation-defined ID that supplies additional data about the source of the fault. For example, it may be the ID of the internal bus master that issued the request that faulted. This makes it possible to distinguish between the job manager, the texture unit and the load/store unit. Another example might be an indication of the type of an invalid data structure. The values in this field are implementation defined. "
        hexmask.long.byte 0x00 0.--7. 1. "           EXCEPTION_TYPE       ,   This field indicates the type of exception that caused the fault. "
        bitfld.long 0x00 8.--9. "               ACCESS_TYPE      ,   This field contains the direction of data transfer that caused the fault, if known.  For the purposes of error reporting, atomic transactions act like a read followed by a write, so denying either permission will result in the atomic transaction failing, and the exceptions ACCESS_TYPE field will be set to 'atomic'. " "atomic,execute:  An execute transaction. ,read:  A read transaction. ,write:  A write transaction. "

group d:0xC0502560++0x03
    line.long 0x00 "ST1MMUAS5_FAULTADDRESS_LO,   This register contains information about the cause of a page fault or bus error. "
        hexmask.long 0x00 0.--31. 1. " ST1MMUAS5FAULTADDRESS_LO ,   This field contains the virtual address (in this address space) of the access that caused the fault.  Additional information about the fault is also available in the FAULTSTATUS register.  If multiple faults occur before the first is handled, the subsequent faults are ignored. They may fault again after handling the first one. "

group d:0xC0502564++0x03
    line.long 0x00 "ST1MMUAS5_FAULTADDRESS_HI,   This register contains information about the cause of a page fault or bus error. "
        hexmask.long 0x00 0.--31. 1. " ST1MMUAS5FAULTADDRESS_HI ,   This field contains the virtual address (in this address space) of the access that caused the fault.  Additional information about the fault is also available in the FAULTSTATUS register.  If multiple faults occur before the first is handled, the subsequent faults are ignored. They may fault again after handling the first one. "

group d:0xC0502568++0x03
    line.long 0x00 "ST1MMUAS5_STATUS,   This register contains dynamic status information about this address space. "
        hexmask.long 0x00 1.--31. 1. " Res166                   ,Res166"
        bitfld.long 0x00 0. "     AS_ACTIVE              ,   This flag is set while a MMU_UPDATE, LOCK, UNLOCK, FLUSH_PT or FLUSH_MEM command is active on this address space. This allows software to safely verify that the address space is in a consistent state after reconfiguring the MMU page tables.  If a new command is written to the corresponding COMMAND register while the AS_ACTIVE bit is set, then the command is ignored. " "false,true"

group d:0xC0502570++0x03
    line.long 0x00 "ST1MMUAS5_TRANSCFG_LO,ST1MMUAS5_TRANSCFG_LO"
        bitfld.long 0x00 4.--5. " Res167                   ,Res167" "0,1,2,3"
        bitfld.long 0x00 11.--13. "            Res168                 ,Res168" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 19.--21. "              Res169               ,Res169" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 23. "                Res170           ,Res170" "0,1"
        textline "                                     "
        bitfld.long 0x00 26.--27. "Res171                   ,Res171" "0,1,2,3"
        bitfld.long 0x00 31. "            Res172                 ,Res172" "0,1"
        bitfld.long 0x00 6.--10. "              INA_BITS             ,   This field allows the system software to restrict the range of input addresses accepted by this translation stage. This is used in conjunction with the hardware limits to determine the valid address range as follows:  INA_BITS_VALID = min(HW_INA_BITS, 55-INA_BITS)  If the input address is outside the range (0, 2  INA_BITS_VALID -1), then a TRANSLATION_FAULT error is generated." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"
        bitfld.long 0x00 14.--18. "               OUTA_BITS        ,   This field allows the system software to restrict the range of output addresses generated by this translation stage. This is used in conjunction with the hardware limits to determine the valid address range as follows:  OUTA_BITS_VALID = min(HW_OUTA_BITS, 55-OUTA_BITS)  If the translated output address is outside the range (0, 2  OUTA_BITS_VALID -1), then a TRANSLATION_FAULT error is generated." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"
        textline "                                     "
        bitfld.long 0x00 0.--3. "MODE                     ,   This field controls the overall operation of the MMU. There are some differences between stage 1 and stage 2.  Execute permissions for a page are evaluated as follows (PTE.&lt;W|R|X> refers to page table entry permissions resolved for hierarchical permissions (if applicable):  EXECUTE_ALLOWED = !((TRANSCFG.WXN &amp; !PTE.W) | (TRANSCFG.XREADABLE &amp; !PTE.R) | (!TRANSCFG.XREADABLE &amp; !PTE.X)) " "LEGACY,UNMAPPED,IDENTITY,3,4,5,AARCH64_4K,7,AARCH64_64K,9,10,11,12,13,14,15"
        bitfld.long 0x00 24.--25. "  PTW_MEMATTR            ,   Memory attributes for page table walks. The allowed values are compatible with the values allowed for  MEMORY_TYPE . For outer cache transactions, the desired attributes for the transaction will be decided by the bus master and communicated to the memory system using signals on the bus.  Changed allowed values for TRANSCFG.PTW_MEMATTR. " "0,NON_CACHEABLE,WRITE_BACK,3"
        bitfld.long 0x00 28.--29. "  PTW_SH               ,   This field specifies the shareability for the page table walks. This is the same encoding as used for ARMv8 page tables. " "non_shareable,1,outer_shareable,inner_shareable"
        bitfld.long 0x00 30. "  R_ALLOCATE       ,   This field sets the inner read allocation hint for the page table walks. This is the same encoding as used for ARMv8 page tables. " "no_read_allocate,read_allocate"
        textline "                                     "
        bitfld.long 0x00 22. "SL_CONCAT_EN             ,   If set then the page table walk starting level will be increased if possible by concatenating up to 16 tables in the starting level. " "false,true"

group d:0xC0502574++0x03
    line.long 0x00 "ST1MMUAS5_TRANSCFG_HI,ST1MMUAS5_TRANSCFG_HI"
        bitfld.long 0x00 0. " Res173                   ,Res173" "0,1"
        hexmask.long 0x00 5.--31. 1. "            Res174                 ,Res174"
        bitfld.long 0x00 1. "       DISABLE_HIER_AP      ,   This flag only has an effect on stage 1 of translation. It is ignored for stage 2. Note the inverted logic - the flag must be set to  dis able hierarchical access permissions." "false,true"
        bitfld.long 0x00 2. "            DISABLE_AF_FAULT ,   This flag can be used to disable access fault checking when in one of AARCH64 modes. " "false,true"
        textline "                                     "
        bitfld.long 0x00 3. "WXN                      ,   This flag can be used to disable all writes to executable pages, overriding access permissions specified in the page table. " "false,true"
        bitfld.long 0x00 4. "        XREADABLE              ,   This flag can be used to enable execution on all readable pages, overriding access permissions specified in the page table. " "false,true"

group d:0xC0502578++0x03
    line.long 0x00 "ST1MMUAS5_FAULTEXTRA_LO,   This register contains additional information about the cause of a page fault or bus error. "
        hexmask.long 0x00 0.--31. 1. " ST1MMUAS5FAULTEXTRA_LO   ,   This field contains the virtual address (in this address space) of the access that caused the fault.  Additional information about the fault is also available in the  FAULTSTATUS and FAULTADDRESS registers. If multiple faults occur before the first is handled, the subsequent faults are ignored. They may fault again after handling the first one.  Fixed duplicate state name in FAULT_ADDRESS - exposes previously hidden field S2FS1WALK. "

group d:0xC050257C++0x03
    line.long 0x00 "ST1MMUAS5_FAULTEXTRA_HI,   This register contains additional information about the cause of a page fault or bus error. "
        hexmask.long.word 0x00 16.--30. 1. " Res175                   ,Res175"
        hexmask.long.word 0x00 0.--15. 1. "         ST1MMUAS5FAULTEXTRA_HI ,   This field contains the virtual address (in this address space) of the access that caused the fault.  Additional information about the fault is also available in the  FAULTSTATUS and FAULTADDRESS registers. If multiple faults occur before the first is handled, the subsequent faults are ignored. They may fault again after handling the first one.  Fixed duplicate state name in FAULT_ADDRESS - exposes previously hidden field S2FS1WALK. "
        bitfld.long 0x00 31. "           S2FS1WALK            ,S2FS1WALK" "stage2,stage1"

width 27.

group d:0xC0502580++0x03
    line.long 0x00 "ST1MMUAS6_TRANSTAB_LO,   This register contains the address of the base level of the translation table, together with some related flags.  Details on the layout of the page tables, and the address translation process, can be found in the section  Memory Management Unit ."
        bitfld.long 0x00 0.--3. " Res176                   ,Res176" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        hexmask.long 0x00 4.--31. 1. "           ST1MMUAS6TRANSTAB_LO   ,   This field contains the address of the top level of a page table structure. This must be 16-byte-aligned, so address bits [3:0] are assumed to be zero.  For a stage 1 page table, this will be an intermediate physical address, and for stage 2 it will be a physical address. The number of actual translated address bits is stored in  OUTA_BITS . The unused high bits must be set to 0. Changed alignment text for TRANSTAB.BASE  TRANSTAB.BASE pointer is a physical (or intermediate) address "

group d:0xC0502584++0x03
    line.long 0x00 "ST1MMUAS6_TRANSTAB_HI,   This register contains the address of the base level of the translation table, together with some related flags.  Details on the layout of the page tables, and the address translation process, can be found in the section  Memory Management Unit ."
        hexmask.long 0x00 0.--31. 1. " ST1MMUAS6TRANSTAB_HI     ,   This field contains the address of the top level of a page table structure. This must be 16-byte-aligned, so address bits [3:0] are assumed to be zero.  For a stage 1 page table, this will be an intermediate physical address, and for stage 2 it will be a physical address. The number of actual translated address bits is stored in  OUTA_BITS . The unused high bits must be set to 0. Changed alignment text for TRANSTAB.BASE  TRANSTAB.BASE pointer is a physical (or intermediate) address "

group d:0xC0502588++0x03
    line.long 0x00 "ST1MMUAS6_MEMATTR_LO,"
        bitfld.long 0x00 0.--3. " ATTRIBUTE0               ,   This field specifies the memory attributes for memory type index 0. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 4.--7. "       ATTRIBUTE1             ,   This field specifies the memory attributes for memory type index 1. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 8.--11. "         ATTRIBUTE2           ,   This field specifies the memory attributes for memory type index 2. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 12.--15. "           ATTRIBUTE3       ,   This field specifies the memory attributes for memory type index 3. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        textline "                                     "
        bitfld.long 0x00 16.--19. "ATTRIBUTE4               ,   This field specifies the memory attributes for memory type index 4. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 20.--23. "       ATTRIBUTE5             ,   This field specifies the memory attributes for memory type index 5. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 24.--27. "         ATTRIBUTE6           ,   This field specifies the memory attributes for memory type index 6. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 28.--31. "           ATTRIBUTE7       ,   This field specifies the memory attributes for memory type index 7. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"

group d:0xC050258C++0x03
    line.long 0x00 "ST1MMUAS6_MEMATTR_HI,"
        bitfld.long 0x00 0.--3. " ATTRIBUTE8               ,   This field specifies the memory attributes for memory type index 8. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 4.--7. "       ATTRIBUTE9             ,   This field specifies the memory attributes for memory type index 9. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 8.--11. "         ATTRIBUTE10          ,   This field specifies the memory attributes for memory type index 10. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 12.--15. "           ATTRIBUTE11      ,   This field specifies the memory attributes for memory type index 11. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        textline "                                     "
        bitfld.long 0x00 16.--19. "ATTRIBUTE12              ,   This field specifies the memory attributes for memory type index 12. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 20.--23. "       ATTRIBUTE13            ,   This field specifies the memory attributes for memory type index 13. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 24.--27. "         ATTRIBUTE14          ,   This field specifies the memory attributes for memory type index 14. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 28.--31. "           ATTRIBUTE15      ,   This field specifies the memory attributes for memory type index 15. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"

group d:0xC0502590++0x03
    line.long 0x00 "ST1MMUAS6_LOCKADDR_LO,   This register tells the MMU to lock a region of virtual memory. All page mappings within this region must be flushed, and no translation requests within this region can complete or fault before the area is unlocked.  Only one region can be locked at a time.  As only 32 bits of the register can be written to at a time, no changes are issued until the LOCK command is written to the COMMAND register. "
        hexmask.long.byte 0x00 6.--11. 1. " Res177                   ,Res177"
        hexmask.long.byte 0x00 0.--5. 1. "           LOCKADDR_SIZE          ,   This field contains the log  2 of the size of the region to lock, minus 1. Only values in the range 11 to 63 are valid values for this field, corresponding to region sizes of 4KB up to the entire address space. Values in the range 0 to 10 result in UNDEFINED behavior and should not be used."
        hexmask.long.tbyte 0x00 12.--31. 1. "             ST1MMUAS6LOCKADDR_LO ,   This field contains the lowest address in the region to be locked. The address is a virtual address in this address space.  Only the upper bits of the address are used. The address is aligned to a multiple of the region size, so a variable number of low-order bits are ignored, depending on the selected region size. It is recommended that software ensures that these low bits in the address are cleared, to avoid confusion. "

group d:0xC0502594++0x03
    line.long 0x00 "ST1MMUAS6_LOCKADDR_HI,   This register tells the MMU to lock a region of virtual memory. All page mappings within this region must be flushed, and no translation requests within this region can complete or fault before the area is unlocked.  Only one region can be locked at a time.  As only 32 bits of the register can be written to at a time, no changes are issued until the LOCK command is written to the COMMAND register. "
        hexmask.long 0x00 0.--31. 1. " ST1MMUAS6LOCKADDR_HI     ,   This field contains the lowest address in the region to be locked. The address is a virtual address in this address space.  Only the upper bits of the address are used. The address is aligned to a multiple of the region size, so a variable number of low-order bits are ignored, depending on the selected region size. It is recommended that software ensures that these low bits in the address are cleared, to avoid confusion. "

group d:0xC0502598++0x03
    line.long 0x00 "ST1MMUAS6_COMMAND,   MMU commands are issued by writing to this register. Any command written to an address space while the corresponding STATUS.AS_ACTIVE flag is set will be ignored.  In general an MMU command only applies to the address space it is submitted to. However a command that invalidates the MMU cache may invalidate the whole MMU cache rather than only those entries specific to one address space. "
        hexmask.long 0x00 0.--31. 1. " ST1MMUAS6COMMAND         ,ST1MMUAS6COMMAND"

group d:0xC050259C++0x03
    line.long 0x00 "ST1MMUAS6_FAULTSTATUS,   This register contains extended status information after a fault. If read before a fault occurs, its contents are the reset value, 0, which indicates no fault.       If multiple faults occur before the first is handled, the subsequent faults are ignored. They may fault again after handling the first one.  If the GPU is in protected mode, this register is not updated, and MMU faults are ignored.        They are not fatal but will halt the GPU until the MMU address space is updated.        However, no fault information wil be visible in this case.  Changed access type of MMU_FAULTSTATUS register when in protected mode. "
        hexmask.long.byte 0x00 10.--15. 1. " Res178                   ,Res178"
        hexmask.long.word 0x00 16.--31. 1. "           SOURCE_ID              ,   This field contains an implementation-defined ID that supplies additional data about the source of the fault. For example, it may be the ID of the internal bus master that issued the request that faulted. This makes it possible to distinguish between the job manager, the texture unit and the load/store unit. Another example might be an indication of the type of an invalid data structure. The values in this field are implementation defined. "
        hexmask.long.byte 0x00 0.--7. 1. "           EXCEPTION_TYPE       ,   This field indicates the type of exception that caused the fault. "
        bitfld.long 0x00 8.--9. "               ACCESS_TYPE      ,   This field contains the direction of data transfer that caused the fault, if known.  For the purposes of error reporting, atomic transactions act like a read followed by a write, so denying either permission will result in the atomic transaction failing, and the exceptions ACCESS_TYPE field will be set to 'atomic'. " "atomic,execute:  An execute transaction. ,read:  A read transaction. ,write:  A write transaction. "

group d:0xC05025A0++0x03
    line.long 0x00 "ST1MMUAS6_FAULTADDRESS_LO,   This register contains information about the cause of a page fault or bus error. "
        hexmask.long 0x00 0.--31. 1. " ST1MMUAS6FAULTADDRESS_LO ,   This field contains the virtual address (in this address space) of the access that caused the fault.  Additional information about the fault is also available in the FAULTSTATUS register.  If multiple faults occur before the first is handled, the subsequent faults are ignored. They may fault again after handling the first one. "

group d:0xC05025A4++0x03
    line.long 0x00 "ST1MMUAS6_FAULTADDRESS_HI,   This register contains information about the cause of a page fault or bus error. "
        hexmask.long 0x00 0.--31. 1. " ST1MMUAS6FAULTADDRESS_HI ,   This field contains the virtual address (in this address space) of the access that caused the fault.  Additional information about the fault is also available in the FAULTSTATUS register.  If multiple faults occur before the first is handled, the subsequent faults are ignored. They may fault again after handling the first one. "

group d:0xC05025A8++0x03
    line.long 0x00 "ST1MMUAS6_STATUS,   This register contains dynamic status information about this address space. "
        hexmask.long 0x00 1.--31. 1. " Res179                   ,Res179"
        bitfld.long 0x00 0. "     AS_ACTIVE              ,   This flag is set while a MMU_UPDATE, LOCK, UNLOCK, FLUSH_PT or FLUSH_MEM command is active on this address space. This allows software to safely verify that the address space is in a consistent state after reconfiguring the MMU page tables.  If a new command is written to the corresponding COMMAND register while the AS_ACTIVE bit is set, then the command is ignored. " "false,true"

group d:0xC05025B0++0x03
    line.long 0x00 "ST1MMUAS6_TRANSCFG_LO,ST1MMUAS6_TRANSCFG_LO"
        bitfld.long 0x00 4.--5. " Res180                   ,Res180" "0,1,2,3"
        bitfld.long 0x00 11.--13. "            Res181                 ,Res181" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 19.--21. "              Res182               ,Res182" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 23. "                Res183           ,Res183" "0,1"
        textline "                                     "
        bitfld.long 0x00 26.--27. "Res184                   ,Res184" "0,1,2,3"
        bitfld.long 0x00 31. "            Res185                 ,Res185" "0,1"
        bitfld.long 0x00 6.--10. "              INA_BITS             ,   This field allows the system software to restrict the range of input addresses accepted by this translation stage. This is used in conjunction with the hardware limits to determine the valid address range as follows:  INA_BITS_VALID = min(HW_INA_BITS, 55-INA_BITS)  If the input address is outside the range (0, 2  INA_BITS_VALID -1), then a TRANSLATION_FAULT error is generated." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"
        bitfld.long 0x00 14.--18. "               OUTA_BITS        ,   This field allows the system software to restrict the range of output addresses generated by this translation stage. This is used in conjunction with the hardware limits to determine the valid address range as follows:  OUTA_BITS_VALID = min(HW_OUTA_BITS, 55-OUTA_BITS)  If the translated output address is outside the range (0, 2  OUTA_BITS_VALID -1), then a TRANSLATION_FAULT error is generated." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"
        textline "                                     "
        bitfld.long 0x00 0.--3. "MODE                     ,   This field controls the overall operation of the MMU. There are some differences between stage 1 and stage 2.  Execute permissions for a page are evaluated as follows (PTE.&lt;W|R|X> refers to page table entry permissions resolved for hierarchical permissions (if applicable):  EXECUTE_ALLOWED = !((TRANSCFG.WXN &amp; !PTE.W) | (TRANSCFG.XREADABLE &amp; !PTE.R) | (!TRANSCFG.XREADABLE &amp; !PTE.X)) " "LEGACY,UNMAPPED,IDENTITY,3,4,5,AARCH64_4K,7,AARCH64_64K,9,10,11,12,13,14,15"
        bitfld.long 0x00 24.--25. "  PTW_MEMATTR            ,   Memory attributes for page table walks. The allowed values are compatible with the values allowed for  MEMORY_TYPE . For outer cache transactions, the desired attributes for the transaction will be decided by the bus master and communicated to the memory system using signals on the bus.  Changed allowed values for TRANSCFG.PTW_MEMATTR. " "0,NON_CACHEABLE,WRITE_BACK,3"
        bitfld.long 0x00 28.--29. "  PTW_SH               ,   This field specifies the shareability for the page table walks. This is the same encoding as used for ARMv8 page tables. " "non_shareable,1,outer_shareable,inner_shareable"
        bitfld.long 0x00 30. "  R_ALLOCATE       ,   This field sets the inner read allocation hint for the page table walks. This is the same encoding as used for ARMv8 page tables. " "no_read_allocate,read_allocate"
        textline "                                     "
        bitfld.long 0x00 22. "SL_CONCAT_EN             ,   If set then the page table walk starting level will be increased if possible by concatenating up to 16 tables in the starting level. " "false,true"

group d:0xC05025B4++0x03
    line.long 0x00 "ST1MMUAS6_TRANSCFG_HI,ST1MMUAS6_TRANSCFG_HI"
        bitfld.long 0x00 0. " Res186                   ,Res186" "0,1"
        hexmask.long 0x00 5.--31. 1. "            Res187                 ,Res187"
        bitfld.long 0x00 1. "       DISABLE_HIER_AP      ,   This flag only has an effect on stage 1 of translation. It is ignored for stage 2. Note the inverted logic - the flag must be set to  dis able hierarchical access permissions." "false,true"
        bitfld.long 0x00 2. "            DISABLE_AF_FAULT ,   This flag can be used to disable access fault checking when in one of AARCH64 modes. " "false,true"
        textline "                                     "
        bitfld.long 0x00 3. "WXN                      ,   This flag can be used to disable all writes to executable pages, overriding access permissions specified in the page table. " "false,true"
        bitfld.long 0x00 4. "        XREADABLE              ,   This flag can be used to enable execution on all readable pages, overriding access permissions specified in the page table. " "false,true"

group d:0xC05025B8++0x03
    line.long 0x00 "ST1MMUAS6_FAULTEXTRA_LO,   This register contains additional information about the cause of a page fault or bus error. "
        hexmask.long 0x00 0.--31. 1. " ST1MMUAS6FAULTEXTRA_LO   ,   This field contains the virtual address (in this address space) of the access that caused the fault.  Additional information about the fault is also available in the  FAULTSTATUS and FAULTADDRESS registers. If multiple faults occur before the first is handled, the subsequent faults are ignored. They may fault again after handling the first one.  Fixed duplicate state name in FAULT_ADDRESS - exposes previously hidden field S2FS1WALK. "

group d:0xC05025BC++0x03
    line.long 0x00 "ST1MMUAS6_FAULTEXTRA_HI,   This register contains additional information about the cause of a page fault or bus error. "
        hexmask.long.word 0x00 16.--30. 1. " Res188                   ,Res188"
        hexmask.long.word 0x00 0.--15. 1. "         ST1MMUAS6FAULTEXTRA_HI ,   This field contains the virtual address (in this address space) of the access that caused the fault.  Additional information about the fault is also available in the  FAULTSTATUS and FAULTADDRESS registers. If multiple faults occur before the first is handled, the subsequent faults are ignored. They may fault again after handling the first one.  Fixed duplicate state name in FAULT_ADDRESS - exposes previously hidden field S2FS1WALK. "
        bitfld.long 0x00 31. "           S2FS1WALK            ,S2FS1WALK" "stage2,stage1"

width 27.

group d:0xC05025C0++0x03
    line.long 0x00 "ST1MMUAS7_TRANSTAB_LO,   This register contains the address of the base level of the translation table, together with some related flags.  Details on the layout of the page tables, and the address translation process, can be found in the section  Memory Management Unit ."
        bitfld.long 0x00 0.--3. " Res189                   ,Res189" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        hexmask.long 0x00 4.--31. 1. "           ST1MMUAS7TRANSTAB_LO   ,   This field contains the address of the top level of a page table structure. This must be 16-byte-aligned, so address bits [3:0] are assumed to be zero.  For a stage 1 page table, this will be an intermediate physical address, and for stage 2 it will be a physical address. The number of actual translated address bits is stored in  OUTA_BITS . The unused high bits must be set to 0. Changed alignment text for TRANSTAB.BASE  TRANSTAB.BASE pointer is a physical (or intermediate) address "

group d:0xC05025C4++0x03
    line.long 0x00 "ST1MMUAS7_TRANSTAB_HI,   This register contains the address of the base level of the translation table, together with some related flags.  Details on the layout of the page tables, and the address translation process, can be found in the section  Memory Management Unit ."
        hexmask.long 0x00 0.--31. 1. " ST1MMUAS7TRANSTAB_HI     ,   This field contains the address of the top level of a page table structure. This must be 16-byte-aligned, so address bits [3:0] are assumed to be zero.  For a stage 1 page table, this will be an intermediate physical address, and for stage 2 it will be a physical address. The number of actual translated address bits is stored in  OUTA_BITS . The unused high bits must be set to 0. Changed alignment text for TRANSTAB.BASE  TRANSTAB.BASE pointer is a physical (or intermediate) address "

group d:0xC05025C8++0x03
    line.long 0x00 "ST1MMUAS7_MEMATTR_LO,"
        bitfld.long 0x00 0.--3. " ATTRIBUTE0               ,   This field specifies the memory attributes for memory type index 0. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 4.--7. "       ATTRIBUTE1             ,   This field specifies the memory attributes for memory type index 1. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 8.--11. "         ATTRIBUTE2           ,   This field specifies the memory attributes for memory type index 2. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 12.--15. "           ATTRIBUTE3       ,   This field specifies the memory attributes for memory type index 3. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        textline "                                     "
        bitfld.long 0x00 16.--19. "ATTRIBUTE4               ,   This field specifies the memory attributes for memory type index 4. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 20.--23. "       ATTRIBUTE5             ,   This field specifies the memory attributes for memory type index 5. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 24.--27. "         ATTRIBUTE6           ,   This field specifies the memory attributes for memory type index 6. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 28.--31. "           ATTRIBUTE7       ,   This field specifies the memory attributes for memory type index 7. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"

group d:0xC05025CC++0x03
    line.long 0x00 "ST1MMUAS7_MEMATTR_HI,"
        bitfld.long 0x00 0.--3. " ATTRIBUTE8               ,   This field specifies the memory attributes for memory type index 8. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 4.--7. "       ATTRIBUTE9             ,   This field specifies the memory attributes for memory type index 9. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 8.--11. "         ATTRIBUTE10          ,   This field specifies the memory attributes for memory type index 10. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 12.--15. "           ATTRIBUTE11      ,   This field specifies the memory attributes for memory type index 11. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        textline "                                     "
        bitfld.long 0x00 16.--19. "ATTRIBUTE12              ,   This field specifies the memory attributes for memory type index 12. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 20.--23. "       ATTRIBUTE13            ,   This field specifies the memory attributes for memory type index 13. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 24.--27. "         ATTRIBUTE14          ,   This field specifies the memory attributes for memory type index 14. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 28.--31. "           ATTRIBUTE15      ,   This field specifies the memory attributes for memory type index 15. " "NORMAL,FAULT,2,3,4,5,6,7,8,9,10,11,12,13,14,15"

group d:0xC05025D0++0x03
    line.long 0x00 "ST1MMUAS7_LOCKADDR_LO,   This register tells the MMU to lock a region of virtual memory. All page mappings within this region must be flushed, and no translation requests within this region can complete or fault before the area is unlocked.  Only one region can be locked at a time.  As only 32 bits of the register can be written to at a time, no changes are issued until the LOCK command is written to the COMMAND register. "
        hexmask.long.byte 0x00 6.--11. 1. " Res190                   ,Res190"
        hexmask.long.byte 0x00 0.--5. 1. "           LOCKADDR_SIZE          ,   This field contains the log  2 of the size of the region to lock, minus 1. Only values in the range 11 to 63 are valid values for this field, corresponding to region sizes of 4KB up to the entire address space. Values in the range 0 to 10 result in UNDEFINED behavior and should not be used."
        hexmask.long.tbyte 0x00 12.--31. 1. "             ST1MMUAS7LOCKADDR_LO ,   This field contains the lowest address in the region to be locked. The address is a virtual address in this address space.  Only the upper bits of the address are used. The address is aligned to a multiple of the region size, so a variable number of low-order bits are ignored, depending on the selected region size. It is recommended that software ensures that these low bits in the address are cleared, to avoid confusion. "

group d:0xC05025D4++0x03
    line.long 0x00 "ST1MMUAS7_LOCKADDR_HI,   This register tells the MMU to lock a region of virtual memory. All page mappings within this region must be flushed, and no translation requests within this region can complete or fault before the area is unlocked.  Only one region can be locked at a time.  As only 32 bits of the register can be written to at a time, no changes are issued until the LOCK command is written to the COMMAND register. "
        hexmask.long 0x00 0.--31. 1. " ST1MMUAS7LOCKADDR_HI     ,   This field contains the lowest address in the region to be locked. The address is a virtual address in this address space.  Only the upper bits of the address are used. The address is aligned to a multiple of the region size, so a variable number of low-order bits are ignored, depending on the selected region size. It is recommended that software ensures that these low bits in the address are cleared, to avoid confusion. "

group d:0xC05025D8++0x03
    line.long 0x00 "ST1MMUAS7_COMMAND,   MMU commands are issued by writing to this register. Any command written to an address space while the corresponding STATUS.AS_ACTIVE flag is set will be ignored.  In general an MMU command only applies to the address space it is submitted to. However a command that invalidates the MMU cache may invalidate the whole MMU cache rather than only those entries specific to one address space. "
        hexmask.long 0x00 0.--31. 1. " ST1MMUAS7COMMAND         ,ST1MMUAS7COMMAND"

group d:0xC05025DC++0x03
    line.long 0x00 "ST1MMUAS7_FAULTSTATUS,   This register contains extended status information after a fault. If read before a fault occurs, its contents are the reset value, 0, which indicates no fault.       If multiple faults occur before the first is handled, the subsequent faults are ignored. They may fault again after handling the first one.  If the GPU is in protected mode, this register is not updated, and MMU faults are ignored.        They are not fatal but will halt the GPU until the MMU address space is updated.        However, no fault information wil be visible in this case.  Changed access type of MMU_FAULTSTATUS register when in protected mode. "
        hexmask.long.byte 0x00 10.--15. 1. " Res191                   ,Res191"
        hexmask.long.word 0x00 16.--31. 1. "           SOURCE_ID              ,   This field contains an implementation-defined ID that supplies additional data about the source of the fault. For example, it may be the ID of the internal bus master that issued the request that faulted. This makes it possible to distinguish between the job manager, the texture unit and the load/store unit. Another example might be an indication of the type of an invalid data structure. The values in this field are implementation defined. "
        hexmask.long.byte 0x00 0.--7. 1. "           EXCEPTION_TYPE       ,   This field indicates the type of exception that caused the fault. "
        bitfld.long 0x00 8.--9. "               ACCESS_TYPE      ,   This field contains the direction of data transfer that caused the fault, if known.  For the purposes of error reporting, atomic transactions act like a read followed by a write, so denying either permission will result in the atomic transaction failing, and the exceptions ACCESS_TYPE field will be set to 'atomic'. " "atomic,execute:  An execute transaction. ,read:  A read transaction. ,write:  A write transaction. "

group d:0xC05025E0++0x03
    line.long 0x00 "ST1MMUAS7_FAULTADDRESS_LO,   This register contains information about the cause of a page fault or bus error. "
        hexmask.long 0x00 0.--31. 1. " ST1MMUAS7FAULTADDRESS_LO ,   This field contains the virtual address (in this address space) of the access that caused the fault.  Additional information about the fault is also available in the FAULTSTATUS register.  If multiple faults occur before the first is handled, the subsequent faults are ignored. They may fault again after handling the first one. "

group d:0xC05025E4++0x03
    line.long 0x00 "ST1MMUAS7_FAULTADDRESS_HI,   This register contains information about the cause of a page fault or bus error. "
        hexmask.long 0x00 0.--31. 1. " ST1MMUAS7FAULTADDRESS_HI ,   This field contains the virtual address (in this address space) of the access that caused the fault.  Additional information about the fault is also available in the FAULTSTATUS register.  If multiple faults occur before the first is handled, the subsequent faults are ignored. They may fault again after handling the first one. "

group d:0xC05025E8++0x03
    line.long 0x00 "ST1MMUAS7_STATUS,   This register contains dynamic status information about this address space. "
        hexmask.long 0x00 1.--31. 1. " Res192                   ,Res192"
        bitfld.long 0x00 0. "     AS_ACTIVE              ,   This flag is set while a MMU_UPDATE, LOCK, UNLOCK, FLUSH_PT or FLUSH_MEM command is active on this address space. This allows software to safely verify that the address space is in a consistent state after reconfiguring the MMU page tables.  If a new command is written to the corresponding COMMAND register while the AS_ACTIVE bit is set, then the command is ignored. " "false,true"

group d:0xC05025F0++0x03
    line.long 0x00 "ST1MMUAS7_TRANSCFG_LO,ST1MMUAS7_TRANSCFG_LO"
        bitfld.long 0x00 4.--5. " Res193                   ,Res193" "0,1,2,3"
        bitfld.long 0x00 11.--13. "            Res194                 ,Res194" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 19.--21. "              Res195               ,Res195" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 23. "                Res196           ,Res196" "0,1"
        textline "                                     "
        bitfld.long 0x00 26.--27. "Res197                   ,Res197" "0,1,2,3"
        bitfld.long 0x00 31. "            Res198                 ,Res198" "0,1"
        bitfld.long 0x00 6.--10. "              INA_BITS             ,   This field allows the system software to restrict the range of input addresses accepted by this translation stage. This is used in conjunction with the hardware limits to determine the valid address range as follows:  INA_BITS_VALID = min(HW_INA_BITS, 55-INA_BITS)  If the input address is outside the range (0, 2  INA_BITS_VALID -1), then a TRANSLATION_FAULT error is generated." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"
        bitfld.long 0x00 14.--18. "               OUTA_BITS        ,   This field allows the system software to restrict the range of output addresses generated by this translation stage. This is used in conjunction with the hardware limits to determine the valid address range as follows:  OUTA_BITS_VALID = min(HW_OUTA_BITS, 55-OUTA_BITS)  If the translated output address is outside the range (0, 2  OUTA_BITS_VALID -1), then a TRANSLATION_FAULT error is generated." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"
        textline "                                     "
        bitfld.long 0x00 0.--3. "MODE                     ,   This field controls the overall operation of the MMU. There are some differences between stage 1 and stage 2.  Execute permissions for a page are evaluated as follows (PTE.&lt;W|R|X> refers to page table entry permissions resolved for hierarchical permissions (if applicable):  EXECUTE_ALLOWED = !((TRANSCFG.WXN &amp; !PTE.W) | (TRANSCFG.XREADABLE &amp; !PTE.R) | (!TRANSCFG.XREADABLE &amp; !PTE.X)) " "LEGACY,UNMAPPED,IDENTITY,3,4,5,AARCH64_4K,7,AARCH64_64K,9,10,11,12,13,14,15"
        bitfld.long 0x00 24.--25. "  PTW_MEMATTR            ,   Memory attributes for page table walks. The allowed values are compatible with the values allowed for  MEMORY_TYPE . For outer cache transactions, the desired attributes for the transaction will be decided by the bus master and communicated to the memory system using signals on the bus.  Changed allowed values for TRANSCFG.PTW_MEMATTR. " "0,NON_CACHEABLE,WRITE_BACK,3"
        bitfld.long 0x00 28.--29. "  PTW_SH               ,   This field specifies the shareability for the page table walks. This is the same encoding as used for ARMv8 page tables. " "non_shareable,1,outer_shareable,inner_shareable"
        bitfld.long 0x00 30. "  R_ALLOCATE       ,   This field sets the inner read allocation hint for the page table walks. This is the same encoding as used for ARMv8 page tables. " "no_read_allocate,read_allocate"
        textline "                                     "
        bitfld.long 0x00 22. "SL_CONCAT_EN             ,   If set then the page table walk starting level will be increased if possible by concatenating up to 16 tables in the starting level. " "false,true"

group d:0xC05025F4++0x03
    line.long 0x00 "ST1MMUAS7_TRANSCFG_HI,ST1MMUAS7_TRANSCFG_HI"
        bitfld.long 0x00 0. " Res199                   ,Res199" "0,1"
        hexmask.long 0x00 5.--31. 1. "            Res200                 ,Res200"
        bitfld.long 0x00 1. "       DISABLE_HIER_AP      ,   This flag only has an effect on stage 1 of translation. It is ignored for stage 2. Note the inverted logic - the flag must be set to  dis able hierarchical access permissions." "false,true"
        bitfld.long 0x00 2. "            DISABLE_AF_FAULT ,   This flag can be used to disable access fault checking when in one of AARCH64 modes. " "false,true"
        textline "                                     "
        bitfld.long 0x00 3. "WXN                      ,   This flag can be used to disable all writes to executable pages, overriding access permissions specified in the page table. " "false,true"
        bitfld.long 0x00 4. "        XREADABLE              ,   This flag can be used to enable execution on all readable pages, overriding access permissions specified in the page table. " "false,true"

group d:0xC05025F8++0x03
    line.long 0x00 "ST1MMUAS7_FAULTEXTRA_LO,   This register contains additional information about the cause of a page fault or bus error. "
        hexmask.long 0x00 0.--31. 1. " ST1MMUAS7FAULTEXTRA_LO   ,   This field contains the virtual address (in this address space) of the access that caused the fault.  Additional information about the fault is also available in the  FAULTSTATUS and FAULTADDRESS registers. If multiple faults occur before the first is handled, the subsequent faults are ignored. They may fault again after handling the first one.  Fixed duplicate state name in FAULT_ADDRESS - exposes previously hidden field S2FS1WALK. "

group d:0xC05025FC++0x03
    line.long 0x00 "ST1MMUAS7_FAULTEXTRA_HI,   This register contains additional information about the cause of a page fault or bus error. "
        hexmask.long.word 0x00 16.--30. 1. " Res201                   ,Res201"
        hexmask.long.word 0x00 0.--15. 1. "         ST1MMUAS7FAULTEXTRA_HI ,   This field contains the virtual address (in this address space) of the access that caused the fault.  Additional information about the fault is also available in the  FAULTSTATUS and FAULTADDRESS registers. If multiple faults occur before the first is handled, the subsequent faults are ignored. They may fault again after handling the first one.  Fixed duplicate state name in FAULT_ADDRESS - exposes previously hidden field S2FS1WALK. "
        bitfld.long 0x00 31. "           S2FS1WALK            ,S2FS1WALK" "stage2,stage1"

tree.end

tree "pmuap"

width 28.

group d:0xD4282800++0x03
    line.long 0x00 "PMU_CC_CP,CP Clock Control Register"
        bitfld.long 0x00 31. " CP_RD_ST_CLEAR                  ,rd_st clear  cp_rd_status can be cleared by writing logic high on this bit." "0,1"
        bitfld.long 0x00 30. "         ACLK_DYN_FC15                    ,dynamic aclk clock change  writing this bit will change the bus clock without going through the core idle, memory controller idle process" "0,1"
        bitfld.long 0x00 29. "   DCLK_DYN_FC16                        ,dynamic dclk clock change  writing this bit will change the bus clock without going through the core idle, memory controller idle process" "0,1"
        bitfld.long 0x00 28. "   CORE_DYN_FC                      ,dynamic core clock change  writing this bit will change the core clock without going through the core idle, memory controller idle process" "0,1"
        textline "                                      "
        bitfld.long 0x00 27. "CP_ALLOW_SPD_CHG                ,<var processor: comm> speed change voting  1 = <var processor: comm> allows frequency change" "0,1"
        bitfld.long 0x00 26. "         BUS_FREQ_CHG_REQ19               ,aclk frequency change request. write 1 to vote frequency change." "0,1"
        bitfld.long 0x00 25. "   DDR_FREQ_CHG_REQ20                   ,dclk frequency change request. write 1 to vote frequency change" "0,1"
        bitfld.long 0x00 24. "   CP_FREQ_CHG_REQ                  ,<var processor: comm> frequency change request. write 1 to vote frequency change." "0,1"
        textline "                                      "
        bitfld.long 0x00 23. "ASYNC522                        ,ap bus interface sync with bus clock  1 = async must set to async" "0,1"
        bitfld.long 0x00 22. "         ASYNC423                         ,cp bus interface sync with bus interface  1 = async  this field must be set to async." "0,1"
        bitfld.long 0x00 21. "   ASYNC3_124                           ,axi bus interface sync with ddr controller  1 = async  this field must be set to async." "0,1"
        bitfld.long 0x00 20. "   ASYNC325                         ,axi bus interface sync with ddr clock  1 = async  this field must be set to async." "0,1"
        textline "                                      "
        bitfld.long 0x00 19. "ASYNC226                        ,ap bus interface sync with ddr clock  1 = async  this field must be set to async." "0,1"
        bitfld.long 0x00 18. "         ASYNC127                         ,cp bus interface sync with ddr clock  1 = async  this field must be set to async." "0,1"
        bitfld.long 0x00 15.--17. "   BUS_CLK_DIV28                        ,clock divider selection for aclk, aclk = <aclk_selection> in fccr/ (this field +1)" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 12.--14. "   DDR_CLK_DIV29                    ,pll1 clock divider configuration for dclk  when fcdclk dclksel is not 3'b00x, dclk source is pll2, pll3, pll4 or pll1_1248 and the divider is bypassed. when dclksel is 3'b00x, pll1_832 or pll1_624 is selected. dclk = <dclk_selection> in fcdclk/ (this fie" "0,1,2,3,4,5,6,7"
        textline "                                      "
        bitfld.long 0x00 0.--2. "CORE_CLK_DIV31                  ,clock divider selection for pclk of <var processor: comm>, pclk = (<var processor: comm> core clock selection in fccr) / (this field +1)" "0,1,2,3,4,5,6,7"

group d:0xD4282804++0x03
    line.long 0x00 "PMU_CC_AP,AP Clock Control Register"
        bitfld.long 0x00 31. " AP_RD_ST_CLEAR                  ,rd_st clear  ap_rd_status can be cleared by writing logic high on this bit" "0,1"
        bitfld.long 0x00 29. "         AP_C2_DYN_FC                     ,ap cluster2 dynamic clock change  writing this bit will change the core clock without going through the core idle, memory controller idle process" "0,1"
        bitfld.long 0x00 28. "   AP_C2_FREQ_CHG_REQ                   ,ap cluster2 frequency change request, the c2_clk_div and c2_aclk div is in pmu_cc3_ap register, should configure it before enable this bit" "0,1"
        bitfld.long 0x00 27. "   ACLK_DYN_FC42                    ,dynamic aclk clock change  writing this bit will change the bus clock without going through the core idle, memory controller idle process" "0,1"
        textline "                                      "
        bitfld.long 0x00 26. "DCLK_DYN_FC43                   ,dynamic dclk clock change  writing this bit will change the bus clock without going through the core idle, memory controller idle process" "0,1"
        bitfld.long 0x00 25. "         AP_C1_DYN_FC                     ,ap cluster1 dynamic clock change  writing this bit will change the core clock without going through the core idle, memory controller idle process" "0,1"
        bitfld.long 0x00 24. "   AP_C0_DYN_FC                         ,ap cluster0 dynamic clock change  writing this bit will change the core clock without going through the core idle, memory controller idle process" "0,1"
        bitfld.long 0x00 23. "   BUS_FREQ_CHG_REQ46               ,aclk frequency change request" "0,1"
        textline "                                      "
        bitfld.long 0x00 22. "DDR_FREQ_CHG_REQ47              ,dclk frequency change request" "0,1"
        bitfld.long 0x00 21. "         AP_C1_FREQ_CHG_REQ               ,ap cluster1 frequency change request" "0,1"
        bitfld.long 0x00 20. "   AP_C0_FREQ_CHG_REQ                   ,ap cluster0 frequency change request" "0,1"
        bitfld.long 0x00 18. "   AP_ALLOW_SPD_CHG                 ,ap speed change voting" "0,1"
        textline "                                      "
        bitfld.long 0x00 15.--17. "BUS_CLK_DIV52                   ,clock divider selection for aclk, aclk = <aclk_selection> in fcaclk/ (this field +1)" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 12.--14. "         DDR_CLK_DIV53                    ,pll1 clock divider configuration for dclk  when fcdclk dclksel is not 3'b00x, dclk source is pll2, pll3, pll4 or pll1_1248 and the divider is bypassed. when dclksel is 3'b00x, pll1_832 or pll1_624 is selected. dclk = <dclk_selection> in fcdclk/ (this field +1)." "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 9.--11. "   C1_ACLK_DIV54                        ,clock divider selection for cluster1 axi interface clock  c1_aclk is divided from pclk. c1_aclk= pclk / (this field +1)" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 6.--8. "   C1_CLK_DIV55                     ,clock divider selection for cluster1 pclk. if (fcap.c1_pllsel<=3), pclk= (fcap.c1_pllsel selectin clock )/(c1_clk_div +1);  else pclk =fcap.c1_pllsel selectin clock" "0,1,2,3,4,5,6,7"
        textline "                                      "
        bitfld.long 0x00 3.--5. "C0_ACLK_DIV56                   ,clock divider selection for cluster0 axi interface clock  c0_aclk is divided from pclk. c0_aclk= pclk / (this field +1)" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 0.--2. "         C0_CLK_DIV57                     ,clock divider selection for cluster0 pclk. if (fcap.c0_pllsel<=3), pclk= (fcap.c0_pllsel selectin clock )/(c0_clk_div +1);  else pclk =fcap.c0_pllsel selectin clock" "0,1,2,3,4,5,6,7"

group d:0xD4282808++0x03
    line.long 0x00 "PMU_DM_CC_CP,Dummy CP Clock Control Register"
        bitfld.long 0x00 31. " PM_AP_C2_FC_DONE64              ,ap frequency change done status  0x0 = frequency change is not done  0x1 = frequency change is done" "0,1"
        bitfld.long 0x00 30. "         PM_AP_C1_FC_DONE65               ,ap frequency change done status  0x0 = frequency change is not done  0x1 = frequency change is done" "0,1"
        bitfld.long 0x00 29. "   PM_ACLK_FC_DONE66                    ,aclk frequency change done status. this bit is set when a frequency change is done while the corresponding fc_req is still in assertion." "0,1"
        bitfld.long 0x00 28. "   PM_DCLK_FC_DONE67                ,dclk frequency change done status. this bit is set when a frequency change is done while the corresponding fc_req is still in assertion." "0,1"
        textline "                                      "
        bitfld.long 0x00 27. "PM_AP_C0_FC_DONE68              ,ap frequency change done status. this bit is set when a frequency change is done while the corresponding fc_req is still in assertion." "0,1"
        bitfld.long 0x00 26. "         CP_FC_DONE69                     ,cp frequency change done status. this bit is set when a frequency change is done while the corresponding fc_req is still in assertion." "0,1"
        bitfld.long 0x00 25. "   AP_RD_STATUS70                       ,ap read status  indicates that the dummy ap clock register is being read by cp or ap.  reading the status is the beginning of the frequency update process. if this bit is set, it indicates that one of the cores is in the frequency update process and the other core must wait until the other core clears this bit (using the <rd_st clear> field in the ap clock control register) to indicate that the frequency change process has completed." "0,1"
        bitfld.long 0x00 24. "   CP_RD_STATUS71                   ,cp read status  indicates that the dummy cp clock register is being read by cp or ap.  reading the status is the beginning of the frequency update process. if this bit is set, it indicates that one of the cores is in the frequency update process and the other core must wait until the other core clears this bit (using the <rd_st clear> field in the cp clock control register) to indicate that the frequency change process has completed." "0,1"
        textline "                                      "
        bitfld.long 0x00 23. "ASYNC572                        ,ap bus interface sync with bus clock  1 = async" "0,1"
        bitfld.long 0x00 22. "         ASYNC473                         ,cp bus interface sync with bus clock  1 = async" "0,1"
        bitfld.long 0x00 21. "   ASYNC3_174                           ,axi bus interface sync with ddr clock  1 = async" "0,1"
        bitfld.long 0x00 20. "   ASYNC375                         ,axi bus interface sync with ddr controller  1 = async" "0,1"
        textline "                                      "
        bitfld.long 0x00 19. "ASYNC276                        ,ap bus interface sync with ddr controller  1 = async" "0,1"
        bitfld.long 0x00 18. "         ASYNC177                         ,cp bus interface sync with ddr controller  1 = async" "0,1"
        bitfld.long 0x00 15.--17. "   BUS_CLK_DIV78                        ,clock divider selection for aclk  aclk = <aclk_selection> in fccr/ (this field +1)" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 12.--14. "   DDR_CLK_DIV79                    ,clock divider selection for dclk  dclk = <dclk_selection> in fccr/ (this field +1)" "0,1,2,3,4,5,6,7"
        textline "                                      "
        bitfld.long 0x00 0.--2. "CORE_CLK_DIV81                  ,clock divider selection for pclk of <var processor: comm>  pclk = (seagull core clock selection in fccr) / (this field +1)" "0,1,2,3,4,5,6,7"

group d:0xD428280C++0x03
    line.long 0x00 "PMU_DM_CC_AP,Dummy AP Clock Control Register"
        bitfld.long 0x00 31. " PM_AP_C2_FC_DONE88              ,ap frequency change done status  0x0 = frequency change is not done  0x1 = frequency change is done" "0,1"
        bitfld.long 0x00 30. "         PM_AP_C1_FC_DONE89               ,ap frequency change done status  0x0 = frequency change is not done  0x1 = frequency change is done" "0,1"
        bitfld.long 0x00 29. "   PM_ACLK_FC_DONE90                    ,aclk frequency change done status  0x0 = frequency change is not done  0x1 = frequency change is done" "0,1"
        bitfld.long 0x00 28. "   PM_DCLK_FC_DONE91                ,dclk frequency change done status  0x0 = frequency change is not done  0x1 = frequency change is done" "0,1"
        textline "                                      "
        bitfld.long 0x00 27. "PM_AP_C0_FC_DONE92              ,ap frequency change done status  0x0 = frequency change is not done  0x1 = frequency change is done" "0,1"
        bitfld.long 0x00 26. "         CP_FC_DONE93                     ,cp frequency change done status  0x0 = frequency change is not done  0x1 = frequency change is done" "0,1"
        bitfld.long 0x00 25. "   AP_RD_STATUS94                       ,ap read status  indicates that the dummy ap clock register is being read by cp or ap.  reading the status is the beginning of the frequency update process. if this bit is set, it indicates that one of the cores is in the frequency update process and the other core must wait until the other core clears this bit (using the <rd_st clear> field in the ap clock control register) to indicate that the frequency change process has completed." "0,1"
        bitfld.long 0x00 24. "   CP_RD_STATUS95                   ,cp read status  indicates that the dummy cp clock register is being read by cp or ap.  reading the status is the beginning of the frequency update process. if this bit is set, it indicates that one of the cores is in the frequency update process and the other core must wait until the other core clears this bit (using the <rd_st clear> field in the cp clock control register) to indicate that the frequency change process has completed." "0,1"
        textline "                                      "
        bitfld.long 0x00 23. "ASYNC596                        ,ap bus interface sync with bus interface" "0,1"
        bitfld.long 0x00 22. "         ASYNC497                         ,cp bus interface sync with bus interface" "0,1"
        bitfld.long 0x00 21. "   ASYNC3_198                           ,axi bus interface sync with ddr controller" "0,1"
        bitfld.long 0x00 20. "   ASYNC399                         ,axi bus interface sync with ddr controller" "0,1"
        textline "                                      "
        bitfld.long 0x00 19. "ASYNC2100                       ,ap bus interface sync with ddr controller" "0,1"
        bitfld.long 0x00 18. "         ASYNC1101                        ,cp bus interface sync with ddr controller" "0,1"
        bitfld.long 0x00 15.--17. "   BUS_CLK_DIV102                       ,clock divider selection for aclk, aclk = <aclk_selection> in fccr/ (this field +1)" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 12.--14. "   DDR_CLK_DIV103                   ,clock divider selection for dclk, dclk = <dclk_selection> in fccr/ (this field +1)" "0,1,2,3,4,5,6,7"
        textline "                                      "
        bitfld.long 0x00 9.--11. "C1_ACLK_DIV104                  ,clock divider selection for cluster1 axi interface clock  c1_aclk is divided from pclk. c1_aclk= pclk / (this field +1)" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 6.--8. "         C1_CLK_DIV105                    ,clock divider selection for cluster1 pclk. if (fcap.c1_pllsel<=3), pclk= (fcap.c1_pllsel selectin clock )/(c1_clk_div +1);  else pclk =fcap.c1_pllsel selectin clock" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 3.--5. "   C0_ACLK_DIV106                       ,clock divider selection for cluster0 axi interface clock  c0_aclk is divided from pclk. c0_aclk= pclk / (this field +1)" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 0.--2. "   C0_CLK_DIV107                    ,clock divider selection for cluster0 pclk. if (fcap.c0_pllsel<=3), pclk= (fcap.c0_pllsel selectin clock )/(c0_clk_div +1);  else pclk =fcap.c0_pllsel selectin clock" "0,1,2,3,4,5,6,7"

group d:0xD4282810++0x03
    line.long 0x00 "PMU_FC_TIMER,Frequency Change Timer Register"
        hexmask.long 0x00 3.--31. 1. " TIMER                           ,frequency change timer  this field defines the frequency change timer value in 26 mhz clock unit"
        bitfld.long 0x00 1.--2. "  TIMER_SEL                        ,timer select  this field defines the timer for applying the clock changes for cp and ap.  0x0 = ap pmu internak timer  0x1 = gsm tcu signal  0x2 = wb rtu signal" "0,1,2,3"
        bitfld.long 0x00 0. "   TIMER_EN                             ,timer enable  this field defines the timer for frequency change sequence.  0 = timer expiration will not be required before applying the new clock divider settings  1 = timer expiration will be required before starting the clock divider settings" "0,1"

group d:0xD4282814++0x03
    line.long 0x00 "PMU_CP_IDLE_CFG,CP Idle Configuration Register"
        bitfld.long 0x00 27.--31. " SEA_SRAM_WAIT                   ,sram power up wait cycle  sram power up counter for 20 ns  this field should remain set to the default value and should not be changed." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"
        bitfld.long 0x00 23.--26. "        SEA_SRAM_VMCVSSM                 ,l1/l2 pd vmc and vssm  this field lis the l1/l2 sram's pdlvmc and pdfvssm input. it should remain set to 0." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 21. "  SEA_DIS_MC_SW_REQ                    ,disable memory controller sw req  this field is used to disable the memory controller entry to idle mode using the memory controller sleep request bits. memory controller will always enter into idle mode based on the hardware state machine request.  0 =" "0,1"
        bitfld.long 0x00 20. "   PM_SEA_MC_WAKE_EN127             ,wake enable  wake up the memory controller when <var processor: comm> wakes up from core idle mode. memory controller will be woken up before the interrupt to the core is released.  0 = memory controller wake disabled  1 = memory controller wake up" "0,1"
        textline "                                      "
        bitfld.long 0x00 19. "CP_L2_PWR_SW                    ,l2sr swh  this field is the number of power switches for the l2 power.  0 = 1 power switch  1 = 2 power switches" "0,1"
        bitfld.long 0x00 18. "         CP_L1_PWR_SW                     ,l1sr swh  this field is the number of power switches for the l1 power.  0 = 1 power switch  1 = 2 power switches" "0,1"
        bitfld.long 0x00 16.--17. "   CP_CORE_PWR_SW                       ,swh  this field is the number of power switches for the core power  0x0 = 1 power switch  0x1 = 2 power switches  0x2 = 3 power switches  0x3 = 4 power switches" "0,1,2,3"
        bitfld.long 0x00 15. "   CP_DIS_L2_SLP2                   ,disable l2 slp2  this field is used to disable the cp l1/l2 power switch sleep2 power down during core power down mode.  1 = disable cp l2 power switch sleep2" "0,1"
        textline "                                      "
        bitfld.long 0x00 14. "CP_DIS_L2_SLP1                  ,disable l2 slp1  this field is used to disable the cp l1/l2 power switch sleep1 power down during core power down mode.  1 = disable cp l2 power switch sleep1" "0,1"
        bitfld.long 0x00 13. "         CP_DIS_SLP2                      ,disable slp2  this field is used to disable the cp core power switch sleep2 power down during core power down mode.  1 = disable ap power switch sleep2" "0,1"
        bitfld.long 0x00 12. "   CP_DIS_SLP1                          ,disable slp1  this field is used to disable the <var processor: application> core power switch sleep1 power down during core power down mode.  1 = disable ap power switch sleep1" "0,1"
        bitfld.long 0x00 11. "   SEA_MASK_JTAG_IDLE               ,mask the jtag idle check during core idle entry for <var processor: comm>  1 = mask the jtag idle check for <var processor: comm>" "0,1"
        textline "                                      "
        bitfld.long 0x00 10. "SEA_L2_CLK_DIS                  ,<var processor: comm> l2 clock enable/disable  1 = l2 controller clock is disabled  0 = l2 controller clock is enabled" "0,1"
        bitfld.long 0x00 9. "         SEA_L2_RESETN                    ,<var processor: comm> l2 assert reset  0 = l2 controller will be in reset  legacy bits only" "0,1"
        bitfld.long 0x00 8. "   CP_L2_ISOB                           ,cp l2 controller isolation enable  0 = isolation enable (power down mode)  1 = isolation disable (normal mode)  legacy bits only" "0,1"
        bitfld.long 0x00 7. "   CP_L2_PWR_OFF                    ,frc l2 sram off  1 = l2 cache power will be off, but l1 cache is retained" "0,1"
        textline "                                      "
        bitfld.long 0x00 6. "CP_SRAM_PWRDWN                  ,cp l1+l2 cache sram power down  1 = when the core issues idle (wait for interrupt or wfi command), the core will go into deep sleep mode and sram power will be off. cpu core will auto clear l1 cache." "0,1"
        bitfld.long 0x00 5. "         CP_PWRDWN                        ,cp power down  1 = when core issue idle (wait for interrupt or wfi command), the core will go into deep sleep mode." "0,1"
        bitfld.long 0x00 2. "   CP_DTCM_PDWN_DIS                     ,dtcm sram pdwn control disable  this field should be set to 0x0 so that tcm memory pdwn will be asserted automatically" "0,1"
        bitfld.long 0x00 0. "   MASK_WFI_CHECK145                ,debug only - it should be 0 during normal operation wfi state check mask  1 = status check masked  0 = status check not masked" "0,1"

group d:0xD428281C++0x03
    line.long 0x00 "PMU_SQU_CLK_GATE_CTRL,SQU Dynamic Clock Gate Control Register"
        bitfld.long 0x00 30. " MP3_MODE_EN                     ,1 = enable mp3 sleep mode.  0 = disable mp3 sleep mode" "0,1"
        bitfld.long 0x00 29. "         SQU_REFCLK_GATE_DIS              ,1 = sw control enable  0 = hardware dynamic gating" "0,1"
        bitfld.long 0x00 28. "   SQU_REFCLK_SW_EN                     ,1 = clock enable in sw mode  0 = clock disable in sw mode" "0,1"
        bitfld.long 0x00 21. "   SQU_BANK4CLK_GATE_DIS            ,1 = sw control enable  0 = hardware dynamic gating" "0,1"
        textline "                                      "
        bitfld.long 0x00 20. "SQU_BANK4CLK_SW_EN              ,1 = clock enable in sw mode  0 = clock disable in sw mode" "0,1"
        bitfld.long 0x00 19. "         SQU_BANK3CLK_GATE_DIS            ,1 = sw control enable  0 = hardware dynamic gating" "0,1"
        bitfld.long 0x00 18. "   SQU_BANK3CLK_SW_EN                   ,1 = clock enable in sw mode  0 = clock disable in sw mode" "0,1"
        bitfld.long 0x00 17. "   SQU_BANK2CLK_GATE_DIS            ,1 = sw control enable  0 = hardware dynamic gating" "0,1"
        textline "                                      "
        bitfld.long 0x00 16. "SQU_BANK2CLK_SW_EN              ,1 = clock enable in sw mode  0 = clock disable in sw mode" "0,1"
        bitfld.long 0x00 15. "         SQU_BANK1CLK_GATE_DIS            ,1 = sw control enable  0 = hardware dynamic gating" "0,1"
        bitfld.long 0x00 14. "   SQU_BANK1CLK_SW_EN                   ,1 = clock enable in sw mode  0 = clock disable in sw mode" "0,1"
        bitfld.long 0x00 13. "   SQU_BANK0CLK_GATE_DIS            ,1 = sw control enable  0 = hardware dynamic gating" "0,1"
        textline "                                      "
        bitfld.long 0x00 12. "SQU_BANK0CLK_SW_EN              ,1 = clock enable in sw mode  0 = clock disable in sw mode" "0,1"
        bitfld.long 0x00 11. "         SQU_S8CLK_GATE_DIS               ,1 = sw control enable  0 = hardware dynamic gating" "0,1"
        bitfld.long 0x00 10. "   SQU_S8CLK_SW_EN                      ,1 = clock enable in sw mode  0 = clock disable in sw mode" "0,1"
        bitfld.long 0x00 9. "   SQU_S4CLK_GATE_DIS               ,1 = sw control enable  0 = hardware dynamic gating" "0,1"
        textline "                                      "
        bitfld.long 0x00 8. "SQU_S4CLK_SW_EN                 ,1 = clock enable in sw mode  0 = clock disable in sw mode" "0,1"
        bitfld.long 0x00 7. "         SQU_S1CLK_GATE_DIS               ,1 = sw control enable  0 = hardware dynamic gating" "0,1"
        bitfld.long 0x00 6. "   SQU_S1CLK_SW_EN                      ,1 = clock enable in sw mode  0 = clock disable in sw mode" "0,1"
        bitfld.long 0x00 5. "   SQU_FMBISTCLK_GATE_DIS           ,1 = sw control enable  0 = hardware dynamic gating" "0,1"
        textline "                                      "
        bitfld.long 0x00 4. "SQU_FMBISTCLK_SW_EN             ,1 = clock enable in sw mode  0 = clock disable in sw mode" "0,1"
        bitfld.long 0x00 3. "         SQU_ROMCLK_GATE_DIS              ,1 = sw control enable  0 = hardware dynamic gating" "0,1"
        bitfld.long 0x00 2. "   SQU_ROMCLK_SW_EN                     ,1 = clock enable in sw mode  0 = clock disable in sw mode" "0,1"
        bitfld.long 0x00 1. "   SQU_CLK_GATE_DIS                 ,1 = sw control enable  0 = hardware dynamic gating" "0,1"
        textline "                                      "
        bitfld.long 0x00 0. "SQU_CLK_SW_EN                   ,1 = clock enable in sw mode  0 = clock disable in sw mode" "0,1"

group d:0xD4282820++0x03
    line.long 0x00 "PMU_JPG_CLK_RES_CTRL,JPG Clock/Reset Control Register"
        bitfld.long 0x00 17. " 2K_AFBC_CLK_EN                  ,2k afbc clock enable   1 = clock enabled  0 = clock disabled" "0,1"
        bitfld.long 0x00 16. "         4K_AFBC_CLK_EN                   ,4k afbc clock enable   1 = clock enabled  0 = clock disabled" "0,1"
        bitfld.long 0x00 15. "   JPG_CLK_FC_REQ                       ,jpg function clk fc request  1 = triggers a frequency change  this field is hardware cleared when the frequency change is done." "0,1"
        bitfld.long 0x00 5.--7. "   JPG_CLK_DIV                      ,jpg function clock divide ratio  isp_clk = jpg_clk_div / (this field +1)" "0,1,2,3,4,5,6,7"
        textline "                                      "
        bitfld.long 0x00 2.--4. "JPG_CLK_SEL                     ,jpg function clock source select  0x0 = 624 mhz  0x1 = 499 mhz  0x2 = 832  0x3 = pll3_div3  0x4 = pll4_div2  0x5 = pll5_div2  0x6 = pll3_div2  0x7 = 1248mhz" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 1. "         JPG_CLK_EN                       ,jpg function clock enable  1 = clock enabled  0 = clock disabled" "0,1"
        bitfld.long 0x00 0. "   JPG_CLK_RSTN                         ,jpg function clock reset  0 = reset" "0,1"

group d:0xD4282824++0x03
    line.long 0x00 "PMU_CSI_CCIC2_CLK_RES_CTRL,CSI CCIC2 Clock/Reset Control Register"
        bitfld.long 0x00 31. " CCIC3_PHY_CLK_SEL               ,ccic3 phy clock select  0 = 104 mhz  1 = 52 mhz" "0,1"
        bitfld.long 0x00 30. "         CCIC3_PHY_CLK_EN                 ,ccic3 phy clock enable  1 = phy clock enabled  0 = phy clock disabled" "0,1"
        bitfld.long 0x00 29. "   CCIC3_PHY_CLK_RST                    ,ccic3 phy clock reset  this clock is also used for dphy reset.  0 = reset" "0,1"
        bitfld.long 0x00 28. "   CAM_MCLK0_EN                     ,cam mclk0 enable" "0,1"
        textline "                                      "
        bitfld.long 0x00 27. "CAM_MCLK_EN                     ,cam mclk enable" "0,1"
        bitfld.long 0x00 23.--26. "         ISIM_VCLK_OUT_DIV                ,clock divider for isim_vclk_out  the source sensor reference clock is selected by [9:8]. the divider of the sensor reference clock is controlled by this register.  isim_vclk_out = isim_vclk_out_div / (this field +1)  the default value is 312/(11+1) = 26 mhz" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 20.--22. "  CSI_FNC_CLK_DIV                      ,csi controller function clock divide ratio  csi_fnc_clk = csi_fnc_clk_div / (this field +1)" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 16.--18. "   CSI_CLK_SEL                      ,csi controller function clock source select  0x0 = pll3_div4 mhz  0x1 = pll4_div3  0x2 = 624   0x3 = pll3_div3   0x4 = 832 mhz  0x5 = pll4_div2  0x6 = pll3_div2   0x7 = pll2_div2" "0,1,2,3,4,5,6,7"
        textline "                                      "
        bitfld.long 0x00 15. "CSI_CLK_FC_REQ                  ,csi controller function clk fc request  1 = trigger frequency change  this field is cleared when the fc completes." "0,1"
        bitfld.long 0x00 8.--9. "         CAM_MCLK_SEL                     ,cam mclkselect  0 = 312 mhz  1 = pll2_div5   2 = 416mhz   3 = pll4_div5" "0,1,2,3"
        bitfld.long 0x00 7. "   CCIC2_PHYCLK_SEL                     ,ccic2 phy clock select  0 = 104 mhz  1 = 52 mhz" "0,1"
        bitfld.long 0x00 6. "   CAM_MCLK1_EN                     ,cam mclk1 enable" "0,1"
        textline "                                      "
        bitfld.long 0x00 5. "CCIC2_PHYCLK_EN                 ,ccic2 phy clock enable  1 = phy clock enabled  0 = phy clock disabled" "0,1"
        bitfld.long 0x00 4. "         CSI_CLK_EN                       ,csi controller function clock enable  1 = peripheral clock enabled  0 = peripheral clock disabled" "0,1"
        bitfld.long 0x00 2. "   CCIC2_PHYCLK_RST                     ,ccic2 phy clock reset  this clock is also used for dphy reset.  0 = reset" "0,1"
        bitfld.long 0x00 1. "   CSI_CLK_RST                      ,reset for csi controller function clock  0 = reset" "0,1"

group d:0xD4282828++0x03
    line.long 0x00 "PMU_CCIC1_CLK_GATE_CTRL,CMOS Camera Interface Controller 1 Dynamic Clock Gate Control Register"
        bitfld.long 0x00 30.--31. " CCIC1_GATE_CSI_CLK_STATIC       ,ccic1 csi static clock gate control  0x0 = hardware dynamic control  0x0 =stop clock   0x1 = stop clock   0x2 = stop clock  0x3 = free running" "0,1,2,3"
        bitfld.long 0x00 28.--29. "         CCIC1_GATE_CLK4X_STATIC          ,ccic1 clk1x static clock gate control  0x0 =stop clock   0x1 = stop clock   0x2 = stop clock  0x3 = free running" "0,1,2,3"
        bitfld.long 0x00 26.--27. "   CCIC1_GATE_CLK1X_STATIC              ,ccic1 hclk static clock gate control  0x0 =stop clock   0x1 = stop clock   0x2 = stop clock  0x3 = free running" "0,1,2,3"
        bitfld.long 0x00 24.--25. "   CCIC1_GATE_HCLK_STATIC           ,ccic1 aclk static clock gate control  0x0 =stop clock   0x1 = stop clock   0x2 = stop clock  0x3 = free running" "0,1,2,3"
        textline "                                      "
        bitfld.long 0x00 22.--23. "CCIC1_GATE_ACLK_STATIC231       ,ccic1 aclk static clock gate control  0x0 =stop clock   0x1 = stop clock   0x2 = stop clock  0x3 = free running" "0,1,2,3"
        bitfld.long 0x00 20.--21. "         CCIC1_GATE_ISP_PIP1_CLK1X_STATIC ,isp pipe1 clk1x static clock gate control  0x0 =stop clock   0x1 = stop clock   0x2 = stop clock  0x3 = free running" "0,1,2,3"
        bitfld.long 0x00 18.--19. "   CCIC1_GATE_ACLK_STATIC233            ,ccic dma aclk static clock gate contro  0x0 =stop clock   0x1 = stop clock   0x2 = stop clock  0x3 = free running" "0,1,2,3"
        bitfld.long 0x00 16.--17. "   CCIC1_GATE_AXI_BRIDGE_CLK_STATIC ,ccic dma (axi bridge 64 to128) hclk static clock gate control  0x0 =stop clock   0x1 = stop clock   0x2 = stop clock  0x3 = free running" "0,1,2,3"
        textline "                                      "
        bitfld.long 0x00 14.--15. "CCIC1_GATE_LANE3_CLK_DYNAMIC    ,ccic1 csi lane3 clock dynamic clock gate control  0x0 = hardware dynamic control  0x1 = hardware dynamic control  0x2 = stop clock  0x3 = free running" "0,1,2,3"
        bitfld.long 0x00 12.--13. "         CCIC1_GATE_LANE2_CLK_DYNAMIC     ,ccic1 csi lane 2 clock dynamic clock gate control  0x0 = hardware dynamic control  0x1 = hardware dynamic control  0x2 = stop clock  0x3 = free running" "0,1,2,3"
        bitfld.long 0x00 10.--11. "   CCIC1_GATE_LANE1_CLK_DYNAMIC         ,ccic1 csi lane 1 clock dynamic clock gate control  0x0 = hardware dynamic control  0x1 = hardware dynamic control  0x2 = stop clock  0x3 = free running" "0,1,2,3"
        bitfld.long 0x00 8.--9. "   CCIC1_GATE_LANE0_CLK_DYNAMIC     ,ccic1 csi lane 0 clock dynamic clock gate control  0x0 = hardware dynamic control  0x1 = hardware dynamic control  0x2 = stop clock  0x3 = free running" "0,1,2,3"
        textline "                                      "
        bitfld.long 0x00 6.--7. "CCIC1_GATE_CSI_CLK_DYNAMIC      ,ccic1 csi clock dynamic clock gate control  0x0 = hardware dynamic control  0x1 = hardware dynamic control  0x2 = stop clock  0x3 = free running" "0,1,2,3"
        bitfld.long 0x00 4.--5. "         CCIC1_GATE_AHB_CLK_DYNAMIC       ,ccic1 ahb clock dynamic clock gate control  0x0 = hardware dynamic control  0x1 = hardware dynamic control  0x2 = stop clock  0x3 = free running" "0,1,2,3"
        bitfld.long 0x00 2.--3. "   CCIC1_GATE_PIP_CLK_DYNAMIC           ,ccic1 pipeline clock dynamic clock gate control  0x0 = hardware dynamic control  0x1 = hardware dynamic control  0x2 = stop clock  0x3 = free running" "0,1,2,3"
        bitfld.long 0x00 0.--1. "   CCIC1_GATE__AXI_CLK_DYNAMIC      ,ccic1 axi clock dynamic clock gate control  0x0 = hardware dynamic control  0x1 = hardware dynamic control  0x2 = stop clock  0x3 = free running" "0,1,2,3"

group d:0xD428282C++0x03
    line.long 0x00 "PMU_FBRC0_CLK_GATE_CTRL,Fabric0 Dynamic Clock Gate Control Register"
        bitfld.long 0x00 28.--31. " PM_249                          ," "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 27. "        FBCR0_DTCCLK_SW_EN               ,axi fabric0 dtc port clock sw mode clock enable  1 = software control enable  0 = hardware dynamic gating" "0,1"
        bitfld.long 0x00 26. "   FBCR0_DTCCLK_GATE_DIS                ,axi fabric0 dtc port clock dynamic gating disable  1 = clock enable in software mode  0 = clock disable in software mode" "0,1"
        bitfld.long 0x00 25. "   FBCR0_S6CLK_SW_EN                ,axi fabric0 s6 port clock sw mode clock enable  1 = software control enable  0 = hardware dynamic gating" "0,1"
        textline "                                      "
        bitfld.long 0x00 24. "FBCR0_S6CLK_GATE_DIS            ,axi fabric0 s6 port clock dynamic gating disable  1 = clock enable in software mode  0 = clock disable in software mode" "0,1"
        bitfld.long 0x00 23. "         FBCR0_S5CLK_SW_EN                ,axi fabric0 s5 port clock sw mode clock enable  1 = software control enable  0 = hardware dynamic gating" "0,1"
        bitfld.long 0x00 22. "   FBCR0_S5CLK_GATE_DIS                 ,axi fabric0 s5 port clock dynamic gating disable  1 = clock enable in software mode  0 = clock disable in software mode" "0,1"
        bitfld.long 0x00 21. "   FBCR0_S4CLK_SW_EN                ,axi fabric0 s4 port clock sw mode clock enable  1 = software control enable  0 = hardware dynamic gating" "0,1"
        textline "                                      "
        bitfld.long 0x00 20. "FBCR0_S4CLK_GATE_DIS            ,axi fabric0 s4 port clock dynamic gating disable  1 = clock enable in software mode  0 = clock disable in software mode" "0,1"
        bitfld.long 0x00 19. "         FBCR0_S3CLK_SW_EN                ,axi fabric0 s3 port clock sw mode clock enable  1 = software control enable  0 = hardware dynamic gating" "0,1"
        bitfld.long 0x00 18. "   FBCR0_S3CLK_GATE_DIS                 ,axi fabric0 s3 port clock dynamic gating disable  1 = clock enable in software mode  0 = clock disable in software mode" "0,1"
        bitfld.long 0x00 17. "   FBCR0_S2CLK_SW_EN                ,axi fabric0 s2 port clock sw mode clock enable  1 = software control enable  0 = hardware dynamic gating" "0,1"
        textline "                                      "
        bitfld.long 0x00 16. "FBCR0_S2CLK_GATE_DIS            ,axi fabric0 s2 port clock dynamic gating disable  1 = clock enable in software mode  0 = clock disable in software mode" "0,1"
        bitfld.long 0x00 15. "         FBCR0_S1CLK_SW_EN                ,axi fabric0 s1 port clock sw mode clock enable  1 = software control enable  0 = hardware dynamic gating" "0,1"
        bitfld.long 0x00 14. "   FBCR0_S1CLK_GATE_DIS                 ,  1 = clock enable in software mode  0 = clock disable in software mode" "0,1"
        bitfld.long 0x00 13. "   FBCR0_S0CLK_SW_EN                ,  1 = software control enable  0 = hardware dynamic gating" "0,1"
        textline "                                      "
        bitfld.long 0x00 12. "FBCR0_S0CLK_GATE_DIS            ,  1 = clock enable in software mode  0 = clock disable in software mode" "0,1"
        bitfld.long 0x00 11. "         FBCR0_M4CLK_SW_EN                ,  1 = software control enable  0 = hardware dynamic gating" "0,1"
        bitfld.long 0x00 10. "   FBCR0_M4CLK_GATE_DIS                 ,  1 = clock enable in software mode  0 = clock disable in software mode" "0,1"
        bitfld.long 0x00 9. "   FBCR0_M3CLK_SW_EN                ,  1 = software control enable  0 = hardware dynamic gating" "0,1"
        textline "                                      "
        bitfld.long 0x00 8. "FBCR0_M3CLK_GATE_DIS            ,  1 = clock enable in software mode  0 = clock disable in software mode" "0,1"
        bitfld.long 0x00 7. "         FBCR0_M2CLK_SW_EN                ,  1 = software control enable  0 = hardware dynamic gating" "0,1"
        bitfld.long 0x00 6. "   FBCR0_M2CLK_GATE_DIS                 ,  1 = clock enable in software mode  0 = clock disable in software mode" "0,1"
        bitfld.long 0x00 5. "   FBCR0_M1CLK_SW_EN                ,  1 = software control enable  0 = hardware dynamic gating" "0,1"
        textline "                                      "
        bitfld.long 0x00 4. "FBCR0_M1CLK_GATE_DIS            ,  1 = clock enable in software mode  0 = clock disable in software mode" "0,1"
        bitfld.long 0x00 3. "         FBCR0_M0CLK_SW_EN                ,  1 = software control enable  0 = hardware dynamic gating" "0,1"
        bitfld.long 0x00 2. "   FBCR0_M0CLK_GATE_DIS                 ,  1 = clock enable in software mode  0 = clock disable in software mode" "0,1"
        bitfld.long 0x00 1. "   FBCR0_CLK_SW_EN                  ,  1 = software control enable  0 = hardware dynamic gating" "0,1"
        textline "                                      "
        bitfld.long 0x00 0. "FBCR0_CLK_GATE_DIS              ,  1 = clock enable in software mode  0 = clock disable in software mode" "0,1"

group d:0xD4282830++0x03
    line.long 0x00 "PMU_FBRC1_CLK_GATE_CTRL,Fabric1 Dynamic Clock Gate Control Register"
        hexmask.long.word 0x00 20.--31. 1. " PM_284                          ,"
        bitfld.long 0x00 19. "      FBCR1_S12CLK_SW_EN               ,1 = sw control enable  0 = hardware dynamic gating" "0,1"
        bitfld.long 0x00 18. "   FBCR1_S12CLK_GATE_DIS                ,1 = clock enable in sw mode  0 = clock disable in sw mode" "0,1"
        bitfld.long 0x00 17. "   FBCR1_S11CLK_SW_EN               ,1 = sw control enable  0 = hardware dynamic gating" "0,1"
        textline "                                      "
        bitfld.long 0x00 16. "FBCR1_S11CLK_GATE_DIS           ,1 = clock enable in sw mode  0 = clock disable in sw mode" "0,1"
        bitfld.long 0x00 15. "         FBCR1_S10CLK_SW_EN               ,1 = sw control enable  0 = hardware dynamic gating" "0,1"
        bitfld.long 0x00 14. "   FBCR1_S10CLK_GATE_DIS                ,1 = clock enable in sw mode  0 = clock disable in sw mode" "0,1"
        bitfld.long 0x00 13. "   FBCR1_M15CLK_SW_EN               ,1 = sw control enable  0 = hardware dynamic gating" "0,1"
        textline "                                      "
        bitfld.long 0x00 12. "FBCR1_M15CLK_GATE_DIS           ,1 = clock enable in sw mode  0 = clock disable in sw mode" "0,1"
        bitfld.long 0x00 11. "         FBCR1_M14CLK_SW_EN               ,1 = sw control enable  0 = hardware dynamic gating" "0,1"
        bitfld.long 0x00 10. "   FBCR1_M14CLK_GATE_DIS                ,1 = clock enable in sw mode  0 = clock disable in sw mode" "0,1"
        bitfld.long 0x00 9. "   FBCR1_M13CLK_SW_EN               ,1 = sw control enable  0 = hardware dynamic gating" "0,1"
        textline "                                      "
        bitfld.long 0x00 8. "FBCR1_M13CLK_GATE_DIS           ,1 = clock enable in sw mode  0 = clock disable in sw mode" "0,1"
        bitfld.long 0x00 7. "         FBCR1_M12CLK_SW_EN               ,1 = sw control enable  0 = hardware dynamic gating" "0,1"
        bitfld.long 0x00 6. "   FBCR1_M12CLK_GATE_DIS                ,1 = clock enable in sw mode  0 = clock disable in sw mode" "0,1"
        bitfld.long 0x00 5. "   FBCR1_M11CLK_SW_EN               ,1 = sw control enable  0 = hardware dynamic gating" "0,1"
        textline "                                      "
        bitfld.long 0x00 4. "FBCR1_M11CLK_GATE_DIS           ,1 = clock enable in sw mode  0 = clock disable in sw mode" "0,1"
        bitfld.long 0x00 3. "         FBCR1_M10CLK_SW_EN               ,1 = sw control enable  0 = hardware dynamic gating" "0,1"
        bitfld.long 0x00 2. "   FBCR1_M10CLK_GATE_DIS                ,1 = clock enable in sw mode  0 = clock disable in sw mode" "0,1"
        bitfld.long 0x00 1. "   FBCR1_CLK_SW_EN                  ,1 = sw control enable  0 = hardware dynamic gating" "0,1"
        textline "                                      "
        bitfld.long 0x00 0. "FBCR1_CLK_GATE_DIS              ,1 = clock enable in sw mode  0 = clock disable in sw mode" "0,1"

group d:0xD4282834++0x03
    line.long 0x00 "PMU_USB_CLK_GATE_CTRL,USB Dynamic Clock Gate Control Register"
        hexmask.long.byte 0x00 24.--31. 1. " PM_311                          ,"
        bitfld.long 0x00 23. "        SPH_ACLK_GATE_DIS                ,1 = sw control enable  0 = hardware dynamic gating" "0,1"
        bitfld.long 0x00 22. "   SPH_ACLK_SW_EN                       ,1 = clock enable in sw mode  0 = clock disable in sw mode" "0,1"
        bitfld.long 0x00 21. "   SPH_RXCLKA_GATE_DIS              ,1 = sw control enable  0 = hardware dynamic gating" "0,1"
        textline "                                      "
        bitfld.long 0x00 20. "SPH_RXCLKA_SW_EN                ,1 = clock enable in sw mode  0 = clock disable in sw mode" "0,1"
        bitfld.long 0x00 19. "         SPH_TXCLKB_GATE_DIS              ,1 = sw control enable  0 = hardware dynamic gating" "0,1"
        bitfld.long 0x00 18. "   SPH_TXCLKB_SW_EN                     ,1 = clock enable in sw mode  0 = clock disable in sw mode" "0,1"
        bitfld.long 0x00 17. "   SPH_RXCLKB_GATE_DIS              ,1 = sw control enable  0 = hardware dynamic gating" "0,1"
        textline "                                      "
        bitfld.long 0x00 16. "SPH_RXCLKB_SW_EN                ,1 = clock enable in sw mode  0 = clock disable in sw mode" "0,1"
        bitfld.long 0x00 15. "         SPH_TXCLKA_GATE_DIS              ,1 = sw control enable  0 = hardware dynamic gating" "0,1"
        bitfld.long 0x00 14. "   SPH_TXCLKA_SW_EN                     ,1 = clock enable in sw mode  0 = clock disable in sw mode" "0,1"
        bitfld.long 0x00 13. "   SPH_CLK_GATE_DIS                 ,1 = sw control enable  0 = hardware dynamic gating" "0,1"
        textline "                                      "
        bitfld.long 0x00 12. "SPH_CLK_SW_EN                   ,1 = clock enable in sw mode  0 = clock disable in sw mode" "0,1"
        bitfld.long 0x00 11. "         USB_ACLK_GATE_DIS                ,1 = sw control enable  0 = hardware dynamic gating" "0,1"
        bitfld.long 0x00 10. "   USB_ACLK_SW_EN                       ,1 = clock enable in sw mode  0 = clock disable in sw mode" "0,1"
        bitfld.long 0x00 9. "   USB_RXCLKA_GATE_DIS              ,1 = sw control enable  0 = hardware dynamic gating" "0,1"
        textline "                                      "
        bitfld.long 0x00 8. "USB_RXCLKA_SW_EN                ,1 = clock enable in sw mode  0 = clock disable in sw mode" "0,1"
        bitfld.long 0x00 7. "         USB_TXCLKB_GATE_DIS              ,1 = sw control enable  0 = hardware dynamic gating" "0,1"
        bitfld.long 0x00 6. "   USB_TXCLKB_SW_EN                     ,1 = clock enable in sw mode  0 = clock disable in sw mode" "0,1"
        bitfld.long 0x00 5. "   USB_RXCLKB_GATE_DIS              ,1 = sw control enable  0 = hardware dynamic gating" "0,1"
        textline "                                      "
        bitfld.long 0x00 4. "USB_RXCLKB_SW_EN                ,1 = clock enable in sw mode  0 = clock disable in sw mode" "0,1"
        bitfld.long 0x00 3. "         USB_TXCLKA_GATE_DIS              ,1 = sw control enable  0 = hardware dynamic gating" "0,1"
        bitfld.long 0x00 2. "   USB_TXCLKA_SW_EN                     ,1 = clock enable in sw mode  0 = clock disable in sw mode" "0,1"
        bitfld.long 0x00 1. "   USB_CLK_GATE_DIS                 ,1 = sw control enable  0 = hardware dynamic gating" "0,1"
        textline "                                      "
        bitfld.long 0x00 0. "USB_CLK_SW_EN                   ,1 = clock enable in sw mode  0 = clock disable in sw mode" "0,1"

group d:0xD4282838++0x03
    line.long 0x00 "PMU_ISP_CLK_RES_CTRL,ISP Clock/Reset Control Register"
        bitfld.long 0x00 31. " ISP_PDWN                        ,isp power down control  this field is active high." "0,1"
        bitfld.long 0x00 30. "         ISP_REPAIR_MEM_CTRL_TRIG         ,isp repairable memory control trigger  1 = triggers isp repairable memory control  this register is hardware cleared when the repair to memory control is done." "0,1"
        bitfld.long 0x00 29. "   ISP_REPAIR_MEM_CTRL_DONE_BYPASS      ,isp repairable memory control done bypass in isp hardware mode  this field is valid when the isp is in hardware mode (isp_hw_mode = 1)." "0,1"
        bitfld.long 0x00 28. "   ISP_MCU_CLK_EN                   ,isp mcu function clock enable  1 = clock enabled  0 = clock disabled" "0,1"
        textline "                                      "
        bitfld.long 0x00 27. "ISP_MCU_CLK_RSTN                ,isp mcu clock reset  0 = reset" "0,1"
        bitfld.long 0x00 26. "         ISP_MCU_CLK_SEL                  ,isp mcu clock divider  0 = 312mhz  1 = 416mhz" "0,1"
        bitfld.long 0x00 24.--25. "   ISP_MCU_CLK_DIV                      ,isp mcu clock divider  isp_mcu_clk = clk/ (this field +1)" "0,1,2,3"
        bitfld.long 0x00 23. "   ISP_CI_BUS_CLK_FC_REQ            ,isp_ci bus clock fc request  1 = triggers a frequency change  this field is hardware cleared when the frequency change is done." "0,1"
        textline "                                      "
        bitfld.long 0x00 21.--22. "ISP_CI_BUS_CLK_SEL              ,isp_ci bus clock select  0x0 =pll1-624 mhz  0x1 = pll1-832 mhz  0x2 = pll1-499m  0x3 =  pll4_div3" "0,1,2,3"
        bitfld.long 0x00 18.--20. "         ISP_CI_BUS_CLK_DIV               ,isp_ci bus clock divide ratio  isp_ci_divided_bus_clk = isp_ci_bus_clk / (this field +1)" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 17. "   ISP_CI_BUS_CLK_EN                    ,isp_ci bus clk enable  this field is the dma clk enable for ccic and isp. it controls the first level axi clock gating for ccic and isp. the second level axi clock gating for ccic and isp each have separate gating control registers.< p>1 = clock enabled<" "0,1"
        bitfld.long 0x00 16. "   ISP_CI_BUS_CLK_RST               ,isp_ci bus clk reset  0 = reset<p>this reset will reset all the axi logic in sc2 expect isp axi logic" "0,1"
        textline "                                      "
        bitfld.long 0x00 15. "ISP_HW_MODE                     ,isp hardware on/off control mode  1 = hardware controls isp on/off procedure" "0,1"
        bitfld.long 0x00 14. "         ISP_SLEEP2                       ,isp power switch sleep2" "0,1"
        bitfld.long 0x00 13. "   ISP_SLEEP1                           ,isp power switch sleep1" "0,1"
        bitfld.long 0x00 12. "   ISP_ISOB                         ,isp isolation cell enable" "0,1"
        textline "                                      "
        bitfld.long 0x00 8.--10. "ISP_CLK_SEL                     ,isp function clock source select: [bit9, bit3, bit2]   0x0 = 416 mhz  0x1 = 499 mhz  0x2 = 624   0x3 = pll4_div4   0x4 = pll5_div3   0x5= pll5_div5  0x6 = pll2_div4   0x7 = pll3_div3" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 7. "         ISP_CLK_FC_REQ                   ,isp function clk fc request  1 = triggers a frequency change  this field is hardware cleared when the frequency change is done." "0,1"
        bitfld.long 0x00 4.--6. "   ISP_CLK_DIV                          ,isp function clock divide ratio  isp_clk = isp_clk_div / (this field +1)" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 3. "   ISP_AXI_RESETN                   ,isp axi resetn  0 =  reset" "0,1"
        textline "                                      "
        bitfld.long 0x00 1. "ISP_CLK_EN                      ,isp function clock enable  1 = clock enabled  0 = clock disabled" "0,1"
        bitfld.long 0x00 0. "         ISP_CLK_RSTN                     ,isp function clock reset  0 = reset" "0,1"

group d:0xD4282840++0x03
    line.long 0x00 "PMU_PMU_CLK_GATE_CTRL,PMU Dynamic Clock Gate Control Register"
        bitfld.long 0x00 31. " 1248M_D1P_EN                    ,1 = clock enable  0 = clock disable. in d0, this bit is not used" "0,1"
        bitfld.long 0x00 30. "         832M_D1P_EN                      ,1 = clock enable  0 = clock disable. in d0, this bit is not used" "0,1"
        bitfld.long 0x00 29. "   624M_D1P_EN                          ,1 = clock enable  0 = clock disable. in d0, this bit is not used" "0,1"
        bitfld.long 0x00 28. "   499M_D1P_EN                      ,1 = clock enable  0 = clock disable. in d0, this bit is not used" "0,1"
        textline "                                      "
        bitfld.long 0x00 27. "416M_D1P_EN                     ,1 = clock enable  0 = clock disable. in d0, this bit is not used" "0,1"
        bitfld.long 0x00 26. "         312M_D1P_EN                      ,1 = clock enable  0 = clock disable. in d0, this bit is not used" "0,1"
        bitfld.long 0x00 25. "   ULPI_CLK_SW_EN                       ,1 = clock enable  0 = clock disable" "0,1"
        bitfld.long 0x00 24. "   AP_32K_CLK_SW_EN                 ,1 = clock enable  0 = clock disable" "0,1"
        textline "                                      "
        bitfld.long 0x00 21. "SYS_1M_CLK_SW_EN                ,1 = clock enable  0 = clock disable" "0,1"
        bitfld.long 0x00 20. "         SYS_62P4M_CLK_SW_EN              ,1 = clock enable  0 = clock disable. if <62p4m_clock_gen_input_312m_clk_sw_en> is 0, this bit is unuseful" "0,1"
        bitfld.long 0x00 19. "   62P4M_CLOCK_GEN_INPUT_312M_CLK_SW_EN ,1 = clock enable  0 = clock disable" "0,1"
        bitfld.long 0x00 18. "   AUDIO_13M_3P25M_INPUT_CLK_EN     ,1 = clock enable  0 = clock disable" "0,1"
        textline "                                      "
        bitfld.long 0x00 17. "ICU_ACLK_SW_EN                  ,1 = clock enable    0 = clock disable. this bit is only used when <icu_aclk_en_ctrl_mode>=1" "0,1"
        bitfld.long 0x00 16. "         ICU_ACLK_EN_CTRL_MODE            ,1 = clock enable controlled by sw register bit <icu_aclk_sw_en>    0 = clock enable controlled by hardware dynamic gating" "0,1"
        bitfld.long 0x00 15. "   AP_PMU_CLK_SW_EN                     ,1 = clock enable    0 = clock disable. this bit is only used when <ap_pmu_clk_en_ctrl_mode>=1" "0,1"
        bitfld.long 0x00 14. "   AP_PMU_CLK_EN_CTRL_MODE          ,1 = clock enable controlled by sw register bit <ap_pmu_clk_sw_en>    0 = clock enable controlled by hardware dynamic gating" "0,1"
        textline "                                      "
        bitfld.long 0x00 13. "MP_PMU_CLK_SW_EN                ,1 = clock enable    0 = clock disable. this bit is only used when <mp_pmu_clk_en_ctrl_mode>=1" "0,1"
        bitfld.long 0x00 12. "         MP_PMU_CLK_EN_CTRL_MODE          ,1 = clock enable controlled by sw register bit <mp_pmu_clk_sw_en>    0 = clock enable controlled by hardware dynamic gating" "0,1"
        bitfld.long 0x00 10.--11. "   PM_391                               ,reserved for future use" "0,1,2,3"
        bitfld.long 0x00 9. "   SYS_ACLK_SW_EN                   ,1 = clock enable    0 = clock disable. this bit is only used when <sys_aclk_en_ctrl_mode>=1" "0,1"
        textline "                                      "
        bitfld.long 0x00 8. "SYS_ACLK_EN_CTRL_MODE           ,1 = clock enable controlled by sw register bit <sys_aclk_sw_en>    0 = clock enable controlled by hardware dynamic gating" "0,1"
        hexmask.long.byte 0x00 2.--7. 1. "         PM_394                           ,reserved for future use"
        bitfld.long 0x00 1. "  FC_SM_REF_CLK_SW_EN                  ,1 = clock enable    0 = clock disable. this bit is only used when <fc_sm_ref_clk_en_ctl_mode>=1" "0,1"
        bitfld.long 0x00 0. "   FC_SM_REF_CLK_EN_CTL_MODE        ,1 = clock enable controlled by sw register bit <fc_sm_ref_clk_sw_en>    0 = clock enable controlled by hardware dynamic gating" "0,1"

group d:0xD4282844++0x03
    line.long 0x00 "PMU_LCD_CLK_RES_CTRL1,LCD Clock/Reset Control Register1"
        bitfld.long 0x00 31. " MIPI_BIT_CLK_FC_REQ             ,mipi bit clk fc request  write 1 to trigger a frequency change. this field is hardware cleared when the frequency change completes." "0,1"
        bitfld.long 0x00 30. "         LCD_PXCLK_FC_REQ                 ,lcd pxclk fc request  write 1 to trigger a frequency change. this field is hardware cleared when the frequency change completes." "0,1"
        bitfld.long 0x00 29. "   LCD_MCLK_FC_REQ                      ,lcd mclk fc request  write 1 to trigger a frequency change. this field is hardware cleared when the frequency change completes." "0,1"
        bitfld.long 0x00 28. "   LCD_ACLK_FC_REQ                  ,lcd aclk fc request  write 1 to trigger a frequency change. this field is hardware cleared when the frequency change completes." "0,1"
        textline "                                      "
        bitfld.long 0x00 27. "PM_HW_MODE407                   ,hardware control mode for lcd power up and power down" "0,1"
        bitfld.long 0x00 26. "         LCD_SLEEP2                       ,lcd power switch sleep2" "0,1"
        bitfld.long 0x00 25. "   LCD_SLEEP1                           ,lcd power switch sleep1" "0,1"
        bitfld.long 0x00 24. "   LCD_ISOB                         ,lcd isolation wrapper  0 = enable isolation (lcd powr-down mode)  1 = disable isolation (lcd active mode)" "0,1"
        textline "                                      "
        bitfld.long 0x00 23. "MIPI_BIT_BLANK_MSK              ,mipi bit clk fc wait blank signal mask   0 wait lcd blank signal   1 not wait lcd blank signal" "0,1"
        bitfld.long 0x00 20.--22. "         MIPI_BIT_CLK_SEL                 ,mipi bit clk clock select   0x0 = 832mhz mhz  0x1 = 624mhz  0x2 = pll5_div2   0x3 = pll3_div2   0x4 =1248    0x5 = 499    0x6 = pll4_div2    0x7 = pll3_div3" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 17.--19. "   MIPI_BIT_CLK_DIV                     ,mipi bit clock divide ratio  mipi_bit_clk = clock source/ (this field +1)" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 16. "   MIPI_BIT_CLK_EN                  ,mipi bit clk enable   0x0 = disable   0x1 =enable" "0,1"
        textline "                                      "
        bitfld.long 0x00 15. "MIPI_BIT_CLK_RST                ,mipi bit clk  reset    0x0 = reset    0x1 = no reset" "0,1"
        bitfld.long 0x00 14. "         LCD_ACLK_BLANK_MSK               ,lcd aclk fc wait blank signal mask   0 wait lcd blank signal   1 not wait lcd blank signal" "0,1"
        bitfld.long 0x00 12.--13. "   LCD_ACLK_SEL                         ,lcd axi clock select  0x0 = 416 mhz  0x1 = 499 mhz  0x2 = 624 clock  0x3 = pll5_div2" "0,1,2,3"
        bitfld.long 0x00 9.--11. "   LCD_ACLK_DIV                     ,lcd axi clock divide ratio  lcd_aclk = clock source  / (this field +1)" "0,1,2,3,4,5,6,7"
        textline "                                      "
        bitfld.long 0x00 8. "LCD_ACLK_EN                     ,lcd axi enable   0x0 = disable   0x1 =enable" "0,1"
        bitfld.long 0x00 7. "         LCD_ACLK_QCHAN_MASK              ,lcd axi q-channel mask   0 = not mask, q-channel enable    1 mask, q-channel disabled" "0,1"
        bitfld.long 0x00 6. "   LCD_HCLK_SWAP_CTRL                   ,lcd hclk swap  this field is used to control the hclk source of lcd in d1p mode.  0x0 = system fabric clock for lcd hclk source in d1p mode  0x1 = bypass vctxo clock for lcdhclk source in d1p mode" "0,1"
        bitfld.long 0x00 5. "   LCD_HCLK_EN                      ,lcd  hclk enable   0x0 = disabled   0x1= enabled" "0,1"
        textline "                                      "
        bitfld.long 0x00 4. "LCD_SW_RST                      ,lcd software reset    0x0 = reset    0x1 = no reset" "0,1"
        bitfld.long 0x00 3. "         DSI_ESCCLK_RESET                 ,dsi esc clock reset  0 = reset" "0,1"
        bitfld.long 0x00 2. "   DSI_ESC_EN                           ,dsi esc clock enable  1 = ref clock enabled  0 = ref clock disabled" "0,1"
        bitfld.long 0x00 0.--1. "   DSI_ESC_SEL                      ,dsi esc clock select  0x0 = 52 mhz  0x1 = 48 mhz  0x2 = 26 mhz  0x3 = 78 mhz" "0,1,2,3"

group d:0xD428284C++0x03
    line.long 0x00 "PMU_LCD_CLK_RES_CTRL2,LCD Clock/Reset Control Register2"
        bitfld.long 0x00 23. " LCD_PXCLK_BLANK_MSK             ,lcd pxclk fc wait blank signal mask   0 wait lcd blank signal   1 not wait lcd blank signal" "0,1"
        bitfld.long 0x00 20.--22. "         LCD_PXCLK_SEL                    ,lcd pxclkclock select   0x0 = 624mhz mhz  0x1 = 499mhz  0x2 = pll5_div3   0x3 = pll3_div4   0x4 =pll4_div4    0x5 = pll1_416" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 17.--19. "   LCD_PXCLK_DIV                        ,lcd pxclk clock divide ratio   lcd_pxclk = clock source/ (this field +1)" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 16. "   LCD_PXCLK_EN                     ,lcd pxclk enable   0x0 = disable   0x1 =enable" "0,1"
        textline "                                      "
        bitfld.long 0x00 7. "LCD_MCLK_BLANK_MSK              ,lcd mclk fc wait blank signal mask   0 wait lcd blank signal   1 not wait lcd blank signal" "0,1"
        bitfld.long 0x00 4.--6. "         LCD_MCLK_SEL                     ,lcd mclkclock select   0x0 = 624mhz mhz  0x1 = 499mhz  0x2 = pll5_div3   0x3 = pll5_div4   0x4 =pll4_div4    0x5 = pll1_416   0x6= pll3_div4 <0x7> pll4_div3" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 1.--3. "   LCD_MCLK_DIV                         ,lcd mclk clock divide ratio   lcd_mclk = clock source/ (this field +1)" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 0. "   LCD_MCLK_EN                      ,lcd mclk enable   0x0 = disable   0x1 =enable" "0,1"

group d:0xD4282850++0x03
    line.long 0x00 "PMU_CCIC_CLK_RES_CTRL,CCIC Clock/Reset Control Register"
        bitfld.long 0x00 31. " CCIC_ISP_HCLK_SWAP_CTRL         ,ccic isp hclk swap  this field is used to control the hclk source of ccic and isp in d1p mode.  0x0 = system fabric clock for ccic and isp hclk source in d1p mode  0x1 = bypass vctxo clock for ccic and isp hclk source in d1p mode" "0,1"
        bitfld.long 0x00 23.--25. "         CCICI_CLK4X_SEL                  ,cmos camera interface controller clock source select  0x0 = pll3_div4  0x1 = pll4_div3  0x2 = 624  0x3 = pll3_div3   0x4 = 832  0x5= pll4_div2  0x6 = pll3_div2  0x7 = 1248m" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 22. "   ISP_CCIC_AHB_RST                     ,ahb clock reset for ccic and isp  0 = reset" "0,1"
        bitfld.long 0x00 21. "   ISP_CCIC_AHBCLK_EN               ,ahb clock enable for ccic and isp  1 = clock enabled  0 = clock disabled" "0,1"
        textline "                                      "
        bitfld.long 0x00 18.--20. "CICIC_CLK4X_DIV                 ,ci function clock divide ratio  ci_fnc_clk = ci_fnc_clk_div / (this field +1)" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 15. "         CCIC_CLK4X_FC_REQ                ,ccic function clk4x fc request  write 1 to trigger a frequency change. this field is hardware cleared when the frequency change completes." "0,1"
        bitfld.long 0x00 7. "   CCIC1_PHYCLK_SEL                     ,ccic1 phy clock select  0 = 104 mhz  1 = 52 mhz" "0,1"
        bitfld.long 0x00 5. "   CCIC1_PHYCLK_EN                  ,ccic1 phy clock enable  1 = phy clock enabled  0 = phy clock disabled" "0,1"
        textline "                                      "
        bitfld.long 0x00 4. "CCIC_CLK4X_EN                   ,cmos camera interface controller peripheral clock enable  1 = peripheral clock enabled  0 = peripheral clock disabled" "0,1"
        bitfld.long 0x00 2. "         CCIC1_PHYCLK_RST                 ,ccic1 phy clock reset  this clock is also used for dphy reset.  0 = reset" "0,1"
        bitfld.long 0x00 1. "   CCIC_CLK4X_RST                       ,cmos camera interface controller peripheral reset  0 = reset" "0,1"

group d:0xD4282854++0x03
    line.long 0x00 "PMU_SDH0_CLK_RES_CTRL,SDH0 Clock/Reset Control Register"
        bitfld.long 0x00 11. " SDH0_CLK_FC_REQ                 ,sdh0 clock frequency change request  when this field is written as 1, it will force sdh0_clk_div to work.  this field will be automatically cleared by hardware when clock switch is done." "0,1"
        bitfld.long 0x00 8.--10. "         SDH0_CLK_DIV                     ,sdh0 clock frequency divisor  0x0 to 0x7 =  sdh0_clk = sdh0 source clock/(sdh0_clk_div + 1)" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 6.--7. "   SDH0_CLK_SEL                         ,sdh0 clock source select   0=416mhz(clk_in_416m_pll1)   1=624mhz(clk_in_pll1_2x)   2=clk_in_pll6_div2   3=400mhz(clk_in_pll6_div4)" "0,1,2,3"
        bitfld.long 0x00 4. "   SDH0_CLK_EN                      ,sdh0 peripheral clock enable  1 = peripheral clock enabled  0 = peripheral clock disabled" "0,1"
        textline "                                      "
        bitfld.long 0x00 3. "SDH_AXICLK_EN                   ,all sdh axi clock enable  this field is used to enable the axi click for all 3 sdh modules.  1 = axi clock enabled  0 = axi clock disabled" "0,1"
        bitfld.long 0x00 1. "         SDH0_RST                         ,sdh0 peripheral reset  0 = reset" "0,1"
        bitfld.long 0x00 0. "   SDH_AXI_RST                          ,all sdh axi reset  this field is used to perform an axi reset for all 3 sdh modules." "0,1"

group d:0xD4282858++0x03
    line.long 0x00 "PMU_SDH1_CLK_RES_CTRL,SDH1 Clock/Reset Control Register"
        bitfld.long 0x00 11. " SDH1_CLK_FC_REQ                 ,sdh1 clock frequency change request  when this field is written as 1, it will force sdh1_clk_div to work.  this field will be automatically cleared by hardware when clock switch is done." "0,1"
        bitfld.long 0x00 8.--10. "         SDH1_CLK_DIV                     ,sdh1 clock frequency divisor  0-7 = sdh1_clk = sdh1 source clock/(sdh1_clk_div + 1)" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 6.--7. "   SDH1_CLK_SEL                         ,sdh1 clock source select   0=416mhz(clk_in_416m_pll1)   1=624mhz(clk_in_pll1_2x)   2=clk_in_pll6_div2   3=400mhz(clk_in_pll6_div4)" "0,1,2,3"
        bitfld.long 0x00 4. "   SDH1_CLK_EN                      ,sdh1 peripheral clock enable  1 = peripheral clock enabled  0 = peripheral clock disabled" "0,1"
        textline "                                      "
        bitfld.long 0x00 1. "SDH1_RST                        ,sdh1 peripheral reset  0 = reset" "0,1"

group d:0xD428285C++0x03
    line.long 0x00 "PMU_USB_CLK_RES_CTRL,USB Clock/Reset Control Register"
        bitfld.long 0x00 9.--10. " USB_SS_SCALEDOWN_MODE           ,usb simulation scaledown mode, when this signal is enabled during simulation, the core uses scaled-down timing values, resulting in faster simulations.  0 = disable all scale-downs   1 = enable scale-down of all timing values except device mode suspend and resume   2 = enable scale-down of device mode suspend and resume timing values only   3 = enable all above scale-down timing values." "0,1,2,3"
        bitfld.long 0x00 8. "         USB_BYPASS_DEB_FILTER            ,usb bypass debounce filters for avalid, bvalid, vbusvalid, sessend, iddig signal when enabled  1 =  enabled  0 = disabled" "0,1"
        bitfld.long 0x00 1. "   USB_AXICLK_EN                        ,usb axi clock enable  1 = axi clock enabled  0 = axi clock disabled" "0,1"
        bitfld.long 0x00 0. "   USB_AXI_RST                      ,usb axi reset  0 = reset   1 = de-reset" "0,1"

group d:0xD4282860++0x03
    line.long 0x00 "PMU_NF_CLK_RES_CTRL,NAND Flash Clock/Reset Control Register"
        bitfld.long 0x00 8. " NF_ECC_RES                      ,nand flash ecc reset  0 = reset" "0,1"
        bitfld.long 0x00 7. "         NF_ECC_CLK_EN                    ,nand flash ecc clock enable  1 = ecc clock enabled  0 = ecc clock disabled" "0,1"
        bitfld.long 0x00 6. "   NF_CLK_SEL                           ,nand flash clock select  0 = 156 mhz  1 = 78 mhz" "0,1"
        bitfld.long 0x00 4. "   NF_CLK_EN                        ,nand flash peripheral clock enable  1 = peripheral clock enabled  0 = peripheral clock disabled" "0,1"
        textline "                                      "
        bitfld.long 0x00 3. "NF_AXICLK_EN                    ,nand flash axi clock enable  1 = axi clock enabled  0 = axi clock disabled" "0,1"
        bitfld.long 0x00 1. "         NF_RST                           ,nand flash peripheral reset  0 = reset" "0,1"
        bitfld.long 0x00 0. "   NF_AXI_RST                           ,nand flash axi reset" "0,1"

group d:0xD4282864++0x03
    line.long 0x00 "PMU_DMA_CLK_RES_CTRL,DMA Clock/Reset Control Register"
        bitfld.long 0x00 3. " DMA_AXICLK_EN                   ,dma axi clock enable  1 = axi clock enabled  0 = axi clock disabled" "0,1"
        bitfld.long 0x00 0. "         DMA_AXI_RST                      ,dma axi reset" "0,1"

group d:0xD4282868++0x03
    line.long 0x00 "PMU_AES_CLK_RES_CTRL,AES Clock/Reset Control Register"
        bitfld.long 0x00 6. " WTM_CLK_SEL                     ,wtm clock select  1 = 104 mhz  0 = 208 mhz" "0,1"
        bitfld.long 0x00 5. "         WTM_CLK_EN                       ,wtm clock enable  1 = wtm clock enabled  0 = wtm clock disabled" "0,1"
        bitfld.long 0x00 4. "   WTM_RST                              ,wtm clock reset" "0,1"

group d:0xD428286C++0x03
    line.long 0x00 "PMU_MCB_CLK_RES_CTRL,MCB Clock/Reset Control Register"
        bitfld.long 0x00 1. " ACLK_SW_RST                     ,mcb aclk port reset  0 = reset" "0,1"
        bitfld.long 0x00 0. "         DCLK_SW_RST                      ,mcb dclk domain reset  0 = reset" "0,1"

group d:0xD4282870++0x03
    line.long 0x00 "PMU_CP_IMR,PMU CP Interrupt Mask Register"
        bitfld.long 0x00 25. " AP_C2_FC_INTR_MASK              ,frequency change done by ap cluster2 interrupt mask  1 = interrupt enabled  0 = interrupt disabled" "0,1"
        bitfld.long 0x00 22. "         AP_CORE9_IDLE_WAKE_INTR_MASK564  ,debug only: <var processor: application> core9 idle wake up interrupt mask  1 = interrupt enabled  0 = interrupt disabled" "0,1"
        bitfld.long 0x00 21. "   AP_CORE8_IDLE_WAKE_INTR_MASK565      ,debug only: <var processor: application> core8 idle wake up interrupt mask  1 = interrupt enabled  0 = interrupt disabled" "0,1"
        bitfld.long 0x00 20. "   AP_C1_FC_INTR_MASK               ,frequency change done by ap cluster1 interrupt mask  1 = interrupt enabled  0 = interrupt disabled" "0,1"
        textline "                                      "
        bitfld.long 0x00 19. "AP_CORE7_IDLE_WAKE_INTR_MASK567 ,debug only: <var processor: application> core7 idle wake up interrupt mask  1 = interrupt enabled  0 = interrupt disabled" "0,1"
        bitfld.long 0x00 18. "         AP_CORE6_IDLE_WAKE_INTR_MASK568  ,debug only: <var processor: application> core6 idle wake up interrupt mask  1 = interrupt enabled  0 = interrupt disabled" "0,1"
        bitfld.long 0x00 17. "   AP_CORE5_IDLE_WAKE_INTR_MASK569      ,debug only: <var processor: application> core5 idle wake up interrupt mask  1 = interrupt enabled  0 = interrupt disabled" "0,1"
        bitfld.long 0x00 16. "   AP_CORE4_IDLE_WAKE_INTR_MASK570  ,debug only: <var processor: application> core4 idle wake up interrupt mask  1 = interrupt enabled  0 = interrupt disabled" "0,1"
        textline "                                      "
        bitfld.long 0x00 11. "SP_CORE_IDLE_WAKE_INTR_MASK572  ,debug only: <var processor: <var processor: <var processor: <var processor: <var processor: secure>>>>> core idle wake up interrupt mask  1 = interrupt enabled  0 = interrupt disabled" "0,1"
        bitfld.long 0x00 10. "         AP_CORE3_IDLE_WAKE_INTR_MASK573  ,debug only: <var processor: application> core3 idle wake up interrupt mask  1 = interrupt enabled  0 = interrupt disabled" "0,1"
        bitfld.long 0x00 9. "   AP_CORE2_IDLE_WAKE_INTR_MASK574      ,debug only: <var processor: application> core2 idle wake up interrupt mask  1 = interrupt enabled  0 = interrupt disabled" "0,1"
        bitfld.long 0x00 8. "   AP_CORE1_IDLE_WAKE_INTR_MASK575  ,debug only: <var processor: application> core1 idle wake up interrupt mask  1 = interrupt enabled  0 = interrupt disabled" "0,1"
        textline "                                      "
        bitfld.long 0x00 7. "AP_CORE0_IDLE_WAKE_INTR_MASK576 ,debug only: <var processor: application> core0 idle wake up interrupt mask  1 = interrupt enabled  0 = interrupt disabled" "0,1"
        bitfld.long 0x00 6. "         CP_IDLE_WAKE_INTR_MASK577        ,debug only: cp idle wake up interrupt mask  1 = interrupt enabled  0 = interrupt disabled" "0,1"
        bitfld.long 0x00 5. "   ACLK_FC_DONE_INTR_MASK578            ,debug only: aclk frequency change done interrupt mask  1 = interrupt enabled  0 = interrupt disabled" "0,1"
        bitfld.long 0x00 4. "   DCLK_FC_DONE_INTR_MASK579        ,debug only: dclk frequency change done interrupt mask  1 = interrupt enabled  0 = interrupt disabled" "0,1"
        textline "                                      "
        bitfld.long 0x00 3. "AP_FC_DONE_INTR_MASK            ,debug only: frequency change done for ap interrupt mask  1 = interrupt enabled  0 = interrupt disabled" "0,1"
        bitfld.long 0x00 2. "         CP_FC_DONE_INTR_MASK581          ,debug only: frequency change done for cp interrupt mask  1 = interrupt enabled  0 = interrupt disabled" "0,1"
        bitfld.long 0x00 1. "   AP_C0_FC_INTR_MASK                   ,frequency change done by ap cluster0 interrupt mask  1 = interrupt enabled  0 = interrupt disabled" "0,1"
        bitfld.long 0x00 0. "   CP_FC_INTR_MASK583               ,frequency change done by cp interrupt mask  1 = interrupt enabled  0 = interrupt disabled" "0,1"

group d:0xD4282874++0x03
    line.long 0x00 "PMU_CP_IRWC,PMU CP Interrupt READ/WRITE Clear Register"
        bitfld.long 0x00 25. " AP_C2_FC_DONE_INTR_IRST591      ,ap cluster2 frequency change done interrupt read clear  1 = read clear  0 = interrupt write clear" "0,1"
        bitfld.long 0x00 22. "         AP_CORE9_IDLE_WAKE_INTR_IRST593  ,<var processor: application> core9 idle wake up interrupt read clear  1 = read clear  0 = interrupt write clear" "0,1"
        bitfld.long 0x00 21. "   AP_CORE8_IDLE_WAKE_INTR_IRST594      ,<var processor: application> core8 idle wake up interrupt read clear  1 = read clear  0 = interrupt write clear" "0,1"
        bitfld.long 0x00 20. "   AP_C1_FC_DONE_INTR_IRST595       ,ap cluster1 frequency change done interrupt read clear  1 = read clear  0 = interrupt write clear" "0,1"
        textline "                                      "
        bitfld.long 0x00 19. "AP_CORE7_IDLE_WAKE_INTR_IRST596 ,<var processor: application> core7 idle wake up interrupt read clear  1 = read clear  0 = interrupt write clear" "0,1"
        bitfld.long 0x00 18. "         AP_CORE6_IDLE_WAKE_INTR_IRST597  ,<var processor: application> core6 idle wake up interrupt read clear  1 = read clear  0 = interrupt write clear" "0,1"
        bitfld.long 0x00 17. "   AP_CORE5_IDLE_WAKE_INTR_IRST598      ,<var processor: application> core5 idle wake up interrupt read clear  1 = read clear  0 = interrupt write clear" "0,1"
        bitfld.long 0x00 16. "   AP_CORE4_IDLE_WAKE_INTR_IRST599  ,<var processor: application> core4 idle wake up interrupt read clear  1 = read clear  0 = interrupt write clear" "0,1"
        textline "                                      "
        bitfld.long 0x00 11. "SP_CORE_IDLE_WAKE_INTR_IRST601  ,<var processor: <var processor: <var processor: <var processor: <var processor: <var processor: secure>>>>>> idle wake up interrupt read clear  1 = read clear  0 = interrupt write clear" "0,1"
        bitfld.long 0x00 10. "         AP_CORE3_IDLE_WAKE_INTR_IRST602  ,<var processor: application> core3 idle wake up interrupt read clear  1 = read clear  0 = interrupt write clear" "0,1"
        bitfld.long 0x00 9. "   AP_CORE2_IDLE_WAKE_INTR_IRST603      ,<var processor: application> core2 idle wake up interrupt read clear  1 = read clear  0 = interrupt write clear" "0,1"
        bitfld.long 0x00 8. "   AP_CORE1_IDLE_WAKE_INTR_IRST604  ,<var processor: application> core1 idle wake up interrupt read clear  1 = read clear  0 = interrupt write clear" "0,1"
        textline "                                      "
        bitfld.long 0x00 7. "AP_CORE0_IDLE_WAKE_INTR_IRST605 ,<var processor: application> core0 idle wake up interrupt read clear  1 = read clear  0 = interrupt write clear" "0,1"
        bitfld.long 0x00 6. "         CP_IDLE_WAKE_INTR_IRST606        ,cp idle wake up interrupt read clear  1 = read clear  0 = interrupt write clear" "0,1"
        bitfld.long 0x00 5. "   ACLK_FC_DONE_INTR_IRST607            ,aclk frequency change done interrupt read clear  1 = read clear  0 = interrupt write clear" "0,1"
        bitfld.long 0x00 4. "   DCLK_FC_DONE_INTR_IRST608        ,dclk frequency change done interrupt read clear  1 = read clear  0 = interrupt write clear" "0,1"
        textline "                                      "
        bitfld.long 0x00 3. "AP_C0_FC_DONE_INTR_IRST609      ,ap cluster0 frequency change done interrupt read clear  1 = read clear  0 = interrupt write clear" "0,1"
        bitfld.long 0x00 2. "         CP_FC_DONE_INTR_IRST610          ,cp frequency change done interrupt read clear  1 = read clear  0 = interrupt write clear" "0,1"
        bitfld.long 0x00 1. "   AP_FC_INTR_IRST611                   ,ap fc interrupt read clear  1 = read clear  0 = interrupt write clear" "0,1"
        bitfld.long 0x00 0. "   CP_FC_INTR_IRST612               ,cp fc interrupt read clear  1 = read clear  0 = interrupt write clear" "0,1"

group d:0xD4282878++0x03
    line.long 0x00 "PMU_CP_ISR,PMU CP Interrupt Status Register"
        bitfld.long 0x00 25. " AP_C2_FC_DONE_INTR_ISR620       ,ap cluster2 frequency change done interrupt status  1 = interrupt active" "0,1"
        bitfld.long 0x00 22. "         AP_CORE9_IDLE_WAKE_INTR_ISR622   ,<var processor: application> core 9 idle wake up interrupt status  1 = interrupt active" "0,1"
        bitfld.long 0x00 21. "   AP_CORE8_IDLE_WAKE_INTR_ISR623       ,<var processor: application> core 8 idle wake up interrupt status  1 = interrupt active" "0,1"
        bitfld.long 0x00 20. "   AP_C1_FC_DONE_INTR_ISR624        ,ap cluster1 frequency change done interrupt status  1 = interrupt active" "0,1"
        textline "                                      "
        bitfld.long 0x00 19. "AP_CORE7_IDLE_WAKE_INTR_ISR625  ,<var processor: application> core 7 idle wake up interrupt status  1 = interrupt active" "0,1"
        bitfld.long 0x00 18. "         AP_CORE6_IDLE_WAKE_INTR_ISR626   ,<var processor: application> core 6 idle wake up interrupt status  1 = interrupt active" "0,1"
        bitfld.long 0x00 17. "   AP_CORE5_IDLE_WAKE_INTR_ISR627       ,<var processor: application> core 5 idle wake up interrupt status  1 = interrupt active" "0,1"
        bitfld.long 0x00 16. "   AP_CORE4_IDLE_WAKE_INTR_ISR628   ,<var processor: application> core 4 idle wake up interrupt status  1 = interrupt active" "0,1"
        textline "                                      "
        bitfld.long 0x00 11. "SP_CORE_IDLE_WAKE_INTR_ISR630   ,<var processor: <var processor: <var processor: <var processor: <var processor: secure>>>>> idle wake up interrupt status  1 = interrupt active" "0,1"
        bitfld.long 0x00 10. "         AP_CORE3_IDLE_WAKE_INTR_ISR631   ,<var processor: application> core 3 idle wake up interrupt status  1 = interrupt active" "0,1"
        bitfld.long 0x00 9. "   AP_CORE2_IDLE_WAKE_INTR_ISR632       ,<var processor: application> core 2 idle wake up interrupt status  1 = interrupt active" "0,1"
        bitfld.long 0x00 8. "   AP_CORE1_IDLE_WAKE_INTR_ISR633   ,<var processor: application> core 1 idle wake up interrupt status  1 = interrupt active" "0,1"
        textline "                                      "
        bitfld.long 0x00 7. "AP_CORE0_IDLE_WAKE_INTR_ISR634  ,<var processor: application> core 0 idle wake up interrupt status  1 = interrupt active" "0,1"
        bitfld.long 0x00 6. "         CP_IDLE_WAKE_INTR_ISR635         ,cp idle wake up interrupt status  1 = interrupt active" "0,1"
        bitfld.long 0x00 5. "   ACLK_FC_DONE_INTR_ISR636             ,aclk frequency change done interrupt status  1 = interrupt active" "0,1"
        bitfld.long 0x00 4. "   DCLK_FC_DONE_INTR_ISR637         ,dclk frequency change done interrupt status  1 = interrupt active" "0,1"
        textline "                                      "
        bitfld.long 0x00 3. "AP_C0_FC_DONE_INTR_ISR638       ,ap cluster0 frequency change done interrupt status  1 = interrupt active" "0,1"
        bitfld.long 0x00 2. "         CP_FC_DONE_INTR_ISR639           ,cp frequency change done interrupt status  1 = interrupt active" "0,1"
        bitfld.long 0x00 1. "   AP_FC_ISR640                         ,ap fc interrupt status  1 = interrupt active" "0,1"
        bitfld.long 0x00 0. "   CP_FC_ISR641                     ,cp fc interrupt status  1 = interrupt active" "0,1"

group d:0xD428287C++0x03
    line.long 0x00 "PMU_SD_ROT_WAKE_CLR,SDIO/Rotary Wake Clear Register"
        bitfld.long 0x00 29.--31. " RSVD648                         ,reserve for future use" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 28. "         USB_CHGDET_WK_STATUS             ,usb line charge detect wake up status" "0,1"
        bitfld.long 0x00 27. "   USB_ID_WK_STATUS                     ,usb line id wake up status" "0,1"
        bitfld.long 0x00 26. "   USB_VBUS_WK_STATUS               ,usb line vbus valid wake up status" "0,1"
        textline "                                      "
        bitfld.long 0x00 25. "USB_LINE1_WK_STATUS             ,usb line state1 wake up status" "0,1"
        bitfld.long 0x00 24. "         USB_LINE0_WK_STATUS              ,usb line state0 wake up status" "0,1"
        bitfld.long 0x00 21.--23. "   RSVD654                              ,reserve for future use" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 20. "   USB_CHGDET_WK_CLR                ,usb line charge detect wake up clear  1 = clear   this bit is self-cleared by hardware" "0,1"
        textline "                                      "
        bitfld.long 0x00 19. "USB_ID_WK_CLR                   ,usb line id wake up clear  1 = clear   this bit is self-cleared by hardware" "0,1"
        bitfld.long 0x00 18. "         USB_VBUS_WK_CLR                  ,usb line vbus valid wake up clear  1 = clear   this bit is self-cleared by hardware" "0,1"
        bitfld.long 0x00 17. "   USB_LINE1_WK_CLR                     ,usb line state1 wake up clear  1 = clear   this bit is self-cleared by hardware" "0,1"
        bitfld.long 0x00 16. "   USB_LINE0_WK_CLR                 ,usb line state0 wake up clear  1 = clear   this bit is self-cleared by hardware" "0,1"
        textline "                                      "
        bitfld.long 0x00 14.--15. "RSVD660                         ,reserve for future use" "0,1,2,3"
        bitfld.long 0x00 12. "         USB_CHGDET_WK_MASK               ,usb line charge detect wake up enable  1 = enable" "0,1"
        bitfld.long 0x00 11. "   USB_ID_WK_MASK                       ,usb line id wake up enable  1 = enable" "0,1"
        bitfld.long 0x00 10. "   USB_VBUS_WK_MASK                 ,usb line vbus valid wake up enable  1 = enable" "0,1"
        textline "                                      "
        bitfld.long 0x00 9. "USB_LINE1_WK_MASK               ,usb line state1 wake up enable  1 = enable" "0,1"
        bitfld.long 0x00 8. "         USB_LINE0_WK_MASK                ,usb line state0 wake up enable  1 = enable" "0,1"
        bitfld.long 0x00 7. "   CS_WK_STATUS                         ,cs wake up status" "0,1"
        bitfld.long 0x00 6. "   SDH2_WK_CLR                      ,sdh2 wake clear  1 = sdh2 wake event clear  this bit is self-cleared by hardware" "0,1"
        textline "                                      "
        bitfld.long 0x00 5. "CS_WK_CLR                       ,clear of dap power wake up request (dap csyspwrupreq)  1 = clear dap_req wakeup" "0,1"
        bitfld.long 0x00 4. "         CS_WK_MASK                       ,dap power wake up enable (dap csyspwrupreq)  1 = enable" "0,1"
        bitfld.long 0x00 3. "   KB_WK_CLR                            ,keypad wake clear  1 = rot wake event clear  this bit is self-cleared by hardware" "0,1"
        bitfld.long 0x00 2. "   ROT_WK_CLR                       ,rotary wake clear  1 = rot wake event clear  this bit is self-cleared by hardware" "0,1"
        textline "                                      "
        bitfld.long 0x00 1. "SDH1_WK_CLR                     ,sdh1 wake clear  1 = sdh1 wake event clear  this bit is self-cleared by hardware" "0,1"
        bitfld.long 0x00 0. "         SDH0_WK_CLR                      ,sdh0 wake clear  1 = sdh0 wake event clear  this bit is self-cleared by hardware" "0,1"

group d:0xD4282884++0x03
    line.long 0x00 "PMU_PWR_STBL_TIMER,Power Stable Timer Register"
        hexmask.long.byte 0x00 16.--23. 1. " PM_PWR_CLK_PRE683               ,clock prescaler for timer count  0x0 = divide by 1  0x1 = divide by 1  0x2 = divide by 2  all other values use an incremental divider."
        hexmask.long.byte 0x00 8.--15. 1. "        PM_PWR_UP_STBL_TIMER684          ,power up stable timer  stable time for power up during core idle mode in 26 mhz unit"
        hexmask.long.byte 0x00 0.--7. 1. "  PM_PWR_DWN_STBL_TIMER685             ,power down stable timer  stable time for the power down during core idle mode in 26 mhz unit"

group d:0xD4282888++0x03
    line.long 0x00 "PMU_DEBUG_REG,"
        bitfld.long 0x00 31. " MIPI_DSI_DPHY_VDD_DVM_VALID     ,mipi dsi dphy vdd dvm valid check  1 = mipi dsi dphy vdd dvm valid  0 = mipi dsi dphy vdd dvm invalid" "0,1"
        bitfld.long 0x00 30. "         AP_CORE_GBL_IRQ_MASK_CLR_DIS     ,<var processor: application> core gbl_irq_mask auto clear disable  pmu can auto clear the <var processor: application> core gbl_irq_mask to enable interrupt.  0 = auto clear function enabled  1 = auto clear function disabled" "0,1"
        bitfld.long 0x00 29. "   CP_GBL_IRQ_MASK_CLR_DIS              ,cp gbl_irq_mask auto clear disable  pmu can auto clear cp gbl_irq_mask to enable interrupt.  0 = auto clear function enabled  1 = auto clear function disabled" "0,1"
        bitfld.long 0x00 28. "   CP_HOT_RESET_PROT_EN             ,<var processor: comm> silent reset protection enable  1 = enable <var processor: comm> silent reset bus protection feature  0 = no bus protection, silent reset will reset <var processor: comm> right away" "0,1"
        textline "                                      "
        bitfld.long 0x00 27. "MASK_LCD_BLANK_CHECK            ,mask lcd blank check  this field is used for debug only - mask the lcd blank indication check for ddr frequency change.  1 = mask the lcd blank indication  0 = normal mode with lcd blank check." "0,1"
        bitfld.long 0x00 26. "         MIPI_CSI_DPHY_4LN_VDD_DVM_VALID  ,mipi csi 4 lane dphy vdd dvm valid check  1 = mipi 4 lane csi dphy vdd dvm valid  0 = mipi 4 lane csi dphy vdd dvm invalid" "0,1"
        bitfld.long 0x00 25. "   MIPI_CSI_DPHY_2LN_VDD_DVM_VALID      ,mipi dphy vdd dvm valid check  1 = mipi csi 2 lane dphy vdd dvm valid  0 = mipi 2 lane csi dphy vdd dvm invalid" "0,1"
        bitfld.long 0x00 24. "   FUNC_PLL_BYPASS                  ,func pll bypass  1 = 26 mhz  0 = 624 mhz" "0,1"
        textline "                                      "
        bitfld.long 0x00 23. "MASK_MC_SW_IDLE_INDICATION      ,mask memory controller software idle indication  debug only - mask the memory controller software idle indication check .  1 = mask the memory controller software idle indication during ap idle process.  0 = normal mode." "0,1"
        bitfld.long 0x00 22. "         AP_WFI_FC                        ,ap frequency change when in wfi  1 = allow a frequency change when core2 is in wfi  0 = do not allow a frequency change when core2 is in wfi" "0,1"
        bitfld.long 0x00 21. "   CP_WFI_FC                            ,cp frequency change when in wfi  1 = allow frequency change when core1 is in wfi  0 = do not allow a frequency change when core1 is in wfi" "0,1"
        bitfld.long 0x00 20. "   MASK_MC_CLK_ON_CHECK             ,debug only - mask the memory controller clock on indication from the memory controller.  1 = mask the memory controller clock on indication  0 = normal mode." "0,1"
        textline "                                      "
        bitfld.long 0x00 19. "MASK_MC_CLK_OFF_CHECK           ,debug only - mask the memory controller clock off indication from the memory controller .  1 = mask the memory controller clock off indication.  0 = normal mode." "0,1"
        bitfld.long 0x00 18. "         MASK_AP_JTAG_IDLE_INDICATION     ,debug only - mask the ap jtag idle indication check.  1 = mask the ap jtag idle indication.  0 = normal mode." "0,1"
        bitfld.long 0x00 17. "   MASK_CP_JTAG_IDLE_INDICATION         ,debug only - mask the cp jtag idle indication check.  1 = mask the cp jtag idle indication.  0 = normal mode." "0,1"
        bitfld.long 0x00 16. "   MASK_MAIN_CLK_ON_CHECK           ,debug only - mask the main clock on indication check during ap idle process. if this bit is set then ap idle sequence will not wait for the acknowledge from main clock on indication.  1 = mask the mc idle indication during ap idle process. 0 = normal mod" "0,1"
        textline "                                      "
        bitfld.long 0x00 15. "MASK_MAIN_CLK_OFF_CHECK         ,debug only - mask the main clock off indication check during ap idle process. if this bit is set then ap idle sequence will not wait for the acknowledge from main clock off indication.  1 = mask the memory controller idle indication during ap idle proces" "0,1"
        bitfld.long 0x00 14. "         MASK_MC_IDLE_INDICATION          ,debug only - mask the memory controller idle indication check during ap idle process. if this bit is set then ap idle sequence will not wait for the acknowledge from memory controller idle indication.1 = mask the memory controller idle indication during a" "0,1"
        bitfld.long 0x00 13. "   MASK_DMA_IDLE_INDICATION             ,debug only - mask the dma idle indication check during ap idle process. if this bit is set then ap idle sequence will not wait for the acknowledge from dma idle indication.1 = mask the dma idle indication during ap idle process.0 = normal mode." "0,1"
        bitfld.long 0x00 12. "   MASK_AP_IDLE_IND                 ,debug only - mask the ap idle indication check during ap idle process. if this bit is set then ap idle sequence will not wait for the acknowledge from ap idle indication.  1 = mask the ap idle indication during ap idle process.  0 = normal mode." "0,1"
        textline "                                      "
        bitfld.long 0x00 11. "MASK_CP_IDLE_IND                ,debug only - mask the cp idle indication check during ap idle process. if this bit is set then ap idle sequence will not wait for the acknowledge from cp idle indication.  1 = mask the cp idle indication during ap idle process.  0 = normal mode." "0,1"
        bitfld.long 0x00 10. "         MASK_AP_CLK_ON_ACK_FOR_IDLE      ,debug only - mask the ap clock on acknowledge from the ap clock generation unit during core idle process. if this bit is set then core idle sequence will not wait for the acknowledge from ap clock generator.  1 = mask the ap clock on acknowledge during c" "0,1"
        bitfld.long 0x00 9. "   MASK_AP_CLK_OFF_ACK_FOR_IDLE         ,debug only - mask the ap clock off acknowledge from the ap clock generation unit during core idle process. if this bit is set then core idle sequence will not wait for the acknowledge from ap clock generator.  1 = mask the ap clock off acknowledge during" "0,1"
        bitfld.long 0x00 8. "   MASK_CP_CLK_ON_ACK_FOR_IDLE      ,debug only - mask the cp clock on acknowledge from the cp clock generation unit during core idle process. if this bit is set then core idle sequence will not wait for the acknowledge from cp clock generator.  1 = mask the cp clock on acknowledge during c" "0,1"
        textline "                                      "
        bitfld.long 0x00 7. "MASK_CP_CLK_OFF_ACK_FOR_IDLE    ,debug only - mask the cp clock off acknowledge from the cp clock generation unit during core idle process. if this bit is set then core idle sequence will not wait for the acknowledge from cp clock generator.  1 = mask the cp clock off acknowledge during" "0,1"
        bitfld.long 0x00 6. "         MASK_ACLK_CLK_OFF_ACK            ,debug only - mask the aclk clock off acknowledge from the cp clock generation unit during frequency change process. if this bit is set then frequency change sequence will not wait for the acknowledge from aclk clock generator.  1 = mask the aclk clock of" "0,1"
        bitfld.long 0x00 5. "   MASK_DCLK_CLK_OFF_ACK                ,debug only - mask the dclk clock off acknowledge from the cp clock generation unit during frequency change process. if this bit is set then frequency change sequence will not wait for the acknowledge from dclk clock generator.  1 = mask the dclk clock of" "0,1"
        bitfld.long 0x00 4. "   MASK_AP_CLK_OFF_ACK              ,debug only - mask the ap clock off acknowledge from the cp clock generation unit during frequency change process. if this bit is set then frequency change sequence will not wait for the acknowledge from ap clock generator.  1 = mask the ap clock off ackn" "0,1"
        textline "                                      "
        bitfld.long 0x00 3. "MASK_CP_CLK_OFF_ACK             ,debug only - mask the cp clock off acknowledge from the cp clock generation unit during frequency change process. if this bit is set then frequency change sequence will not wait for the acknowledge from cp clock generator.  1 = mask the cp clock off ackn" "0,1"
        bitfld.long 0x00 2. "         MASK_MC_HALT                     ,debug only - mask the halt acknowledge from the memory controller during frequency change process. if this bit is set then frequency change sequence will not wait for the acknowledge from memory controller halt request.  1 = mask the halt acknowledge wai" "0,1"
        bitfld.long 0x00 1. "   MASK_AP_HALT                         ,debug only - mask the halt acknowledge from the ap during frequency change process. if this bit is set then frequency change sequence will not wait for the acknowledge from ap halt request.  1 = mask the halt acknowledge wait during frequency change proc" "0,1"
        bitfld.long 0x00 0. "   MASK_CP_HALT                     ,debug only - mask the halt acknowledge from the cp during frequency change process. if this bit is set then frequency change sequence will not wait for the acknowledge from cp halt request.  1 = mask the halt acknowledge wait during frequency change proc" "0,1"

group d:0xD428288C++0x03
    line.long 0x00 "PMU_SRAM_PWR_DWN,Core SRAM Power Down Register"
        bitfld.long 0x00 21. " CP_L2_LOW_LEAKAGE_EN            ,cp l2 cache ram power down in software mode  1 = sram power down  0 = sram active" "0,1"
        bitfld.long 0x00 20. "         CP_L2_LOW_LEAKAGE_DIS            ,cp l2 cache ram power down hardware control disable  1 = software control  0 = hardware control" "0,1"
        bitfld.long 0x00 19. "   AP_L2_LOW_LEAKAGE_EN                 ,ap l2 cache ram power down in software mode  1 = sram power down  0 = sram active" "0,1"
        bitfld.long 0x00 18. "   AP_L2_LOW_LEAKAGE_DIS            ,ap l2 cache ram power down hardware control disable  1 = software control  0 = hardware control" "0,1"
        textline "                                      "
        bitfld.long 0x00 17. "SQU_SRAM_PDWN_CP                ,squ sram power down from cp  1 = sram power down  0 = sram active" "0,1"
        bitfld.long 0x00 16. "         SQU_SRAM_PDWN_AP                 ,squ sram power down from ap  1 = sram power down  0 = sram active" "0,1"
        bitfld.long 0x00 9. "   AP_L1_LOW_LEAKAGE_EN                 ,ap l1 cache ram power down in software mode  1 = sram power down  0 = sram active" "0,1"
        bitfld.long 0x00 8. "   AP_L1_LOW_LEAKAGE_DIS            ,ap l1 cache ram power down hardware control disable  1 = software control  0 = hardware control" "0,1"
        textline "                                      "
        bitfld.long 0x00 1. "CP_L1_LOW_LEAKAGE_EN            ,cp l1 cache ram power down in software mode  1 = sram power down  0 = sram active" "0,1"
        bitfld.long 0x00 0. "         CP_L1_LOW_LEAKAGE_DIS            ,cp l1 cache ram power down hardware control disable  1 = software control  0 = hardware control" "0,1"

group d:0xD4282890++0x03
    line.long 0x00 "PMU_CORE_STATUS,Core Status Register"
        bitfld.long 0x00 31. " AP_CORE7_C2                     ,<var processor: application> core7 in c2 mode indication  this field is used to indicate whether or not <var processor: application> core7 is in c2 mode.  1 = <var processor: application> core7 is in c2 mode" "0,1"
        bitfld.long 0x00 30. "         AP_CORE7_C1                      ,<var processor: application> core7 in c1 mode indication  this field is used to indicate whether or not <var processor: application> core7 is in c1 mode.  1 = <var processor: application> core7 is in c1 mode (here c1 means external idle mode)" "0,1"
        bitfld.long 0x00 29. "   AP_CORE7_WFI_FLAG                    ,<var processor: application> core7 wfi flag  this field reflects the wfi flag that is generated by core7. when core7 enters wfi, this field will be set.." "0,1"
        bitfld.long 0x00 28. "   AP_CORE6_C2                      ,<var processor: application> core6 in c2 mode indication  this field is used to indicate whether or not <var processor: application> core6 is in c2 mode.  1 = <var processor: application> core6 is in c2 mode" "0,1"
        textline "                                      "
        bitfld.long 0x00 27. "AP_CORE6_C1                     ,<var processor: application> core6 in c1 mode indication  this field is used to indicate whether or not <var processor: application> core6 is in c1 mode.  1 = <var processor: application> core6 is in c1 mode (here c1 means external idle mode)" "0,1"
        bitfld.long 0x00 26. "         AP_CORE6_WFI_FLAG                ,<var processor: application> core6 wfi flag  this field reflects the wfi flag that is generated by core6. when core6 enters wfi, this field will be set." "0,1"
        bitfld.long 0x00 25. "   AP_CORE5_C2                          ,<var processor: application> core5 in c2 mode indication  this field is used to indicate whether or not <var processor: application> core5 is in c2 mode.  1 = <var processor: application> core5 is in c2 mode" "0,1"
        bitfld.long 0x00 24. "   AP_CORE5_C1                      ,<var processor: application> core5 in c1 mode indication  this field is used to indicate whether or not <var processor: application> core5 is in c1 mode.  1 = <var processor: application> core5 is in c1 mode (here c1 means external idle mode)" "0,1"
        textline "                                      "
        bitfld.long 0x00 23. "AP_CORE5_WFI_FLAG               ,<var processor: application> core5 wfi flag  this field reflects the wfi flag that is generated by core5. when core5 enters wfi, this field will be set." "0,1"
        bitfld.long 0x00 22. "         AP_CORE4_C2                      ,<var processor: application> core4 in c2 mode indication  this field is used to indicate whether or not <var processor: application> core4 is in c2 mode.  1 = <var processor: application> core4 is in c2 mode" "0,1"
        bitfld.long 0x00 21. "   AP_CORE4_C1                          ,<var processor: application> core4 in c1 mode indication  this field is used to indicate whether or not <var processor: application> core4 is in c1 mode.  1 = <var processor: application> core4 is in c1 mode (here c1 means external idle mode)" "0,1"
        bitfld.long 0x00 20. "   AP_CORE4_WFI_FLAG                ,<var processor: application> core4 wfi flag  this field reflects the wfi flag that is generated by core4. when core4 enters wfi, this field will be set." "0,1"
        textline "                                      "
        bitfld.long 0x00 19. "AP_C1_MPSUB_M2                  ,<q><var processor: application mp> cluster1 subsystem idle mode<\q> indication  this field is used to indicate whether or not the <var processor: application mp> subsystem is in m2 mode.  1 = <var processor: application mp> subsystem is in m2 mode" "0,1"
        bitfld.long 0x00 18. "         AP_C1_MPSUB_M1                   ,<var processor: application mp> cluster1 subsystem in m1 mode indication  this field is used to indicate whether or not the <var processor: application mp> subsystem is in m1 mode.  1 = <var processor: application mp> subsystem is in m1 mode (here m1 means <var processor: application mp> subsystem external idle mode)" "0,1"
        bitfld.long 0x00 17. "   AP_C1_MPSUB_IDLE_FLAG                ,<var processor: application mp> cluster1  subsystem idle flag  this field reflects the and logic value of scu_idle and l2clkstopped generated in the <var processor: application mp> subsystem.  1 = core0/core1/core2/core3/scu/l2 are all in idle state" "0,1"
        bitfld.long 0x00 16. "   SP_IDLE                          ,<var processor: <var processor: <var processor: <var processor: <var processor: secure>>>>> 'core idle mode' indication  this field is used to indicate whether or not <var processor: <var processor: <var processor: <var processor: secure>>>> core is in 'core idle mode' mode.  1 = <var processor: <var processor: <var processor: <var processor: secure>>>> core is in core idle mode" "0,1"
        textline "                                      "
        bitfld.long 0x00 15. "AP_CORE3_C2                     ,<var processor: application> core3 in c2 mode indication  this field is used to indicate whether or not <var processor: application> core3 is in c2 mode.  1 = <var processor: application> core3 is in c2 mode" "0,1"
        bitfld.long 0x00 14. "         AP_CORE3_C1                      ,<var processor: application> core3 in c1 mode indication  this field is used to indicate whether or not <var processor: application> core3 is in c1 mode.  1 = <var processor: application> core3 is in c1 mode (here c1 means external idle mode)" "0,1"
        bitfld.long 0x00 13. "   AP_CORE3_WFI_FLAG                    ,<var processor: application> core3 wfi flag  this field reflects the wfi flag that is generated by core3. when core3 enters wfi, this field will be set." "0,1"
        bitfld.long 0x00 12. "   AP_CORE2_C2                      ,<var processor: application> core2 in c2 mode indication  this field is used to indicate whether or not <var processor: application> core2 is in c2 mode.  1 = <var processor: application> core2 is in c2 mode" "0,1"
        textline "                                      "
        bitfld.long 0x00 11. "AP_CORE2_C1                     ,<var processor: application> core2 in c1 mode indication  this field is used to indicate whether or not <var processor: application> core2 is in c1 mode.  1 = <var processor: application> core2 is in c1 mode (here c1 means external idle mode)" "0,1"
        bitfld.long 0x00 10. "         AP_CORE2_WFI_FLAG                ,<var processor: application> core2 wfi flag  this field reflects the wfi flag that is generated by core2. when core2 enters wfi, this field will be set." "0,1"
        bitfld.long 0x00 9. "   AP_CORE1_C2                          ,<var processor: application> core1 in c2 mode indication  this field is used to indicate whether or not <var processor: application> core1 is in c2 mode.  1 = <var processor: application> core1 is in c2 mode" "0,1"
        bitfld.long 0x00 8. "   AP_CORE1_C1                      ,<var processor: application> core1 in c1 mode indication  this field is used to indicate whether or not <var processor: application> core1 is in c1 mode.  1 = <var processor: application> core1 is in c1 mode (here c1 means external idle mode)" "0,1"
        textline "                                      "
        bitfld.long 0x00 7. "AP_CORE1_WFI_FLAG               ,<var processor: application> core1 wfi flag  this field reflects the wfi flag that is generated by core1. when core1 enters wfi, this field will be set." "0,1"
        bitfld.long 0x00 6. "         AP_CORE0_C2                      ,<var processor: application> core0 in c2 mode indication  this field is used to indicate whether or not <var processor: application> core0 is in c2 mode.  1 = <var processor: application> core0 is in c2 mode" "0,1"
        bitfld.long 0x00 5. "   AP_CORE0_C1                          ,<var processor: application> core0 in c1 mode indication  this field is used to indicate whether or not <var processor: application> core0 is in c1 mode.  1 = <var processor: application> core0 is in c1 mode (here c1 means external idle mode)" "0,1"
        bitfld.long 0x00 4. "   AP_CORE0_WFI_FLAG                ,<var processor: application> core0 wfi flag  this field reflects the wfi flag that is generated by core0. when core0 enters wfi, this field will be set." "0,1"
        textline "                                      "
        bitfld.long 0x00 3. "AP_C0_MPSUB_M2                  ,<q><var processor: application mp> cluster0 subsystem idle mode<\q> indication  this field is used to indicate whether or not the <var processor: application mp> subsystem is in m2 mode.  1 = <var processor: application mp> subsystem is in m2 mode" "0,1"
        bitfld.long 0x00 2. "         AP_C0_MPSUB_M1                   ,<var processor: application mp> cluster0 subsystem in m1 mode indication  this field is used to indicate whether or not the <var processor: application mp> subsystem is in m1 mode.  1 = <var processor: application mp> subsystem is in m1 mode (here m1 means <var processor: application mp> subsystem external idle mode)" "0,1"
        bitfld.long 0x00 1. "   AP_C0_MPSUB_IDLE_FLAG                ,<var processor: application mp> cluster0  subsystem idle flag  this field reflects the and logic value of scu_idle and l2clkstopped generated in the <var processor: application mp> subsystem.  1 = core0/core1/core2/core3/scu/l2 are all in idle state" "0,1"

group d:0xD4282894++0x03
    line.long 0x00 "PMU_RES_FRM_SLP_CLR,Resume from Sleep Clear Register"
        bitfld.long 0x00 0. " CLR_RSM_FRM_SLP                 ,clear resume from sleep indication  1 = clear the status signal in ciu sys_boot_cntr[14]" "0,1"

group d:0xD4282898++0x03
    line.long 0x00 "PMU_AP_IMR,PMU AP Interrupt Mask Register"
        bitfld.long 0x00 25. " AP_C2_FC_DONE_INTR_MASK         ,debug only: frequency change done for ap cluster2 interrupt mask  1 = interrupt enabled  0 = interrupt disabled" "0,1"
        bitfld.long 0x00 22. "         AP_CORE9_IDLE_WAKE_INTR_MASK800  ,debug only: <var processor: application> core9 idle wake up interrupt mask  1 = interrupt enabled  0 = interrupt disabled" "0,1"
        bitfld.long 0x00 21. "   AP_CORE8_IDLE_WAKE_INTR_MASK801      ,debug only: <var processor: application> core8 idle wake up interrupt mask  1 = interrupt enabled  0 = interrupt disabled" "0,1"
        bitfld.long 0x00 20. "   AP_C1_FC_DONE_INTR_MASK          ,debug only: frequency change done for ap cluster1 interrupt mask  1 = interrupt enabled  0 = interrupt disabled" "0,1"
        textline "                                      "
        bitfld.long 0x00 19. "AP_CORE7_IDLE_WAKE_INTR_MASK803 ,debug only: <var processor: application> core7 idle wake up interrupt mask  1 = interrupt enabled  0 = interrupt disabled" "0,1"
        bitfld.long 0x00 18. "         AP_CORE6_IDLE_WAKE_INTR_MASK804  ,debug only: <var processor: application> core6 idle wake up interrupt mask  1 = interrupt enabled  0 = interrupt disabled" "0,1"
        bitfld.long 0x00 17. "   AP_CORE5_IDLE_WAKE_INTR_MASK805      ,debug only: <var processor: application> core5 idle wake up interrupt mask  1 = interrupt enabled  0 = interrupt disabled" "0,1"
        bitfld.long 0x00 16. "   AP_CORE4_IDLE_WAKE_INTR_MASK806  ,debug only: <var processor: application> core4 idle wake up interrupt mask  1 = interrupt enabled  0 = interrupt disabled" "0,1"
        textline "                                      "
        bitfld.long 0x00 11. "SP_CORE_IDLE_WAKE_INTR_MASK808  ,debug only: <var processor: <var processor: <var processor: <var processor: <var processor: secure>>>>> idle wake up interrupt mask  1 = interrupt enabled  0 = interrupt disabled" "0,1"
        bitfld.long 0x00 10. "         AP_CORE3_IDLE_WAKE_INTR_MASK809  ,debug only: <var processor: application> core3 idle wake up interrupt mask  1 = interrupt enabled  0 = interrupt disabled" "0,1"
        bitfld.long 0x00 9. "   AP_CORE2_IDLE_WAKE_INTR_MASK810      ,debug only: <var processor: application> core2 idle wake up interrupt mask  1 = interrupt enabled  0 = interrupt disabled" "0,1"
        bitfld.long 0x00 8. "   AP_CORE1_IDLE_WAKE_INTR_MASK811  ,debug only: <var processor: application> core1 idle wake up interrupt mask  1 = interrupt enabled  0 = interrupt disabled" "0,1"
        textline "                                      "
        bitfld.long 0x00 7. "AP_CORE0_IDLE_WAKE_INTR_MASK812 ,debug only: <var processor: application> core0 idle wake up interrupt mask  1 = interrupt enabled  0 = interrupt disabled" "0,1"
        bitfld.long 0x00 6. "         CP_IDLE_WAKE_INTR_MASK813        ,debug only: cp idle wake up interrupt mask  1 = interrupt enabled  0 = interrupt disabled" "0,1"
        bitfld.long 0x00 5. "   ACLK_FC_DONE_INTR_MASK814            ,debug only: aclk frequency change done interrupt mask  1 = interrupt enabled  0 = interrupt disabled" "0,1"
        bitfld.long 0x00 4. "   DCLK_FC_DONE_INTR_MASK815        ,debug only: dclk frequency change done interrupt mask  1 = interrupt enabled  0 = interrupt disabled" "0,1"
        textline "                                      "
        bitfld.long 0x00 3. "AP_C0_FC_DONE_INTR_MASK         ,debug only: frequency change done for ap cluster0 interrupt mask  1 = interrupt enabled  0 = interrupt disabled" "0,1"
        bitfld.long 0x00 2. "         CP_FC_DONE_INTR_MASK817          ,debug only: frequency change done for cp interrupt mask  1 = interrupt enabled  0 = interrupt disabled" "0,1"
        bitfld.long 0x00 1. "   AP_FC_INTR_MASK                      ,ap fc interrupt mask  1 = interrupt enabled  0 = interrupt disabled" "0,1"
        bitfld.long 0x00 0. "   CP_FC_INTR_MASK819               ,frequency change done by cp interrupt mask  1 = interrupt enabled  0 = interrupt disabled" "0,1"

group d:0xD428289C++0x03
    line.long 0x00 "PMU_AP_IRWC,PMU AP Interrupt READ/WRITE Clear Register"
        bitfld.long 0x00 25. " AP_C2_FC_DONE_INTR_IRST827      ,ap cluster2 frequency change done interrupt read clear  1 = read clear  0 = interrupt write clear" "0,1"
        bitfld.long 0x00 22. "         AP_CORE9_IDLE_WAKE_INTR_IRST829  ,<var processor: application> core9 idle wake up interrupt read clear  1 = read clear  0 = interrupt write clear" "0,1"
        bitfld.long 0x00 21. "   AP_CORE8_IDLE_WAKE_INTR_IRST830      ,<var processor: application> core8 idle wake up interrupt read clear  1 = read clear  0 = interrupt write clear" "0,1"
        bitfld.long 0x00 20. "   AP_C1_FC_DONE_INTR_IRST831       ,ap cluster1 frequency change done interrupt read clear  1 = read clear  0 = interrupt write clear" "0,1"
        textline "                                      "
        bitfld.long 0x00 19. "AP_CORE7_IDLE_WAKE_INTR_IRST832 ,<var processor: application> core7 idle wake up interrupt read clear  1 = read clear  0 = interrupt write clear" "0,1"
        bitfld.long 0x00 18. "         AP_CORE6_IDLE_WAKE_INTR_IRST833  ,<var processor: application> core6 idle wake up interrupt read clear  1 = read clear  0 = interrupt write clear" "0,1"
        bitfld.long 0x00 17. "   AP_CORE5_IDLE_WAKE_INTR_IRST834      ,<var processor: application> core5 idle wake up interrupt read clear  1 = read clear  0 = interrupt write clear" "0,1"
        bitfld.long 0x00 16. "   AP_CORE4_IDLE_WAKE_INTR_IRST835  ,<var processor: application> core4 idle wake up interrupt read clear  1 = read clear  0 = interrupt write clear" "0,1"
        textline "                                      "
        bitfld.long 0x00 11. "SP_CORE_IDLE_WAKE_INTR_IRST837  ,<var processor: secure> wake up interrupt read clear  wake up interrupt read clear  1 = read clear  0 = interrupt write clear" "0,1"
        bitfld.long 0x00 10. "         AP_CORE3_IDLE_WAKE_INTR_IRST838  ,<var processor: application> core3 idle wake up interrupt read clear  1 = read clear  0 = interrupt write clear" "0,1"
        bitfld.long 0x00 9. "   AP_CORE2_IDLE_WAKE_INTR_IRST839      ,<var processor: application> core2 idle wake up interrupt read clear  1 = read clear  0 = interrupt write clear" "0,1"
        bitfld.long 0x00 8. "   AP_CORE1_IDLE_WAKE_INTR_IRST840  ,<var processor: application> core1 idle wake up interrupt read clear  1 = read clear  0 = interrupt write clear" "0,1"
        textline "                                      "
        bitfld.long 0x00 7. "AP_CORE0_IDLE_WAKE_INTR_IRST841 ,<var processor: application> core0 idle wake up interrupt read clear  1 = read clear  0 = interrupt write clear" "0,1"
        bitfld.long 0x00 6. "         CP_IDLE_WAKE_INTR_IRST842        ,cp idle wake up interrupt read clear  1 = read clear  0 = interrupt write clear" "0,1"
        bitfld.long 0x00 5. "   ACLK_FC_DONE_INTR_IRST843            ,aclk frequency change done interrupt read clear  1 = read clear  0 = interrupt write clear" "0,1"
        bitfld.long 0x00 4. "   DCLK_FC_DONE_INTR_IRST844        ,dclk frequency change done interrupt read clear  1 = read clear  0 = interrupt write clear" "0,1"
        textline "                                      "
        bitfld.long 0x00 3. "AP_C0_FC_DONE_INTR_IRST845      ,ap cluster0 frequency change done interrupt read clear  1 = read clear  0 = interrupt write clear" "0,1"
        bitfld.long 0x00 2. "         CP_FC_DONE_INTR_IRST846          ,cp frequency change done interrupt read clear  1 = read clear  0 = interrupt write clear" "0,1"
        bitfld.long 0x00 1. "   AP_FC_INTR_IRST847                   ,ap fc interrupt read clear  1 = read clear  0 = interrupt write clear" "0,1"
        bitfld.long 0x00 0. "   CP_FC_INTR_IRST848               ,cp fc interrupt read clear  1 = read clear  0 = interrupt write clear" "0,1"

group d:0xD42828A0++0x03
    line.long 0x00 "PMU_AP_ISR,PMU AP Interrupt Status Register"
        bitfld.long 0x00 25. " AP_C2_FC_DONE_INTR_ISR856       ,ap cluster2 frequency change done interrupt status  1 = interrupt active" "0,1"
        bitfld.long 0x00 22. "         AP_CORE9_IDLE_WAKE_INTR_ISR858   ,<var processor: application> core 9 idle wake up interrupt status  1 = interrupt active" "0,1"
        bitfld.long 0x00 21. "   AP_CORE8_IDLE_WAKE_INTR_ISR859       ,<var processor: application> core 8 idle wake up interrupt status  1 = interrupt active" "0,1"
        bitfld.long 0x00 20. "   AP_C1_FC_DONE_INTR_ISR860        ,ap cluster1 frequency change done interrupt status  1 = interrupt active" "0,1"
        textline "                                      "
        bitfld.long 0x00 19. "AP_CORE7_IDLE_WAKE_INTR_ISR861  ,<var processor: application> core 7 idle wake up interrupt status  1 = interrupt active" "0,1"
        bitfld.long 0x00 18. "         AP_CORE6_IDLE_WAKE_INTR_ISR862   ,<var processor: application> core 6 idle wake up interrupt status  1 = interrupt active" "0,1"
        bitfld.long 0x00 17. "   AP_CORE5_IDLE_WAKE_INTR_ISR863       ,<var processor: application> core 5 idle wake up interrupt status  1 = interrupt active" "0,1"
        bitfld.long 0x00 16. "   AP_CORE4_IDLE_WAKE_INTR_ISR864   ,<var processor: application> core 4 idle wake up interrupt status  1 = interrupt active" "0,1"
        textline "                                      "
        bitfld.long 0x00 11. "SP_CORE_IDLE_WAKE_INTR_ISR866   ,sp core idle wake up interrupt status  1 = interrupt active" "0,1"
        bitfld.long 0x00 10. "         AP_CORE3_IDLE_WAKE_INTR_ISR867   ,<var processor: application> core 3 idle wake up interrupt status  1 = interrupt active" "0,1"
        bitfld.long 0x00 9. "   AP_CORE2_IDLE_WAKE_INTR_ISR868       ,<var processor: application> core 2 idle wake up interrupt status  1 = interrupt active" "0,1"
        bitfld.long 0x00 8. "   AP_CORE1_IDLE_WAKE_INTR_ISR869   ,<var processor: application> core 1 idle wake up interrupt status  1 = interrupt active" "0,1"
        textline "                                      "
        bitfld.long 0x00 7. "AP_CORE0_IDLE_WAKE_INTR_ISR870  ,<var processor: application> core 0 idle wake up interrupt status  1 = interrupt active" "0,1"
        bitfld.long 0x00 6. "         CP_IDLE_WAKE_INTR_ISR871         ,cp idle wake up interrupt status  1 = interrupt active" "0,1"
        bitfld.long 0x00 5. "   ACLK_FC_DONE_INTR_ISR872             ,aclk frequency change done interrupt status  1 = interrupt active" "0,1"
        bitfld.long 0x00 4. "   DCLK_FC_DONE_INTR_ISR873         ,dclk frequency change done interrupt status  1 = interrupt active" "0,1"
        textline "                                      "
        bitfld.long 0x00 3. "AP_C0_FC_DONE_INTR_ISR874       ,ap cluster0 frequency change done interrupt status  1 = interrupt active" "0,1"
        bitfld.long 0x00 2. "         CP_FC_DONE_INTR_ISR875           ,cp frequency change done interrupt status  1 = interrupt active" "0,1"
        bitfld.long 0x00 1. "   AP_FC_ISR876                         ,ap fc interrupt status  1 = interrupt active" "0,1"
        bitfld.long 0x00 0. "   CP_FC_ISR877                     ,cp fc interrupt status  1 = interrupt active" "0,1"

group d:0xD42828A4++0x03
    line.long 0x00 "PMU_VPU_CLK_RES_CTRL,VPU Clock/Reset Control Register"
        bitfld.long 0x00 21. " VPU_CLK_FC_REQ                  ,vpu  clk frequency change request  write 1 to trigger a frequency change. this field is hardware cleared when the frequency change completes." "0,1"
        bitfld.long 0x00 20. "         VPU_FUSE_LOAD_MASK               ,only for debug to set" "0,1"
        bitfld.long 0x00 19. "   VPU_HW_MODE                          ,vpu hardware on/off mode" "0,1"
        bitfld.long 0x00 18. "   VPU_SLEEP2                       ,vpu power switch sleep2" "0,1"
        textline "                                      "
        bitfld.long 0x00 17. "VPU_SLEEP1                      ,vpu power switch sleep1" "0,1"
        bitfld.long 0x00 16. "         VPU_ISOB                         ,vpu isolation wrapper  0 = enable isolation (vpu power-down mode)  1 = disable isolation (vpu active mode)" "0,1"
        bitfld.long 0x00 13.--15. "   VPU_CLK_DIV                          ,vpu func clock divide ratio  vpu_clk = vpu_clk_sel / (this field +1)" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 10.--12. "   VPU_CLK_SEL                      ,vpu func clock select  0x0 = pll1 624 mhz  0x1 = pll1 499 mhz  0x2 = pll1 832mhx  0x3 = pll3_div3 0x4 = pll3_div2 0x5 = pll4_div2 0x6 = pll5_div2 0x7 = pll1 1248mhz" "0,1,2,3,4,5,6,7"
        textline "                                      "
        bitfld.long 0x00 3. "VPU_CLK_EN                      ,vpu func clock enable  1 =  clock enabled  0 =  clock disabled" "0,1"
        bitfld.long 0x00 0. "         VPU_RST                          ,vpu  reset" "0,1"

group d:0xD42828AC++0x03
    line.long 0x00 "PMU_DTC_CLK_RES_CTRL,DTC Clock/Reset Control Register"
        bitfld.long 0x00 3. " DTC_AXICLK_EN                   ,dtc axi clock enable  1 = axi clock enabled  0 = axi clock disabled" "0,1"
        bitfld.long 0x00 0. "         DTC_AXI_RST                      ,dtc axi reset" "0,1"

group d:0xD42828B0++0x03
    line.long 0x00 "PMU_MC_HW_SLP_TYPE,Memory Controller Hardware Sleep Type Register"
        bitfld.long 0x00 11. " 4X_CLK_MODE915                  ,4x clk mode  enabled 4:1 dclk mode" "0,1"
        bitfld.long 0x00 10. "         MC_REG_TABLE_EN                  ,enable ffc ddr clock change.  0 = enable, 1 = disable" "0,1"
        bitfld.long 0x00 9. "   2X_CLK_MODE                          ,2x clk mode  enabled 2x dclk for ddr freq_ratio=1:1" "0,1"
        bitfld.long 0x00 8. "   MC_TB0_MASK                      ,memory controller table0 operation  with this field, sleep mode exit can automatically trigger memory controller table0 operation.  0 = enable  1 = disable please keep default value" "0,1"
        textline "                                      "
        bitfld.long 0x00 3.--7. "MC_REG_TABLE_NUM                ,memory controller register table number  valid values are from 0x0 to 0x1f. this is used for table-based ddr clock change." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"

group d:0xD42828B4++0x03
    line.long 0x00 "PMU_MC_SLP_REQ_AP,Memory Controller AP Sleep Request Register"
        bitfld.long 0x00 1. " MC_SLP_ACK928                   ,memory controller low power acknowledge .  1 = memory controller in low power mode." "0,1"
        bitfld.long 0x00 0. "         MC_SLP_REQ_AP                    ,memory controller <var processor: application mp> sleep request  this field is used for <var processor: application mp> request to the memory controller to enter into sleep mode.  1 = <var processor: application mp> allows mc to enter into sleep mode" "0,1"

group d:0xD42828B8++0x03
    line.long 0x00 "PMU_MC_SLP_REQ_CP,Memory Controller <var Processor: Comm> Sleep Request Register"
        bitfld.long 0x00 1. " MC_SLP_ACK937                   ,memory controller low power acknowledge .  1 = memory controller in low power mode." "0,1"
        bitfld.long 0x00 0. "         MC_SLP_REQ_CP                    ,memory controller <var processor: comm> sleep request  this field is used for <var processor: comm> request to the memory controller to enter into sleep mode.  1 = <var processor: comm> allows mc to enter into sleep mode." "0,1"

group d:0xD42828BC++0x03
    line.long 0x00 "PMU_MC_SLP_REQ_MSA,Memory Controller MSA Sleep Request Register"
        bitfld.long 0x00 1. " MC_SLP_ACK946                   ,memory controller low power acknowledge .  1 = memory controller in low power mode." "0,1"
        bitfld.long 0x00 0. "         MC_SLP_REQ_MSA                   ,memory controller msa sleep request  this field is used for msa request to the mc to enter into sleep mode.  1 = msa allows mc to enter into sleep mode." "0,1"

group d:0xD42828C0++0x03
    line.long 0x00 "PMU_MC_SW_SLP_TYPE,Memory Controller Software Sleep Type Register"
        bitfld.long 0x00 0.--2. " MC_SW_SLP_TYPE                  ,software controlled sleep type for memory controller  0x0 = self refresh power down  0x1 = active power down  0x2 = precharge power down  0x3 = deep power down" "0,1,2,3,4,5,6,7"

group d:0xD42828C4++0x03
    line.long 0x00 "PMU_PLL_SEL_STATUS,PLL Clock Select Status Register"
        bitfld.long 0x00 14.--16. " AP_C2_PLL_SEL                   ,<var processor: application> cluster2 core clock selection  0x0 = pll1 1248 mhz  0x1 = pll1 832 mhz     0x2= pll3_div2(1.05g)   0x3=pll2_div2          0x4=pll5_div1   0x5=pll6_div1      0x6=pll4_div1(1.75g)             0x7=pll3_div1(2.1g)" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 11.--13. "         AP_C1_PLL_SEL                    ,<var processor: application> cluster1 core clock selection  0x0 = pll1 1248 mhz  0x1 = pll1 832 mhz     0x2= pll3_div2(1.05g)   0x3=pll2_div2   0x4=pll5_div1   0x5=pll6_div1   0x6=pll4_div1(1.75g)    0x7 = reserved" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 8.--10. "   AP_C0_PLL_SEL                        ,<var processor: application> cluster0 core clock selection  0x0 = pll1 624 mhz  0x1 = pll1 832 mhz     0x2= pll1 499mhz    0x3 = pll3_div2(1.05g)    0x4 = pll1 1248mhz     0x5~0x7 reserved" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 6.--7. "   ACLK_PLL_SEL                     ,bus clock pll select  0x0 = pll1 (416 mhz)  0x1 = pll1 (624 mhz)  0x2 = pll2out  0x3= pll2outp" "0,1,2,3"
        textline "                                      "
        bitfld.long 0x00 3.--5. "DCLK_PLL_SEL                    ,ddr clock selection  0x7 = pll3 div2   0x6 = pll5 div2   0x4 = pll2 div2   0x5 = pll4 div2   0x0 = pll1 624 mhz  0x1 = pll1 832 mhz" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 0.--2. "         CP_PLL_SEL                       ,<var processor: comm> pll select  0x0 = pll1 (416 mhz)  0x1 = pll1 (624 mhz)  0x2 = pll2out  0x3= pll1_312 mhz" "0,1,2,3,4,5,6,7"

group d:0xD42828CC++0x03
    line.long 0x00 "PMU_GPU_CLK_RES_CTRL,GPU Clock/Reset Control Register"
        bitfld.long 0x00 18.--20. " GPU_CLK_SEL                     ,gpu function clock select  0x0 = pll1 624 mhz  0x1 = pll1 499 mhz  0x2 = pll1 832mhz  0x3 = pll3_div3   0x4 = pll4_div2   0x5 = pll5_div2   0x6 = pll3_div2   0x7 = pll1 1248mhz" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 16. "         GPU_CLKMODE                      ,gpu function clk and bus clk frequency ratio.  0 = bus clk frequency equals function clk frequency.    1 = bus clk frequency is half of function clk frequency." "0,1"
        bitfld.long 0x00 15. "   GPU_FNC_FC_REQ                       ,gpu function clk frequency change request  write 1 to trigger a frequency change. this field is hardware cleared when the frequency change completes." "0,1"
        bitfld.long 0x00 12.--14. "   GPU_CLK_DIV                      ,gpu function clk divider  gpu_fnc_clk = gpu_clk_sel / (this field +1)" "0,1,2,3,4,5,6,7"
        textline "                                      "
        bitfld.long 0x00 11. "PM_HW_MODE981                   ,hardware control mode for gpu power up and power down" "0,1"
        bitfld.long 0x00 10. "         GPU_SLEEP2                       ,gpu power switch sleep2" "0,1"
        bitfld.long 0x00 9. "   GPU_SLEEP1                           ,gpu power switch sleep1" "0,1"
        bitfld.long 0x00 8. "   GPU_ISOB                         ,gpu isolation wrapper  0 = enable isolation (gpu powr-down mode)  1 = disable isolation (gpu active mode)" "0,1"
        textline "                                      "
        bitfld.long 0x00 4. "GPU_CLK_EN                      ,gpu functional clock enable  1 = peripheral clock enabled  0 = peripheral clock disabled" "0,1"
        bitfld.long 0x00 1. "         GPU_RST1                         ,gpu peripheral reset 1  0 = reset" "0,1"

group d:0xD42828D4++0x03
    line.long 0x00 "PMUA_SMC_CLK_RES_CTRL,SMC Clock/Reset Control Register"
        bitfld.long 0x00 6.--7. " SMC_CLK_SEL                     ,smc peripheral clock select  0x0 = 62.4 mhz  0x1 = 31.2 mhz  0x2 = 78 mhz  0x3 = 104 mhz" "0,1,2,3"
        bitfld.long 0x00 4. "         SMC_CLK_EN                       ,smc peripheral clock enable  1 = peripheral clock enabled  0 = peripheral clock disabled" "0,1"
        bitfld.long 0x00 3. "   SMC_AXICLK_EN                        ,smc axi clock enable  1 = axi clock enabled  0 = axi clock disabled" "0,1"
        bitfld.long 0x00 1. "   SMC_RST                          ,smc peripheral reset  0 = reset" "0,1"
        textline "                                      "
        bitfld.long 0x00 0. "SMC_AXI_RST                     ,smc axi reset" "0,1"

group d:0xD42828D8++0x03
    line.long 0x00 "PMUA_PWR_CTRL_REG,Power Control Register"
        bitfld.long 0x00 14. " VSP_AUTO_PWR_ON                 ,vsp auto power on  when asserted to 1, it triggers a request to power up the vsp power island  when de-asserted to 0, it triggers a request to power down vsp power, if vsp_clk_res_ctrl[27] is set" "0,1"
        bitfld.long 0x00 12. "         LCD_AUTO_PWR_ON                  ,lcd auto power on  1 = triggers request to power up the audio power island  0 = triggers request to power down audio power, if pmu_lcd_clk_rst_ctrl1[27] is set" "0,1"
        bitfld.long 0x00 10. "   AUDIO_AUTO_PWR_ON                    ,audio auto power on  1 = triggers request to power up the audio power island  0 = triggers request to power down audio power, if pmu_audio_cl[10] is set" "0,1"
        bitfld.long 0x00 4. "   ISP_AUTO_PWR_ON                  ,isp auto power on  when asserted to 1, it triggers a request to power up the isp power island  when de-asserted to 0, it triggers a request to power down isp power, if isp_clk_res_ctrl[15] is set" "0,1"
        textline "                                      "
        bitfld.long 0x00 2. "VPU_AUTO_PWR_ON                 ,vpu auto power on  when asserted to 1, it triggers a request to power up the vpu power island  when de-asserted to 0, it triggers a request to power down vpu power, if vpu_clk_res_ctrl[19] is set" "0,1"
        bitfld.long 0x00 0. "         GPU_AUTO_PWR_ON                  ,gpu auto power on  when asserted to 1, it triggers a request to power up the gpu power island  when de-asserted to 0, it triggers a request to power down gpu power, if gpu_clk_res_ctrl[11] is set" "0,1"

group d:0xD42828DC++0x03
    line.long 0x00 "PMUA_PWR_BLK_TMR_REG,Block Power Timer Register"
        hexmask.long.word 0x00 16.--31. 1. " PWR_ON1_TIMER                   ,gpu/vpu/isp/audio  auto-power on sleep1 to sleep2 delay"
        hexmask.long.byte 0x00 8.--15. 1. "      PWR_ON2_TIMER                    ,gpu/vpu/isp/audio auto-power on sleep2 to clock_en delay"
        hexmask.long.byte 0x00 0.--7. 1. "  PWR_OFF_TIMER                        ,gpu/vpu/isp/audio auto-power off sleep2 to sleep1 delay"

group d:0xD42828E0++0x03
    line.long 0x00 "PMUA_SDH2_CLK_RES_CTRL,SDH2 Clock/Reset Control Register"
        bitfld.long 0x00 11. " SDH2_CLK_FC_REQ                 ,sdh2 clock frequency change request  when this field is set to 1, it will force sdh2_clk_div to work. this field will be automatically cleared by hardware when clock switch is done." "0,1"
        bitfld.long 0x00 8.--10. "         SDH2_CLK_DIV                     ,sdh2 clock frequency divisor  0-7 =  sdh2_clk = sdh2 source clock/(sdh2_clk_div + 1)" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 6.--7. "   SDH2_CLK_SEL                         ,sdh0 clock source select   0=416mhz(clk_in_416m_pll1)   1=624mhz(clk_in_pll1_2x)   2=clk_in_pll6_div2   3=400mhz(clk_in_pll6_div4)" "0,1,2,3"
        bitfld.long 0x00 4. "   SDH2_CLK_EN                      ,sdh2 peripheral clock enable  1 = peripheral clock enabled  0 = peripheral clock disabled" "0,1"
        textline "                                      "
        bitfld.long 0x00 1. "SDH2_RST                        ,sdh2 peripheral reset  0 = reset" "0,1"

group d:0xD4282920++0x03
    line.long 0x00 "PMU_C0_CAPMP_IDLE_CFGx0,Cluster0 <var Processor: Application MP> Idle Configuration Register for Core x"

group d:0xD42828E4++0x03
    line.long 0x00 "PMU_C0_CAPMP_IDLE_CFGx1,Cluster0 <var Processor: Application MP> Idle Configuration Register for Core x"

group d:0xD4282950++0x03
    line.long 0x00 "PMU_C0_CAPMP_IDLE_CFGx2,Cluster0 <var Processor: Application MP> Idle Configuration Register for Core x"

group d:0xD4282954++0x03
    line.long 0x00 "PMU_C0_CAPMP_IDLE_CFGx3,Cluster0 <var Processor: Application MP> Idle Configuration Register for Core x"
        bitfld.long 0x00 19. " DIS_MP_L2_SLP1054               ,disable <var processor: application mp> l2 power switch  this field is used to disable the <var processor: application mp> l2 power switch sleep power down during <var processor: application mp> power down mode.  1 = disable <var processor: application" "0,1"
        bitfld.long 0x00 18. "         DIS_MP_SLP1055                   ,disable <var processor: application mp> power switch  this field is used to disable the <var processor: application mp> power switch sleep power down during mp subsystem power down mode.  1 = disable mp power switch sleep" "0,1"
        bitfld.long 0x00 16. "   MP_L2_PWR_OFF1057                    ,frc l2 sram off  1 = l2 cache power is off" "0,1"
        bitfld.long 0x00 13. "   L2_HW_CACHE_FLUSH_EN1059         ,l2 hardware cache flush enable  0x1= enable" "0,1"
        textline "                                      "
        bitfld.long 0x00 12. "MASK_SRAM_REPAIR_DONE_CHECK1060 ,mask sram repair done check  1 = mask sram repair done check" "0,1"
        bitfld.long 0x00 11. "         MASK_CLK_OFF_CHECK1061           ,mask <var processor: application mp> clock off state check  this field is used to mask the <var processor: application mp> clock off check during the mp idle process." "0,1"
        bitfld.long 0x00 10. "   MASK_CLK_STBL_CHECK1062              ,mask mp clock stbl state check  this field is used to mask the mp clock stable check during mp wakeup." "0,1"
        bitfld.long 0x00 9. "   MASK_JTAG_IDLE_CHECK1063         ,mask jtag idle state check  this field is used to mask the jtag idle check during <var processor: application mp> idle entry.  1 = mask jtag idle check" "0,1"
        textline "                                      "
        bitfld.long 0x00 8. "MASK_IDLE_CHECK1064             ,mask <var processor: application mp> idle state check  debug only - it should be 0 during normal operation  1 = status check masked  0 = status check not masked" "0,1"
        bitfld.long 0x00 7. "         ACINACTM_HW_CTRL1065             ,acinactm hardware control   0x0=low power state machine does not control acinactm port.   0x1= low power state machine will control acinactm port of <var processor: application mp>.  when m2/m1 low power mode is entered, acinactm port will be high" "0,1"
        bitfld.long 0x00 5. "   DIS_MC_SW_REQ1067                    ,disable memory controller software req  this field is used to disable the memory controller entry to idle mode using the memory controller sleep request bits. the memory controller will always enter into idle mode based upon the hardware state machine re" "0,1"
        bitfld.long 0x00 4. "   MP_WAKE_MC_EN1068                ,<var processor: application mp> wake mc enable  wake up the memory controller when the <var processor: application mp> wakes up from idle mode. the memory controller will be woken up before the interrupt to the core is released.  0 = memory controller w" "0,1"
        textline "                                      "
        bitfld.long 0x00 3. "MP_SCU_SRAM_PWRDWN1069          ,not used. scu sram does not support retention" "0,1"
        bitfld.long 0x00 3. "         PM_1070                          ,reserved for future use" "0,1"
        bitfld.long 0x00 2. "   L2_SRAM_PWRDWN1071                   ,l2 cache sram power down  this field does not take effect if mp_pwrdwn is 0.  1 = when <var processor: application mp> is idle, l2 sram power will be off  0 = when <var processor: application mp> is idle, l2 sram is in retention mode" "0,1"
        bitfld.long 0x00 1. "   MP_PWRDWN1072                    ,<var processor: application mp> power down  this field does not take effect if mp_idle is 0.  1 = when <var processor: application mp> is idle, <var processor: application mp> will go into deep sleep mode and <var processor: application mp> logic will b" "0,1"
        textline "                                      "
        bitfld.long 0x00 0. "MP_IDLE1073                     ,<var processor: application mp> idle  1 = when <var processor: application mp> is idle, <var processor: application mp> clocks will be gated externally" "0,1"

group d:0xD42828E8++0x03
    line.long 0x00 "PMUA_MC_CTRL,Memory Controller AHB Register"
        bitfld.long 0x00 29. " BYPS_DFI_INIT_HW                ,debug bit 1: bypass phy_arc_hw_en control of phy signals 0: no bypass, take effect when mc_core_init==0" "0,1"
        bitfld.long 0x00 28. "         BYPS_FREQ_HW                     ,debug bit 1: bypass core/dfi freq control by hardware 0: no bypass, take effect except audio init phy and core" "0,1"
        bitfld.long 0x00 27. "   MC_SEL_AUD_APB                       ,debug bit 1: select audio apb to mc core and phy apb 0: default way on memory map" "0,1"
        bitfld.long 0x00 26. "   BYPS_PHY_ARC_HW                  ,debug bit 1: bypass phy_arc_hw_en control of phy signals 0: no bypass, phy_arc_hw_en take effect when mc_phy_arc_hw==1&&mc_core_init==0" "0,1"
        textline "                                      "
        bitfld.long 0x00 25. "BYPS_DEASS_PWROK                ,debug bit 1: bypass deassert pwrok in main pmu when pll off 0: deassert pwrok in main pmu before pll off" "0,1"
        bitfld.long 0x00 24. "         MC_INIT_BYPASS                   ,debug bit 1: mc initiallization bypassed when low power exit 0: mc initiallization follow ap_idle_sm when low power exit" "0,1"
        bitfld.long 0x00 17. "   MC_DEASS_PWROK                       ,1: deassert pwrok for mc phy,  the bit would be cleared automatically" "0,1"
        bitfld.long 0x00 16. "   MC_ASS_PWROK                     ,1: assert pwrok for mc phy,  the bit would be cleared automatically" "0,1"
        textline "                                      "
        bitfld.long 0x00 14. "MC_PHY_ARC_HW                   ,1: hw override arc control: rst/stall/clken/cms to enable arc firmware executing when low power exit 0: no use arc hw control to enable firmware" "0,1"
        bitfld.long 0x00 13. "         MC_CORE_INIT                     ,1: init mc core when low power exit 0: init mc core bypassed when low power exit, if mc_init_bypass==0, only init mc phy" "0,1"
        bitfld.long 0x00 12. "   MC_INIT_BY_AUDIO                     ,1: mc initiallized by audio core when low power exit 0: mc initiallized by table when low power exit" "0,1"
        bitfld.long 0x00 9. "   MC_PHY_RSTN                      ,memory controller phy reset  0 = reset" "0,1"
        textline "                                      "
        bitfld.long 0x00 8. "MC_CORE_RSTN                    ,memory controller core reset  0 = reset" "0,1"
        bitfld.long 0x00 4. "         HW_DRAIN_CAM                     ,1: drive csysdiscamdrain==1 to memory controller when hwffc 0:" "0,1"
        bitfld.long 0x00 3. "   DTE_AHBCLK_EN                        ,dte ahbi clock enable  1 = ahb clock enabled  0 = ahb clock disabled" "0,1"
        bitfld.long 0x00 2. "   DTE_HCLK_RST                     ,dte hclk reset: 0 = reset" "0,1"
        textline "                                      "
        bitfld.long 0x00 1. "MCK5_AHBCLK_EN                  ,memory controller ahb clock enable  1 = ahb clock enabled  0 = ahb clock disabled" "0,1"
        bitfld.long 0x00 0. "         MCK5_HCLK_RST                    ,memory controller hclk reset  0 = reset" "0,1"

group d:0xD42828F0++0x03
    line.long 0x00 "PMUA_PWR_STATUS_REG,Power Status Register"
        bitfld.long 0x00 12. " LCD_PWR_STAT                    ,hw updated status of pwr_ctrl[12] when the lcd has entered/exit its lpm." "0,1"
        bitfld.long 0x00 10. "         AUDIO_PWR_STAT                   ,audio power state update  hardware updated status of pwr_ctrl[10] when the audio has entered/exit its lpm.  0x0 = audio is powered off  0x1 = audio is powered on" "0,1"
        bitfld.long 0x00 9. "   GNSS_SD_PWR_STAT1114                 ,gnss domain power state  before turning off gnss_aon power, software must ensure gnss_sd power is off by polling this bit.  0x0 = gnss_sd is powered off  0x1 = gnss_sd is powered on" "0,1"
        bitfld.long 0x00 8. "   GNSS_PWR_STAT1115                ,gnss power state update  hardware updated status of pwr_ctrl[8] when the gnss has entered/exit its lpm.  0x0 = gnss is powered off  0x1 = gnss is powered on" "0,1"
        textline "                                      "
        bitfld.long 0x00 9. "GNSS_SD_PWR_STAT1116            ,gnss domain power state  before turning off gnss_aon power, software must ensure gnss_sd power is off by polling this bit.  0x0 = gnss_sd is powered off  0x1 = gnss_sd is powered on" "0,1"
        bitfld.long 0x00 8. "         GNSS_PWR_STAT1117                ,gnss power state update  hardware updated status of pwr_ctrl[8] when the gnss has entered/exit its lpm.  0x0 = gnss is powered off  0x1 = gnss is powered on" "0,1"
        bitfld.long 0x00 4. "   ISP_PWR_STAT                         ,hw updated status of pwr_ctrl[4] when the isp has entered/exit its lpm." "0,1"
        bitfld.long 0x00 2. "   VPU_PWR_STAT                     ,hw updated status of pwr_ctrl[2] when the vpu has entered/exit its lpm." "0,1"
        textline "                                      "
        bitfld.long 0x00 0. "GPU_PWR_STAT                    ,hw updated status of pwr_ctrl[0] when the gpu has entered/exit its lpm." "0,1"

group d:0xD42828F8++0x03
    line.long 0x00 "PMU_SP_IDLE_CFG,SP Idle Configuration Register"
        bitfld.long 0x00 4. " MASK_SP_IDLE_IND                ,mask <var processor: secure> idle indication  debug only - mask the <var processor: secure> idle indication check during ap/cp idle process. if this bit is set, then ap/cp idle sequence does not wait for acknowledgement from the <var processor: secure> i" "0,1"
        bitfld.long 0x00 3. "         SP_GBL_IRQ_MASK_CLR_DIS          ,sp gbl_irq_mask auto clear disable  pmu can auto clear sp gbl_irq_mask to enable interrupt.  0 = auto clear function enabled  1 = auto clear function disabled" "0,1"
        bitfld.long 0x00 2. "   MASK_SP_CLK_ON_CHECK                 ,mask <var processor: secure> clock on check  debug only - mask the <var processor: secure> clock on indication check during <var processor: secure> idle process. if this bit is set, then the <var processor: secure> idle sequence does not wait for acknowl" "0,1"
        bitfld.long 0x00 1. "   MASK_SP_CLK_OFF_ACK              ,mask <var processor: secure> clock off acknowledge  debug only - mask the <var processor: secure> clock off acknowledge from the <var processor: secure> clock generation unit  1 = mask the cp clock off acknowledge during frequency change process  0 = n" "0,1"
        textline "                                      "
        bitfld.long 0x00 0. "MASK_WFI_CHECK1135              ,wfi state check mask  debug only - it should be 0 during normal operation  1 = status check masked  0 = status check not masked" "0,1"

group d:0xD42828FC++0x03
    line.long 0x00 "PMU_GNSS_PWR_CTRL,GNSS Power Control Register"
        bitfld.long 0x00 9. " GNSS_RST_STATUS                 ,gnss reset status    0x0 = gnss is in reset state   0x1 = gnss reset  is released" "0,1"
        bitfld.long 0x00 8. "         GNSS_SILENT_RST_MODE             ,gnss reset mode slect.  this select only take effect when gnss_hiw_mode is 0. when gnss_hw_mode is 1, gnss reset mode is always normal mode   0x0 = gnss reset mode is normal mode   0x1 = gnss reset mode is silent reset mode. reset is asserted only when gnss bus interface is idle" "0,1"
        bitfld.long 0x00 7. "   GNSS_ACLK_EN                         ,gnss axi clock enable  0x0 = gnss axi clock is disabled  0x1 = gnss axi clock is enabled" "0,1"
        bitfld.long 0x00 6. "   GNSS_FUSE_LOAD_MASK              ,gnss fuse load mask  debug only  0x0 = no mask  0x1 = mask fuse load done check" "0,1"
        textline "                                      "
        bitfld.long 0x00 5. "GNSS_FUSE_LOAD_START            ,gnss fuse load start  note that when gnss fuse loading finishes, this field is automatically cleared by hardware logic.  0x0 = don't trigger gnns fuse loading or fuse loading has finished  0x1 = trigger gnns fuse loading" "0,1"
        bitfld.long 0x00 4. "         GNSS_SLEEP2                      ,gnss power switch sleep2" "0,1"
        bitfld.long 0x00 3. "   GNSS_SLEEP1                          ,gnss power switch sleep1" "0,1"
        bitfld.long 0x00 2. "   GNSS_ISOB                        ,gnss isolation control  0x0 = enable isolation (gnss powr-down mode)  0x1 = disable isolation (gnss active mode)" "0,1"
        textline "                                      "
        bitfld.long 0x00 1. "GNSS_RSTN                       ,gnss software reset  0x0 = gnss is in reset state  0x1 = gnss is released from reset" "0,1"
        bitfld.long 0x00 0. "         GNSS_HW_MODE1153                 ,hardware control mode for gnss power up and down" "0,1"
        bitfld.long 0x00 0. "   GNSS_HW_MODE1154                     ,hardware control mode for gnss power up and down" "0,1"

group d:0xD4282900++0x03
    line.long 0x00 "PMU_CC2_AP,AP Clock Control Register2"
        bitfld.long 0x00 29. " MPSUB_DBG_RST                   ,<var processor: application mp> debug reset  this field is used to reset the <var processor: application mp> debug/coresight logic, including <var processor: application> core dbg logic.  1 = reset is asserted  0 = reset is de-asserted" "0,1"
        bitfld.long 0x00 28. "         C1_MPSUB_SW_RST                  ,<var processor: application mp> reset  this field is used to reset the <var processor: application mp> logic except debug/coresight logic.  1 = reset is asserted  0 = reset is de-asserted" "0,1"
        bitfld.long 0x00 26. "   CPU7_SW_RST                          , cpu7 core software reset  1 = reset is asserted  0 = reset is de-asserted" "0,1"
        bitfld.long 0x00 25. "   CPU7_POR_RST                     , cpu7 core power on reset  this field is used to reset cpu7 all logic, including debug logic.  1 = reset is asserted  0 = reset is de-asserted" "0,1"
        textline "                                      "
        bitfld.long 0x00 23. "CPU6_SW_RST                     , cpu6 core software reset  this field is used to reset cpu6 core logic only.  1 = reset is asserted  0 = reset is de-asserted" "0,1"
        bitfld.long 0x00 22. "         CPU6_POR_RST                     ,cpu6 core power on reset  this field is used to reset cpu6 all logic, including debug logic.  1 = reset is asserted  0 = reset is de-asserted" "0,1"
        bitfld.long 0x00 20. "   CPU5_SW_RST                          ,cpu5 core software reset  this field is used to reset cpu5 core logic only.  1 = reset is asserted  0 = reset is de-asserted" "0,1"
        bitfld.long 0x00 19. "   CPU5_POR_RST                     ,cpu5 core power on reset  this field is used to reset cpu5 all logic, including debug logic.  1 = reset is asserted  0 = reset is de-asserted" "0,1"
        textline "                                      "
        bitfld.long 0x00 17. "CPU4_SW_RST                     ,cpu4 core software reset  this field is used to reset cpu4 core logic only.  1 = core software reset is asserted  0 = core software reset is de-asserted" "0,1"
        bitfld.long 0x00 16. "         CPU4_POR_RST                     ,cpu4 core power on reset  this field is used to reset cpu4 all logic including debug logic.  1 = core power on reset is asserted  0 = core power on reset is de-asserted" "0,1"
        bitfld.long 0x00 12. "   C0_MPSUB_SW_RST                      ,<var processor: application mp> reset  this field is used to reset the <var processor: application mp> logic except debug/coresight logic.  1 = reset is asserted  0 = reset is de-asserted" "0,1"
        bitfld.long 0x00 10. "   CPU3_SW_RST                      , cpu3 core software reset  1 = reset is asserted  0 = reset is de-asserted" "0,1"
        textline "                                      "
        bitfld.long 0x00 9. "CPU3_POR_RST                    , cpu3 core power on reset  this field is used to reset cpu3 all logic, including debug logic.  1 = reset is asserted  0 = reset is de-asserted." "0,1"
        bitfld.long 0x00 7. "         CPU2_SW_RST                      , cpu2 core software reset  this field is used to reset cpu2 core logic only.  1 = reset is asserted  0 = reset is de-asserted" "0,1"
        bitfld.long 0x00 6. "   CPU2_POR_RST                         ,cpu2 core power on reset  this field is used to reset cpu2 all logic, including debug logic.  1 = reset is asserted  0 = reset is de-asserted" "0,1"
        bitfld.long 0x00 4. "   CPU1_SW_RST                      ,cpu1 core software reset  this field is used to reset cpu1 core logic only.  1 = reset is asserted  0 = reset is de-asserted" "0,1"
        textline "                                      "
        bitfld.long 0x00 3. "CPU1_POR_RST                    ,cpu1 core power on reset  this field is used to reset cpu1 all logic, including debug logic.  1 = reset is asserted  0 = reset is de-asserted" "0,1"
        bitfld.long 0x00 1. "         CPU0_SW_RST                      ,cpu0 core software reset  this field is used to reset cpu0 core logic only.  1 = core software reset is asserted  0 = core software reset is de-asserted" "0,1"
        bitfld.long 0x00 0. "   CPU0_POR_RST                         ,cpu0 core power on reset  this field is used to reset cpu0 all logic including debug logic.  1 = core power on reset is asserted  0 = core power on reset is de-asserted" "0,1"

group d:0xD4282904++0x03
    line.long 0x00 "PMUA_EM_CLK_RES_CTRL,EMMC5.0 Clock/Reset Control Register"
        bitfld.long 0x00 31. " EM_PHY_TMS_SW                   ,em5.0 ephy pad bypass/test mode sw enable   1 = bypass/test mode enable  0 = bypass/test disabled" "0,1"
        bitfld.long 0x00 30. "         EM_PHY_TOE_SW                    ,test data output select   1 = tdo ports are sampled with fclk (low speed only).   0 = tdo ports are directly from receiver" "0,1"
        bitfld.long 0x00 29. "   EM_PHY_VREF                          ,sw control the ephy vref port value" "0,1"
        bitfld.long 0x00 28. "   EM_PHY_V18EN                     ,ephy io 1.8 enable sw control   1 = 1.8v enable   0 = 1.8v disable" "0,1"
        textline "                                      "
        bitfld.long 0x00 27. "EM_PHY_LP_SEL                   ,ephy low power mode sw control   1 = lp mode enable   0 = lp mode disable" "0,1"
        bitfld.long 0x00 15. "         EM_1248M_CLK_EN                  ,em5.0 1248 mhz input clock enable  0 = disable em 1248m clock divider clock source  1 = enable em 1248m clock divider clock source" "0,1"
        bitfld.long 0x00 12.--14. "   EM_1248M_CLK_DIV                     ,emmc5.0 1248 mhz input clock frequency divisor  0x0 to 0x7 =  em_1248m_div5 = 1248 m source clock/(em_1248_clk_div + 1)" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 11. "   EM_CLK_FC_REQ                    ,when write this bit to 1 will force em_clk_div work, this bit will automatically cleared by hardware when clock switch is done" "0,1"
        textline "                                      "
        bitfld.long 0x00 8.--10. "EM_CLK_DIV                      ,em_clk_div  0-7 = em_clk = em source clock/(em_clk_div + 1)" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 6.--7. "         EM_CLK_SEL                       ,em clock source select  0 = 416mhz(clk_in_416m_pll1)  1 = 624 mhz(clk_in_pll1_2x)   2=48mhz clock  3=800mhz(clk_in_pll2)" "0,1,2,3"
        bitfld.long 0x00 4. "   EM_CLK_EN                            ,em peripheral clock enable  1 = peripheral clock enabled  0 = peripheral clock disabled" "0,1"
        bitfld.long 0x00 3. "   EM_AXICLK_EN                     ,em axi clock enable  1 = axi clock enabled  0 = axi clock disabled" "0,1"
        textline "                                      "
        bitfld.long 0x00 1. "EM_RST                          ,em peripheral reset  0 = reset, actually emmc5.0 controller will only use em_axi_rst." "0,1"
        bitfld.long 0x00 0. "         EM_AXI_RST                       ,em axi reset." "0,1"

group d:0xD4282908++0x03
    line.long 0x00 "TRACE_CONFIG,Trace Clock Control Register"
        bitfld.long 0x00 19.--21. " PCLKDBG_DIV                     ,clock divider selection for pclkdbg. pclkdbg = atclk / (this field +1)" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 17.--18. "         DBG_CLK_SEL                      ,internal trace clock source select  0x0 = 624 mhz  0x1 = 416 mhz  0x2 = 499mhz  0x3 = 832mhz clock  note that the debug clock is generated based on atclk." "0,1,2,3"
        bitfld.long 0x00 16. "   SWRST                                ,software reset  this field is used to reset all debug logic, low assert" "0,1"
        bitfld.long 0x00 15. "   TRACE_CLK_FC_REQ                 ,trace clock frequency change request  1 = trace_clk_div forced to work  this field is automatically cleared by hardware when clock switch is done" "0,1"
        textline "                                      "
        bitfld.long 0x00 11. "TPIU_CLK_SEL                    ,tpiu clock selection  select tpiu use internal clock or external input clock from pad, default will use the clock from internal" "0,1"
        bitfld.long 0x00 8.--10. "         TRACE_CLK_DIV                    ,trace clock frequency divisor  0-7 =trace_clk = trace source clock/(trace_clk_div + 1)" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 6.--7. "   TRACE_CLK_SEL                        ,internal trace clock source select  0x0 = 624 mhz  0x1 = 416 mhz  0x2 = 499mhz  0x3 = 832mhz clock" "0,1,2,3"
        bitfld.long 0x00 5. "   DBG_CLK_FC_REQ                   ,debug clock frequency change request  1 = force dbg_clk_div to operate  this field is automatically cleared by hardware when clock switch is done" "0,1"
        textline "                                      "
        bitfld.long 0x00 4. "TRACE_CLK_EN                    ,trace clock enable  enable the internal trace clock for tpiu trace output" "0,1"
        bitfld.long 0x00 3. "         DBGCLK_EN                        ,debug clock enable (including atclk and pclkdbg)  0 = debug clock disabled  1 = debug clock enabled" "0,1"
        bitfld.long 0x00 0.--2. "   ATCLK_DIV                            ,clock divider selection for atclk  atclk = (debug clock selection in trace_config[18:17]) / (this field +1)" "0,1,2,3,4,5,6,7"

group d:0xD4282910++0x03
    line.long 0x00 "PMUA_USB_PHY_CTRL0,USB PHY Control Register0"
        bitfld.long 0x00 18.--21. " USB_PHY_PLLPTUNE                ,usb phy pllptune" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 16.--17. "        USB_PHY_PLLITUNE                 ,usb phy pllitune" "0,1,2,3"
        bitfld.long 0x00 11. "   USB_PHY_DCDENB                       ,usb phy dcdenb" "0,1"
        bitfld.long 0x00 10. "   USB_PHY_VDATSRCENB               ,usb phy vdatsrcenb" "0,1"
        textline "                                      "
        bitfld.long 0x00 9. "USB_PHY_VDATDETENB              ,usb phy vdatdetenb" "0,1"
        bitfld.long 0x00 8. "         USB_PHY_CHGSEL                   ,usb phy chgsel" "0,1"
        bitfld.long 0x00 7. "   USB_PHY_TXBITSTUFFENH                ,usb phy txbitstuffenh" "0,1"
        bitfld.long 0x00 6. "   USB_PHY_TXBITSTUFFEN             ,usb phy txbitstuffen" "0,1"
        textline "                                      "
        bitfld.long 0x00 5. "USB_PHY_SIDDQ                   ,usb phy siddq  1 = siddq mode<0> = not siddq mode" "0,1"
        bitfld.long 0x00 4. "         USB_PHY_SLEEPM                   ,usb phy sleepm  0 = sleep<1> = not sleep" "0,1"
        bitfld.long 0x00 3. "   USB_PHY_OTGDIS                       ,usb phy otg disable" "0,1"
        bitfld.long 0x00 2. "   USB_PHY_COMMONONN                ,usb phy commononn" "0,1"
        textline "                                      "
        bitfld.long 0x00 1. "USB_PHY_PORTRST                 ,usb phy port reset  1 = reset<0> = not reset" "0,1"
        bitfld.long 0x00 0. "         USB_PHY_POR                      ,usb phy power reset  1 = reset<0> = not reset" "0,1"

group d:0xD4282914++0x03
    line.long 0x00 "PMUA_USB_PHY_CTRL1,USB PHY Control Register1"
        bitfld.long 0x00 27. " USB_PHY_TXPREEMPPULSETUNE       ,usb phy txpreemppulsetune" "0,1"
        bitfld.long 0x00 25.--26. "         USB_PHY_TXPREEMPAMPTUNE          ,usb phy txpreempamptune0" "0,1,2,3"
        bitfld.long 0x00 23.--24. "   USB_PHY_TXRESTUNE                    ,usb phy txrestune" "0,1,2,3"
        bitfld.long 0x00 21.--22. "   USB_PHY_TXRISETUNE               ,usb phy txrisetune" "0,1,2,3"
        textline "                                      "
        bitfld.long 0x00 17.--20. "USB_PHY_TXVREFTUNE              ,usb phy txvreftune" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 13.--16. "        USB_PHY_TXFSLSTUNE               ,usb phy txfslstune" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 11.--12. "  USB_PHY_TXHSXVTUNE                   ,usb phy txhsxvtune" "0,1,2,3"
        bitfld.long 0x00 8.--10. "   USB_PHY_OTGTUNE                  ,usb phy otgtune" "0,1,2,3,4,5,6,7"
        textline "                                      "
        bitfld.long 0x00 6.--7. "USB_PHY_VDATREFTUNE             ,usb phy vdatreftune" "0,1,2,3"
        bitfld.long 0x00 3.--5. "         USB_PHY_SQRXTUNE                 ,usb phy sqrxtune" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 0.--2. "   USB_PHY_COMPDISTUNE                  ,usb phy compdistune" "0,1,2,3,4,5,6,7"

group d:0xD428291C++0x03
    line.long 0x00 "PMUA_USB_PHY_TEST,USB PHY Test Register"
        hexmask.long.byte 0x00 24.--31. 1. " USB_PHY_TESTDATAIN              ,usb phy testdatain"
        bitfld.long 0x00 20.--23. "        USB_PHY_TESTADDR                 ,usb phy testaddr" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 19. "  USB_PHY_TESTBURNIN                   ,usb phy testburnin" "0,1"
        bitfld.long 0x00 18. "   USB_PHY_TESTDATAOUTSEL           ,usb phy testdataoutsel" "0,1"
        textline "                                      "
        bitfld.long 0x00 17. "USB_PHY_TESTEN                  ,usb phy testen" "0,1"
        bitfld.long 0x00 16. "         USB_PHY_TESTCLK                  ,usb phy testclk" "0,1"
        hexmask.long.byte 0x00 8.--15. 1. "   USB_PHY_SCANPSI                      ,usb phy scanpsi"
        bitfld.long 0x00 6. "  USB_PHY_LOOPBACKENB              ,usb phy loopbackenb" "0,1"
        textline "                                      "
        bitfld.long 0x00 5. "USB_PHY_SCANNSI                 ,usb phy scannsi" "0,1"
        bitfld.long 0x00 4. "         USB_PHY_SCANEN                   ,usb phy scanen" "0,1"
        bitfld.long 0x00 3. "   USB_PHY_SCANCLK                      ,usb phy scanclk" "0,1"
        bitfld.long 0x00 1.--2. "   USB_PHY_VATESTENB                ,usb phy vatestenb" "0,1,2,3"
        textline "                                      "
        bitfld.long 0x00 0. "USB_PHY_ATERESET                ,usb phy atereset" "0,1"

group d:0xD4282924++0x03
    line.long 0x00 "PMU_CAP_COREx_IDLE_CFG0,<var Processor: Application> Core x  Idle Configuration Register"

group d:0xD4282928++0x03
    line.long 0x00 "PMU_CAP_COREx_IDLE_CFG1,<var Processor: Application> Core x  Idle Configuration Register"

group d:0xD4282960++0x03
    line.long 0x00 "PMU_CAP_COREx_IDLE_CFG2,<var Processor: Application> Core x  Idle Configuration Register"

group d:0xD4282964++0x03
    line.long 0x00 "PMU_CAP_COREx_IDLE_CFG3,<var Processor: Application> Core x  Idle Configuration Register"

group d:0xD4282B04++0x03
    line.long 0x00 "PMU_CAP_COREx_IDLE_CFG4,<var Processor: Application> Core x  Idle Configuration Register"

group d:0xD4282B08++0x03
    line.long 0x00 "PMU_CAP_COREx_IDLE_CFG5,<var Processor: Application> Core x  Idle Configuration Register"

group d:0xD4282B0C++0x03
    line.long 0x00 "PMU_CAP_COREx_IDLE_CFG6,<var Processor: Application> Core x  Idle Configuration Register"

group d:0xD4282B10++0x03
    line.long 0x00 "PMU_CAP_COREx_IDLE_CFG7,<var Processor: Application> Core x  Idle Configuration Register"

group d:0xD4282B40++0x03
    line.long 0x00 "PMU_CAP_COREx_IDLE_CFG8,<var Processor: Application> Core x  Idle Configuration Register"

group d:0xD4282B44++0x03
    line.long 0x00 "PMU_CAP_COREx_IDLE_CFG9,<var Processor: Application> Core x  Idle Configuration Register"
        bitfld.long 0x00 20.--21. " PM_PSW_MODE1300                 ,power switch mode  <var processor: application> core has both big macro power switch and distributed power switch. this field selects different power switch mode.  0x0 = both big macro switches and distributed switches used. during power up – first powe" "0,1,2,3"
        bitfld.long 0x00 19. "         PM_DIS_CORE_L1_SLP1301           ,disable l1 slp  this field is used to disable the core l1 sram power switch sleep power down during core power down mode.  1 = disable core l1 power switch sleep" "0,1"
        bitfld.long 0x00 18. "   PM_DIS_CORE_SLP1302                  ,disable core slp  this field is used to disable the core power switch sleep power down during core power down mode.  1 = disable core power switch sleep" "0,1"
        bitfld.long 0x00 11. "   MASK_CLK_OFF_CHECK1304           ,mask core clock off check during core idle process." "0,1"
        textline "                                      "
        bitfld.long 0x00 10. "MASK_CLK_STBL_CHECK1305         ,mask core clock stable check during core wakeup." "0,1"
        bitfld.long 0x00 9. "         MASK_JTAG_IDLE_CHECK1306         ,mask the jtag idle check during mp idle entry  1 = mask the jtag idle check." "0,1"
        bitfld.long 0x00 8. "   PM_MASK_CORE_WFI_IDLE_CHECK1307      ,debug only - it should be 0 during normal operation mask core wfi idle check  1 = status check masked  0 = status check not masked" "0,1"
        bitfld.long 0x00 4. "   MASK_GIC_NFIQ_TO_CORE            ,mask nfiq generated in gic for <var processor: application> core. software can set this bit before core enter c2. apmu hardware will automatically clear this bit when core enter c2" "0,1"
        textline "                                      "
        bitfld.long 0x00 3. "MASK_GIC_NIRQ_TO_CORE           ,mask nirq generated in gic for <var processor: application> core. software can set this bit before core enter c2. apmu hardware will automatically clear this bit when core enter c2" "0,1"
        bitfld.long 0x00 2. "         PM_CORE_L1_SRAM_PWRDWN1311       ,not used. l1 does not support retention" "0,1"
        bitfld.long 0x00 1. "   PM_CORE_PWRDWN1312                   ,core power down. this bit does not takes effect if core_idle is 0.  1 = when core issue wfi idle, core will go into deep sleep mode and power will be turned off. this bit will not take effect if <var processor: application> dbgnopwrdwn is set" "0,1"
        bitfld.long 0x00 0. "   PM_CORE_IDLE1313                 ,core idle  1 = when core issue wfi idle, the core clock will be gated externally. this bit will not take effect if <var processor: application> dbgnopwrdwn is set" "0,1"

group d:0xD428292C++0x03
    line.long 0x00 "PMU_CAP_COREx_WAKEUP0,<var Processor: Application> Core x Wakeup Register"

group d:0xD4282930++0x03
    line.long 0x00 "PMU_CAP_COREx_WAKEUP1,<var Processor: Application> Core x Wakeup Register"

group d:0xD4282934++0x03
    line.long 0x00 "PMU_CAP_COREx_WAKEUP2,<var Processor: Application> Core x Wakeup Register"

group d:0xD4282938++0x03
    line.long 0x00 "PMU_CAP_COREx_WAKEUP3,<var Processor: Application> Core x Wakeup Register"

group d:0xD4282B24++0x03
    line.long 0x00 "PMU_CAP_COREx_WAKEUP4,<var Processor: Application> Core x Wakeup Register"

group d:0xD4282B28++0x03
    line.long 0x00 "PMU_CAP_COREx_WAKEUP5,<var Processor: Application> Core x Wakeup Register"

group d:0xD4282B2C++0x03
    line.long 0x00 "PMU_CAP_COREx_WAKEUP6,<var Processor: Application> Core x Wakeup Register"

group d:0xD4282B30++0x03
    line.long 0x00 "PMU_CAP_COREx_WAKEUP7,<var Processor: Application> Core x Wakeup Register"

group d:0xD4282B60++0x03
    line.long 0x00 "PMU_CAP_COREx_WAKEUP8,<var Processor: Application> Core x Wakeup Register"

group d:0xD4282B64++0x03
    line.long 0x00 "PMU_CAP_COREx_WAKEUP9,<var Processor: Application> Core x Wakeup Register"
        bitfld.long 0x00 9. " WAKEUP_CORE9                    ,wakeup core9  if software writes 1 to this field, core 9 is woken up. writes of 0 to this bit and writes to this bit if core 9 is in c0 mode are ignored. this bit is cleared by pmu hardware when core3 exits c1/c2 mode." "0,1"
        bitfld.long 0x00 8. "         WAKEUP_CORE8                     ,wakeup core8  if software writes 1 to this field, core 8 is woken up. writes of 0 to this bit and writes to this bit if core 8 is in c0 mode are ignored. this bit is cleared by pmu hardware when core3 exits c1/c2 mode." "0,1"
        bitfld.long 0x00 7. "   WAKEUP_CORE7                         ,wakeup core7  if software writes 1 to this field, core 7 is woken up. writes of 0 to this bit and writes to this bit if core 7 is in c0 mode are ignored. this bit is cleared by pmu hardware when core3 exits c1/c2 mode." "0,1"
        bitfld.long 0x00 6. "   WAKEUP_CORE6                     ,wakeup core6  if software writes 1 to this field, core 6 is woken up. writes of 0 to this bit and writes to this bit if core 6 is in c0 mode are ignored. this bit is cleared by pmu hardware when core3 exits c1/c2 mode." "0,1"
        textline "                                      "
        bitfld.long 0x00 5. "WAKEUP_CORE5                    ,wakeup core5  if software writes 1 to this field, core 5 is woken up. writes of 0 to this bit and writes to this bit if core 5 is in c0 mode are ignored. this bit is cleared by pmu hardware when core3 exits c1/c2 mode." "0,1"
        bitfld.long 0x00 4. "         WAKEUP_CORE4                     ,wakeup core 4  if software writes 1 to this field, core 4 is woken up. writes of 0 to this bit and writes to this bit if core 4 is in c0 mode are ignored. this bit is cleared by pmu hardware when core3 exits c1/c2 mode." "0,1"
        bitfld.long 0x00 3. "   WAKEUP_CORE3                         ,wakeup core3  if software writes 1 to this field, core 3 is woken up. writes of 0 to this bit and writes to this bit if core 3 is in c0 mode are ignored. this bit is cleared by pmu hardware when core3 exits c1/c2 mode." "0,1"
        bitfld.long 0x00 2. "   WAKEUP_CORE2                     ,wakeup core2  if software writes 1 to this field, core 2 is woken up. writes of 0 to this bit and writes to this bit if core 2 is in c0 mode are ignored. this bit is cleared by pmu hardware when core3 exits c1/c2 mode." "0,1"
        textline "                                      "
        bitfld.long 0x00 1. "WAKEUP_CORE1                    ,wakeup core1  if software writes 1 to this field, core 1 is woken up. writes of 0 to this bit and writes to this bit if core 1 is in c0 mode are ignored. this bit is cleared by pmu hardware when core3 exits c1/c2 mode." "0,1"
        bitfld.long 0x00 0. "         WAKEUP_CORE0                     ,wakeup core 0  if software writes 1 to this field, core 0 is woken up. writes of 0 to this bit and writes to this bit if core 0 is in c0 mode are ignored. this bit is cleared by pmu hardware when core3 exits c1/c2 mode." "0,1"

group d:0xD4282940++0x03
    line.long 0x00 "PMU_DVC_DFC_DEBUG,PMU DVC and DFC Debug Register"
        bitfld.long 0x00 5. " GLB_INT_MASK_USE_OLD_LOGIC      ,ap global interrupt mask use old logic   0x1=use old logic" "0,1"
        bitfld.long 0x00 4. "         AP_HW_DVC_EN_FOR_FAST_WAKEUP     ,enable hw-dvc or not if  ap interrupt is already pending before ap low power entry  0x0 = ap low power mode will not trigger hw-dvc if  ap interrupt is already pending before ap low power entry   0x1 = ap low power mode will trigger hw-dvc even if  ap interrupt is already pending before ap low power entry" "0,1"
        bitfld.long 0x00 3. "   APSUB_DFC_CHECK_MASK                 ,dfc check mask in ap subsystem pmu state machine  0 = dfc status check enabled  1 = dfc status check masked" "0,1"
        bitfld.long 0x00 2. "   APSUB_DVC_CHECK_MASK             ,dvc check mask in ap subsystem pmu state machine  0 = dfc status check enabled  1 = dfc status check masked" "0,1"
        textline "                                      "
        bitfld.long 0x00 1. "CP_DVC_CHECK_MASK               ,dvc check mask in cp pmu state machine    0 = dfc status check enabled  1 = dfc status check masked" "0,1"
        bitfld.long 0x00 0. "         MP_DVC_CHECK_MASK                ,dvc check mask in dragon mp subsystem pmu state machine  0 = dfc status check enabled  1 = dfc status check masked" "0,1"

group d:0xD4282948++0x03
    line.long 0x00 "PMU_VSP_CLK_RES_CTRL,VSP Clock/Reset Control Register"
        bitfld.long 0x00 27. " VSP_HW_MODE                     ,vsp hardware on/off control mode  1 = hardware controls isp on/off procedure" "0,1"
        bitfld.long 0x00 26. "         VSP_SLEEP2                       ,vsp power switch sleep2" "0,1"
        bitfld.long 0x00 25. "   VSP_SLEEP1                           ,vsp power switch sleep1" "0,1"
        bitfld.long 0x00 24. "   VSP_ISOB                         ,vsp isolation cell enable" "0,1"
        textline "                                      "
        bitfld.long 0x00 22.--23. "XM4_OCEM_DIV                    ,xm4 ocem clock divide ratio" "0,1,2,3"
        bitfld.long 0x00 20.--21. "         XM4_IOP_DIV                      ,xm4 iop clock divide ratio" "0,1,2,3"
        bitfld.long 0x00 18.--19. "   XM4_EDAP_DIV                         ,xm4 edap clock divide ratio" "0,1,2,3"
        bitfld.long 0x00 17. "   AFBC_DEC_CLK_EN                  ,afbc decoder function clock enable  1 = clock enabled  0 = clock disabled" "0,1"
        textline "                                      "
        bitfld.long 0x00 16. "AFBC_ENC_CLK_EN                 ,afbc encoder function clock enable  1 = clock enabled  0 = clock disabled" "0,1"
        bitfld.long 0x00 15. "         VSP_CLK_FC_REQ                   ,vsp function clk fc request  1 = triggers a frequency change  this field is hardware cleared when the frequency change is done." "0,1"
        bitfld.long 0x00 14. "   XM4_OCEM_RSTN                        ,xm4 ocem clock reset  0 = reset" "0,1"
        bitfld.long 0x00 13. "   XM4_GLB_RSTN                     ,xm4 global clock reset  0 = reset" "0,1"
        textline "                                      "
        bitfld.long 0x00 12. "XM4_SYS_RSTN                    ,xm4 system clock reset  0 = reset" "0,1"
        bitfld.long 0x00 11. "         XM4_CORE_RSTN                    ,xm4 core clock reset  0 = reset" "0,1"
        bitfld.long 0x00 10. "   VSP_CLK_RSTN                         ,vsp function clock reset  0 = reset" "0,1"
        bitfld.long 0x00 8. "   VSP_CLK_EN                       ,vsp function clock enable  1 = clock enabled  0 = clock disabled" "0,1"
        textline "                                      "
        bitfld.long 0x00 3.--5. "VSP_CLK_SEL                     ,isp function clock source select  0x0 = 624mhz  0x1 = 499 mhz  0x2 = 832mhz  0x3 = pll3_div2  0x4 = pll3_div3  0x5 = pll3_div4  0x6 = pll2_div4  0x7 = pll4_div3" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 0.--2. "         VSP_CLK_DIV                      ,vsp function clock divide ratio  vsp_clk = vsp_clk_div / (this field +1)" "0,1,2,3,4,5,6,7"

group d:0xD428294C++0x03
    line.long 0x00 "PMU_AUDIO_CLK_RES_CTRL,Audio Clock Reset Enable Register"
        bitfld.long 0x00 31. " AUDIO_SD_STATUS                 ,audio sd domain status  1 audio pmu is  in power on status ;   0=audio pmu is power off status" "0,1"
        bitfld.long 0x00 30. "         AUDIO_FUSE_LOAD_START            ,audio fuse load start. note that when audio fuse loading finishes, this field is automatically cleared by hardware logic.  0x0 = don't trigger audio fuse loading or fuse loading has finished  0x1 = trigger audio fuse loading" "0,1"
        bitfld.long 0x00 29. "   AUDIO_FUSE_LOAD_MASK                 ,audio fuse load mask, only used when audio uses hw power mode  0x0 = no mask  0x1 = mask fuse load operation." "0,1"
        bitfld.long 0x00 28. "   AP_POWER_CTL_AUDIO_AUTHO         ,ap power control audio authority  0=ap  can control audio power now  1: ap can't control audio power" "0,1"
        textline "                                      "
        bitfld.long 0x00 27. "AUDIO_HW_MODE                   ,hardware control mode for audio power up and down" "0,1"
        bitfld.long 0x00 26. "         AUDIO_SLEEP2                     ,audio power switch sleep2" "0,1"
        bitfld.long 0x00 25. "   AUDIO_SLEEP1                         ,audio power switch sleep1" "0,1"
        bitfld.long 0x00 24. "   AUDIO_ISOB                       ,audio isolation control  0x0 = enable isolation (audio powr-down mode)  0x1 = disable isolation (audio active mode)" "0,1"
        textline "                                      "
        bitfld.long 0x00 23. "AUDIO_PWR_STATUS                ,power status for audio island   1  = audio island is power off   0 = audio island is power on" "0,1"
        bitfld.long 0x00 20.--22. "         AUDIO_APB_DIV                    ,clock divider for apb clock in audio island apb_clk =aud_clk/(audio_apb_div+1)" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 16.--17. "   AUDIO_AXI_DIV                        ,clock divider for apb clock in audio island axi_clk = aud_clk/(audio_axi_div+1)" "0,1,2,3"
        bitfld.long 0x00 15. "   AUDIO_FC_REQ                     ,audio island main clock fc request  1 = triggers a frequency change  this field is hardware cleared when the frequency change is done." "0,1"
        textline "                                      "
        bitfld.long 0x00 12. "AUDIO_CLK_EN                    ,audio clcok enable  1 = enable" "0,1"
        bitfld.long 0x00 10. "         AUDIO_HW_CKG_BYPASS              ,audio always on domain reset, this bit should be always set to 1 after the silicon power up" "0,1"
        bitfld.long 0x00 7.--9. "   AUDIO_CLK_SEL                        ,clock sel control for audio main clock   0= pll 312m   1= pll 416m   2= pll 499m   3 = pll7_div2   4 = pll7_div3   5 = pll7_div4   6 = pll7_div5" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 4.--6. "   AUDIO_CLK_DIV                    ,clock divider control for audio main clock audio main clk = selected clk/(audio_clk_div+1)" "0,1,2,3,4,5,6,7"
        textline "                                      "
        bitfld.long 0x00 3. "AUDIO_APMU_RESET                ,audio apmu reset, this bit should be always set to 1 after the silicon power up" "0,1"
        bitfld.long 0x00 2. "         TL421_EXT_CORE_RESET             ,tl421 ext_core_rst    0 = reset   1 = release reset" "0,1"
        bitfld.long 0x00 1. "   TL421_ORESET                         ,tl421 orst    0 = reset   1 = release reset" "0,1"
        bitfld.long 0x00 0. "   AUDIO_SYS_RESET                  ,audio island system reset   0 = reset   1 = release reset" "0,1"

group d:0xD4282980++0x03
    line.long 0x00 "DFC_AP,<var Processor: Application MP> DCLK Dynamic Freq Change Control Register"
        bitfld.long 0x00 1.--3. " PM_FL1417                       ,dclk freq level in active mode  required freq level by <var processor: application mp> in active mode" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 0. "         PM_DFC_REQ1418                   ,dclk hfc request in active mode  dclk hfc request for <var processor: application mp> in active mode  software can write 1 to this bit to trigger a dclk hfc request. hardware will automatically clear this bit when hfc is done. writes of 0 to this bit are ignored." "0,1"

group d:0xD4282988++0x03
    line.long 0x00 "DFC_STATUS,DCLK Hardware Freq Change Status Register"
        bitfld.long 0x00 7.--10. " PM_DFC_CAUSE1426                ,dclk dfc cause  this field is the cause of the current ongoing dfc. it is only valid when the <dclk_dfc_status> field is 1.  0x1 = <var processor: application mp> triggered dfc  0x2 = <var processor: comm> triggered dfc in active mode  0x4 = msa trigged dfc in active mode    0x8 = gnss triggered dfc in active mode    others = low power mode entry/exit triggered dfc" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 4.--6. "        PM_TFL1427                       ,target freq level of dclk" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 1.--3. "   PM_CFL1428                           ,current freq level of dclk" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 0. "   PM_DFC_STATUS1429                ,dclk dfc status  the dclk dfc may be triggered in active state or <var processor: comm>/msa entering low power mode.  0 = there is no dfc or dfc has finished  1 = dfc is in progress" "0,1"

group d:0xD4282990++0x03
    line.long 0x00 "DFC_LEVEL0,DCLK Freq Level 0 Control Register"
        bitfld.long 0x00 16.--19. " VL1437                          ,required voltage level" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 7.--11. "        MC_TABLE_NUM1439                 ,memory controller table number  valid values are from 0x1 to 0xe. this is used for table-based ddr clock freq change." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"
        bitfld.long 0x00 4.--6. "  DDR_CLK_DIV1440                      ,clock divider selection for dclk  dclk = <dclk_clock_selection> / (this field +1)" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 3. "   4X_CLK_MODE1441                  ,enable 4:1 dclk mode  0x0 = 2:1 dclk mode  0x1 = 4:1 dclk mode" "0,1"
        textline "                                      "
        bitfld.long 0x00 0.--2. "DCLKSEL1442                     ,ddr clock selection                7=pll3 div2                               6=pll5 div2                              0x5 = pll4 div2                             0x4 = pll2 div2                          0x3 = pll6 div1                          0x2 = pll2 div1                     0x1= pll1 832 mhz                          0x0 = pll1 624 mhz" "0,1,2,3,4,5,6,7"

group d:0xD4282994++0x03
    line.long 0x00 "DFC_LEVEL1,DCLK Freq Level 1 Control Register"
        bitfld.long 0x00 16.--19. " VL1450                          ,required voltage level" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 7.--11. "        MC_TABLE_NUM1452                 ,memory controller table number  valid values are from 0x1 to 0xe. this is used for table-based ddr clock freq change." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"
        bitfld.long 0x00 4.--6. "  DDR_CLK_DIV1453                      ,clock divider selection for dclk  dclk = <dclk_clock_selection> / (this field +1)" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 3. "   4X_CLK_MODE1454                  ,enable 4:1 dclk mode  0x0 = 2:1 dclk mode  0x1 = 4:1 dclk mode" "0,1"
        textline "                                      "
        bitfld.long 0x00 0.--2. "DCLKSEL1455                     ,ddr clock selection                7=pll3 div2                               6=pll5 div2                              0x5 = pll4 div2                             0x4 = pll2 div2                          0x3 = pll6 div1                          0x2 = pll2 div1                     0x1= pll1 832 mhz                          0x0 = pll1 624 mhz" "0,1,2,3,4,5,6,7"

group d:0xD4282998++0x03
    line.long 0x00 "DFC_LEVEL2,DCLK Freq Level 2 Control Register"
        bitfld.long 0x00 16.--19. " VL1463                          ,required voltage level" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 7.--11. "        MC_TABLE_NUM1465                 ,memory controller table number  valid values are from 0x1 to 0xe. this is used for table-based ddr clock freq change." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"
        bitfld.long 0x00 4.--6. "  DDR_CLK_DIV1466                      ,clock divider selection for dclk  dclk = <dclk_clock_selection> / (this field +1)" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 3. "   4X_CLK_MODE1467                  ,enable 4:1 dclk mode  0x0 = 2:1 dclk mode  0x1 = 4:1 dclk mode" "0,1"
        textline "                                      "
        bitfld.long 0x00 0.--2. "DCLKSEL1468                     ,ddr clock selection                7=pll3 div2                               6=pll5 div2                              0x5 = pll4 div2                             0x4 = pll2 div2                          0x3 = pll6 div1                          0x2 = pll2 div1                     0x1= pll1 832 mhz                          0x0 = pll1 624 mhz" "0,1,2,3,4,5,6,7"

group d:0xD428299C++0x03
    line.long 0x00 "DFC_LEVEL3,DCLK Freq Level 3 Control Register"
        bitfld.long 0x00 16.--19. " VL1476                          ,required voltage level" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 7.--11. "        MC_TABLE_NUM1478                 ,memory controller table number  valid values are from 0x1 to 0xe. this is used for table-based ddr clock freq change." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"
        bitfld.long 0x00 4.--6. "  DDR_CLK_DIV1479                      ,clock divider selection for dclk  dclk = <dclk_clock_selection> / (this field +1)" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 3. "   4X_CLK_MODE1480                  ,enable 4:1 dclk mode  0x0 = 2:1 dclk mode  0x1 = 4:1 dclk mode" "0,1"
        textline "                                      "
        bitfld.long 0x00 0.--2. "DCLKSEL1481                     ,ddr clock selection                7=pll3 div2                               6=pll5 div2                              0x5 = pll4 div2                             0x4 = pll2 div2                          0x3 = pll6 div1                          0x2 = pll2 div1                     0x1= pll1 832 mhz                          0x0 = pll1 624 mhz" "0,1,2,3,4,5,6,7"

group d:0xD42829A0++0x03
    line.long 0x00 "DFC_LEVEL4,DCLK Freq Level 4 Control Register"
        bitfld.long 0x00 16.--19. " VL1489                          ,required voltage level" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 7.--11. "        MC_TABLE_NUM1491                 ,memory controller table number  valid values are from 0x1 to 0xe. this is used for table-based ddr clock freq change." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"
        bitfld.long 0x00 4.--6. "  DDR_CLK_DIV1492                      ,ddr clock selection  0x7 = pll3 div2   0x6 = pll5 div2   0x4 = pll2 div2   0x5 = pll4 div2   0x0 = pll1 624 mhz  0x1 = pll1 832 mhz" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 3. "   4X_CLK_MODE1493                  ,enable 4:1 dclk mode  0x0 = 2:1 dclk mode  0x1 = 4:1 dclk mode" "0,1"
        textline "                                      "
        bitfld.long 0x00 0.--2. "DCLKSEL1494                     ,ddr clock selection                7=pll3 div2                               6=pll5 div2                              0x5 = pll4 div2                             0x4 = pll2 div2                          0x3 = pll6 div1                          0x2 = pll2 div1                     0x1= pll1 832 mhz                          0x0 = pll1 624 mhz" "0,1,2,3,4,5,6,7"

group d:0xD42829A4++0x03
    line.long 0x00 "DFC_LEVEL5,DCLK Freq Level 5 Control Register"
        bitfld.long 0x00 16.--19. " VL1502                          ,required voltage level" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 7.--11. "        MC_TABLE_NUM1504                 ,memory controller table number  valid values are from 0x1 to 0xe. this is used for table-based ddr clock freq change." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"
        bitfld.long 0x00 4.--6. "  DDR_CLK_DIV1505                      ,clock divider selection for dclk  dclk = <dclk_clock_selection> / (this field +1)" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 3. "   4X_CLK_MODE1506                  ,enable 4:1 dclk mode  0x0 = 2:1 dclk mode  0x1 = 4:1 dclk mode" "0,1"
        textline "                                      "
        bitfld.long 0x00 0.--2. "DCLKSEL1507                     ,ddr clock selection                7=pll3 div2                               6=pll5 div2                              0x5 = pll4 div2                             0x4 = pll2 div2                          0x3 = pll6 div1                          0x2 = pll2 div1                     0x1= pll1 832 mhz                          0x0 = pll1 624 mhz" "0,1,2,3,4,5,6,7"

group d:0xD42829A8++0x03
    line.long 0x00 "DFC_LEVEL6,DCLK Freq Level 6 Control Register"
        bitfld.long 0x00 16.--19. " VL1515                          ,required voltage level" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 7.--11. "        MC_TABLE_NUM1517                 ,memory controller table number  valid values are from 0x1 to 0xe. this is used for table-based ddr clock freq change." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"
        bitfld.long 0x00 4.--6. "  DDR_CLK_DIV1518                      ,clock divider selection for dclk  dclk = <dclk_clock_selection> / (this field +1)" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 3. "   4X_CLK_MODE1519                  ,enable 4:1 dclk mode  0x0 = 2:1 dclk mode  0x1 = 4:1 dclk mode" "0,1"
        textline "                                      "
        bitfld.long 0x00 0.--2. "DCLKSEL1520                     ,ddr clock selection                7=pll3 div2                               6=pll5 div2                              0x5 = pll4 div2                             0x4 = pll2 div2                          0x3 = pll6 div1                          0x2 = pll2 div1                     0x1= pll1 832 mhz                          0x0 = pll1 624 mhz" "0,1,2,3,4,5,6,7"

group d:0xD42829AC++0x03
    line.long 0x00 "DFC_LEVEL7,DCLK Freq Level 7 Control Register"
        bitfld.long 0x00 16.--19. " VL1528                          ,required voltage level" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 7.--11. "        MC_TABLE_NUM1530                 ,memory controller table number  valid values are from 0x1 to 0xe. this is used for table-based ddr clock freq change." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"
        bitfld.long 0x00 4.--6. "  DDR_CLK_DIV1531                      ,clock divider selection for dclk  dclk = <dclk_clock_selection> / (this field +1)" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 3. "   4X_CLK_MODE1532                  ,enable 4:1 dclk mode  0x0 = 2:1 dclk mode  0x1 = 4:1 dclk mode" "0,1"
        textline "                                      "
        bitfld.long 0x00 0.--2. "DCLKSEL1533                     ,ddr clock selection                7=pll3 div2                               6=pll5 div2                              0x5 = pll4 div2                             0x4 = pll2 div2                          0x3 = pll6 div1                          0x2 = pll2 div1                     0x1= pll1 832 mhz                          0x0 = pll1 624 mhz" "0,1,2,3,4,5,6,7"

group d:0xD42829B0++0x03
    line.long 0x00 "PMU_DEBUG2_REG,PMU Debug2 Register"
        hexmask.long.word 0x00 16.--31. 1. " GNSS_VOTING_MASK                ,gnss voting mask  0x0 = no mask  0x1 = mask"
        bitfld.long 0x00 12.--13. "      CSYSFREQUENCY_DDRC               ,fp to ddrc lp/ffc protocol signal" "0,1,2,3"
        bitfld.long 0x00 11. "   CSYSACK_DDRC_CH1                     ,ack from ddrc ch1 lp/ffc protocol signal" "0,1"
        bitfld.long 0x00 10. "   CSYSACK_DDRC                     ,ack from ddrc ch0 lp/ffc protocol signal" "0,1"
        textline "                                      "
        bitfld.long 0x00 9. "CSYSMODE_DDRC                   ,csysmode to ddrc lp/ffc protocol signal" "0,1"
        bitfld.long 0x00 8. "         CSYSREQ_DDRC                     ,csysreq to ddrc lp/ffc protocol signal" "0,1"
        bitfld.long 0x00 2. "   DCLK_MSTR_GATE_OK_CHECK_ACLK         ,ap clkgen mask dclk_mstr_gate_ok check  1 = no check  0 = check" "0,1"
        bitfld.long 0x00 1. "   DCLK_MSTR_GATE_OK_CHECK_CP       ,ap clkgen mask dclk_mstr_gate_ok check  1 = no check  0 = check" "0,1"
        textline "                                      "
        bitfld.long 0x00 0. "DCLK_MSTR_GATE_OK_CHECK_AP      ,ap clkgen mask dclk_mstr_gate_ok check  1 = no check  0 = check" "0,1"

group d:0xD42829B8++0x03
    line.long 0x00 "GNSS_WAKEUP_CTRL,GNSS Wakeup Control Register"
        bitfld.long 0x00 2. " GNSS_WAKEUP_STATUS              ,gnss wakeup signal status  this field is used to sample the wakeup signal from the gnss module.  0x0 = wakeup signal inactive  0x1 = wakeup active" "0,1"
        bitfld.long 0x00 1. "         GNSS_WAKEUP_CLR                  ,gnss wakeup clear  the <var processor: application mp> acknowledges the wake-up event from gps.  it can only be asserted when the wake-up event from the gps is active. it is cleared by hardware when the gps get an acknowledge from the <var processor: ap" "0,1"
        bitfld.long 0x00 0. "   GNSS_WAKEUP_EN                       ,gnss wakeup enable  0x0 = disable gnss wakeup  0x1 = enable gnss wakeup chip" "0,1"

group d:0xD42829BC++0x03
    line.long 0x00 "PMU_CCIC2_CLK_GATE_CTRL,CMOS Camera Interface Controller 2 Dynamic Clock Gate Control Register"
        bitfld.long 0x00 30.--31. " CCIC2_GATE_CSI_CLK_STATIC       ,ccic2 csi static clock gate control  0x0 =stop clock   0x1 = stop clock   0x2 = stop clock  0x3 = free running" "0,1,2,3"
        bitfld.long 0x00 28.--29. "         CCIC2_GATE_CLK4X_STATIC          ,ccic2 clk4x static clock gate control  0x0 =stop clock   0x1 = stop clock   0x2 = stop clock  0x3 = free running" "0,1,2,3"
        bitfld.long 0x00 26.--27. "   CCIC2_GATE_CLK1X_STATIC              ,ccic2 clk1x static clock gate control  0x0 =stop clock   0x1 = stop clock   0x2 = stop clock  0x3 = free running" "0,1,2,3"
        bitfld.long 0x00 24.--25. "   CCIC2_GATE_HCLK_STATIC           ,ccic2 hclk static clock gate control  0x0 =stop clock   0x1 = stop clock   0x2 = stop clock  0x3 = free running" "0,1,2,3"
        textline "                                      "
        bitfld.long 0x00 22.--23. "CCIC2_GATE_ACLK_STATIC          ,ccic2 aclk static clock gate control  0x0 =stop clock   0x1 = stop clock   0x2 = stop clock  0x3 = free running" "0,1,2,3"
        bitfld.long 0x00 20.--21. "         CCIC2_GATE_ISP_PIP2_CLK1X_STATIC ,isp pipe2 clk1x static clock gate control  0x0 =stop clock   0x1 = stop clock   0x2 = stop clock  0x3 = free running" "0,1,2,3"
        bitfld.long 0x00 18.--19. "   CCIC2_GATE_QOS_HCLK_STATIC           ,axi4to1qos hclk static clock gate contro  0x0 =stop clock   0x1 = stop clock   0x2 = stop clock  0x3 = free running" "0,1,2,3"
        bitfld.long 0x00 16.--17. "   CCIC2_GATE_DESC_HCLK_STATIC      ,sc2_desc_top hclk static clock gate control  0x0 =stop clock   0x1 = stop clock   0x2 = stop clock  0x3 = free running" "0,1,2,3"
        textline "                                      "
        bitfld.long 0x00 10.--11. "CCIC2_GATE_LANE1_CLK_DYNAMIC    ,ccic2 csi lane 1 clock dynamic clock gate control  0x0 = hardware dynamic control  0x1 = hardware dynamic control  0x2 = stop clock  0x3 = free running" "0,1,2,3"
        bitfld.long 0x00 8.--9. "         CCIC2_GATE_LANE0_CLK_DYNAMIC     ,ccic2 csi lane 0 clock dynamic clock gate control  0x0 = hardware dynamic control  0x1 = hardware dynamic control  0x2 = stop clock  0x3 = free running" "0,1,2,3"
        bitfld.long 0x00 6.--7. "   CCIC2_GATE_CSI_CLK_DYNAMIC           ,ccic2 csi clock dynamic clock gate control  0x0 = hardware dynamic control  0x1 = hardware dynamic control  0x2 = stop clock  0x3 = free running" "0,1,2,3"
        bitfld.long 0x00 4.--5. "   CCIC2_GATE_AHB_CLK_DYNAMIC       ,ccic2 ahb clock dynamic clock gate control  0x0 = hardware dynamic control  0x1 = hardware dynamic control  0x2 = stop clock  0x3 = free running" "0,1,2,3"
        textline "                                      "
        bitfld.long 0x00 2.--3. "CCIC2_GATE_PIP_CLK_DYNAMIC      ,ccic2 pipeline clock dynamic clock gate control  0x0 = hardware dynamic control  0x1 = hardware dynamic control  0x2 = stop clock  0x3 = free running" "0,1,2,3"
        bitfld.long 0x00 0.--1. "         CCIC2_GATE__AXI_CLK_DYNAMIC      ,ccic2 axi clock dynamic clock gate control  0x0 = hardware dynamic control  0x1 = hardware dynamic control  0x2 = stop clock  0x3 = free running" "0,1,2,3"

group d:0xD42829C0++0x03
    line.long 0x00 "PMU_GT_WAKEUP_C0_CTRL,Generic Timer Wakeup Core0 Control Register"
        bitfld.long 0x00 8. " GT_WAKEUP_C0_STATUS             ,generic timer wakeup core0 status. read  0x0 = no wakeup interrupt occur  0x1 = wakeup interrrupt occur write  0x0 = clear wakeup interrupt status   0x1 = no effect" "0,1"
        bitfld.long 0x00 0. "         GT_WAKEUP_C0_ENB                 ,generic timer wakeup core0 enable, when core0 enter c2  0x0 = not enable  0x1 = enable" "0,1"

group d:0xD42829C4++0x03
    line.long 0x00 "PMU_GT_WAKEUP_C1_CTRL,Generic Timer Wakeup Core1 Control Register"
        bitfld.long 0x00 8. " GT_WAKEUP_C1_STATUS             ,generic timer wakeup core1 status. read  0x0 = no wakeup interrupt occur  0x1 = wakeup interrrupt occur write  0x0 = clear wakeup interrupt status   0x1 = no effect" "0,1"
        bitfld.long 0x00 0. "         GT_WAKEUP_C1_ENB                 ,generic timer wakeup core1 enable, when core1 enter c2  0x0 = not enable  0x1 = enable" "0,1"

group d:0xD42829C8++0x03
    line.long 0x00 "PMU_GT_WAKEUP_C2_CTRL,Generic Timer Wakeup Core2 Control Register"
        bitfld.long 0x00 8. " GT_WAKEUP_C2_STATUS             ,generic timer wakeup core2 status. read  0x0 = no wakeup interrupt occur  0x1 = wakeup interrrupt occur write  0x0 = clear wakeup interrupt status   0x1 = no effect" "0,1"
        bitfld.long 0x00 0. "         GT_WAKEUP_C2_ENB                 ,generic timer wakeup core2 enable, when core2 enter c2  0x0 = not enable  0x1 = enable" "0,1"

group d:0xD42829CC++0x03
    line.long 0x00 "PMU_GT_WAKEUP_C3_CTRL,Generic Timer Wakeup Core3 Control Register"
        bitfld.long 0x00 8. " GT_WAKEUP_C3_STATUS             ,generic timer wakeup core3 status. read  0x0 = no wakeup interrupt occur  0x1 = wakeup interrrupt occur write  0x0 = clear wakeup interrupt status   0x1 = no effect" "0,1"
        bitfld.long 0x00 0. "         GT_WAKEUP_C3_ENB                 ,generic timer wakeup core3 enable, when core3 enter c2  0x0 = not enable  0x1 = enable" "0,1"

group d:0xD42829D0++0x03
    line.long 0x00 "PMU_GT_WAKEUP_C0_ML,Generic Timer Wakeup Core0 Match Low Register"
        hexmask.long 0x00 0.--31. 1. " GT_WAKEUP_C0_ML                 ,generic timer wakeup core0 match low register"

group d:0xD42829D4++0x03
    line.long 0x00 "PMU_GT_WAKEUP_C0_MH,Generic Timer Wakeup Core0 Match High Register"
        hexmask.long 0x00 0.--31. 1. " GT_WAKEUP_C0_MH                 ,generic timer wakeup core0 match high register"

group d:0xD42829D8++0x03
    line.long 0x00 "PMU_GT_WAKEUP_C1_ML,Generic Timer Wakeup Core1 Match Low Register"
        hexmask.long 0x00 0.--31. 1. " GT_WAKEUP_C1_ML                 ,generic timer wakeup core1 match low register"

group d:0xD42829DC++0x03
    line.long 0x00 "PMU_GT_WAKEUP_C1_MH,Generic Timer Wakeup Core1 Match High Register"
        hexmask.long 0x00 0.--31. 1. " GT_WAKEUP_C1_MH                 ,generic timer wakeup core1 match high register"

group d:0xD42829E0++0x03
    line.long 0x00 "PMU_GT_WAKEUP_C2_ML,Generic Timer Wakeup Core2 Match Low Register"
        hexmask.long 0x00 0.--31. 1. " GT_WAKEUP_C2_ML                 ,generic timer wakeup core2 match low register"

group d:0xD42829E4++0x03
    line.long 0x00 "PMU_GT_WAKEUP_C2_MH,Generic Timer Wakeup Core2 Match High Register"
        hexmask.long 0x00 0.--31. 1. " GT_WAKEUP_C2_MH                 ,generic timer wakeup core2 match high register"

group d:0xD42829E8++0x03
    line.long 0x00 "PMU_GT_WAKEUP_C3_ML,Generic Timer Wakeup Core3 Match Low Register"
        hexmask.long 0x00 0.--31. 1. " GT_WAKEUP_C3_ML                 ,generic timer wakeup core3 match low register"

group d:0xD42829EC++0x03
    line.long 0x00 "PMU_GT_WAKEUP_C3_MH,Generic Timer Wakeup Core3 Match High Register"
        hexmask.long 0x00 0.--31. 1. " GT_WAKEUP_C3_MH                 ,generic timer wakeup core3 match high register"

group d:0xD4282B34++0x03
    line.long 0x00 "FC_LOCK_STATUS,Frequency change Lock Status Register"
        bitfld.long 0x00 1. " CP_RD_STATUS1685                ,cp read status   0x0=cp does not get the fc lock.  0x1=cp get the fc lock ." "0,1"
        bitfld.long 0x00 0. "         AP_RD_STATUS1686                 ,ap read status   0x0=ap does not get the fc lock.  0x1=ap get the fc lock ." "0,1"

group d:0xD4282A08++0x03
    line.long 0x00 "PMU_GT_WAKEUP_C4_CTRL,Generic Timer Wakeup Core4 Control Register"
        bitfld.long 0x00 8. " GT_WAKEUP_C4_STATUS             ,generic timer wakeup core4 status. read  0x0 = no wakeup interrupt occur  0x1 = wakeup interrrupt occur write  0x0 = clear wakeup interrupt status   0x1 = no effect" "0,1"
        bitfld.long 0x00 0. "         GT_WAKEUP_C4_ENB                 ,generic timer wakeup core4 enable, when core3 enter c2  0x0 = not enable  0x1 = enable" "0,1"

group d:0xD4282A0C++0x03
    line.long 0x00 "PMU_GT_WAKEUP_C5_CTRL,Generic Timer Wakeup Core5 Control Register"
        bitfld.long 0x00 8. " GT_WAKEUP_C5_STATUS             ,generic timer wakeup core5 status. read  0x0 = no wakeup interrupt occur  0x1 = wakeup interrrupt occur write  0x0 = clear wakeup interrupt status   0x1 = no effect" "0,1"
        bitfld.long 0x00 0. "         GT_WAKEUP_C5_ENB                 ,generic timer wakeup core5 enable, when core3 enter c2  0x0 = not enable  0x1 = enable" "0,1"

group d:0xD4282A10++0x03
    line.long 0x00 "PMU_GT_WAKEUP_C6_CTRL,Generic Timer Wakeup Core6 Control Register"
        bitfld.long 0x00 8. " GT_WAKEUP_C6_STATUS             ,generic timer wakeup core6 status. read  0x0 = no wakeup interrupt occur  0x1 = wakeup interrrupt occur write  0x0 = clear wakeup interrupt status   0x1 = no effect" "0,1"
        bitfld.long 0x00 0. "         GT_WAKEUP_C6_ENB                 ,generic timer wakeup core6 enable, when core3 enter c2  0x0 = not enable  0x1 = enable" "0,1"

group d:0xD4282A14++0x03
    line.long 0x00 "PMU_GT_WAKEUP_C7_CTRL,Generic Timer Wakeup Core7 Control Register"
        bitfld.long 0x00 8. " GT_WAKEUP_C7_STATUS             ,generic timer wakeup core7 status. read  0x0 = no wakeup interrupt occur  0x1 = wakeup interrrupt occur write  0x0 = clear wakeup interrupt status   0x1 = no effect" "0,1"
        bitfld.long 0x00 0. "         GT_WAKEUP_C7_ENB                 ,generic timer wakeup core7 enable, when core3 enter c2  0x0 = not enable  0x1 = enable" "0,1"

group d:0xD4282A18++0x03
    line.long 0x00 "PMU_GT_WAKEUP_C4_ML,Generic Timer Wakeup Core4 Match Low Register"
        hexmask.long 0x00 0.--31. 1. " GT_WAKEUP_C4_ML                 ,generic timer wakeup core4 match low register"

group d:0xD4282A1C++0x03
    line.long 0x00 "PMU_GT_WAKEUP_C4_MH,Generic Timer Wakeup Core4 Match High Register"
        hexmask.long 0x00 0.--31. 1. " GT_WAKEUP_C4_MH                 ,generic timer wakeup core4 match high register"

group d:0xD4282A20++0x03
    line.long 0x00 "PMU_GT_WAKEUP_C5_ML,Generic Timer Wakeup Core5 Match Low Register"
        hexmask.long 0x00 0.--31. 1. " GT_WAKEUP_C5_ML                 ,generic timer wakeup core5 match low register"

group d:0xD4282A24++0x03
    line.long 0x00 "PMU_GT_WAKEUP_C5_MH,Generic Timer Wakeup Core5 Match High Register"
        hexmask.long 0x00 0.--31. 1. " GT_WAKEUP_C5_MH                 ,generic timer wakeup core5 match high register"

group d:0xD4282A28++0x03
    line.long 0x00 "PMU_GT_WAKEUP_C6_ML,Generic Timer Wakeup Core6 Match Low Register"
        hexmask.long 0x00 0.--31. 1. " GT_WAKEUP_C6_ML                 ,generic timer wakeup core6 match low register"

group d:0xD4282A2C++0x03
    line.long 0x00 "PMU_GT_WAKEUP_C6_MH,Generic Timer Wakeup Core6 Match High Register"
        hexmask.long 0x00 0.--31. 1. " GT_WAKEUP_C6_MH                 ,generic timer wakeup core6 match high register"

group d:0xD4282A30++0x03
    line.long 0x00 "PMU_GT_WAKEUP_C7_ML,Generic Timer Wakeup Core7 Match Low Register"
        hexmask.long 0x00 0.--31. 1. " GT_WAKEUP_C7_ML                 ,generic timer wakeup core7 match low register"

group d:0xD4282A34++0x03
    line.long 0x00 "PMU_GT_WAKEUP_C7_MH,Generic Timer Wakeup Core7 Match High Register"
        hexmask.long 0x00 0.--31. 1. " GT_WAKEUP_C7_MH                 ,generic timer wakeup core7 match high register"

group d:0xD4282A38++0x03
    line.long 0x00 "PMU_GT_WAKEUP_C8_CTRL,Generic Timer Wakeup Core8 Control Register"
        bitfld.long 0x00 8. " GT_WAKEUP_C8_STATUS             ,generic timer wakeup core8 status. read  0x0 = no wakeup interrupt occur  0x1 = wakeup interrrupt occur write  0x0 = clear wakeup interrupt status   0x1 = no effect" "0,1"
        bitfld.long 0x00 0. "         GT_WAKEUP_C8_ENB                 ,generic timer wakeup core8 enable, when core3 enter c2  0x0 = not enable  0x1 = enable" "0,1"

group d:0xD4282A3C++0x03
    line.long 0x00 "PMU_GT_WAKEUP_C9_CTRL,Generic Timer Wakeup Core9 Control Register"
        bitfld.long 0x00 8. " GT_WAKEUP_C9_STATUS             ,generic timer wakeup core9 status. read  0x0 = no wakeup interrupt occur  0x1 = wakeup interrrupt occur write  0x0 = clear wakeup interrupt status   0x1 = no effect" "0,1"
        bitfld.long 0x00 0. "         GT_WAKEUP_C9_ENB                 ,generic timer wakeup core9 enable, when core3 enter c2  0x0 = not enable  0x1 = enable" "0,1"

group d:0xD4282A48++0x03
    line.long 0x00 "PMU_GT_WAKEUP_C8_ML,Generic Timer Wakeup Core8 Match Low Register"
        hexmask.long 0x00 0.--31. 1. " GT_WAKEUP_C8_ML                 ,generic timer wakeup core8 match low register"

group d:0xD4282A4C++0x03
    line.long 0x00 "PMU_GT_WAKEUP_C8_MH,Generic Timer Wakeup Core8 Match High Register"
        hexmask.long 0x00 0.--31. 1. " GT_WAKEUP_C8_MH                 ,generic timer wakeup core8 match high register"

group d:0xD4282A50++0x03
    line.long 0x00 "PMU_GT_WAKEUP_C9_ML,Generic Timer Wakeup Core9 Match Low Register"
        hexmask.long 0x00 0.--31. 1. " GT_WAKEUP_C9_ML                 ,generic timer wakeup core9 match low register"

group d:0xD4282A54++0x03
    line.long 0x00 "PMU_GT_WAKEUP_C9_MH,Generic Timer Wakeup Core9 Match High Register"
        hexmask.long 0x00 0.--31. 1. " GT_WAKEUP_C9_MH                 ,generic timer wakeup core9 match high register"

group d:0xD4282B14++0x03
    line.long 0x00 "PMU_C1_CAPMP_IDLE_CFGx0,Cluster1 <var Processor: Application MP> Idle Configuration Register for Core x"

group d:0xD4282B18++0x03
    line.long 0x00 "PMU_C1_CAPMP_IDLE_CFGx1,Cluster1 <var Processor: Application MP> Idle Configuration Register for Core x"

group d:0xD4282B1C++0x03
    line.long 0x00 "PMU_C1_CAPMP_IDLE_CFGx2,Cluster1 <var Processor: Application MP> Idle Configuration Register for Core x"

group d:0xD4282B20++0x03
    line.long 0x00 "PMU_C1_CAPMP_IDLE_CFGx3,Cluster1 <var Processor: Application MP> Idle Configuration Register for Core x"
        bitfld.long 0x00 19. " DIS_MP_L2_SLP1839               ,disable <var processor: application mp> l2 power switch  this field is used to disable the <var processor: application mp> l2 power switch sleep power down during <var processor: application mp> power down mode.  1 = disable <var processor: application" "0,1"
        bitfld.long 0x00 18. "         DIS_MP_SLP1840                   ,disable <var processor: application mp> power switch  this field is used to disable the <var processor: application mp> power switch sleep power down during mp subsystem power down mode.  1 = disable mp power switch sleep" "0,1"
        bitfld.long 0x00 16. "   MP_L2_PWR_OFF1842                    ,frc l2 sram off  1 = l2 cache power is off" "0,1"
        bitfld.long 0x00 13. "   L2_HW_CACHE_FLUSH_EN1844         ,l2 hardware cache flush enable  0x1= enable" "0,1"
        textline "                                      "
        bitfld.long 0x00 12. "MASK_SRAM_REPAIR_DONE_CHECK1845 ,mask sram repair done check  1 = mask sram repair done check" "0,1"
        bitfld.long 0x00 11. "         MASK_CLK_OFF_CHECK1846           ,mask <var processor: application mp> clock off state check  this field is used to mask the <var processor: application mp> clock off check during the mp idle process." "0,1"
        bitfld.long 0x00 10. "   MASK_CLK_STBL_CHECK1847              ,mask mp clock stbl state check  this field is used to mask the mp clock stable check during mp wakeup." "0,1"
        bitfld.long 0x00 9. "   MASK_JTAG_IDLE_CHECK1848         ,mask jtag idle state check  this field is used to mask the jtag idle check during <var processor: application mp> idle entry.  1 = mask jtag idle check" "0,1"
        textline "                                      "
        bitfld.long 0x00 8. "MASK_IDLE_CHECK1849             ,mask <var processor: application mp> idle state check  debug only - it should be 0 during normal operation  1 = status check masked  0 = status check not masked" "0,1"
        bitfld.long 0x00 7. "         ACINACTM_HW_CTRL1850             ,acinactm hardware control   0x0=low power state machine does not control acinactm port.   0x1= low power state machine will control acinactm port of <var processor: application mp>.  when m2/m1 low power mode is entered, acinactm port will be high" "0,1"
        bitfld.long 0x00 5. "   DIS_MC_SW_REQ1852                    ,disable memory controller software req  this field is used to disable the memory controller entry to idle mode using the memory controller sleep request bits. the memory controller will always enter into idle mode based upon the hardware state machine re" "0,1"
        bitfld.long 0x00 4. "   MP_WAKE_MC_EN1853                ,<var processor: application mp> wake mc enable  wake up the memory controller when the <var processor: application mp> wakes up from idle mode. the memory controller will be woken up before the interrupt to the core is released.  0 = memory controller w" "0,1"
        textline "                                      "
        bitfld.long 0x00 3. "MP_SCU_SRAM_PWRDWN1854          ,not used. scu sram does not support retention" "0,1"
        bitfld.long 0x00 3. "         PM_1855                          ,reserved for future use" "0,1"
        bitfld.long 0x00 2. "   L2_SRAM_PWRDWN1856                   ,l2 cache sram power down  this field does not take effect if mp_pwrdwn is 0.  1 = when <var processor: application mp> is idle, l2 sram power will be off  0 = when <var processor: application mp> is idle, l2 sram is in retention mode" "0,1"
        bitfld.long 0x00 1. "   MP_PWRDWN1857                    ,<var processor: application mp> power down  this field does not take effect if mp_idle is 0.  1 = when <var processor: application mp> is idle, <var processor: application mp> will go into deep sleep mode and <var processor: application mp> logic will b" "0,1"
        textline "                                      "
        bitfld.long 0x00 0. "MP_IDLE1858                     ,<var processor: application mp> idle  1 = when <var processor: application mp> is idle, <var processor: application mp> clocks will be gated externally" "0,1"

group d:0xD4282B00++0x03
    line.long 0x00 "PMU_CCI_CLK_CTRL,CCI550 Clock Control Register"
        hexmask.long.word 0x00 17.--31. 1. " PM_1865                         ,reserved"
        bitfld.long 0x00 16. "      MASK_DRAGON_ADB400_CCI_SIDE_IDLE ,mask dragon adb400 cci side idle flag for cci_idle_clk_off_req   1=mask   0=unmask" "0,1"
        bitfld.long 0x00 15. "   CCI_CLK_SMOOTH_MUX_DIS               ,cci clock smoothmux disable   0= cci clock smoothmux enable, it will hw switch to vcxo clock when cpu enters m2 and gpu shutdonw   1=cci clock smoothmux disable, it only selects the clock from cci_clock_gen, when  cpu enters m2 and gpu shutdonw, the cci clock is gated." "0,1"
        bitfld.long 0x00 14. "   CCI_CLKEN_BY_INT_AP              ,cci clock also can be enabled by sys_int_ap[127:0]  0x1=enable this function. if this bit is 0x0, then the cci clock is still only controlled by the status of cpu clusters and gpu" "0,1"
        textline "                                      "
        bitfld.long 0x00 13. "CCI550_CLKGEN_AUTO_CG_EN        ,cci550 clock generator working clock automatic gating control    0x0 = cci550 clock generator working clock automatic gating is disabled and the clock is free-runing    0x1 = cci550 clock generator working clock automatic gating is enabled" "0,1"
        bitfld.long 0x00 12. "         CCI550_FC_REQ                    ,cci550  freq change request. when frequency change is done, this bit is automaticlly cleared by hardware" "0,1"
        bitfld.long 0x00 11. "   PM_1871                              ,reserved" "0,1"
        bitfld.long 0x00 8.--10. "   CCI550_BIU_CLK_DIV               ,clock divider selection for cci550 axi_m0 port to fabric.  aclk_m0 = aclkm1/ (this field +1)" "0,1,2,3,4,5,6,7"
        textline "                                      "
        bitfld.long 0x00 7. "PM_1873                         ,reserved" "0,1"
        bitfld.long 0x00 4.--6. "         CCI550_MC_CLK_DIV                ,clock divider selection for cci550 axi_m1 port to mck. aclk_m1 = pll_source / (this field +1)" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 3. "   PM_1875                              ,reserved" "0,1"
        bitfld.long 0x00 0.--2. "   CCI550_PLLSEL                    ,<var processor: application> cci550 clock selection  0x0 = pll1_499mhz   0x1 = pll1 624mhz   0x2 = pll1_832 mhz   0x3 = pll3_div3（700m）   0x4=pll2_div4(600m)   0x5=pll3_div4(525m)   0x6=pll4_div3(335m)   0x7=pll3_div2(1050m)" "0,1,2,3,4,5,6,7"

group d:0xD4282B38++0x03
    line.long 0x00 "PMU_CC3_AP,AP Clock Control Register"
        bitfld.long 0x00 18. " C2_MPSUB_SW_RST                 ,<var processor: application mp> reset  this field is used to reset the <var processor: application mp> logic except debug/coresight logic.  1 = reset is asserted  0 = reset is de-asserted" "0,1"
        bitfld.long 0x00 10. "         CPU9_SW_RST                      ,cpu9 core software reset  this field is used to reset cpu9 core logic only.  1 = reset is asserted  0 = reset is de-asserted" "0,1"
        bitfld.long 0x00 9. "   CPU9_POR_RST                         ,cpu9 core power on reset  this field is used to reset cpu9 all logic, including debug logic.  1 = reset is asserted  0 = reset is de-asserted" "0,1"
        bitfld.long 0x00 7. "   CPU8_SW_RST                      ,cpu8 core software reset  this field is used to reset cpu8 core logic only.  1 = core software reset is asserted  0 = core software reset is de-asserted" "0,1"
        textline "                                      "
        bitfld.long 0x00 6. "CPU8_POR_RST                    ,cpu8 core power on reset  this field is used to reset cpu8 all logic including debug logic.  1 = core power on reset is asserted  0 = core power on reset is de-asserted" "0,1"
        bitfld.long 0x00 3.--5. "         C2_ACLK_DIV1891                  ,clock divider selection for cluster2 axi interface clock  c2_aclk is divided from pclk. c2_aclk= pclk / (this field +1)" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 0.--2. "   C2_CLK_DIV1892                       ,clock divider selection for cluster2 pclk. if (fcap.c2_pllsel<=3), pclk= (fcap.c2_pllsel selectin clock )/(c2_clk_div +1);  else pclk =fcap.c2_pllsel selectin clock" "0,1,2,3,4,5,6,7"

group d:0xD4282B3C++0x03
    line.long 0x00 "PMU_DM_CC2_AP,Dummy AP Clock Control2 Register"
        bitfld.long 0x00 3.--5. " C2_ACLK_DIV1900                 ,clock divider selection for cluster2 axi interface clock  c2_aclk is divided from pclk. c2_aclk= pclk / (this field +1)" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 0.--2. "         C2_CLK_DIV1901                   ,clock divider selection for cluster2 pclk. if (fcap.c2_pllsel<=3), pclk= (fcap.c2_pllsel selectin clock )/(c2_clk_div +1);  else pclk =fcap.c2_pllsel selectin clock" "0,1,2,3,4,5,6,7"

group d:0xD4282B50++0x03
    line.long 0x00 "PMU_C2_CAPMP_IDLE_CFGx0,Cluster2 <var Processor: Application MP> Idle Configuration Register for Core x"

group d:0xD4282B54++0x03
    line.long 0x00 "PMU_C2_CAPMP_IDLE_CFGx1,Cluster2 <var Processor: Application MP> Idle Configuration Register for Core x"
        bitfld.long 0x00 19. " DIS_MP_L2_SLP1910               ,disable <var processor: application mp> l2 power switch  this field is used to disable the <var processor: application mp> l2 power switch sleep power down during <var processor: application mp> power down mode.  1 = disable <var processor: application" "0,1"
        bitfld.long 0x00 18. "         DIS_MP_SLP1911                   ,disable <var processor: application mp> power switch  this field is used to disable the <var processor: application mp> power switch sleep power down during mp subsystem power down mode.  1 = disable mp power switch sleep" "0,1"
        bitfld.long 0x00 16. "   MP_L2_PWR_OFF1913                    ,frc l2 sram off  1 = l2 cache power is off" "0,1"
        bitfld.long 0x00 13. "   L2_HW_CACHE_FLUSH_EN1915         ,l2 hardware cache flush enable  0x1= enable" "0,1"
        textline "                                      "
        bitfld.long 0x00 12. "MASK_SRAM_REPAIR_DONE_CHECK1916 ,mask sram repair done check  1 = mask sram repair done check" "0,1"
        bitfld.long 0x00 11. "         MASK_CLK_OFF_CHECK1917           ,mask <var processor: application mp> clock off state check  this field is used to mask the <var processor: application mp> clock off check during the mp idle process." "0,1"
        bitfld.long 0x00 10. "   MASK_CLK_STBL_CHECK1918              ,mask mp clock stbl state check  this field is used to mask the mp clock stable check during mp wakeup." "0,1"
        bitfld.long 0x00 9. "   MASK_JTAG_IDLE_CHECK1919         ,mask jtag idle state check  this field is used to mask the jtag idle check during <var processor: application mp> idle entry.  1 = mask jtag idle check" "0,1"
        textline "                                      "
        bitfld.long 0x00 8. "MASK_IDLE_CHECK1920             ,mask <var processor: application mp> idle state check  debug only - it should be 0 during normal operation  1 = status check masked  0 = status check not masked" "0,1"
        bitfld.long 0x00 7. "         ACINACTM_HW_CTRL1921             ,acinactm hardware control   0x0=low power state machine does not control acinactm port.   0x1= low power state machine will control acinactm port of <var processor: application mp>.  when m2/m1 low power mode is entered, acinactm port will be high" "0,1"
        bitfld.long 0x00 5. "   DIS_MC_SW_REQ1923                    ,disable memory controller software req  this field is used to disable the memory controller entry to idle mode using the memory controller sleep request bits. the memory controller will always enter into idle mode based upon the hardware state machine re" "0,1"
        bitfld.long 0x00 4. "   MP_WAKE_MC_EN1924                ,<var processor: application mp> wake mc enable  wake up the memory controller when the <var processor: application mp> wakes up from idle mode. the memory controller will be woken up before the interrupt to the core is released.  0 = memory controller w" "0,1"
        textline "                                      "
        bitfld.long 0x00 3. "MP_SCU_SRAM_PWRDWN1925          ,not used. scu sram does not support retention" "0,1"
        bitfld.long 0x00 3. "         PM_1926                          ,reserved for future use" "0,1"
        bitfld.long 0x00 2. "   L2_SRAM_PWRDWN1927                   ,l2 cache sram power down  this field does not take effect if mp_pwrdwn is 0.  1 = when <var processor: application mp> is idle, l2 sram power will be off  0 = when <var processor: application mp> is idle, l2 sram is in retention mode" "0,1"
        bitfld.long 0x00 1. "   MP_PWRDWN1928                    ,<var processor: application mp> power down  this field does not take effect if mp_idle is 0.  1 = when <var processor: application mp> is idle, <var processor: application mp> will go into deep sleep mode and <var processor: application mp> logic will b" "0,1"
        textline "                                      "
        bitfld.long 0x00 0. "MP_IDLE1929                     ,<var processor: application mp> idle  1 = when <var processor: application mp> is idle, <var processor: application mp> clocks will be gated externally" "0,1"

group d:0xD4282B70++0x03
    line.long 0x00 "PMU_CORE2_STATUS2,Core Status2 Register"
        bitfld.long 0x00 9. " AP_CORE9_C2                     ,<var processor: application> core9 in c2 mode indication  this field is used to indicate whether or not <var processor: application> core9 is in c2 mode.  1 = <var processor: application> core9 is in c2 mode" "0,1"
        bitfld.long 0x00 8. "         AP_CORE9_C1                      ,<var processor: application> core1 in c9 mode indication  this field is used to indicate whether or not <var processor: application> core9 is in c1 mode.  1 = <var processor: application> core9 is in c1 mode (here c1 means external idle mode)" "0,1"
        bitfld.long 0x00 7. "   AP_CORE9_WFI_FLAG                    ,<var processor: application> core9 wfi flag  this field reflects the wfi flag that is generated by core1. when core9 enters wfi, this field will be set." "0,1"
        bitfld.long 0x00 6. "   AP_CORE8_C2                      ,<var processor: application> core8 in c2 mode indication  this field is used to indicate whether or not <var processor: application> core8 is in c2 mode.  1 = <var processor: application> core8 is in c2 mode" "0,1"
        textline "                                      "
        bitfld.long 0x00 5. "AP_CORE8_C1                     ,<var processor: application> core8 in c1 mode indication  this field is used to indicate whether or not <var processor: application> core8 is in c1 mode.  1 = <var processor: application> core8 is in c1 mode (here c1 means external idle mode)" "0,1"
        bitfld.long 0x00 4. "         AP_CORE8_WFI_FLAG                ,<var processor: application> core8 wfi flag  this field reflects the wfi flag that is generated by core8. when core8 enters wfi, this field will be set." "0,1"
        bitfld.long 0x00 3. "   AP_C2_MPSUB_M2                       ,<q><var processor: application mp> cluster2 subsystem idle mode<\q> indication  this field is used to indicate whether or not the <var processor: application mp> subsystem is in m2 mode.  1 = <var processor: application mp> subsystem is in m2 mode" "0,1"
        bitfld.long 0x00 2. "   AP_C2_MPSUB_M1                   ,<var processor: application mp> cluster2 subsystem in m1 mode indication  this field is used to indicate whether or not the <var processor: application mp> subsystem is in m1 mode.  1 = <var processor: application mp> subsystem is in m1 mode (here m1 means <var processor: application mp> subsystem external idle mode)" "0,1"
        textline "                                      "
        bitfld.long 0x00 1. "AP_C2_MPSUB_IDLE_FLAG           ,<var processor: application mp> cluster2  subsystem idle flag  this field reflects the and logic value of scu_idle and l2clkstopped generated in the <var processor: application mp> subsystem.  1 = core8/core9/scu/l2 are all in idle state" "0,1"

tree.end

tree "dsi"

width 22.

group d:0xD4238000++0x03
    line.long 0x00 "DSI_CTRL_0,DSI Control Register 0"
        bitfld.long 0x00 31. " CFG_SOFT_RST              ,software reset dsi module  1 = reset dsi module  0 = de-assert software reset" "0,1"
        bitfld.long 0x00 30. "         CFG_SOFT_RST_REG          ,software reset config registers  1 = reset dsi config registers to default values  0 = de-assert reset" "0,1"
        bitfld.long 0x00 29. "     CFG_CLR_PHY_FIFO         ,configure clear phy tx fifo  1 = clear fifo data to 0  0 = de-assert clear. it is not used currently and reserved for future use." "0,1"
        bitfld.long 0x00 28. "       CFG_RST_TXLP              ,software reset lp tx submodule  1 = reset lp tx module  0 = de-assert software reset" "0,1"
        textline "                                "
        bitfld.long 0x00 27. "CFG_RST_CPU               ,software reset cpu tx submodule  1 = reset cpu tx module  0 = de-assert software reset" "0,1"
        bitfld.long 0x00 26. "         CFG_RST_CPN               ,software reset cpn tx submodule  1 = reset cpn tx module  0 = de-assert software reset" "0,1"
        bitfld.long 0x00 24. "     CFG_RST_VPN              ,software reset video panel submodule  1 = reset vpn module  0 = de-assert software reset" "0,1"
        bitfld.long 0x00 23. "       CFG_DSI_PHY_RST           ,software reset dphy submodule  1 = reset dphy  0 = de-assert software reset" "0,1"
        textline "                                "
        bitfld.long 0x00 17. "CFG_DSI_HCLK_DIS          ,dsi ahb clock disable. dsi config registers can still be written or read even if dsi ahb clock is disabled.  1 = dsi ahb clock will be gated   0 = dsi ahb clock is passed to dsi module" "0,1"
        bitfld.long 0x00 16. "         CFG_DSI_CLK_DIS           ,dsi clock disable  1 = dsi clock will be gated   0 = dsi clock is passed to dsi module" "0,1"
        bitfld.long 0x00 8. "     CFG_VPN_TX_EN            ,video panel interface tx enable  1 = enable video panel tx packet to dphy. dsi will send video packets to peripheral.   0 = disable video panel interface tx." "0,1"
        bitfld.long 0x00 4. "       CFG_VPN_SLV               ,video panel interface in slave mode  1 = video panel work in slave mode, and it will receive vsync from input lcd interface, and use it to control the internal timing.   0 = video panel interface works in master mode. dsi will send vsync to lcd module and control the v timing and h timing.   this bit must set to 1, vpn just support slave mode." "0,1"
        textline "                                "
        bitfld.long 0x00 2. "CFG_CPN_EN                ,command panel interface enable  1 = command panel is running and can accept data from the command panel interface  0 = disable command panel interface." "0,1"
        bitfld.long 0x00 0. "         CFG_VPN_EN                ,video panel interface enable  1 = video panel is running.  0 = disable video panel interface.   setting this field to 1 will star the video panel timing." "0,1"

group d:0xD4238004++0x03
    line.long 0x00 "DSI_CTRL_1,DSI Control Register 1"
        bitfld.long 0x00 8. " CFG_EOTP_EN               ,eotp enable  1 = enable eotp packet  0 = disable eotp packet" "0,1"
        bitfld.long 0x00 6.--7. "         CFG_CPN_VCH_NO            ,command panel virtual channel number" "0,1,2,3"
        bitfld.long 0x00 0.--1. "     CFG_VPN_VCH_NO           ,video panel virtual channel number for active panel 1  this parameter defines the virtual channel number for vpn" "0,1,2,3"

group d:0xD4238008++0x03
    line.long 0x00 "DSI_IRQ_ST1,DSI Interrupt Status Register1"
        bitfld.long 0x00 3. " IRQ_DPHY_ERR_HS_RXP       ,dphy hstx contention rxp error" "0,1"
        bitfld.long 0x00 2. "         IRQ_DPHY_ERR_HS_RXN       ,dphy hstx contention rxn error" "0,1"
        bitfld.long 0x00 1. "     IRQ_DPHY_ERR_HS_CONTP    ,dphy hstx contention contp error" "0,1"
        bitfld.long 0x00 0. "       IRQ_DPHY_ERR_HS_CONTN     ,dphy hstx contention contn error" "0,1"

group d:0xD423800C++0x03
    line.long 0x00 "DSI_IRQ_MASK1,DSI Interrupt Mask Register1"
        bitfld.long 0x00 0.--3. " CFG_IRQ_MASK1             ,dsi interrupt mask  this field is used to mask interrupt requests. if one bit is set to 0x1, the corresponding interrupt status is masked." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"

group d:0xD4238010++0x03
    line.long 0x00 "DSI_IRQ_ST,DSI Interrupt Status Register"
        bitfld.long 0x00 31. " IRQ_LAST_LINE             ,last line interupt" "0,1"
        bitfld.long 0x00 30. "         IRQ_CPN_TE                ,command panel tearing effect." "0,1"
        bitfld.long 0x00 29. "     IRQ_TA_TIMEOUT           ,turnaround acknowledge timeout for dphy" "0,1"
        bitfld.long 0x00 28. "       IRQ_RX_TIMEOUT            ,lp-rx timeout for dphy" "0,1"
        textline "                                "
        bitfld.long 0x00 27. "IRQ_TX_TIMEOUT            ,hs tx timeout for dphy" "0,1"
        bitfld.long 0x00 26. "         IRQ_RX_STATE_ERR          ,peripheral status error  after dsi receives an ack with error report packet from slave, it will mark this bit if there is error status reported." "0,1"
        bitfld.long 0x00 25. "     IRQ_RX_ERR               ,dsi rx packet error  dsi receives a packet from slave and the received packet has error status (ecc error/crc error/unknown packet)" "0,1"
        bitfld.long 0x00 24. "       IRQ_RX_FIFO_FULL_ERR      ,rx fifo full error" "0,1"
        textline "                                "
        bitfld.long 0x00 23. "IRQ_PHY_FIFO_UNDERRUN     ,phy fifo underrun error" "0,1"
        bitfld.long 0x00 22. "         IRQ_REQ_CNT_ERR           ,tx request count error  the delays between an active panel tx request to the dphy ready are not consistent." "0,1"
        bitfld.long 0x00 21. "     IRQ_RXPSR_FIFO_FULL_ERR  ,rx parser fifo full error" "0,1"
        bitfld.long 0x00 20. "       IRQ_VPN_REQ_PHY_DLY_ERR   ,vpn request delay error at phy interface  vpn packets are delayed at the phy interface." "0,1"
        textline "                                "
        bitfld.long 0x00 19. "IRQ_VPN_BF_UNDERRUN_ERR   ,vpn buffer underrun error" "0,1"
        bitfld.long 0x00 18. "         IRQ_VPN_REQ_ARB_DLY_ERR   ,vpn request delay error at arbiter interface  vpn packets are delayed at arbiter point." "0,1"
        bitfld.long 0x00 17. "     IRQ_VPN_BF_OVERRUN_ERR   ,vpn buffer overrun error" "0,1"
        bitfld.long 0x00 16. "       IRQ_VPN_TIMING_ERR        ,vpn data timing error  pixel data may be incorrect. data fifo for vpn path is read too early or too late, and fifo is empty when it is read." "0,1"
        textline "                                "
        bitfld.long 0x00 15. "IRQ_VPN_VACT_DONE         ,vpn vact done" "0,1"
        bitfld.long 0x00 14. "         IRQ_VPN_BF_FULL           ,vpn buffer full error  pixel data may be incorrect." "0,1"
        bitfld.long 0x00 13. "     IRQ_CPN_BF_FULL          ,cpn buffer full error  pixel data may be incorrect." "0,1"
        bitfld.long 0x00 12. "       IRQ_DPHY_ERR_CONT_LP1     ,dphy lp1 contention detect  ppi errcontertionlp1" "0,1"
        textline "                                "
        bitfld.long 0x00 11. "IRQ_DPHY_ERR_CONT_LP0     ,dphy lp0 contention detect  ppi errcontertionlp0" "0,1"
        bitfld.long 0x00 10. "         IRQ_DPHY_ERR_SYNC_ESC     ,dphy sync error  ppi errsyncesc, partial byte detected" "0,1"
        bitfld.long 0x00 9. "     IRQ_DPHY_ERR_ESC         ,dphy invalid command detect  ppi erresc, invalid esc command detected" "0,1"
        bitfld.long 0x00 8. "       IRQ_DPHY_RX_LINE_ERR      ,dphy invalid line state detect  ppi errcontrol" "0,1"
        textline "                                "
        bitfld.long 0x00 7. "IRQ_RX_TRG3               ,dphy rx trigger 3 received  by default, the value of trigger 3 is 0x05, and its meaning is not defined by specification." "0,1"
        bitfld.long 0x00 6. "         IRQ_RX_TRG2               ,dphy rx trigger 2 received  by default, trigger 2 is for acknowledge trigger, and its value is 0x84." "0,1"
        bitfld.long 0x00 5. "     IRQ_RX_TRG1              ,dphy rx trigger 1 received  by default, trigger 1 is for te trigger, and its value is 0xba." "0,1"
        bitfld.long 0x00 4. "       IRQ_RX_TRG0               ,dphy rx trigger 0 received  by default, trigger 0 is for reset trigger, and its value is 0x46." "0,1"
        textline "                                "
        bitfld.long 0x00 3. "IRQ_RX_ULPS               ,dphy rx ulps received" "0,1"
        bitfld.long 0x00 2. "         IRQ_RX_PKT                ,dphy rx packet received" "0,1"
        bitfld.long 0x00 1. "     IRQ_CPN_TX_DONE          ,command panel data transmission done" "0,1"
        bitfld.long 0x00 0. "       IRQ_CPU_TX_DONE           ,cpu packet transmission done" "0,1"

group d:0xD4238014++0x03
    line.long 0x00 "DSI_IRQ_MASK,DSI Interrupt Mask Register"
        hexmask.long 0x00 0.--31. 1. " CFG_IRQ_MASK              ,dsi interrupt mask  this field is used to mask interrupt requests. if one bit is set to 0x1, the corresponding interrupt status is masked."

group d:0xD4238018++0x03
    line.long 0x00 "DSI_FPGA_PHY_CTRL_0,DSI FPGA PHY Control Register 0"
        bitfld.long 0x00 14. " CFG_DPHY_FCLK_REV         ,fpga dphy fclk reverse" "0,1"
        bitfld.long 0x00 13. "         CFG_DPHY_TXRX_BYTECLK_REV ,fpga dphy txrx_byteclk reverse" "0,1"
        bitfld.long 0x00 12. "     CFG_DPHY_HSREQ_LANE3     ,fpga dphy lane3 hs requeset" "0,1"
        bitfld.long 0x00 11. "       CFG_DPHY_HSREQ_LANE2      ,fpga dphy lane2 hs requeset" "0,1"
        textline "                                "
        bitfld.long 0x00 10. "CFG_DPHY_HSREQ_LANE1      ,fpga dphy lane1 hs requeset" "0,1"
        bitfld.long 0x00 9. "         CFG_DPHY_HSREQ_LANE0      ,fpga dphy lane0 hs requeset" "0,1"
        bitfld.long 0x00 8. "     CFG_DPHY_HSREQ_LANECLK   ,fpga dphy laneclk hs requeset" "0,1"
        bitfld.long 0x00 7. "       CFG_DPHY_ENABLECLK        ,fpga dphy enable clk lane" "0,1"
        textline "                                "
        bitfld.long 0x00 6. "CFG_DPHY_ENABLE1125       ,fpga dphy enable1" "0,1"
        bitfld.long 0x00 5. "         CFG_DPHY_ENABLE0126       ,fpga dphy enable0" "0,1"
        bitfld.long 0x00 4. "     CFG_DPHY_MASSLVZ127      ,fpga dphy masterslaverz" "0,1"
        bitfld.long 0x00 3. "       CFG_DPHY_TXRXZ            ,reserved for future use" "0,1"
        textline "                                "
        bitfld.long 0x00 2. "CFG_DPHY_RSTZCAL129       ,fpga dphy rstzcal" "0,1"
        bitfld.long 0x00 1. "         CFG_DPHY_SHUTDOWN130      ,fpga dphy shutdown" "0,1"
        bitfld.long 0x00 0. "     CFG_DPHY_RESETZ131       ,fpga dphy resetz" "0,1"

group d:0xD423801C++0x03
    line.long 0x00 "DSI_FPGA_PHY_CTRL_1,DSI FPGA PHY Control Register 1"
        bitfld.long 0x00 24. " CFG_DPHY_ENABLE1139       ,fpga dphy lock" "0,1"
        hexmask.long.byte 0x00 16.--23. 1. "         CFG_DPHY_ENABLE0140       ,fpga dphy testdout"
        hexmask.long.byte 0x00 8.--15. 1. "    CFG_DPHY_MASSLVZ141      ,fpga dphy testdin"
        bitfld.long 0x00 2. "      CFG_DPHY_RSTZCAL143       ,fpga dphy testen" "0,1"
        textline "                                "
        bitfld.long 0x00 1. "CFG_DPHY_SHUTDOWN144      ,fpga dphy testclr" "0,1"
        bitfld.long 0x00 0. "         CFG_DPHY_RESETZ145        ,fpga dphy testclk" "0,1"

group d:0xD4238020++0x03
    line.long 0x00 "DSI_CPU_CMD_0,DSI CPU Packet Command Register 0"
        bitfld.long 0x00 31. " CFG_CPU_CMD_REQ           ,cpu command request  1 = cpu packet request  0 = no request or request done  after software writes a command with this bit set to 1, the dsi module sends out a packet as requested. dsi de-asserts this field after packet is sent." "0,1"
        bitfld.long 0x00 30. "         CFG_CPU_SP                ,cpu short packet  1 = cpu packet is a short packet  0 = cpu packet is a long packet" "0,1"
        bitfld.long 0x00 29. "     CFG_CPU_TURN             ,cpu turn around  1 = after cpu packet, turn around the bus  0 = don’t turn around bus after cpu packet" "0,1"
        bitfld.long 0x00 27. "       CFG_CPU_TXLP              ,low power tx for cpu packets  1 = transfer cpu packets through low power mode  0 = use high-speed mode to send cpu packets" "0,1"
        textline "                                "
        hexmask.long.word 0x00 0.--15. 1. "CFG_CPU_WC                ,cpu packet byte count  for high speed transfer, this is the payload byte count for long packets and doesn't include crc bytes. for high speed short packet transfer, this parameter is ignored. for low power transfer, this is the byte count for the whole packet transmission, including crc bytes, and cfg_cpu_sp is ignored."

group d:0xD4238024++0x03
    line.long 0x00 "DSI_CPU_CMD_1,DSI CPU Packet Command Register 1"
        bitfld.long 0x00 20.--23. " CFG_TXLP_LPDT             ,lpdt tx enable  lpdt tx enable signals for low power tx" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 16.--19. "        CFG_TXLP_ULPS             ,ulps tx enable  ulps tx enable signals for low power tx" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        hexmask.long.word 0x00 0.--15. 1. "    CFG_TXLP_TRIGGER_CODE    ,low power tx trigger code"

group d:0xD423802C++0x03
    line.long 0x00 "DSI_CPU_CMD_3,DSI CPU Packet Command Register 3"
        bitfld.long 0x00 31. " CFG_CPU_DAT_REQ           ,cpu packet data buffer read/write request  1 = cpu packet data request   0 = no request or request done  after software writes a command with this bit set to 1, the dsi module will write data to the packet data buffer or read data from the data buffer as requested. dsi will de-assert this bit after write/read operation is done. read data will be valid after this bit is reset to zero." "0,1"
        bitfld.long 0x00 30. "         CFG_CPU_DAT_RW            ,cpu packet data buffer read/write operation  1 = cpu packet data write operation   0 = cpu packet data read operation" "0,1"
        hexmask.long.byte 0x00 16.--23. 1. "     CFG_CPU_DAT_ADDR         ,cpu packet data address  this is the byte address for packet data. every write/read operation, 4 bytes of data will be written or read. software should increase address by 4 after each operation. packet data start from packet header. address 0: bits [7:0] are for type_id, bits [23:8] are for length, and bits [31:24] are for ecc. address 4: payload data if packet is a long packet, and so on. the maximum packet data buffer is 256 bytes."

group d:0xD4238030++0x03
    line.long 0x00 "DSI_CPU_WDAT,DSI CPU Packet Data Register"
        hexmask.long 0x00 0.--31. 1. " CFG_CPU_WDAT              ,cpu wdata 0  the dsi can generate packets based on cpu programmed data. this register defines the cpu packet data.  this register is the cpu packet data to be written to the packet data buffer. software should program packet data to this register and then program the dsi cpu packet command register 3 to put the packet data into the tx packet data buffer. for every write/read operation, 4-byte data is written/read. bits [7:0] are the lsb and bits [31:24] are the msb.  for packet data at address 0, bits [7:0] are for type_id, bits [23:8] are for length, and bits [31:24] are for ecc.  for data at address 4, payload data if packet is a long packet, and so on.  if packet is transmitted in high speed, hardware generates ecc and crc to replace this ecc/crc code in the packet data buffer. under low power tx, hardware does not insert ecc/crc and sends out the ecc/crc code in the packet data buffer."

group d:0xD4238034++0x03
    line.long 0x00 "DSI_CPU_STATUS_0,DSI CPU Command Status 0"
        hexmask.long.word 0x00 0.--15. 1. " CFG_CPU_PKT_CNT           ,cpu packet counter  this counter counts how many cpu packets are sent out through dsi. this register is write clear."

group d:0xD4238038++0x03
    line.long 0x00 "DSI_CPU_STATUS_1,DSI CPU Command Status 1"
        hexmask.long 0x00 0.--31. 1. " CFG_CPU_CMD_TX_CNT        ,cpu cmd tx counter  this counter counts how many byte clock cycles it takes to transfer the current cpu command. it begins to count after cpu command is received, and stops to counter after dphy gets ready for another tx request. this counter could help to decide the cfg_l*_slot_**_cnt values of register 0x130, 0x134, 0x1b0, and 0x1b4."

group d:0xD423803C++0x03
    line.long 0x00 "DSI_CPU_STATUS_2,DSI CPU Command Status 2"
        hexmask.long 0x00 0.--31. 1. " CFG_CPU_CMD_CNT           ,cpu cmd execution counter  this counter counts how many byte clock cycles it takes to execute the current cpu command. this counter only counts the cycles which cpu engine is busy. this counter could help to decide the cfg_l*_slot_**_cnt values of register 0x130, 0x134, 0x1b0, and 0x1b4."

group d:0xD4238040++0x03
    line.long 0x00 "DSI_CPU_STATUS_3,DSI CPU Command Status 3"
        hexmask.long 0x00 0.--31. 1. " CFG_TXLP_CNT              ,low power tx byte clock count. this counter counts how many byte clock cycles it takes to transfer a low power packet."

group d:0xD4238044++0x03
    line.long 0x00 "DSI_CPU_STATUS_4,DSI CPU Command Status 4"
        hexmask.long 0x00 0.--31. 1. " CFG_BTA_CNT               ,bus turn around byte clock count. this counter counts how many byte clock cycles it takes to do a bus turn around operation."

group d:0xD423804C++0x03
    line.long 0x00 "DSI_CPN_STATUS_1,DSI Command Panel Path Status 1"
        hexmask.long 0x00 0.--31. 1. " CFG_CPN_STATUS_1          ,command panel path status 1.  {smt_bf_cnt[5:0], smt_fifo_bcnt[9:0],   3'b0, smt_cs[4:0],    2'b0, smt_wr_on, smt_dma_on,   smt_fifo_empty, smt_bf_empty, smt_fifo_full_r, smt_bf_full_r}"

group d:0xD4238050++0x03
    line.long 0x00 "DSI_CPN_CMD,DSI Command Panel Command Register"
        bitfld.long 0x00 28.--31. " CFG_CPN_TE_EN             ,command panel tearing effect signal enable" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 24.--26. "        CFG_CPN_RGB_TYPE          ,command panel data rgb type  0x0 = 888 mode  0x1 = 666 unpacked mode  0x2 = 565 mode  0x3 = 444 mode  0x4 = 332 mode  0x5 = 111 mode" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 3. "     CFG_CPN_BURST_MODE       ,command panel interface burst mode enable   0 = enable previous command pandel interface.   1 = burst mode interface between lcd and dsi will take effect.  this interface is more efficient than the previous one." "0,1"
        bitfld.long 0x00 2. "       CFG_CPN_FIRSTP_SEL        ,command panel first packet select   0 = fifo empty <1> vsync from dp650" "0,1"
        textline "                                "
        bitfld.long 0x00 1. "CFG_CPN_DMA_DIS           ,command panel dma_on disable  1 = disable smt_dma_on signal from lcd controller. dsi will not receive command panel interface data from lcd even smt_dma_on signal is active high.  0 = receive lcd command panel interface data when smt_dma_on is high." "0,1"
        bitfld.long 0x00 0. "         CFG_CPN_ADDR0_EN          ,command panel address bit indicator  0 = when smt_addr = 1, bus data are for pixel rgb data. when smt_addr = 0, bus data are ignored  1 = when smt_addr = 0, bus data are for pixel rgb data. when smt_addr = 1, bus data are ignored." "0,1"

group d:0xD4238054++0x03
    line.long 0x00 "DSI_CPN_CTRL_0,DSI Command Panel Control 0 Register"
        hexmask.long.byte 0x00 16.--21. 1. " CFG_DCS_LONGWR_CODE       ,dsi command code for writing command panel data  the default data is 0x39 from dsi specification."
        hexmask.long.byte 0x00 8.--15. 1. "        CFG_DCS_WR_CON_CODE       ,dcs command for continuous write  the default value is 0x3c in mipi alliance standard for display command set specification."
        hexmask.long.byte 0x00 0.--7. 1. "    CFG_DCS_WR_STR_CODE      ,dcs command for first write  the default value is 0x2c in the mipi alliance standard for display command set specification."

group d:0xD4238058++0x03
    line.long 0x00 "DSI_CPN_CTRL_1,DSI Command Panel Control 1 Register"
        hexmask.long.word 0x00 16.--25. 1. " CFG_CPN_PKT_CNT           ,command panel packet length  this field defines the packet length for command panel packets."
        hexmask.long.word 0x00 0.--9. 1. "      CFG_CPN_FIFO_FULL_LEVEL   ,command panel fifo full level, in byte count"

group d:0xD423805C++0x03
    line.long 0x00 "DSI_CPN_STATUS_0,DSI Command Panel Control Status 0"
        hexmask.long 0x00 0.--31. 1. " CFG_CPN_FRM_CNT           ,command panel frame counter  this counter counts how many command panel frames are sent out through dsi. this register is write clear."

group d:0xD4238060++0x03
    line.long 0x00 "DSI_RX_PKT_ST_0,DSI RX Packet 0 Status Register"
        bitfld.long 0x00 31. " RX_PKT0_ST_VLD            ,rx packet 0 status valid  1 = valid status  0 = invalid status" "0,1"
        bitfld.long 0x00 26. "         RX_PKT0_ST_EOTP           ,rx packet 0 is eotp  1 = received packet is eotp packet  0 = other packet  it is valid only when rx_pkt0_st_vld = 1." "0,1"
        bitfld.long 0x00 25. "     RX_PKT0_ST_ACK           ,rx packet 0 is ack packet  1 = received packet is an ack packet with or without error  0 = other packet  it is valid only when rx_pkt0_st_vld = 1." "0,1"
        bitfld.long 0x00 24. "       RX_PKT0_ST_SP             ,rx packet 0 short packet  1 = received packet is a short packet  0 = long packet  it is valid only when rx_pkt0_st_vld = 1." "0,1"
        textline "                                "
        hexmask.long.byte 0x00 16.--21. 1. "RX_PKT0_PKT_PTR           ,rx packet 0 data pointer  packet header in fifo is the raw data from dphy and is before ecc correction.  it is valid only when rx_pkt0_st_vld = 1."
        bitfld.long 0x00 14.--15. "        RX_PKT0_VCH               ,rx packet 0 virtual channel number  it is valid only when rx_pkt0_st_vld = 1." "0,1,2,3"
        bitfld.long 0x00 8.--11. "     RX_PKT0_ECC_FLAGS        ,rx packet 0 ecc error flags  bit [11]:  1 = no ecc error  0 = ecc error    bit [10]:  1 = correctable error in data bits    bit [9]:  1 = correctable error happens at parity bits    bit [8]: 1 = incorrectable error  it is valid only when rx_pkt0_st_vld = 1." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 4. "      RX_PKT0_NO_CRC            ,rx packet 0 without crc  rx packet doesn't contain crc and crc part contain 0x0000. it is valid only when rx_pkt0_st_vld = 1." "0,1"
        textline "                                "
        bitfld.long 0x00 3. "RX_PKT0_UNKNOWN_ERR       ,rx packet 0 type unknown error  it is valid only when rx_pkt0_st_vld = 1." "0,1"
        bitfld.long 0x00 2. "         RX_PKT0_ST_ERR            ,rx packet 0 ack status error  the ack packet has error status. the dsi_rx_pkt_hdr_0 should be checked to see what error happens. it is valid only when rx_pkt0_st_vld = 1." "0,1"
        bitfld.long 0x00 1. "     RX_PKT0_ECC_ERR          ,rx packet 0 ecc error  it is valid only when rx_pkt0_st_vld = 1." "0,1"
        bitfld.long 0x00 0. "       RX_PKT0_CRC_ERR           ,rx packet crc error  it is valid only when rx_pkt0_st_vld = 1." "0,1"

group d:0xD4238064++0x03
    line.long 0x00 "DSI_RX_PKT_HDR_0,DSI RX Packet 0 Header Register"
        hexmask.long 0x00 0.--31. 1. " RX_PKT0_HDR               ,rx packet 0 header  bits [7:0]: dataid  bits [23:8]: length  bits [31:23]: ecc--corrected if error detected."

group d:0xD4238068++0x03
    line.long 0x00 "DSI_RX_PKT_ST_1,DSI RX Packet 1 Status Register"
        bitfld.long 0x00 31. " RX_PKT1_ST_VLD            ,rx packet 1 status valid  1 = valid status  0 = invalid status" "0,1"
        bitfld.long 0x00 26. "         RX_PKT1_ST_EOTP           ,rx packet 1 is eotp  1 = received packet is eotp packet  0 = other packet  it is valid only when rx_pkt0_st_vld = 1." "0,1"
        bitfld.long 0x00 25. "     RX_PKT1_ST_ACK           ,rx packet 1 is ack packet  1 = received packet is an ack packet with or without error  0 = other packet  it is valid only when rx_pkt0_st_vld = 1." "0,1"
        bitfld.long 0x00 24. "       RX_PKT1_ST_SP             ,rx packet 1 short packet  1 = received packet is a short packet  0 = long packet valid only when rx_pkt0_st_vld = 1." "0,1"
        textline "                                "
        hexmask.long.byte 0x00 16.--21. 1. "RX_PKT1_PKT_PTR           ,rx packet 1 data pointer  packet header in fifo is the raw data from dphy and is before ecc correction.  valid only when rx_pkt0_st_vld = 1."
        bitfld.long 0x00 14.--15. "        RX_PKT1_VCH               ,rx packet 1 virtual channel number  valid only when rx_pkt0_st_vld = 1." "0,1,2,3"
        bitfld.long 0x00 8.--11. "     RX_PKT1_ECC_FLAGS        ,rx packet 1 ecc error flags  bit [11]:  1 = no ecc error  0 = ecc error    bit [10]:  1 = correctable error in data bits    bit [9]:  1 = correctable error happens at parity bits    bit [8]:  1 = incorrectable error  it is valid only when rx_pkt0_st_vld = 1." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 4. "      RX_PKT1_NO_CRC            ,rx packet 1 without crc  rx packet doesn't contain crc and crc part contain 0x0000. it is valid only when rx_pkt0_st_vld = 1." "0,1"
        textline "                                "
        bitfld.long 0x00 3. "RX_PKT1_UNKNOWN_ERR       ,rx packet type unknown error  it is valid only when rx_pkt0_st_vld = 1." "0,1"
        bitfld.long 0x00 2. "         RX_PKT1_ST_ERR            ,rx packet 1 ack status error  the dsi_rx_pkt_hdr_0 should be checked to see what error happens. it is valid only when rx_pkt0_st_vld = 1." "0,1"
        bitfld.long 0x00 1. "     RX_PKT1_ECC_ERR          ,rx packet 1 ecc error  it is valid only when rx_pkt0_st_vld = 1." "0,1"
        bitfld.long 0x00 0. "       RX_PKT1_CRC_ERR           ,rx packet 1 crc error  it is valid only when rx_pkt0_st_vld = 1." "0,1"

group d:0xD423806C++0x03
    line.long 0x00 "DSI_RX_PKT_HDR_1,DSI RX Packet 1 Header Register"
        hexmask.long 0x00 0.--31. 1. " RX_PKT1_HDR               ,rx packet 1 header"

group d:0xD4238070++0x03
    line.long 0x00 "DSI_RX_PKT_CTRL,DSI RX Packet Read Control Register"
        bitfld.long 0x00 31. " RX_PKT_RD_REQ             ,rx packet fifo read request  1 = read request  0 = invalid req  this bit will be cleared to 0 after read operation is done and rx data valid." "0,1"
        hexmask.long.byte 0x00 16.--21. 1. "         RX_PKT_RD_PTR             ,rx packet data fifo read pointer  for every read operation, the hardware will return the data from the pointer address. software must increment this pointer for the next data after each byte is read."
        hexmask.long.byte 0x00 0.--7. 1. "    RX_PKT_RD_DATA           ,rx fifo read data  valid when rx_pkt_rd_req = 0.  first byte: dataid  second byte: wc0  third byte: wc1  fourth byte: raw ecc received from dphy, not corrected  fifth byte and beyond: long packet data"

group d:0xD4238074++0x03
    line.long 0x00 "DSI_RX_PKT_CTRL_1,DSI RX Packet Read Control 1 Register"
        bitfld.long 0x00 8.--11. " RX_PKT_CNT                ,rx packet count in rx fifo  all lp rx packets are stored in the fifo and start from address 0." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        hexmask.long.byte 0x00 0.--7. 1. "        RX_PKT_BCNT               ,rx byte count in rx fifo  the whole lp rx data are stored in the fifo and start from address 0."

group d:0xD4238078++0x03
    line.long 0x00 "DSI_RX_PKT_ST_2,DSI RX Packet 2 Status Register"
        bitfld.long 0x00 31. " RX_PKT2_ST_VLD            ,rx packet 2 status valid  1 = valid status  0 = invalid status" "0,1"
        bitfld.long 0x00 26. "         RX_PKT2_ST_EOTP           ,rx packet 2 is eotp  1 = received packet is eotp packet  0 = other packet  it is valid only when rx_pkt0_st_vld = 1." "0,1"
        bitfld.long 0x00 25. "     RX_PKT2_ST_ACK           ,rx packet 2 is an ack packet<p>1 = received packet is a ack packet with or without error  0 = other packet  it is valid only when rx_pkt0_st_vld = 1." "0,1"
        bitfld.long 0x00 24. "       RX_PKT2_ST_SP             ,rx packet 2 short packet  1 = received packet is a short packet  0 = long packet  valid only when rx_pkt0_st_vld = 1." "0,1"
        textline "                                "
        hexmask.long.byte 0x00 16.--21. 1. "RX_PKT2_PKT_PTR           ,rx packet 2 data pointer  packet header in fifo is the raw data from dphy and is before ecc correction. valid only when rx_pkt0_st_vld = 1."
        bitfld.long 0x00 14.--15. "        RX_PKT2_VCH               ,rx packet 2 virtual channel number  valid only when rx_pkt0_st_vld = 1." "0,1,2,3"
        bitfld.long 0x00 8.--11. "     RX_PKT2_ECC_FLAGS        ,rx packet 2 ecc error flags  bit [11]:   1 = no ecc error  0 = ecc error    bit [10]:  1 = correctable error in data bits    bit [9]:  1 = correctable error happens at parity bits    bit [8]:  1 = incorrectable error  it is valid only when rx_pkt0_st_vld = 1." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 4. "      RX_PKT2_NO_CRC            ,rx packet 2 without crc  rx packet doesn't contain crc and crc part contain 0x0000. it is valid only when rx_pkt0_st_vld = 1." "0,1"
        textline "                                "
        bitfld.long 0x00 3. "RX_PKT2_UNKNOWN_ERR       ,rx packet 2 type unknown error  it is valid only when rx_pkt0_st_vld = 1." "0,1"
        bitfld.long 0x00 2. "         RX_PKT2_ST_ERR            ,rx packet 2 ack status error  the dsi_rx_pkt_hdr_0 should be checked to see what error happens. it is valid only when rx_pkt0_st_vld = 1." "0,1"
        bitfld.long 0x00 1. "     RX_PKT2_ECC_ERR          ,rx packet 2 ecc error  it is valid only when rx_pkt0_st_vld = 1." "0,1"
        bitfld.long 0x00 0. "       RX_PKT2_CRC_ERR           ,rx packet 2 crc error  it is valid only when rx_pkt0_st_vld = 1." "0,1"

group d:0xD423807C++0x03
    line.long 0x00 "DSI_RX_PKT_HDR_2,DSI RX Packet 2 Header Register"
        hexmask.long 0x00 0.--31. 1. " RX_PKT2_HDR               ,rx packet 2 header"

group d:0xD4238084++0x03
    line.long 0x00 "DSI_LCD_BDG_CTRL0,DSI LCD Bridge Control Register 0"
        hexmask.long.word 0x00 16.--27. 1. " CFG_VPN_FIFO_AFULL_CNT    ,dsi vpn fifo almost full count vpn fifo read_point - write_point shoud be greater than this value"
        bitfld.long 0x00 9. "      CFG_HSYNC_MISSING_FIX     ,fix the hsync missing bug" "0,1"
        bitfld.long 0x00 8. "     CFG_TXLP_LANE_TURN_FIX   ,fix the txlp lane turn bug" "0,1"
        bitfld.long 0x00 6. "       CFG_VPN_FIFO_AFULL_BYPASS ,by pass vpn fifo almost full  0 = not bypass  1 = bypass, the lcd output pixel data to vpn fifo  not care the almost full signal" "0,1"
        textline "                                "
        bitfld.long 0x00 5. "CFG_CPN_VSYNC_EDGE        ,cpn vsync signal edge select  0 = posedge select  1 = negedge select" "0,1"
        bitfld.long 0x00 4. "         CFG_CPN_TE_EDGE           ,cpn tearing effect signal edge select  0 = posedge select  1 = negedge select" "0,1"
        bitfld.long 0x00 2.--3. "     CFG_CPN_TE_MODE          ,cpn tearing effect mode select  0 = no tearing effect  1 = mode a, tearing effect signal consists of v-blanking only   2 = mode b, tearing effect signal consists of v-blanking and h-blanking  3 = mode c, tearing effect signal output the n h-blanking" "0,1,2,3"
        bitfld.long 0x00 1. "       CFG_PIXEL_SWAP            ,lcd output pixel swap  0 = don't swap lcd output pixel data  1 = swap lcd output pixel data" "0,1"
        textline "                                "
        bitfld.long 0x00 0. "CFG_SPLIT_EN              ,split mode enable, this bit should be set as same as lcd split mode  0 =  split mode disable, just dsia is used for display   1 = split mode enable, both dsia and dsib are used for display" "0,1"

group d:0xD4238088++0x03
    line.long 0x00 "DSI_LCD_BDG_CTRL1,DSI LCD Bridge Control Register 1"
        hexmask.long.word 0x00 16.--31. 1. " CFG_CPN_TE_DLY_CNT        ,cpn tearing effect delay count, the lcd output pixel data will delay cfg_cpn_te_dly_cnt cycles after te pulse"
        hexmask.long.word 0x00 0.--15. 1. "      CFG_CPN_TE_LINE_CNT       ,cpn tearing effect line count, when te_mode = 2, this field will take effect. the lcd output pixel data will wait for cfg_cpn_te_line_cnt te pulse"

group d:0xD42380E4++0x03
    line.long 0x00 "DSI_TX_TIMER,DSI TX Timer Register"
        hexmask.long 0x00 0.--31. 1. " CFG_TX_TIMER_CNT          ,tx transmission timer value  this timer monitors the tx operation on the dsi output side. it could generate irq after timer timeout. by default setting, timeout will not happen because the reset value is the maximum value (0xffffffff)."

group d:0xD42380E8++0x03
    line.long 0x00 "DSI_RX_TIMER,DSI RX Timer Register"
        hexmask.long 0x00 0.--31. 1. " CFG_RX_TIMER_CNT          ,rx timer value  this timer monitors the rx operation on the dsi operation. it could generate irq after timer timeout. by default setting, timeout will not happen because the reset value is the maximum value (0xffffffff)."

group d:0xD42380EC++0x03
    line.long 0x00 "DSI_TURN_TIMER,DSI Turn Around Timer Register"
        hexmask.long 0x00 0.--31. 1. " CFG_TURN_TIMER_CNT        ,bus turn around timer value  this timer monitors the turn around operation on the dsi. it could generate irq after timer timeout. by default setting, timeout will not happen because the reset value is the maximum value (0xffffffff)."

group d:0xD4238100++0x03
    line.long 0x00 "DSI_VPN_CTRL_0,DSI Video Panel  Control Register 0"
        hexmask.long.word 0x00 16.--31. 1. " CFG_VPN_DLY_CNT           ,vpn vsync delay count in slave mode. in slave mode, dsi will start h/v timing depending on input vsync timing from lcd module.   in slave mode, after dsi receives a vsync from lcd controller, it will start a vsync timing by delaying this count of clock."
        hexmask.long.byte 0x00 0.--7. 1. "      CFG_VPN_TX_DLY_CNT        ,vpn tx delay count  after dsi starts a hsync timing, delay this count of dphy byte clock count to start a vss packet transfer. this is a dsi internal delay to guarantee a fixed tx timing at dphy interface."

group d:0xD4238104++0x03
    line.long 0x00 "DSI_VPN_CTRL_1,DSI Video Panel Control Register 1"
        bitfld.long 0x00 31. " CFG_VPN_VSYNC_RST_EN      ,lcd vsync reset enable in slave mode  1 = reset dsi vertical state machine when lcd vsync comes. this will only take effect when lcd is in slave mode.  0 = don't reset dsi vertical state machine" "0,1"
        bitfld.long 0x00 27. "         CFG_VPN_AUTO_WC_DIS       ,vpn auto word count disable  this bit has lower priority than cfg_vpn_hact_wc_en  0x0 = enable auto word count calculation, and hardware automatically calculates how many bytes will be sent in each h line slot  0x1 = auto word count calculation will not be effective" "0,1"
        bitfld.long 0x00 26. "     CFG_VPN_HACT_WC_EN       ,vpn hact word count enable  this bit has higher priority than cfg_vpn_auto_wc_en  0x0 = cfg_hact_wc will not be effective if cfg_vpn_auto_wc_dis is 0  0x1 = enable hact word count parameter, and cfg_hact_wc will be used to decide how many bytes are sent" "0,1"
        bitfld.long 0x00 25. "       CFG_VPN_TIMING_CHECK_DIS  ,vpn hss/hse/hact tx timing check disable  0x0 = check timing before requesting dphy for tx  0x1 = don't check timing before requesting dphy for tx" "0,1"
        textline "                                "
        bitfld.long 0x00 24. "CFG_VPN_AUTO_DLY_DIS      ,vpn auto vsync delay count disable  0x0 = enable auto vsync delay count calculation, and hardware will automatically use halt of cfg_htotal_cnt to replace cfg_vpn_dly_cnt  0x1 = auto vsync delay count disabled, hardware will use the cfg_vpn_dly_cnt for vsync delay" "0,1"
        bitfld.long 0x00 22. "         CFG_VPN_HLP_PKT_EN        ,long blanking packet enable  1 = dsi will send out a long blanking packet during hlp time slot  0 = long blanking packet is disabled, dsi will go to low power during this time slot  in most cases, this field should be programmed to 0x0." "0,1"
        bitfld.long 0x00 21. "     CFG_VPN_HEX_PKT_EN       ,extra long blanking packet enable  1 = dsi will send out a long blanking packet after pixel data transmission and before hfp  0 = extra long blanking packet is disabled, dsi will go to low power during this time slot  in most cases, this field should be programmed to 0x0." "0,1"
        bitfld.long 0x00 20. "       CFG_VPN_HFP_PKT_EN        ,front porch packet enable  1 = dsi will send out a long blanking packet during hfp time slot  0 = hfp long blanking packet is disabled, dsi will go to low power during this time slot  if front porch period is not long enough for dphy to go to low power state and come back to hs again timely for next hss packet, this field should be programmed to 0x1." "0,1"
        textline "                                "
        bitfld.long 0x00 18. "CFG_VPN_HBP_PKT_EN        ,back porch packet enable  1 = dsi will send out a long blanking packet during hbp time slot  0 = hbp long blanking packet is disabled, dsi will go to low power during this time slot  if back porch period is not long enough for dphy to go to low power state and come back to hs again timely for next pixel data packet, this field should be programmed to 0x1." "0,1"
        bitfld.long 0x00 17. "         CFG_VPN_HSE_PKT_EN        ,hse packet enable  1 = dsi will send out hse packet during hbp time slot  0 = hse packet is disabled, dsi will go to low power during this time slot  enable this bit when transmission mode is in non-burst mode with sync pulse." "0,1"
        bitfld.long 0x00 16. "     CFG_VPN_HSA_PKT_EN       ,hsa packet enable  1 = dsi will send out hsa long blanking packet during hbp time slot  0 = hsa packet is disabled, dsi will go to low power during this time slot  if transmission mode is non-burst mode with sync event or burst mode, this field should be disabled. if transmission mode is non-burst mode with sync pulse, this field can be programmed to 0x1." "0,1"
        bitfld.long 0x00 14. "       CFG_VPN_HEX_SLOT_EN       ,extra long packet enable after pixel data  1 = enable extra long packet after pixel data transfer, this will insert a long blanking packet before hfp  0 = no extra long packet is inserted after pixel data transfer  this field takes effect only in burst mode.  in most cases, this field should be programmed to 0x0." "0,1"
        textline "                                "
        bitfld.long 0x00 10. "CFG_VPN_LAST_LINE_TURN    ,turn around bus at last h line  1 = dsi will turn around the bus every frame during the last h line, this will request slave to return an acknowledge or acknowledge with error  0 = dsi will not turn around the bus during the last h line  in most cases, this field should be programmed to 0x0." "0,1"
        bitfld.long 0x00 9. "         CFG_VPN_LPM_FRAME_EN      ,go to low power every frame  1 = dsi will go to low power mode every frame during the last h line  0 = dsi will not go to low power mode during the last h line  in most cases, this field should be programmed to 0x0." "0,1"
        bitfld.long 0x00 2.--3. "     CFG_VPN_BURST_MODE       ,dsi transmission mode for lcd 1  0x0 = non-burst mode with sync pulse  0x1 = non-burst mode with sync event  0x2 = burst mode" "0,1,2,3"
        bitfld.long 0x00 0.--1. "       CFG_VPN_RGB_TYPE          ,lcd 1 input data rgb mode for lcd 1  0x0 = 565 rgb mode  0x1 = 666 packet mode  0x2 = 666 un-packet mode  0x3 = 888 rgb mode" "0,1,2,3"

group d:0xD4238110++0x03
    line.long 0x00 "DSI_VPN_TIMING_0,DSI Video Panel Timing Register 0"
        hexmask.long.word 0x00 16.--31. 1. " CFG_VPN_HACT_CNT          ,vpn hact clock count in byte clock domain. this parameter defines the byte clock cycle numbers for horizontal line pixel data period    the data byte number for this period is hact_byte_cnt = hact_cnt*lane_num"
        hexmask.long.word 0x00 0.--15. 1. "      CFG_VPN_HTOTAL_CNT        ,vpn htotal clock count in byte clock domain. this parameter defines the byte clock cycle numbers for horizontal line period    the data byte number for this period is htotal_byte_cnt = htotal_cnt*lane_num"

group d:0xD4238114++0x03
    line.long 0x00 "DSI_VPN_TIMING_1,DSI Video Panel Timing Register 1"
        hexmask.long.word 0x00 16.--31. 1. " CFG_VPN_HSYNC_CNT         ,vpn hsync clock count in byte clock domain. this parameter defines the byte clock cycle numbers for horizontal line hsync period    the data byte number for this period is hsync_byte_cnt = hsync_cnt*lane_num"
        hexmask.long.word 0x00 0.--15. 1. "      CFG_VPN_HBP_CNT           ,vpn hbp clock count in byte clock domain. this parameter defines the byte clock cycle numbers for horizontal line back porch period    the data byte number for this period is hbp_byte_cnt = hbp_cnt*lane_num    front porch clock count can be calculated by: hfp_cnt = htotal_cnt - hsync_cnt - hact_cnt - hbp_cnt    the data byte number for front porch period is hfp_byte_cnt = hfp_cnt*lane_num"

group d:0xD4238118++0x03
    line.long 0x00 "DSI_VPN_TIMING_2,DSI Video Panel Timing Register 2"
        hexmask.long.word 0x00 16.--31. 1. " CFG_VPN_VACT_CNT          ,vpn vact line count"
        hexmask.long.word 0x00 0.--15. 1. "      CFG_VPN_VTOTAL_CNT        ,vpn vtotal line count"

group d:0xD423811C++0x03
    line.long 0x00 "DSI_VPN_TIMING_3,DSI Video Panel Timing Register 3"
        hexmask.long.word 0x00 16.--31. 1. " CFG_VPN_VSYNC_CNT         ,vpn vsync line count"
        hexmask.long.word 0x00 0.--15. 1. "      CFG_VPN_VBP_CNT           ,vpn vbp line count"

group d:0xD4238120++0x03
    line.long 0x00 "DSI_VPN_WC_0,DSI Video Panel Word Count Register 0"
        hexmask.long.word 0x00 16.--31. 1. " CFG_VPN_HBP_WC            ,vpn hbp packet payload data byte count  this parameter must be programmed if hbp_pkt_en is 0x1, otherwise it can be kept as 0x0   if transmission mode is non-burst mode with sync pulse, hbp_wc = hbp_byte_cnt - hse_byte_cnt(4) - hbp_pkt_overhead(6)  if transmission mode is non-burst mode with sync event or burst mode, hbp_wc = hsync_byte_cnt + hbp_byte_cnt - hss_byte_cnt(4) - hbp_pkt_overhead(6)"
        hexmask.long.word 0x00 0.--15. 1. "      CFG_VPN_HSA_WC            ,vpn hsa packet payload data byte count  this parameter must be programmed if hsa_pkt_en is 0x1, otherwise it can be kept as 0x0   if transmission mode is non-burst mode with sync pulse, hsa_wc = hsync_byte_cnt - hss_byte_cnt(4) - hsa_pkt_overhead(6), otherwise it is 0x0"

group d:0xD4238124++0x03
    line.long 0x00 "DSI_VPN_WC_1,DSI Video Panel Word Count Register 1"
        hexmask.long.word 0x00 16.--31. 1. " CFG_VPN_HFP_WC            ,vpn hfp packet payload data byte count  this parameter must be programmed if hfp_pkt_en is 0x1, otherwise it can be kept as 0x0   if transmission mode is non-burst mode with sync pulse, or non-burst mode with sync event, hfp_wc = hfp_byte_cnt - hact_pkt_overhead(6) - hfp_pkt_overhead(6)   if transmission mode is burst mode and hex_pkt_en = 1, hfp_wc = hfp_byte_cnt - hact_pkt_overhead(6) - hfp_pkt_overhead(6)   if transmission mode is burst mode and hex_pkt_en = 0, hfp_wc = hfp_byte_cnt + (hact_byte_cnt - hact_wc) - hact_pkt_overhead(6) - hfp_pkt_overhead(6)"
        hexmask.long.word 0x00 0.--15. 1. "      CFG_VPN_HACT_WC           ,vpn hact packet payload data byte count    this parameter is equal to active pixel rgb data total byte count"

group d:0xD4238128++0x03
    line.long 0x00 "DSI_VPN_WC_2,DSI Video Panel Word Count Register 2"
        hexmask.long.word 0x00 16.--31. 1. " CFG_VPN_HEX_WC            ,vpn hex packet payload data byte count  this parameter must be programmed if hex_pkt_en is 0x1, otherwise it can be kept as 0x0   if transmission mode is burst mode, hex_wc = hact_byte_cnt - hact_wc - hex_pkt_overhead(6)   otherwise hex_wc = 0"
        hexmask.long.word 0x00 0.--15. 1. "      CFG_VPN_HLP_WC            ,vpn hlp packet payload data byte count  this parameter must be programmed if hlp_pkt_en is 0x1, otherwise it can be kept as 0x0   if transmission mode is non-burst mode with sync pulse, hlp_wc = htotal_byte_cnt - hsync_byte_cnt - hse_byte_cnt(4) - hlp_pkt_overhead(6)   if transmission mode is non-burst mode with sync event or burst mode, hlp_wc = htotal_byte_cnt - hss_byte_cnt(4) - hlp_pkt_overhead(6)"

group d:0xD4238130++0x03
    line.long 0x00 "DSI_VPN_SLOT_CNT_0,DSI Video Panel Time Slot Count 0 Register"
        hexmask.long.word 0x00 16.--31. 1. " CFG_VPN_SLOT_SP_CNT       ,vpn time slot count for short packet. this parameter defines a min slot period for short packet transmission, which should ensure dphy can go to low power, send the short packet, and return to hs again in time for next active panel packet which has a strict timing requirement.   if any dsi active panel data flow is working, and cpu or smart interface wants to send short packet between the active panel packets, the internal state machine will try to find a time slot between active panel packets which has a larger period than the defined value. dsi will only send cpu or command panel short packet during such slot to ensure dphy has enough time to go to low power, send the packet, and return to hs again in time for next active panel packet which has a strict timing requirement.  the programming of his parameter is necessary only when multiple panels or data paths are working simultaneously."
        hexmask.long.word 0x00 0.--15. 1. "      CFG_VPN_SLOT_LP_CNT       ,vpn time slot count for long packet. this parameter defines a min slot period for long packet transmission, which should ensure dphy can go to low power, send the long packet, and return to hs again in time for next active panel packet which has a strict timing requirement.   the programming of his parameter is necessary only when multiple panels or data paths are working simultaneously."

group d:0xD4238134++0x03
    line.long 0x00 "DSI_VPN_SLOT_CNT_1,DSI Video Panel Time Slot Count 1"
        hexmask.long.word 0x00 16.--31. 1. " CFG_VPN_SLOT_TXLP_CNT     ,vpn time slot count for low power packet tx. this parameter defines a min slot period for low power packet transmission, which should ensure dphy can go to low power, send the low power packet, and return to hs again in time for next active panel packet which has a strict timing requirement.   the programming of his parameter is necessary only when multiple panels or data paths are working simultaneously."
        hexmask.long.word 0x00 0.--15. 1. "      CFG_VPN_SLOT_TN_CNT       ,vpn time slot count for bus turn around. this parameter defines a min slot period for short packet transmission, which should ensure dphy can go to low power, turn around the bus, and return to hs again in time for next active panel packet which has a strict timing requirement."

group d:0xD4238138++0x03
    line.long 0x00 "DSI_VPN_SYNC_CODE,DSI Video Panel Sync Code"

group d:0xD4238140++0x03
    line.long 0x00 "DSI_VPN_STATUS_0,DSI VPN Status Register 0"
        bitfld.long 0x00 31. " CFG_VPN_RD_ERR            ,vpn input buffer read error. this includes cfg_vpn_rd_2early, cfg_vpn_line_miss, and cfg_vpn_rd_underrun." "0,1"
        bitfld.long 0x00 30. "         CFG_VPN_LINE_MISS         ,vpn input buffer line miss. this indicates a whole h line pixel data missed." "0,1"
        bitfld.long 0x00 29. "     CFG_VPN_RD_2EARLY        ,vpn input buffer read too early" "0,1"
        bitfld.long 0x00 28. "       CFG_VPN_RD_UNDERRUN       ,vpn input buffer underrun" "0,1"
        textline "                                "
        bitfld.long 0x00 27. "CFG_VPN_BF_FULL           ,vpn input buffer full" "0,1"
        bitfld.long 0x00 26. "         CFG_VPN_RD_DELAY_ERR      ,vpn request delay error at arbiter" "0,1"
        hexmask.long.tbyte 0x00 0.--20. 1. "     CFG_VPN_STATUS_0         ,dsi vpn status register for debug purpose   {l1_lcd[4:0]_cs, l1_vst[6:0], l1_hst[8:0]}"

group d:0xD4238144++0x03
    line.long 0x00 "DSI_VPN_STATUS_1,DSI VPN Status Register 1"
        hexmask.long.word 0x00 16.--31. 1. " CFG_VPN_WRDONE_RDDONE_CNT ,vpn input buffer write done to input buffer read done clock count. this could help to tune the vsync delay count."
        hexmask.long.word 0x00 0.--15. 1. "      CFG_VPN_WR2RD_CNT         ,vpn input buffer write to input buffer read clock count. this could help to tune the vsync delay count."

group d:0xD4238148++0x03
    line.long 0x00 "DSI_VPN_STATUS_2,DSI VPN Status Register 2"
        hexmask.long.word 0x00 16.--31. 1. " CFG_VPN_UNDERRUN_CNT      ,vpn input buffer underrun count"
        hexmask.long.word 0x00 0.--15. 1. "      CFG_VPN_RD_DATWR_CNT      ,vpn input buffer read to data write count"

group d:0xD423814C++0x03
    line.long 0x00 "DSI_VPN_STATUS_3,DSI VPN Status Register 3"
        hexmask.long.word 0x00 16.--31. 1. " CFG_VPN_REQ_ARB_DLY_CNT   ,vpn tx req delay count at arbiter interface"
        hexmask.long.word 0x00 0.--15. 1. "      CFG_VPN_REQ_PHY_DLY_CNT   ,vpn tx req delay count at dphy interface"

group d:0xD4238150++0x03
    line.long 0x00 "DSI_VPN_STATUS_4,DSI VPN Status Register 4"
        hexmask.long 0x00 0.--31. 1. " CFG_VPN_FRM_CNT           ,dsi vpn tx frame count"

group d:0xD4238180++0x03
    line.long 0x00 "DSI_PHY_CTRL_0,DPHY Control Register 0"
        bitfld.long 0x00 31. " CFG_RX_TRG_REG_DIS        ,disable register for low power rx trigger signals. internal use." "0,1"
        bitfld.long 0x00 30. "         CFG_TX_LANE_0             ,new packet tx start from lane 0  =0 if two packets are transferred continuously, all data are packed and distributed to all enabled lanes the second packet could start from any lane  1 = transmission of every new packet starts from lane 0 if two packets are transferred continuously, and the first packet doesn't occupy all lanes, then extra byte of 0 will be inserted in at the end of first packet to ensure the second packet start from lane 0 this is an debug option and should be set to 0" "0,1"
        bitfld.long 0x00 27. "     CFG_FCLK_NOT             ,reverse the input byte clk from dphy to dsi control logic. the output data to dphy should be valid at falling edge of byte clk." "0,1"
        hexmask.long.byte 0x00 16.--23. 1. "       CFG_STOP_ST_CNT           ,dphy stop state count. for txlp and phy control"
        textline "                                "
        hexmask.long.byte 0x00 8.--15. 1. "CFG_RX_DLY_CNT            ,dphy rx_delay count. for rx control"

group d:0xD4238184++0x03
    line.long 0x00 "DSI_PHY_CTRL_1,DPHY Control Register 1"
        bitfld.long 0x00 17. " CFG_VDD_ANA_VALID         ,dphy analog vdd valid" "0,1"
        bitfld.long 0x00 16. "         CFG_VDD_DVM_VALID         ,dphy digital vdd valid" "0,1"
        bitfld.long 0x00 2. "     CFG_ULPS_REQ_BYTE        ,dphy all lane force to ulps" "0,1"
        bitfld.long 0x00 1. "       CFG_TX_ULPS_CLK_ESC       ,dphy clk lane force to ulps" "0,1"
        textline "                                "
        bitfld.long 0x00 0. "CFG_CONT_CLK_HS           ,dphy clock lane continuous clocking in hs" "0,1"

group d:0xD4238188++0x03
    line.long 0x00 "DSI_PHY_CTRL_2,DPHY Control Register 2"
        bitfld.long 0x00 14. " CFG_CSR_HSTX_RX_EN        ,rx enable when dphy hstx   0x0 = disable   0x1 enable" "0,1"
        bitfld.long 0x00 12.--13. "         CFG_CSR_LANE_MAP          ,dphy data map to lane order   0x0 = lane0, lane1, lane2, lane3    0x1 = lane0,  lane3, lane1, lane2    0x2 = lane0, lane2, lane3, lane1    = 0x3 reserved." "0,1,2,3"
        bitfld.long 0x00 8.--11. "     CFG_CSR_LANE_RESC_EN     ,dphy lp receiver enable  enable the reverse escape lp receiver. lane immediately transmits to receive mode." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 4.--7. "      CFG_CSR_LANE_EN           ,dphy data lane enable" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        textline "                                "
        bitfld.long 0x00 0.--3. "CFG_CSR_LANE_TURN         ,dphy bus turn around  this field indicates that the protocol desires to turn the lane around, allowing the other side to begin transmitting." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"

group d:0xD423818C++0x03
    line.long 0x00 "DSI_PHY_CTRL_3,DPHY Control Register 3"
        bitfld.long 0x00 9. " CFG_FORCECLK_HIZ_HS       ,dphy clk lane force to high-z in hs mode" "0,1"
        bitfld.long 0x00 8. "         CFG_FORCECLK_HIZ_LP       ,dphy clk lane force to high-z in lp mode" "0,1"
        bitfld.long 0x00 4.--7. "     CFG_FORCE_HIZ_HS         ,dphy force data lane to high-z in hs mode" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 0.--3. "      CFG_FORCE_HIZ_LP          ,dphy data lane force to high-z in lp mode" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"

group d:0xD4238190++0x03
    line.long 0x00 "DSI_PHY_STATUS_0,DPHY Status Register 0"
        bitfld.long 0x00 28.--31. " DPHY_RDY_HS_BYTE          ,dphy hs tx ready signals" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 24.--27. "        TX_REQ_HS_BYTE            ,dphy hs tx request signals" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 16.--19. "    DPHY_LANE_RX_LINE_ERR653 ,ppi errcontrol  illegal line state detected" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 12.--15. "      DPHY_ERR_SYNC_ESC654      ,ppi errsyncesc  partial byte detected" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        textline "                                "
        bitfld.long 0x00 8.--11. "DPHY_ERR_ESC655           ,ppi erresc  invalid esc command detected" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 4.--7. "        DPHY_ERR_CONT_LP0656      ,ppi errcontentionlp0  contention detect" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 0.--3. "    DPHY_ERR_CONT_LP1657     ,ppi errcontentionlp0  contention detect" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"

group d:0xD4238194++0x03
    line.long 0x00 "DSI_PHY_STATUS_1,DPHY Status Register 1"
        bitfld.long 0x00 31. " DPHY_ULP_STATE_BYTE       ,all lanes are ulps" "0,1"
        bitfld.long 0x00 30. "         DPHY_STOP_STATE_BYTE      ,ppi stopstate - all lanes in stop state" "0,1"
        bitfld.long 0x00 29. "     DPHY_CLK_ULPS_ACTIVE_N   ,ppi clock ulpsactivenot" "0,1"
        bitfld.long 0x00 28. "       DPHY_RX_CLK_ULPS_N        ,ppi rxulpsclknot" "0,1"
        textline "                                "
        bitfld.long 0x00 24.--27. "DPHY_LANE_DIR             ,ppi direction" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 20.--23. "        DPHY_ULPS_ACTIVE_N        ,ppi ulpsactivenot" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 16.--19. "    DPHY_LANE_RX_LINE_ERR670 ,ppi errcontrol - illegal line state detected." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 12.--15. "      DPHY_ERR_ESC671           ,ppi erresc - invalid esc command detected" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        textline "                                "
        bitfld.long 0x00 8.--11. "DPHY_ERR_SYNC_ESC672      ,ppi errsyncesc - partial byte detected" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 4.--7. "        DPHY_ERR_CONT_LP0673      ,ppi errcontentionlp0 - contention detect" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 0.--3. "    DPHY_ERR_CONT_LP1674     ,ppi errcontentionlp0 - contention detect" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"

group d:0xD4238198++0x03
    line.long 0x00 "DSI_PHY_LPRX_0,DPHY LP RX Register 0"
        bitfld.long 0x00 28.--31. " DPHY_LANE_RX_TRG3         ,dphy_lane_rx_trg3" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 24.--27. "        DPHY_LANE_RX_TRG2         ,dphy_lane_rx_trg2" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 20.--23. "    DPHY_LANE_RX_TRG1        ,dphy_lane_rx_trg1" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 16.--19. "      DPHY_LANE_RX_TRG0         ,dphy_lane_rx_trg0" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        textline "                                "
        bitfld.long 0x00 12.--15. "DPHY_LANE_RX_ULPS         ,dphy_lane_rx_ulps" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 8.--11. "        DPHY_LANE_RX_LPDT         ,dphy_lane_rx_lpdt" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 4.--7. "    DPHY_LANE_RX_DVALID      ,dphy_lane_rx_dvalid" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 0.--3. "      DPHY_LANE_RX_CLK          ,dphy_lane_rx_clk" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"

group d:0xD423819C++0x03
    line.long 0x00 "DSI_PHY_LPRX_1,DPHY LP RX Register 1"
        hexmask.long 0x00 0.--31. 1. " DPHY_LANE_DOUT_RX         ,dphy_lane_dout_rx"

group d:0xD42381A0++0x03
    line.long 0x00 "DSI_PHY_LPTX_0,DPHY LP TX Register 0"
        hexmask.long.word 0x00 20.--31. 1. " DPHY_TX_TRIGGER_ESC_L     ,tx_trigger_esc[11:0]"
        bitfld.long 0x00 16.--19. "      DPHY_TX_ULPS_ESC          ,tx_ulps_esc" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 12.--15. "    DPHY_TX_LPDT_ESC         ,tx_lpdt_esc" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 8.--11. "      DPHY_TX_VALID_ESC         ,tx_valid_esc" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        textline "                                "
        bitfld.long 0x00 4.--7. "DPHY_TX_REQ_ESC           ,tx_req_esc" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 0.--3. "        DPHY_LANE_RDY_ESC         ,dphy_lane_rdy_esc" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"

group d:0xD42381A4++0x03
    line.long 0x00 "DSI_PHY_LPTX_1,DPHY LP TX Register 1"
        bitfld.long 0x00 0.--3. " DPHY_TX_TRIGGER_ESC_H     ,tx_trigger_esc[15:12]" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"

group d:0xD42381A8++0x03
    line.long 0x00 "DSI_PHY_LPTX_2,DPHY LP TX Register 2"
        hexmask.long 0x00 0.--31. 1. " DPHY_TX_DATA_ESC          ,tx_data_esc"

group d:0xD42381AC++0x03
    line.long 0x00 "DSI_PHY_STATUS_2,DPHY Status Register 2"
        hexmask.long.word 0x00 16.--31. 1. " CFG_TX_REQ_CNT_R          ,tx previous req to rdy delay count"
        hexmask.long.word 0x00 0.--15. 1. "      CFG_TX_REQ_CNT            ,tx req to rdy delay count"

group d:0xD42381C0++0x03
    line.long 0x00 "DSI_PHY_TIME_0,DPHY Timing Control Register 0"
        hexmask.long.byte 0x00 24.--31. 1. " CFG_CSR_TIME_HS_EXIT      ,length of hs exit period in tx_clk_esc cycles  this field is used for the time to drive lp-11 after hs burst.  hs exit period = (1+cfg_csr_hs_exit)/66 mhz  by default, dphy esc clock frequency is 66 mhz  from mipi spec, the minimum value is 100 ns."
        hexmask.long.byte 0x00 16.--23. 1. "        CFG_CSR_TIME_HS_TRAIL     ,dphy hs trail period length  this field is used for the time to drive flipped differential state after the last payload data bit of a hs transmission burst.  length of hs trail period is in tx_clk_esc cycles.  hs trail time = (1 + cfg_csr_hs_trail)/66 mhz  from mipi spec, the minimum value is defined by max (8*ui, 60 ns + 4*ui)."
        hexmask.long.byte 0x00 8.--15. 1. "    CDG_CSR_TIME_HS_ZERO     ,dphy hs zero state length  this field is used for the time to drive hs-0 before the sync sequence.  length of hs zero state is in tx_clk_esc cycles.  hs zero state length >= (cfg_csr_time_zero - 2)/66 mhz + 3*tbyte_clk   from mipi spec, the minimum value for (time hs prep + time hs zero) is 145 ns + 10*ui."
        hexmask.long.byte 0x00 0.--7. 1. "      CFG_CSR_TIME_HS_PREP      ,dphy hs prepare state length  this field is used for the time to drive lp-00 to prepare for hs transmission.   it is the length of hs prepare state period in tx_clk_esc cycles.  time hs prep = (1+ cfg_csr_time_hs_prep)/66 mhz  from mipi specification for dphy, the minimum value for this parameter is 40 ns + 4*ui, and the maximum value is 85 ns_6*ui."

group d:0xD42381C4++0x03
    line.long 0x00 "DSI_PHY_TIME_1,DPHY Timing Control Register 1"
        hexmask.long.byte 0x00 24.--31. 1. " CFG_CSR_TIME_TA_GET       ,time to drive lp-00 by new transmitter in tx_clk_esc cycles  ta get time = (1 + cfg_csr_time_ta_get)/66 mhz  from mipi spec, the typical value is 5*tlpx, where tlpx is dphy lp length: tlpx = (1 + cfg_csr_time_lpx)/66 mhz"
        hexmask.long.byte 0x00 16.--23. 1. "        CFG_CSR_TIME_TA_GO        ,time to drive lp-00 after turn request in tx_clk_esc cycles  ta go time = (1 + ta_go)/66 mhz  from mipi spec, the typical value is 4*tlpx."
        hexmask.long.word 0x00 0.--15. 1. "    CFG_CSR_TIME_WAKEUP      ,dphy hs wakeup period length  this field is the recovery time from ultra-low power state (ulps).  twakeup = (1 + cfg_csr_time_wakeup)/66 mhz  from mipi spec, the minimum value is 1 ms."

group d:0xD42381C8++0x03
    line.long 0x00 "DSI_PHY_TIME_2,DPHY Timing Control Register 2"
        hexmask.long.byte 0x00 24.--31. 1. " CFG_CSR_TIME_CK_EXIT      ,dphy clk exit period length in tx_clk_esc cycles  tck_exit = (1 + cfg_csr_time_ck_exit)/66 mhz  this field should use the same value as cfg_csr_time_hs_exit"
        hexmask.long.byte 0x00 16.--23. 1. "        CFG_CSR_TIME_CK_TRAIL     ,dphy clk trail period length in tx_clk_esc cycles  this field is the time to drive hs differential state after the last payload clock bit of a hs transmission burst.  clk trail time = (1 + cfg_csr_time_ck_trail)/66 mhz  from mipi spec, the minimum value is 60 ns."
        hexmask.long.byte 0x00 8.--15. 1. "    CFG_CSR_TIME_CK_ZERO     ,dphy clk zero state length in tx_clk_esc cycles  this field is the time for lead hs-0 drive period before starting the clock.  tck_zero = (1 + cfg_csr_time_ck_zero)/66 mhz  from mipi spec, the minimum value for (tck_prep+tck_zero) is 300 ns, where in <var product number> tck_prep is the same as time hs prep defined by cfg_cst_time_hs_prep."
        hexmask.long.byte 0x00 0.--7. 1. "      CFG_CSR_TIME_CK_LPX       ,dphy clk lp length  this field is the length of clk low power state period in tx_clk_esc cycles.  clk lpx time = tck_lpx = (1 + cfg_csr_time_ck_lpx) / 66 mhz  this field should be set to the same value as cfg_cst_time_lpx."

group d:0xD42381CC++0x03
    line.long 0x00 "DSI_PHY_TIME_3,DPHY Timing Control Register 3"
        hexmask.long.byte 0x00 8.--15. 1. " CFG_CSR_TIME_LPX          ,dphy lp length  this field is the length of any low power state period in tx_clk_esc cycles.  lpx time = tlpx = (1 + cfg_csr_time_lpx) / 66 mhz  from mipi spec, the minimum value is 50 ns."
        hexmask.long.byte 0x00 0.--7. 1. "        CFG_CSR_TIME_REQRDY       ,dphy hs req to rdy length  this field is the minimum byte clock cycles of dsi hs tx request to dphy ready.  sometimes it may be important for this length to be consistent to maintain precise vertical and horizontal timing. in most cases, this parameter should be kept at the default of 0x0.  total cycles between dsi hs tx request to dphy ready is composed by dphy <q>clock lane timing,</q> <q>gap,</q> <q>data lane timing</q> and some other items inside dphy.   clock lane timing = (2*(cfg_csr_time_ck_lpx + 1) + (cfg_csr_time_hs_prep + 1) + (cfg_csr_time_ck_zero + 1))/66 mhz   gap = (16ui +2)/66 mhz  data lane timing = ((2*cfg_csr_time_lpx + 1) + (cfg_csr_time_hs_prep + 1) + (cfg_csr_time_hs_zero + 1))/66 mhz    (1 + cfg_csr_time_reqrdy)/frequecy_byte_clk = (clock lane timing + gap + data lane timing + 10/66 mhz)   one other way to get a value for this parameter is to after dsi active panel data flow is running, read back the value of register dsi_phy_status_2 (0x1ac). bits [7:0] of this register is the current clock cycle value of delay between dsi tx request and dphy ready. add 2 to this value and program it to cfg_csr_time_reqrdy."

group d:0xD42381D0++0x03
    line.long 0x00 "DSI_PHY_CODE_0,DPHY CODE Register 0"
        hexmask.long.byte 0x00 24.--31. 1. " CFG_TRIG3_CODE            ,dphy trigger 3 code"
        hexmask.long.byte 0x00 16.--23. 1. "        CFG_TRIG2_CODE            ,dphy trigger 2 code"
        hexmask.long.byte 0x00 8.--15. 1. "    CFG_TRIG1_CODE           ,dphy trigger 1 code"
        hexmask.long.byte 0x00 0.--7. 1. "      CFG_TRIG0_CODE            ,dphy trigger 0 code"

group d:0xD42381D4++0x03
    line.long 0x00 "DSI_PHY_CODE_1,DPHY CODE Register 1"
        hexmask.long.byte 0x00 24.--31. 1. " CFG_CSR_ULPS_CODE         ,dphy ultra low power code"
        hexmask.long.byte 0x00 16.--23. 1. "        CFG_CSR_LPDT_CODE         ,dphy low power data transfer code"

group d:0xD42381E0++0x03
    line.long 0x00 "DSI_PHY_ANA_PWR_CTRL,DPHY ANALOG POWER Controller Register"
        bitfld.long 0x00 8. " CFG_DPHY_ANA_RESETB       ,dphy analog reset  0 = reaset dphy analog   1= de-reset dphy analog" "0,1"
        bitfld.long 0x00 0. "         CFG_DPHY_ANA_PU           ,dphy analog power up  0 = power down dphy analog  1= power up dphy analog" "0,1"

group d:0xD42381E4++0x03
    line.long 0x00 "DSI_PHY_ANA_CTRL0,DPHY ANALOG Controller Register 0"
        bitfld.long 0x00 29.--31. " CFG_DPHY_LPRX_VTTH        ,lprx reference voltage high  000: 760mv …..  20mv per stage 010: 800mv 111: 900 mv" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 26.--28. "         CFG_DPHY_LPRX_VTHL        ,lprx reference voltage low 000: 540mv …..  20mv per stage 010:580mv 011:600mv 111: 680 mv" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 24.--25. "     CFG_DPHY_LPTX_RES        ,lptx driver impedance control 000" "0,1,2,3"
        bitfld.long 0x00 21.--23. "       CFG_DPHY_HSTX_RES         ,hstx driver impedance control. 000: 120 ohm (differential @tt) 100: 100 ohm 111:  89   ohm" "0,1,2,3,4,5,6,7"
        textline "                                "
        bitfld.long 0x00 20. "CFG_DPHY_HSTX_LP          ,low power mode for hstx driver.   1 = lower power   0 = normal" "0,1"
        bitfld.long 0x00 17.--19. "         CFG_DPHY_ADJ_DLY_CK       ,adjust delay of ch_ck hstx driver output to manage skew between channels. 30ps (@tt) per stage. 000: 0 stage        111:  7 stages" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 16. "     CFG_DPHY_EN_CH_CK        ,enable for ch_ck.   when disabled, ch_ck is power down mode, pad_ckp and pad_ckn are in high-z mode  0 = disable  1 = enable" "0,1"
        bitfld.long 0x00 13.--15. "       CFG_DPHY_ADJ_DLY3         ,adjust delay of ch3 hstx driver output to manage skew between channels. 30ps (@tt) per stage. 000: 0 stage        111:  7 stages" "0,1,2,3,4,5,6,7"
        textline "                                "
        bitfld.long 0x00 12. "CFG_DPHY_EN_CH3           ,enable for ch3.   when disabled, ch3 is power down mode, pad_dn3 and pad_p3 are in high-z mode  0 = disable  1 = enable" "0,1"
        bitfld.long 0x00 9.--11. "         CFG_DPHY_ADJ_DLY2         ,adjust delay of ch2 hstx driver output to manage skew between channels. 30ps (@tt) per stage. 000: 0 stage        111:  7 stages" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 8. "     CFG_DPHY_EN_CH2          ,enable for ch2.   when disabled, ch2 is power down mode, pad_dn2 and pad_p2 are in high-z mode  0 = disable  1 = enable" "0,1"
        bitfld.long 0x00 5.--7. "       CFG_DPHY_ADJ_DLY1         ,adjust delay of ch1 hstx driver output to manage skew between channels. 30ps (@tt) per stage. 000: 0 stage        111:  7 stages" "0,1,2,3,4,5,6,7"
        textline "                                "
        bitfld.long 0x00 4. "CFG_DPHY_EN_CH1           ,enable for ch1.   when disabled, ch1 is power down mode, pad_dn1 and pad_p1 are in high-z mode  0 = disable  1 = enable" "0,1"
        bitfld.long 0x00 1.--3. "         CFG_DPHY_ADJ_DLY0         ,adjust delay of ch0 hstx driver output to manage skew between channels. 30ps (@tt) per stage. 000: 0 stage        111:  7 stages" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 0. "     CFG_DPHY_EN_CH0          ,enable for ch0.   when disabled, ch0 is power down mode, pad_dn0 and pad_p0 are in high-z mode  0 = disable  1 = enable" "0,1"

group d:0xD42381E8++0x03
    line.long 0x00 "DSI_PHY_ANA_CTRL1,DPHY ANALOG Controller Register 1"
        bitfld.long 0x00 23. " CFG_CLK_SEL               ,dphy bit clk select    0 = pll_div2 output    1 = mipi_bit_clk mux output" "0,1"
        bitfld.long 0x00 20. "         CFG_SWAP_PN_CH3           ,swap pn polarity for ch3" "0,1"
        bitfld.long 0x00 19. "     CFG_SWAP_PN_CH2          ,swap pn polarity for ch2" "0,1"
        bitfld.long 0x00 18. "       CFG_SWAP_PN_CHCK          ,swap pn polarity for ch ck" "0,1"
        textline "                                "
        bitfld.long 0x00 17. "CFG_SWAP_PN_CH1           ,swap pn polarity for ch1" "0,1"
        bitfld.long 0x00 16. "         CFG_SWAP_PN_CH0           ,swap pn polarity for ch0" "0,1"
        bitfld.long 0x00 15. "     CFG_SET_TEST             ,select analog phy self-test 1: enable phy self-test. at this mode, phybypass all control signal 0: disable phy self-test." "0,1"
        bitfld.long 0x00 14. "       DFG_SET_TEST_LP           ,select lp or hs self-test mode. it only be valid when sel_test is high. 1: lp mode self test 0: hs mode self test" "0,1"
        textline "                                "
        bitfld.long 0x00 12.--13. "DFG_TEST_PATTERN          ,select self-test pattern generation 00: all 0 01: all 1 10: ck pattern (0101) 11: prbs7" "0,1,2,3"
        bitfld.long 0x00 11. "         CFG_EN_CLK_DIV2           ,enable half rate hstx mode. when enabled, phy will work at half data rate of pll input clock. 1: enable 0 disable" "0,1"
        bitfld.long 0x00 8.--10. "     CFG_DPHY_HSTX_VREF       ,hstx vreg control 000: 340mv …..  20mv per stage 011: 400mv 111: 480 mv" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 5.--7. "       CFG_DPHY_LPCDVTHH         ,lpcd reference voltage high  000: 300mv …..  20mv per stage 101:400mv 111: 440 mv" "0,1,2,3,4,5,6,7"
        textline "                                "
        bitfld.long 0x00 2.--4. "CFG_DPHY_LPCDVTHL         ,lpcd reference voltage low 000: 200mv …..  20mv per stage 010: 240mv 111: 340 mv" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 1. "         CFG_DPHY_PULL_DN          ,pull down enable: 1: enable pull down pad io for ch1,ch2,ch3,chck when both hstx and lptx are not enabled. 0: disable pull down pad io for ch1,ch2,ch3,chck when both hstx and lptx are not enabled. it's high z in this state." "0,1"
        bitfld.long 0x00 0. "     CFG_DPHY_PULL_DN_CH0     ,pull down enable for ch0 1: enable pull down pad io when all hstx, lptx and lprx are not enabled. 0: disable pull down  pad io when both hstx and lptx are not enabled. it's high z in this state." "0,1"

tree.end

tree "dro"

width 20.

group d:0xD4013200++0x03
    line.long 0x00 "DRO_CTRL,DRO monitor control register"
        bitfld.long 0x00 1. " INT_DRO          ," "0,1"
        bitfld.long 0x00 0. "         DRO_MONITOR_EN ," "0,1"

group d:0xD4013204++0x03
    line.long 0x00 "DRO_threshold_high,DRO threshold high addr"
        hexmask.long.word 0x00 0.--15. 1. " THRESHOLD_HIGH   ,"

group d:0xD4013208++0x03
    line.long 0x00 "DRO_threshold_low,DRO threshold low addr"
        hexmask.long.word 0x00 0.--15. 1. " THRESHOLD_LOW    ,"

group d:0xD401320C++0x03
    line.long 0x00 "DRO_tgl_cnt,DRO toggle CNT addr"
        hexmask.long.word 0x00 0.--15. 1. " DRO_RUNNING_TIME ,"

group d:0xD4013210++0x03
    line.long 0x00 "DRO_idle,DRO Idle time addr"
        hexmask.long 0x00 0.--31. 1. " IDLE_TIME        ,"

group d:0xD4013214++0x03
    line.long 0x00 "DRO_ring_cnt,DRO RING CNT addr"

group d:0xD4013218++0x03
    line.long 0x00 "DRO_cnt_ref,DRO CNT REF addr"

group d:0xD401321C++0x03
    line.long 0x00 "DRO_expt,DRO exception addr"

tree.end

tree "pmudvc"

width 15.

group d:0xD4052000++0x03
    line.long 0x00 "DVCR,Dynamic Voltage Change Control Register"
        bitfld.long 0x00 1. " VC_EN                         ,voltage change enable in active mode  1 = voltage change is allowed in active mode  0 = voltage change is not allowed" "0,1"
        bitfld.long 0x00 0. "     DV_LPM_AVC_EN16    ,automatic voltage change enable in low power mode  0 = automatic voltage change is disabled for every component  1 = automatic voltage change is enabled." "0,1"

group d:0xD4052020++0x03
    line.long 0x00 "DVC_AP,<var Processor: Application MP>  Dynamic Voltage Change Register"
        bitfld.long 0x00 28.--31. " C2_VL3:0                      ,cluster2 voltage level in active mode  required voltage level by <var processor: application mp> in m0/m1* mode  this voltage level can be dynamically changed due to a frequency change." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 24.--27. "    PERI_VL3:0         ,peripheral voltage level in d0 active mode" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 16.--19. "  C1_VL3:0             ,cluster1 voltage level in active mode  required voltage level by <var processor: application mp> in m0/m1* mode  this voltage level can be dynamically changed due to a frequency change." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 15. "  DV_VC_REQ27      ,voltage change request in active mode  voltage change request for <var processor: application mp> in m0/m1* power mode  software can write 1 to this bit to trigger a voltage change request. hardware will automaticly clear this bit when dvc is done. writes of 0 to this bit are ignored." "0,1"
        textline "                         "
        bitfld.long 0x00 8.--11. "C0_VL3:0                      ,cluster0 voltage level in active mode  required voltage level by <var processor: application mp> in m0/m1* mode  this voltage level can be dynamically changed due to a frequency change." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 7. "    C2_LPM_AVC_EN      ,cluster2 automatic voltage change enable in low power mode  this field is used for the <var processor: application mp>  0 = automatic voltage change is disabled  1 =  automatic voltage change is enabled  when <var processor: application mp> enters into m2* mode,  hardware automatically triggers a voltage change request." "0,1"
        bitfld.long 0x00 6. "   C1_LPM_AVC_EN        ,cluster1 automatic voltage change enable in low power mode  this field is used for the <var processor: application mp>  0 = automatic voltage change is disabled  1 =  automatic voltage change is enabled  when <var processor: application mp> enters into m2* mode,  hardware automatically triggers a voltage change request." "0,1"
        bitfld.long 0x00 5. "   C0_LPM_AVC_EN    ,cluster0 automatic voltage change enable in low power mode  this field is used for the <var processor: application mp>  0 = automatic voltage change is disabled  1 =  automatic voltage change is enabled  when <var processor: application mp> enters into m2* mode,  hardware automatically triggers a voltage change request." "0,1"
        textline "                         "
        bitfld.long 0x00 0.--3. "DV_LPM_VL3:034                ,required voltage level by <var processor: application mp> in m2* low power mode" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"

group d:0xD405202C++0x03
    line.long 0x00 "DVC_APSUB,AP Subsystem Dynamic Voltage Change Register"
        bitfld.long 0x00 31. " UDR_AP_SLP_AVC_EN             ,automatic voltage change enable in udr ap_sleep mode(ap_d2 mode)  0 =  automatic voltage change is disabled  1 = automatic voltage change is enabled  when the ap subsystem enters into udr ap_sleep mode,  hardware automatically triggers a voltage change." "0,1"
        bitfld.long 0x00 24.--27. "     UDR_AP_SLP_VL      ,required voltage level in udr ap_sleep mode" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 23. "  NUDR_AP_SLP_AVC_EN   ,automatic voltage change enable in non-udr ap_sleep mode(ap_d1 mode)  0 =  automatic voltage change is disabled  1 = automatic voltage change is enabled  when the ap subsystem enters into non-udr ap_sleep mode,  hardware automatically triggers a voltage change." "0,1"
        bitfld.long 0x00 16.--19. "   NUDR_AP_SLP_VL   ,required voltage level in non-udr ap_sleep mode" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        textline "                         "
        bitfld.long 0x00 15. "AP_IDLE_DDROFF_AVC_EN         ,automatic voltage change enable in ap_idle_ddroff mode(ap_d1pp mode)  0 = automatic voltage change is disabled  1 = automatic voltage change is enabled  when the ap subsystem enters into ap_idle_ddroff mode,  hardware automatically triggers a voltage change request." "0,1"
        bitfld.long 0x00 8.--11. "     AP_IDLE_DDROFF_VL  ,required voltage level in ap_idle_ddroff mode( (ap_idle with ddr in self-refresh mode)" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 7. "  AP_IDLE_DDRON_AVC_EN ,automatic voltage change enable in ap_idle_ddron mode(ap_d1p mode)  0 = automatic voltage change is disabled  1 = automatic voltage change is enabled  when the ap subsystem enters into ap_idle_ddron mode,  hardware automatically triggers a voltage change request." "0,1"
        bitfld.long 0x00 0.--3. "   AP_IDLE_DDRON_VL ,required voltage level in ap_idle_ddron mode (ap_idle with ddr on mode)" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"

group d:0xD4052030++0x03
    line.long 0x00 "DVC_CHIP,Chip Top Dynamic Voltage Change Register"
        bitfld.long 0x00 15. " UDR_SLP_AVC_EN                ,automatic voltage change enable in udr chip sleep mode(d2 mode) with vctcxo on  0 = automatic voltage change is disabled  1 = automatic voltage change is enabled  when udr chip sleep mode is entered,  hardware automatically triggers a voltage change request." "0,1"
        bitfld.long 0x00 8.--11. "     UDR_SLP_VL         ,required voltage level in udr chip sleep mode with vctcxo on" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 7. "  NUDR_SLP_AVC_EN      ,automatic voltage change enable in non-udr chip sleep mode(d1 mode) with vctcxo on  0 = automatic voltage change is disabled  1 = automatic voltage change is enabled  when non-udr chip sleep mode is entered,  hardware automatically triggers a voltage change request." "0,1"
        bitfld.long 0x00 0.--3. "   NUDR_SLP_VL      ,required voltage level in non-udr chip sleep mode with vctcxo on" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"

group d:0xD4052040++0x03
    line.long 0x00 "DVC_STATUS,Dynamic Voltage Change Status Register"
        bitfld.long 0x00 24.--27. " DV_CAUSE73                    ,dvc cause  this field is the cause of the current ongoing dvc. it is only valid when the <dynamic voltage change status> field is 1.   0x1 = <var processor: application mp> software-triggered dvc   0x8 = hw-dfc triggered dvc <p>0x2=rsvd. <p>0x4=rsvd.   others = lpm entry/exit trigger dvc" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 16.--19. "    DV_TVL3:075        ,target voltage level of vcc_main" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 8.--11. "  DV_CVL3:077          ,current voltage level of vcc_main" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 0. "  DV_DVC_STATUS79  ,voltage change status  the voltage change may be triggered in active state or entering low power mode.  0 = there is no voltage change or a voltage change has finished  1 = voltage change is in progress" "0,1"

group d:0xD4052050++0x03
    line.long 0x00 "DVC_IMR, DVC Interrupt Mask Register"
        bitfld.long 0x00 0. " AP_VC_DONE_INTR_MASK          ,ap software triggered dvc done interrupt mask  1 = interrupt enabled  0 = interrupt disabled" "0,1"

group d:0xD4052054++0x03
    line.long 0x00 "DVC_ISR, DVC Interrupt Status Register"
        bitfld.long 0x00 0. " AP_VC_DONE_INTR_ISR           ,ap software triggered dvc done interrupt status   read 0 indicates no interrupt active. software write 0 to this bit to clear this interrupt  read 1 indicates interrupt is active. software write 1 has no effect to this bit's value" "0,1"

group d:0xD4052058++0x03
    line.long 0x00 "DVC_DEBUG, DVC Debug Register"
        bitfld.long 0x00 2. " TOP_REDUN_FUSE_LOAD_DONE_MASK ,top redundacy fuse load done check mask.   0x1=mask." "0,1"
        bitfld.long 0x00 1. "     CNT_DIS_FOR_VL_DWN ,enable/disable dvc stable timer counting when voltage change from high to low   0x0 = enabled   0x1 = disabled" "0,1"
        bitfld.long 0x00 0. "   M_DVC_CHECK_MASK     ,dvc check mask in main  state machine  0 = dvc status check is enabled  1 = dvc status check is masked" "0,1"

group d:0xD405205C++0x03
    line.long 0x00 "DVC_EXTRA_STR,DVC Extra Stable Time Register"
        hexmask.long.word 0x00 0.--15. 1. " DVC_EXTRA_STR                 ,extra stable time needed for dvc except voltage ramp up time in vctcxo cycles."

group d:0xD4052060++0x03
    line.long 0x00 "VL01STR,Voltage Level 0 to Level 1 Stable Time Register"
        hexmask.long.word 0x00 0.--15. 1. " VL56_ST121                    ,voltage level 0 to level 1 stable time  this field determines the wait time for a voltage change from level 0 to level 1 in vctcxo cycles."

group d:0xD4052064++0x03
    line.long 0x00 "VL12STR,Voltage Level 1 to Level 2 Stable Time Register"
        hexmask.long.word 0x00 0.--15. 1. " VL56_ST130                    ,voltage level 1 to level 2 stable time  this field determines the wait time for a voltage change from level 1 to level 2 in vctcxo cycles."

group d:0xD4052068++0x03
    line.long 0x00 "VL23STR,Voltage Level 2 to Level 3 Stable Time Register"
        hexmask.long.word 0x00 0.--15. 1. " VL56_ST138                    ,voltage level 2 to level 3 stable time  this field determines the wait time for a voltage change from level 2 to level 3 in vctcxo cycles."

group d:0xD405206C++0x03
    line.long 0x00 "VL34STR,Voltage Level 3 to Level 4 Stable Time Register"
        hexmask.long.word 0x00 0.--15. 1. " VL56_ST147                    ,voltage level 3 to level 4 stable time  this field determines the wait time for a voltage change from level 3 to level 4 in vctcxo cycles."

group d:0xD4052070++0x03
    line.long 0x00 "VL45STR,Voltage Level 4 to Level  5 Stable Time Register"
        hexmask.long.word 0x00 0.--15. 1. " VL78_ST155                    ,voltage level 4 to level 5 stable time  this field determines the wait time for a voltage change from level 4 to level 5 in vctcxo cycles."

group d:0xD4052074++0x03
    line.long 0x00 "VL56STR,Voltage Level 5 to Level  6 Stable Time Register"
        hexmask.long.word 0x00 0.--15. 1. " VL78_ST163                    ,voltage level 5 to level 6 stable time  this field determines the wait time for a voltage change from level 5 to level 6 in vctcxo cycles."

group d:0xD4052078++0x03
    line.long 0x00 "VL67STR,Voltage Level 6 to Level  7 Stable Time Register"
        hexmask.long.word 0x00 0.--15. 1. " VL78_ST171                    ,voltage level 6 to level 7 stable time  this field determines the wait time for a voltage change from level 6 to level 7 in vctcxo cycles."

group d:0xD405207C++0x03
    line.long 0x00 "VL78STR,Voltage Level 7 to Level  8 Stable Time Register"
        hexmask.long.word 0x00 0.--15. 1. " VL78_ST179                    ,voltage level 7 to level 8 stable time  this field determines the wait time for a voltage change from level 7 to level 8 in vctcxo cycles."

group d:0xD4052080++0x03
    line.long 0x00 "VL89STR,Voltage Level 8 to Level 9 Stable Time Register"
        hexmask.long.word 0x00 0.--15. 1. " VL89_ST                       ,voltage level 8 to level 9 stable time  this field determines the wait time for a voltage change from level 8 to level 9 in vctcxo cycles."

group d:0xD4052084++0x03
    line.long 0x00 "VL910STR,Voltage Level 9 to Level  10 Stable Time Register"
        hexmask.long.word 0x00 0.--15. 1. " VL910_ST                      ,voltage level 9 to level 10 stable time  this field determines the wait time for a voltage change from level 9 to level 10 in vctcxo cycles."

group d:0xD4052088++0x03
    line.long 0x00 "VL1011STR,Voltage Level 10 to Level 11 Stable Time Register"
        hexmask.long.word 0x00 0.--15. 1. " VL1011_ST                     ,voltage level 10 to level 11 stable time  this field determines the wait time for a voltage change from level 10 to level 11 in vctcxo cycles."

group d:0xD405208C++0x03
    line.long 0x00 "VL1112STR,Voltage Level 11 to Level  12 Stable Time Register"
        hexmask.long.word 0x00 0.--15. 1. " VL1112_ST                     ,voltage level 11 to level 12 stable time  this field determines the wait time for a voltage change from level 11 to level 12 in vctcxo cycles."

group d:0xD4052090++0x03
    line.long 0x00 "VL1213STR,Voltage Level 12 to Level  13 Stable Time Register"
        hexmask.long.word 0x00 0.--15. 1. " VL1213_ST                     ,voltage level 12 to level 13 stable time  this field determines the wait time for a voltage change from level 12 to level 13 in vctcxo cycles."

group d:0xD4052094++0x03
    line.long 0x00 "VL1314STR,Voltage Level 13 to Level  14 Stable Time Register"
        hexmask.long.word 0x00 0.--15. 1. " VL1314_ST                     ,voltage level 13 to level 14 stable time  this field determines the wait time for a voltage change from level 13 to level 14 in vctcxo cycles."

group d:0xD4052098++0x03
    line.long 0x00 "VL1415STR,Voltage Level 14 to Level  15 Stable Time Register"
        hexmask.long.word 0x00 0.--15. 1. " VL1415_ST                     ,voltage level 14 to level 15 stable time  this field determines the wait time for a voltage change from level 14 to level 15 in vctcxo cycles."

tree.end

tree "pmumain"

width 16.

group d:0xD4050004++0x03
    line.long 0x00 "CPSR,Marvell Seagull/Mohawk Power Status Register"
        bitfld.long 0x00 31. " MAI_DSPIDL24          ,reflects the state of the marvell msa core (not marvell msa subsystem). the availability of the marvell msa subsystem memories and peripheral bus to the marvell seagull/mohawk core is still governed by means of mpcrx[dspsd], and is not reflected by this bit.  0 = marvell msa core is currently not in idle state  1 = marvell msa core is currently in idle state" "0,1"
        bitfld.long 0x00 30. "       AP_IDLE25             ,reflects the state of the marvell mohawk core.  0x1= core is in external idle or power off mode" "0,1"
        bitfld.long 0x00 29. "     MAI_SG_IDLE26                ,1 = <var processor: comm> is idle   0 = <var processor: comm> is active" "0,1"
        bitfld.long 0x00 28. "       MAI_DSPAVL27             ,marvell msa subsystem availability indication. this field should be read after mpcrx[dspsd] is deasserted, to verify the clock is resumed  0 = marvell msa subsystem clock is not running  1 = marvell msa subsystem clock is running" "0,1"
        textline "                          "
        bitfld.long 0x00 27. "AP_WFI28              ,reflects the state of the marvell mohawk core.  0 = marvell mohawk core is currently not in wfi state  1 = marvell mohawk core is currently in wfi state" "0,1"
        bitfld.long 0x00 26. "       SG_WFI29              , seagull wfi flag. it reflects the wfi flag that is directly output from seagull. when seagull enters wfi, this field will be set." "0,1"
        bitfld.long 0x00 25. "     APOFF30                      ,reflects the power state of the marvell mohawk core.   1 = core is currently in power-off mode" "0,1"
        bitfld.long 0x00 24. "       MAI_COMM_TOP_D231        ,reflects the power state of comm_top   1 = comm_top is in d2 mode. in this mode, msa/seagull are powered off" "0,1"
        textline "                          "
        bitfld.long 0x00 0.--3. "MAI_COMM_TOP_STATE33  ,comm_top low power state   0x8=comm_top is in d0 state    0xb=comm_top is in d2 state" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"

group d:0xD4050008++0x03
    line.long 0x00 "FCCR,Frequency Change Control Register"
        bitfld.long 0x00 28. " I2SCLKSEL             ,i<super 2>s divider clock selection  1 = from vctcxo  0 = from 312 mhz clock" "0,1"
        hexmask.long.word 0x00 0.--8. 1. "       PLL1FBD44             ,actually this register bits are not used in auiqla, it's fixed to 0x30 now."

group d:0xD405000C++0x03
    line.long 0x00 "POCR,PLL and Oscillator Control Register"
        bitfld.long 0x00 31. " FORCE                 ,force all  clocks to be free running  0 = this field does not affect  clock gating  1 = all  output clocks are never gated" "0,1"
        hexmask.long.byte 0x00 16.--23. 1. "       VCXOST                ,determines the wait time for vctcxo and clock limiter stabilization. referred to as d1 in table 36.  0x0 = wait time = one 32.768 khz clock cycle  0x1 = wait time = two 32.768 khz clock cycles  \xc9   0xe5  wait time = 230 32.768 khz clock cycles  0xe6  reserved  \xc9   0xff  reserved"
        hexmask.long.word 0x00 0.--11. 1. "    WAITPLLLOCKTIMEVALUE         ,determines the wait time for pll lock. referred to as d2 in table 36. this value determines lock time for both plls (pll1 and pll2).  0x0 = main pll lock time = 1 vctcxo/2 cycle   0x1 = main pll lock time = 2 vctcxo/2 cycles           \xc9   0xfff  main pll lock time = 4096 vctcxo/2 cycles"

group d:0xD4050010++0x03
    line.long 0x00 "POSR,PLL and Oscillator Status Register"
        bitfld.long 0x00 27. " MAI_PLL1_LOCK63       ,1: pll1 is locked" "0,1"
        hexmask.long.byte 0x00 18.--25. 1. "       PLL2REFD              ,pll2 refdiv  decoding -tbd"
        hexmask.long.word 0x00 9.--17. 1. "    PLL2FBD                      ,pll2 fbdiv   decoding - tbd"
        hexmask.long.word 0x00 0.--8. 1. "    PLL1FBD67                ,pll1 fbdiv   decoding - tbd"

group d:0xD4050014++0x03
    line.long 0x00 "SUCCR,Slow UART (UART 1) Clock Generation Control Register"
        hexmask.long.word 0x00 16.--28. 1. " UARTDIVN              ,uart clock generation programmable divider numerator value.  the uart clock is generated using a fractional divider. see section 1.5.2.3, slow uart clock divider programming, on page 73 for calculating the required values. this divider configuration is common to all uart modules"
        hexmask.long.word 0x00 0.--12. 1. "    UARTDIVD              ,uart clock generation programmable divider denominator value.  the uart clock is generated using a fractional divider. see section 1.5.2.3, slow uart clock divider programming, on page 73 for calculating the required values. this divider configuration is common to all uart modules"

group d:0xD4050018++0x03
    line.long 0x00 "VRCR,VCTCXO SW request Control Register"
        hexmask.long.tbyte 0x00 9.--31. 1. " MAI_83                ,"
        bitfld.long 0x00 8. "  SW_REQ                ,sw request of vctcxo" "0,1"
        bitfld.long 0x00 7. "     MAI_85                       ," "0,1"
        bitfld.long 0x00 6. "       REQ_POL2                 ,vcxo_req2 request polarity" "0,1"
        textline "                          "
        bitfld.long 0x00 5. "REQ_POL1              ,vcxo_req1 request polarity" "0,1"
        bitfld.long 0x00 4. "       REQ_POL0              ,vcxo_req request polarity" "0,1"
        bitfld.long 0x00 3. "     MAI_89                       ," "0,1"
        bitfld.long 0x00 2. "       REQ_EN2                  ,enable vcxo_req2 for vcxo_out2" "0,1"
        textline "                          "
        bitfld.long 0x00 1. "REQ_EN1               ,enable vcxo_req1 for vcxo_out1" "0,1"
        bitfld.long 0x00 0. "       REQ_EN0               ,enable vcxo_req for vcxo_out" "0,1"

group d:0xD405001C++0x03
    line.long 0x00 "PLL3CR,PLL3 Control Register"
        bitfld.long 0x00 30.--31. " PLL3SSC_MODE          ,spectrum spread mode 00: center-spread 01: up-spread 10: down-spread 11: down-spread" "0,1,2,3"
        bitfld.long 0x00 29. "       MAI_SSC_FORCE_LOCK100 ,set pll force lock  0: disable 1: enable, when reg3<4>=0, set force lock to pll_lk signal" "0,1"
        bitfld.long 0x00 28. "     MAI_SPRD_DEP_STEP101         ,increase spectrum spread depth by 2 0: disable 1: spread depth x2" "0,1"
        bitfld.long 0x00 24.--27. "       MAI_SPRD_DEP102          ,set spectrum spread depth(peak-peak) 0000: no ssc 0001: 500ppm 0010: 1000ppm 0011: 1500ppm 0100: 2000ppm 0101: 2500ppm 0110: 3000ppm 0111: 3500ppm 1000: 4000ppm 1001: 4500ppm 1010: 5000ppm 1011: 5500ppm 1100: 6000ppm 1101: 6000ppm 1110: 6000ppm 1111: 6000ppm" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        textline "                          "
        bitfld.long 0x00 19. "PLL3_PU               ,pll3 power on  0 = pll off  1 = pll on; pll3 is automatically off whenever pll is off." "0,1"
        hexmask.long.byte 0x00 8.--14. 1. "       PLL3_FBDIV            ,pll3 fbdiv"
        hexmask.long.byte 0x00 0.--7. 1. "    PLL3_FRCDIV                  ,pll3 frcdiv"

group d:0xD4050028++0x03
    line.long 0x00 "CRSR,Marvell Seagull/Mohawk Reset Status Register"
        bitfld.long 0x00 8.--11. " MAI_SWR116            ,software controlled, reset events tracking field. this field may be written (and read) to any value between 0x0 and 0xf.   this field's content does not affect  functionality in any way" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 2. "      MAI_WDTR118           ,indicates whether the last system reset was caused by a watchdog timer reset event  0 = last system reset was not caused by watchdog timer reset  1 = last system reset was caused by watchdog timer reset  depending on the type of reset the device has experienced, one of the reset values in [2:0] is 1 and the others are 0." "0,1"
        bitfld.long 0x00 1. "     MAI_EMR119                   ,indicates whether the last system reset was caused by an external master reset event  0 = last system reset was not caused by external master reset  1 = last system reset was caused by external master reset  depending on the type of reset the device has experienced, one of the reset values in [2:0] is 1 and the others are 0." "0,1"
        bitfld.long 0x00 0. "       MAI_POR120               ,indicates whether the last system reset was caused by a power on reset  event  0 = last system reset was not caused by power on reset  1 = last system reset was caused by power on reset  depending on the type of reset the device has experienced, one of the reset values in [2:0] is 1 and the others are 0." "0,1"

group d:0xD405002C++0x03
    line.long 0x00 "XDCR,Delay control register for WFSTATE"
        hexmask.long.byte 0x00 24.--31. 1. " XDCR_TIE4             ,pmost_cnt_done (pmose to drowsy)"
        hexmask.long.byte 0x00 16.--23. 1. "      XDCR_TO2              ,firewall_cnt2-done (from firewall to prefirewall2)"
        hexmask.long.word 0x00 0.--15. 1. "    XDCR_TO1                     ,nmos_cnt2_done (from nmos2 to firewall)"

group d:0xD4050030++0x03
    line.long 0x00 "GPCR,General Purpose Clock Generation Control Register"
        hexmask.long.word 0x00 16.--31. 1. " GPCDIVN               ,general purpose clock generation programmable divider numerator value.  this clock is generated using a fractional divider, off the vctcxo clock. see section 1.5.2.3, slow uart clock divider programming, on page 73 for examples of calculating the programmed values."
        hexmask.long.word 0x00 0.--15. 1. "    GPCDIVD               ,general purpose clock generation programmable divider denominator value.  this clock is generated using a fractional divider, off the vctcxo clock. see section 1.5.2.3, slow uart clock divider programming, on page 73 for examples of calculating the programmed values."

group d:0xD4050034++0x03
    line.long 0x00 "PLL2CR,PLL2 Control Register"
        bitfld.long 0x00 30.--31. " PLL2SSC_MODE          ,spectrum spread mode 00: center-spread 01: up-spread 10: down-spread 11: down-spread" "0,1,2,3"
        bitfld.long 0x00 29. "       MAI_SSC_FORCE_LOCK145 ,set pll force lock  0: disable 1: enable, when reg3<4>=0, set force lock to pll_lk signal" "0,1"
        bitfld.long 0x00 28. "     MAI_SPRD_DEP_STEP146         ,increase spectrum spread depth by 2 0: disable 1: spread depth x2" "0,1"
        bitfld.long 0x00 24.--27. "       MAI_SPRD_DEP147          ,set spectrum spread depth(peak-peak) 0000: no ssc 0001: 500ppm 0010: 1000ppm 0011: 1500ppm 0100: 2000ppm 0101: 2500ppm 0110: 3000ppm 0111: 3500ppm 1000: 4000ppm 1001: 4500ppm 1010: 5000ppm 1011: 5500ppm 1100: 6000ppm 1101: 6000ppm 1110: 6000ppm 1111: 6000ppm" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        textline "                          "
        bitfld.long 0x00 19. "PLL2_PU               ,pll2 power on  0 = pll2 off  1 = pll2 on; pll3 is automatically off whenever pll1 is off." "0,1"
        hexmask.long.byte 0x00 8.--14. 1. "       PLL2_FBDIV            ,pll2 fbdiv"
        hexmask.long.byte 0x00 0.--7. 1. "    PLL2_FRCDIV                  ,pll2 frcdiv"

group d:0xD4050038++0x03
    line.long 0x00 "SCCR,Slow Clock Control Register"
        bitfld.long 0x00 2. " BB_F_SLP_EN           ,force modem into sleep mode." "0,1"
        bitfld.long 0x00 1. "       AFE_CLK_EN            ,afe calibration clock (26 mhz vcxo) enable  0 = disable  1 = enable" "0,1"
        bitfld.long 0x00 0. "     SCS                          ,slow clock select:  0 = 32khz internal clock is derived from vctcxo divider  1 = 32khz internal clock uses 32khz clock input" "0,1"

group d:0xD4050040++0x03
    line.long 0x00 "ISCCRx,I2S Clock Generation Control Register"
        bitfld.long 0x00 31. " MAI_SYSCLK_EN169      ,enables the i2s clock input to sysclkn generator as well as the output of the generator." "0,1"
        bitfld.long 0x00 30. "       MAI_SYSCLK_BASE170    ,selects the i2s m/n divider input clock frequency:  0 = sysclkn generator base clock rate is 26 mhz  1 = sysclkn generator base clock rate is 156 mhz." "0,1"
        bitfld.long 0x00 29. "     MAI_BITCLK_EN171             ,enables the i2s clock input to the bit clock generator." "0,1"
        bitfld.long 0x00 27.--28. "       MAI_BITCLK_DIV_468172    ,determine bitclk1:sysclk1 relation:  0x0 = reserved  0x1 = bitclk1 rate is the sysclk1 rate divide by 4  0x2 = bitclk1 rate is the sysclk1 rate divide by 6  0x3 = bitclk1 rate is the sysclk1 rate divide by 8" "0,1,2,3"
        textline "                          "
        hexmask.long.word 0x00 15.--26. 1. "MAI_DENOM173          ,i2s clock generation programmable divider denominator value.  the i2s sysclk is generated using a fractional divider. see section 1.5.2.4, i2s clock divider programming, on page 74 for calculating the required values."
        hexmask.long.word 0x00 0.--14. 1. "    MAI_NOM174            ,i2s clock generation programmable divider numerator value.  the i2s sysclk is generated using a fractional divider. see section 1.5.2.4, i2s clock divider programming, on page 74 for calculating the required values."

group d:0xD405004C++0x03
    line.long 0x00 "PLL5CR,PLL5 Control Register"
        bitfld.long 0x00 30.--31. " PLL5SSC_MODE181       ,spectrum spread mode 00: center-spread 01: up-spread 10: down-spread 11: down-spread" "0,1,2,3"
        bitfld.long 0x00 29. "       MAI_SSC_FORCE_LOCK182 ,set pll force lock  0: disable 1: enable, when reg3<4>=0, set force lock to pll_lk signal" "0,1"
        bitfld.long 0x00 28. "     MAI_SPRD_DEP_STEP183         ,increase spectrum spread depth by 2 0: disable 1: spread depth x2" "0,1"
        bitfld.long 0x00 24.--27. "       MAI_SPRD_DEP184          ,set spectrum spread depth(peak-peak) 0000: no ssc 0001: 500ppm 0010: 1000ppm 0011: 1500ppm 0100: 2000ppm 0101: 2500ppm 0110: 3000ppm 0111: 3500ppm 1000: 4000ppm 1001: 4500ppm 1010: 5000ppm 1011: 5500ppm 1100: 6000ppm 1101: 6000ppm 1110: 6000ppm 1111: 6000ppm" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        textline "                          "
        bitfld.long 0x00 19. "PLL5_PU               ,pll5 power on  0 = pll5 off  1 = pll on; pll5 is automatically off whenever pll is off." "0,1"
        hexmask.long.byte 0x00 8.--14. 1. "       PLL5_FBDIV            ,pll5 fbdiv"
        hexmask.long.byte 0x00 0.--7. 1. "    PLL5_FRCDIV                  ,pll5 frcdiv"

group d:0xD4050050++0x03
    line.long 0x00 "PLL4CR,PLL4 Control Register"
        bitfld.long 0x00 30.--31. " PLL5SSC_MODE196       ,spectrum spread mode 00: center-spread 01: up-spread 10: down-spread 11: down-spread" "0,1,2,3"
        bitfld.long 0x00 29. "       MAI_SSC_FORCE_LOCK197 ,set pll force lock  0: disable 1: enable, when reg3<4>=0, set force lock to pll_lk signal" "0,1"
        bitfld.long 0x00 28. "     MAI_SPRD_DEP_STEP198         ,increase spectrum spread depth by 2 0: disable 1: spread depth x2" "0,1"
        bitfld.long 0x00 24.--27. "       MAI_SPRD_DEP199          ,set spectrum spread depth(peak-peak) 0000: no ssc 0001: 500ppm 0010: 1000ppm 0011: 1500ppm 0100: 2000ppm 0101: 2500ppm 0110: 3000ppm 0111: 3500ppm 1000: 4000ppm 1001: 4500ppm 1010: 5000ppm 1011: 5500ppm 1100: 6000ppm 1101: 6000ppm 1110: 6000ppm 1111: 6000ppm" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        textline "                          "
        bitfld.long 0x00 19. "PLL4_PU               ,pll4 power on  0 = pll off  1 = pll on; pll4 is automatically off whenever pll4 is off." "0,1"
        hexmask.long.byte 0x00 8.--14. 1. "       PLL4_FBDIV            ,pll4 fbdiv"
        hexmask.long.byte 0x00 0.--7. 1. "    PLL4_FRCDIV                  ,pll4 frcdiv"

group d:0xD4050054++0x03
    line.long 0x00 "FCAP,<var Processor: Application> Core Frequency Change Control Register"
        bitfld.long 0x00 8.--10. " C2_PLLSEL             ,<var processor: application> cluster2 core clock selection  0x0 = pll1 1248 mhz  0x1 = pll1 832 mhz     0x2= pll3_div2(1.05g)   0x3=pll2_div2          0x4=pll5_div1   0x5=pll6_div1      0x6=pll4_div1(1.75g)             0x7=pll3_div1(2.1g)" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 4.--6. "       C1_PLLSEL             ,<var processor: application> cluster1 core clock selection  0x0 = pll1 1248 mhz  0x1 = pll1 832 mhz     0x2= pll3_div2(1.05g)   0x3=pll2_div2   0x4=pll5_div1   0x5=pll6_div1   0x6=pll4_div1(1.75g)    0x7 = reserved" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 0.--2. "     C0_PLLSEL                    ,<var processor: application> cluster0 core clock selection  0x0 = pll1 624 mhz  0x1 = pll1 832 mhz     0x2= pll1 499mhz    0x3 = pll3_div2(1.05g)    0x4 = pll1 1248mhz     0x5~0x7 reserved" "0,1,2,3,4,5,6,7"

group d:0xD405005C++0x03
    line.long 0x00 "FCDCLK,DCLK Frequency Change Control Register"
        bitfld.long 0x00 0.--2. " MAI_DCLKSEL225        ,ddr clock selection                7=pll3 div2                               6=pll5 div2                              0x5 = pll4 div2                             0x4 = pll2 div2                          0x3 = pll6_div1                           0x2 = pll2 div1                     0x1= pll1 832 mhz                          0x0 = pll1 624 mhz" "0,1,2,3,4,5,6,7"

group d:0xD4050060++0x03
    line.long 0x00 "FCACLK,ACLK Frequency Change Control Register"
        bitfld.long 0x00 0. " ACLKSEL               ,axi clock selection  0x0 = pll1 416 mhz  0x1 = pll1 312 mhz" "0,1"

group d:0xD4050100++0x03
    line.long 0x00 "DSOC,Debug Signals Output Control Register"
        bitfld.long 0x00 8. " TPCTL                 ,test points control mux select. this field determines whether the test points mux is controlled by tunit, by means of pm_ext_tpsel input port or by means of tpsel field of this register  0 = test points mux control is by means of pm_ext_tpsel input bus  1 = test points mux control is by means of dsoc[tpsel] field" "0,1"
        hexmask.long.byte 0x00 0.--6. 1. "       TPSEL                 ,test points mux select - each combination of these bits will yield a different set of signals driven on the cw_bus_out output bus. detailed description of these signals may be found in the  mas"

group d:0xD4050200++0x03
    line.long 0x00 "WDTPCR,WDT (CP Timers) Control Register"
        bitfld.long 0x00 4.--6. " MAI_FNCLKSEL253       ,0x0 = 13 mhz clock" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 2. "       MAI_RST255            ,timers h/w reset generation (resets both apb & functional domains)  0 = no reset  1 = reset" "0,1"
        bitfld.long 0x00 1. "     MAI_FNCLK256                 ,timers + wdtfunctional clock enable/disable  0 = clock off  1 = clock on" "0,1"
        bitfld.long 0x00 0. "       ABCLK                    ,cp timers and wdt apb bus clock enable/disable  0 = clock off  1 = clock on" "0,1"

group d:0xD4050210++0x03
    line.long 0x00 "RIPCCR,RIPC Control Register"
        bitfld.long 0x00 2. " MAI_RST265            ,r-ipc h/w reset generation  )  0 = no reset  1 = reset" "0,1"
        bitfld.long 0x00 0. "       MAI_APBCLK267         ,r-ipc apb bus clock enable/disable  0 = clock off  1 = clock on" "0,1"

group d:0xD4050214++0x03
    line.long 0x00 "DBG,DBG Register"
        bitfld.long 0x00 1. " DBG_CP_AXI_ACCESS_MSK ,debug used. mask communicon processor axi request.  0= not mask.  1= mask." "0,1"
        bitfld.long 0x00 0. "       DBG_CP_DDR_ACCESS_MSK ,debug used. mask communicon processor ddr request.  0= not mask.  1= mask." "0,1"

group d:0xD4051000++0x03
    line.long 0x00 "APSLPW,Marvell Seagull/Mohawk Power Control Register"
        bitfld.long 0x00 24. " MAI_INTCLR285         ,interrupt clear register.   a write of 1 followed by a write of 0 to this field clears the pm_moh_wakeup_int output of .  the read value is the last value written to this field." "0,1"
        bitfld.long 0x00 23. "       MAI_SLPWP0286         ,sleep mode wake-up decoder port 0 disable  0 = wake-up port 0 is enabled  1 = wake-up port 0 is disabled" "0,1"
        bitfld.long 0x00 22. "     MAI_SLPWP1287                ,sleep mode wake-up decoder port 1 disable  0 = wake-up port 1 is enabled  1 = wake-up port 1 is disabled" "0,1"
        bitfld.long 0x00 21. "       MAI_SLPWP2288            ,sleep mode wake-up decoder port 2 disable  0 = wake-up port 2 is enabled  1 = wake-up port 2 is disabled" "0,1"
        textline "                          "
        bitfld.long 0x00 20. "MAI_SLPWP3289         ,sleep mode wake-up decoder port 3 disable  0 = wake-up port 3 is enabled  1 = wake-up port 3 is disabled" "0,1"
        bitfld.long 0x00 18. "       MAI_SLPWP4291         ,sleep mode wake-up decoder port 4 disable  0 = wake-up port 4 is enabled  1 = wake-up port 4 is disabled" "0,1"
        bitfld.long 0x00 17. "     MAI_SLPWP5292                ,sleep mode wake-up decoder port 5 disable  0 = wake-up port 5 is enabled  1 = wake-up port 5 is disabled" "0,1"
        bitfld.long 0x00 16. "       MAI_SLPWP6293            ,sleep mode wake-up decoder port 6 disable  0 = wake-up port 6 is enabled  1 = wake-up port 6 is disabled" "0,1"
        textline "                          "
        bitfld.long 0x00 15. "MAI_SLPWP7294         ,sleep mode wake-up decoder port 7 disable  0 = wake-up port 7 is enabled  1 = wake-up port 7 is disabled" "0,1"

group d:0xD4051004++0x03
    line.long 0x00 "APSR,Marvell Seagull/Mohawk Power Status Register"
        bitfld.long 0x00 31. " MAI_DSPIDL303         ,reflects the state of the marvell msa core (not marvell msa subsystem). the availability of the marvell msa subsystem memories and peripheral bus to the marvell seagull/mohawk core is still governed by means of mpcrx[dspsd], and is not reflected by this bit.  0 = marvell msa core is currently not in idle state  1 = marvell msa core is currently in idle state" "0,1"
        bitfld.long 0x00 30. "       AP_IDLE304            ,reflects the state of the marvell mohawk core.  0x1= core is in external idle or power off mode" "0,1"
        bitfld.long 0x00 29. "     MAI_SG_IDLE305               ,1 = <var processor: comm> is idle   0 = <var processor: comm> is active" "0,1"
        bitfld.long 0x00 28. "       MAI_DSPAVL306            ,marvell msa subsystem availability indication. this field should be read after mpcrx[dspsd] is deasserted, to verify the clock is resumed  0 = marvell msa subsystem clock is not running  1 = marvell msa subsystem clock is running" "0,1"
        textline "                          "
        bitfld.long 0x00 27. "AP_WFI307             ,reflects the state of the marvell mohawk core.  0 = marvell mohawk core is currently not in wfi state  1 = marvell mohawk core is currently in wfi state" "0,1"
        bitfld.long 0x00 26. "       SG_WFI308             , seagull wfi flag. it reflects the wfi flag that is directly output from seagull. when seagull enters wfi, this field will be set." "0,1"
        bitfld.long 0x00 25. "     APOFF309                     ,reflects the power state of the marvell mohawk core.   1 = core is currently in power-off mode" "0,1"
        bitfld.long 0x00 24. "       MAI_COMM_TOP_D2310       ,reflects the power state of comm_top   1 = comm_top is in d2 mode. in this mode, msa/seagull are powered off" "0,1"
        textline "                          "
        bitfld.long 0x00 0.--3. "MAI_COMM_TOP_STATE312 ,comm_top low power state   0x8=comm_top is in d0 state    0xb=comm_top is in d2 state" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"

group d:0xD4051020++0x03
    line.long 0x00 "APRR,Marvell Seagull/Mohawk Programmable Reset Register"
        bitfld.long 0x00 31. " SGR_SEL               ,communication processor reset mode select.  1=direct mode. set cpr will reset communication processor immediately.  0=silent reset mode. set cpr will not reset communication processor immediately. only when all communication processor memory and register request finished, communication processor can be reseted." "0,1"
        bitfld.long 0x00 30. "       SGR_RST               ,communication processor reset status.  1= communication processor at reset state.  0=communication at active state." "0,1"
        hexmask.long.tbyte 0x00 9.--29. 1. "     SIRST_CNT                    ,communication processor silent reset wait time this field determines the wait time for the completion of a silent reset to communication processor. when the wait counter has reached this value, silrst is set to 1."
        bitfld.long 0x00 8. "  RST_DONE                 ,reset done flag. this bit is set when sirst_cnt counter to 0" "0,1"
        textline "                          "
        bitfld.long 0x00 6. "MAI_SLAVE_R324        ,slave_reset_out pin sw reset control  1 = slave_reset_out is low.  0 = slave_reset_out may be high base on reset_in and wdt reset." "0,1"
        bitfld.long 0x00 5. "       MAI_DSRAMINT325       ,this signal hold the msa from start execution after released from reset. it will be used to hold msa from start execution till his boot address in sram will be initial with valid code.  1 = execution is hold  0 = msa is running" "0,1"
        bitfld.long 0x00 4. "     MAI_WDTR326                  ,negate hardware reset to the wdt after system reset. this field is reset due to a wdt reset event  reading 0 = wdt reset is still asserted from the last system reset  reading 1 = wdt reset is negated  writing 0 = operation is ignored  writing 1 = negates the wdt reset  the actual release of the wdt reset signal might be delayed by up to 11/2 cycles of the 32.768 khz clock" "0,1"
        bitfld.long 0x00 3. "       MAI_BBR327               ,apply global hardware reset to the baseband logic  0 = hardware reset is negated  1 = hardware reset is asserted  the baseband logic reset is effected also from dprr register." "0,1"
        textline "                          "
        bitfld.long 0x00 2. "MAI_DSPR328           ,apply global hardware reset to the whole marvell msa subsystem.  0 = hardware reset is negated  1 = hardware reset is asserted" "0,1"
        bitfld.long 0x00 1. "       MAI_APR329            ,this is read only bit - cp_wf_fuse  0 = mohawk core was the second core to boot  1 = mohawk core was the first core to boot." "0,1"
        bitfld.long 0x00 0. "     MAI_CPR330                   ,apply hardware reset to the communication processor (seagull core).  1 = core is hold in reset.  0 = core is released from reset  the initial value of this bit is determined by cp_wf_fuse_not  cp_wf_fuse = 1 (seagull core is the first one to boot).  cp_wf_fose not is 0 when seagull wakeup first" "0,1"

group d:0xD4051024++0x03
    line.long 0x00 "ACGR,Marvell Seagull/Mohawk Clock Gating Register"
        bitfld.long 0x00 19. " MAI_WDT_13M339        ,enable the functional 13 mhz clock output of the main  to the watchdogtimer.  0 = clock not enabled  1 = clock enabled" "0,1"
        bitfld.long 0x00 16. "       MAI_CLK_1248M341      ,enable the functional 1248 mhz clock output.   0 = clock not enabled  1 = clock enabled" "0,1"
        bitfld.long 0x00 15. "     MAI_CLK_624M342              ,enable the functional 624 mhz clock output.   0 = clock not enabled  1 = clock enabled" "0,1"
        bitfld.long 0x00 14. "       MAI_CLK_832M343          ,enable the functional 832 mhz clock output.  0 = clock not enabled  1 = clock enabled" "0,1"
        textline "                          "
        bitfld.long 0x00 13. "MAI_CLK_312M344       ,enable the functional 312 mhz clock output.  0 = clock not enabled  1 = clock enabled" "0,1"
        bitfld.long 0x00 12. "       MAI_CLK_104M345       ,enable the functional 104 mhz clock output.  0 = clock not enabled  1 = clock enabled" "0,1"
        bitfld.long 0x00 11. "     MAI_CLK_52M346               ,enable the functional 52 mhz clock output for ap pmu and ap perihrals.  0 = clock not enabled  1 = clock enabled" "0,1"
        bitfld.long 0x00 10. "       MAI_CLK_48M347           ,enable the functional 48 mhz clock output.  0 = clock not enabled  1 = clock enabled" "0,1"
        textline "                          "
        bitfld.long 0x00 9. "MAI_GPC348            ,enable the m/n clock generator of the vcxo clockconfigured through gpcr, the clcok is output to vcxo_out pad func3  0 = clock not enabled  1 = clock enabled" "0,1"
        bitfld.long 0x00 8. "       MAI_AP_FUART349       ,enable the functional fast uart clock output (58.5 mhz) of the main  to the application processor apb portion.  0 = clock not enabled  1 = clock enabled" "0,1"
        bitfld.long 0x00 7. "     MAI_CLK_52M350               ,enable the functional 52 mhz clock output for apb peripherals  0 = clock not enabled  1 = clock enabled" "0,1"
        bitfld.long 0x00 6. "       MAI_AP_TWSI351           ,enable the 32m clock of the functional twsi clock output of the main  to the application processor apb portion.  0 = clock not enabled  1 = clock enabled" "0,1"
        textline "                          "
        bitfld.long 0x00 5. "MAI_CLK_208M352       ,enable the functional 208 mhz clock output.  0 = clock not enabled  1 = clock enabled" "0,1"
        bitfld.long 0x00 4. "       MAI_CLK_26M353        ,enable the functional 26 mhz clock output.  0 = clock not enabled  1 = clock enabled" "0,1"
        bitfld.long 0x00 3. "     MAI_CLK_13M354               ,enable the functional 13 mhz clock output.  0 = clock not enabled  1 = clock enabled" "0,1"
        bitfld.long 0x00 2. "       MAI_CLK_6.5M355          ,enable the functional 6.5 mhz clock output.  0 = clock not enabled  1 = clock enabled" "0,1"
        textline "                          "
        bitfld.long 0x00 1. "MAI_AP_SUART356       ,enable the functional m/n slow uart clock output (configured through succr) of the main  to the application processor apb portion. it's just uart slow clock(14.17m) source enable   0 = clock not enabled  1 = clock enabled." "0,1"
        bitfld.long 0x00 0. "       MAI_CLK_416M357       ,enable the functional 416 mhz clock output.   0 = clock not enabled  1 = clock enabled" "0,1"

group d:0xD4051028++0x03
    line.long 0x00 "ARSR,Marvell Seagull/Mohawk Reset Status Register"
        bitfld.long 0x00 8.--11. " MAI_SWR366            ,software controlled, reset events tracking field. this field may be written (and read) to any value between 0x0 and 0xf.   this field's content does not affect  functionality in any way" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 2. "      MAI_WDTR368           ,indicates whether the last system reset was caused by a watchdog timer reset event  0 = last system reset was not caused by watchdog timer reset  1 = last system reset was caused by watchdog timer reset  depending on the type of reset the device has experienced, one of the reset values in [2:0] is 1 and the others are 0." "0,1"
        bitfld.long 0x00 1. "     MAI_EMR369                   ,indicates whether the last system reset was caused by an external master reset event  0 = last system reset was not caused by external master reset  1 = last system reset was caused by external master reset  depending on the type of reset the device has experienced, one of the reset values in [2:0] is 1 and the others are 0." "0,1"
        bitfld.long 0x00 0. "       MAI_POR370               ,indicates whether the last system reset was caused by a power on reset  event  0 = last system reset was not caused by power on reset  1 = last system reset was caused by power on reset  depending on the type of reset the device has experienced, one of the reset values in [2:0] is 1 and the others are 0." "0,1"

group d:0xD4051030++0x03
    line.long 0x00 "PWRMODE_STAUTS,Power Mode Status Register"
        hexmask.long.word 0x00 16.--31. 1. " PWRMODE_STATUS377     ,this field indicates that the system has entered and exited which state. one bit for one low power mode. if set to 1 indicate the low power mode has occured. it is cleared by set 1 to approprate bit of clr_pwrmode_status  bit0 for d1p mode  bit1 for d1pp mode   bit2 for d1 mode  bit3 for d2 mode  bit 4 for d2p   bit5 for d2pp mode  bit6 for cluster0 m2  bit7 for cluster1 m2"
        hexmask.long.word 0x00 16.--31. 1. "    PWRMODE_STATUS378     ,this field indicates that the system has entered and exited which state. one bit for one low power mode. if set to 1 indicate the low power mode has occured. it is cleared by set 1 to approprate bit of clr_pwrmode_status  bit0 for d1p mode  bit1 for d1pp mode   bit2 for d1 mode  bit3 for d2 mode  bit 4 for d2p   bit5 for d2pp mode  bit6 for cluster0 m2  bit7 for cluster1 m2  bit8 for cluster2 m2"
        hexmask.long.word 0x00 0.--15. 1. "  CLR_PWRMODE_STATUS           ,clear power mode status. set 1 to cleare approprate of pwrmode_status bit."

group d:0xD4051048++0x03
    line.long 0x00 "AWUCRS,Wakeup and Clock Resume Lines Status Register"
        bitfld.long 0x00 31. " MAI_BB_DROWSY_EN386   ,bb_drowsy_en" "0,1"
        bitfld.long 0x00 30. "       MAI_BB_VCTCXO_REQ387  ,bb_vctcxo_req" "0,1"
        bitfld.long 0x00 29. "     MAI_MSA_WAKE_PM_BB_CLKRES388 ,msa_wake/pm_bb_clkres" "0,1"
        bitfld.long 0x00 28. "       MAI_PM_CLKRES389         ,pm_clkres" "0,1"
        textline "                          "
        bitfld.long 0x00 27. "MAI_GSM_WAKEUP390     ,gsm wakeup" "0,1"
        bitfld.long 0x00 26. "       MAI_FB_WAKEUP391      ,fb wakeup" "0,1"
        bitfld.long 0x00 25. "     MAI_AP_ASYNC_INT392          ,ap async int" "0,1"
        bitfld.long 0x00 24. "       MAI_AP_FULL_IDLE393      ,ap full idle" "0,1"
        textline "                          "
        bitfld.long 0x00 23. "MAI_SDH1_AUDIO394     ,sdh1/audio wakeup" "0,1"
        bitfld.long 0x00 22. "       MAI_SDH2395           ,sdh2 wakeup" "0,1"
        bitfld.long 0x00 21. "     MAI_KEYPRESS396              ,keypress" "0,1"
        bitfld.long 0x00 20. "       MAI_TRACKBALL397         ,trackball" "0,1"
        textline "                          "
        bitfld.long 0x00 19. "MAI_NEWROTARY398      ,newrotary" "0,1"
        bitfld.long 0x00 18. "       MAI_WDT399            ,wdt" "0,1"
        bitfld.long 0x00 17. "     MAI_RTC_ALARM400             ,rtc alarm" "0,1"
        bitfld.long 0x00 16. "       MAI_CP_TIMER_3401        ,cp timer 3" "0,1"
        textline "                          "
        bitfld.long 0x00 15. "MAI_CP_TIMER_2402     ,cp timer 2" "0,1"
        bitfld.long 0x00 14. "       MAI_CP_TIMER_1403     ,cp timer 1" "0,1"
        bitfld.long 0x00 13. "     MAI_AP1_TIMER_3404           ,ap1 timer 3" "0,1"
        bitfld.long 0x00 12. "       MAI_AP1_TIMER_2405       ,ap1 timer 2" "0,1"
        textline "                          "
        bitfld.long 0x00 11. "MAI_AP1_TIMER_1406    ,ap1 timer 1" "0,1"
        bitfld.long 0x00 10. "       MAI_AP0_2_TIMER_3407  ,ap0 timer 3 and ap2 timer 3" "0,1"
        bitfld.long 0x00 9. "     MAI_AP0_2_TIMER_2408         ,ap0 timer 2 and ap2 timer 2" "0,1"
        bitfld.long 0x00 8. "       MAI_AP0_2_TIMER_1409     ,ap0 timer 1 and ap2 timer 1" "0,1"
        textline "                          "
        bitfld.long 0x00 7. "MAI_WAKEUP7410        ,wakeup7 line in status" "0,1"
        bitfld.long 0x00 6. "       MAI_WAKEUP6411        ,wakeup6 line in status" "0,1"
        bitfld.long 0x00 5. "     MAI_WAKEUP5412               ,wakeup5 line in status" "0,1"
        bitfld.long 0x00 4. "       MAI_WAKEUP4413           ,wakeup4 line in status" "0,1"
        textline "                          "
        bitfld.long 0x00 3. "MAI_WAKEUP3414        ,wakeup3 line in status" "0,1"
        bitfld.long 0x00 2. "       MAI_WAKEUP2415        ,wakeup2 line in status" "0,1"
        bitfld.long 0x00 1. "     MAI_WAKEUP1416               ,wakeup1 line in status" "0,1"
        bitfld.long 0x00 0. "       MAI_WAKEUP0417           ,wakeup0 line in status" "0,1"

group d:0xD405104C++0x03
    line.long 0x00 "AWUCRM,Wakeup and Clock Resume Lines Mask Register"
        bitfld.long 0x00 31. " MAI_AUDIO_WAKEUP424   ,mask audio_wakeup" "0,1"
        bitfld.long 0x00 30. "       MAI_AP_GT_WAKEUP425   ,mask ap generic timer wakeup" "0,1"
        bitfld.long 0x00 29. "     MAI_GSM_WAKEUPWMX426         ,mask gsm wakeup from pm_clkres" "0,1"
        bitfld.long 0x00 28. "       MAI_FB_WAKEUPX427        ,mask fb wakeup from pm_clkres" "0,1"
        textline "                          "
        bitfld.long 0x00 27. "MAI_GSM_WAKEUPWM428   ,mask gsm wakeup from msa_wake" "0,1"
        bitfld.long 0x00 26. "       MAI_FB_WAKEUPWM429    ,mask fb wakeup rom msa_wake" "0,1"
        bitfld.long 0x00 25. "     MAI_AP_ASYNC_INT430          ,mask ap async int from pm_clkres" "0,1"
        bitfld.long 0x00 24. "       MAI_AP_FULL_IDLE431      ,mask ap full idle from pm_clkres" "0,1"
        textline "                          "
        bitfld.long 0x00 23. "MAI_SDH1_AUDIO432     ,mask sdh1/audio wakeup" "0,1"
        bitfld.long 0x00 22. "       MAI_SDH2433           ,mask sdh2 wakeup" "0,1"
        bitfld.long 0x00 21. "     MAI_KEYPRESS434              ,mask keypress wakeup" "0,1"
        bitfld.long 0x00 20. "       MAI_TRACKBALL435         ,mask trackball wakeup" "0,1"
        textline "                          "
        bitfld.long 0x00 19. "MAI_NEWROTARY436      ,mask newrotary wakeup" "0,1"
        bitfld.long 0x00 18. "       MAI_WDT437            ,mask wdt wakeup" "0,1"
        bitfld.long 0x00 17. "     MAI_RTC_ALARM438             ,mask rtc alarm wakeup" "0,1"
        bitfld.long 0x00 16. "       MAI_CP_TIMER_3439        ,mask cp timer int3 wakeup" "0,1"
        textline "                          "
        bitfld.long 0x00 15. "MAI_CP_TIMER_2440     ,mask cp timer int2 wakeup" "0,1"
        bitfld.long 0x00 14. "       MAI_CP_TIMER_1441     ,mask cp timer int1 wakeup" "0,1"
        bitfld.long 0x00 13. "     MAI_AP1_TIMER_3442           ,mask ap timer1 int3 wakeup" "0,1"
        bitfld.long 0x00 12. "       MAI_AP1_TIMER_2443       ,mask ap timer1 int2 wakeup" "0,1"
        textline "                          "
        bitfld.long 0x00 11. "MAI_AP1_TIMER_1444    ,mask ap timer1 int1 wakeup" "0,1"
        bitfld.long 0x00 10. "       MAI_AP0_2_TIMER_3445  ,mask ap timer0 and ap timer2 int3 wakeup" "0,1"
        bitfld.long 0x00 9. "     MAI_AP0_2_TIMER_2446         ,mask ap timer0 and ap timer2 int2 wakeup" "0,1"
        bitfld.long 0x00 8. "       MAI_AP0_2_TIMER_1447     ,mask ap timer0 and ap timer2 int1 wakeup" "0,1"
        textline "                          "
        bitfld.long 0x00 7. "MAI_WAKEUP7448        ,mask wakeup7 input to pm_clkres" "0,1"
        bitfld.long 0x00 6. "       MAI_WAKEUP6449        ,mask wakeup6 input to pm_clkres" "0,1"
        bitfld.long 0x00 5. "     MAI_WAKEUP5450               ,mask wakeup5 input to pm_clkres" "0,1"
        bitfld.long 0x00 4. "       MAI_WAKEUP4451           ,mask wakeup4 input to pm_clkres" "0,1"
        textline "                          "
        bitfld.long 0x00 3. "MAI_WAKEUP3452        ,mask wakeup3 input to pm_clkres" "0,1"
        bitfld.long 0x00 2. "       MAI_WAKEUP2453        ,mask wakeup2 input to pm_clkres" "0,1"
        bitfld.long 0x00 1. "     MAI_WAKEUP1454               ,mask wakeup1input to pm_clkres" "0,1"
        bitfld.long 0x00 0. "       MAI_WAKEUP0455           ,mask wakeup0 input to pm_clkres" "0,1"

group d:0xD4051050++0x03
    line.long 0x00 "APBCSCR,APB Clock Source Control Register"
        bitfld.long 0x00 0. " APB_52M               ,system apb clk source selection  0 = clock is 26 mhz  1 = clock is 52 mhz" "0,1"

group d:0xD4051064++0x03
    line.long 0x00 "AWUCRS1,Wakeup and Clock Resume Lines Status Register1"
        bitfld.long 0x00 0. " MAI_AP_GT_WAKEUP472   ,ap generic timer wakeup status" "0,1"

group d:0xD4051080++0x03
    line.long 0x00 "SHGPIOCTRL,Sensor hub GPIO control "
        bitfld.long 0x00 31. " BYPASS_SH_INT0        ,this bit used to select the interrupt source for sensor hub int0 0: from gpio74 interrupt 1:from pmic interrupt" "0,1"
        bitfld.long 0x00 25. "       SGADDRMAPEN481        ,this bit control the interrupt trigger type for pmic to audio island 0:high level trigger 1:low level trigger" "0,1"
        bitfld.long 0x00 24. "     EN_PMIC_INT                  ,0:disable  1:enable" "0,1"
        hexmask.long.byte 0x00 16.--23. 1. "       GPIO_OUT_SEL             ,bit[23:16] control the out put source for gpio81,80,79,78,65,66,65,62,61 0:from ap 1:from gpo of audio island"
        textline "                          "
        hexmask.long.byte 0x00 8.--15. 1. "INT_EN                ,bit[15:8] control the interrupt enable for gpio81~gpio74 . 0:disable  1:enable"
        hexmask.long.byte 0x00 0.--7. 1. "      INT_TYPE              ,bit[7:0] control the interrupt trigger type for gpio81~gpio74 . 0:high level trigger 1:low level trigger"

group d:0xD4051084++0x03
    line.long 0x00 "SGADDRMAP,Marvell Seagull  Address Map"
        bitfld.long 0x00 16. " SGADDRMAPEN493        ,seagull address map enable  1=enable  0=disable" "0,1"
        hexmask.long.word 0x00 0.--15. 1. "       SGADDRMAPTG           ,seagull address map target address. if seagull address map enable and seagull write to 0xffff003f to 0xffffffff and seagull read from 0xffff0000 to 0xffffffff, the high 16bit address will use sgaddrmaptg."

group d:0xD4051088++0x03
    line.long 0x00 "MSAADDRMAP,MSA  Address Map"
        bitfld.long 0x00 7. " MSAADDRMAPEN          ,msa address map enable  1=enable  0=disable" "0,1"
        hexmask.long.byte 0x00 0.--6. 1. "       MSAADDRMAPTG          ,msa address map target address. if msa address map enable and msa write/read address in the range from 0xd2000000 to 0xd3ffffff, msa address high 7bit will use msaaddrmaptg"

group d:0xD4051080++0x03
    line.long 0x00 "MSAMEMCTRL,MSA Memory Control"
        bitfld.long 0x00 31. " SRAM_FUSE_REPAIR_CTRL ," "0,1"
        bitfld.long 0x00 29.--30. "       MAI_GSRAM_WTC511      ,grayback gsram wtc" "0,1,2,3"
        bitfld.long 0x00 27.--28. "     MAI_GSRAM_RTC512             ,grayback gsram rtc" "0,1,2,3"
        bitfld.long 0x00 25.--26. "       MAI_GSRAM_ROM_RTC_REF513 ,grayback l2 rom rtc ref" "0,1,2,3"
        textline "                          "
        bitfld.long 0x00 22.--24. "MAI_GSRAM_ROM_RTC514  ,grayback l2 rom rtc" "0,1,2,3,4,5,6,7"
        hexmask.long.word 0x00 22.--30. 1. "       MAI_RESERVED515       ,"
        bitfld.long 0x00 21. "  PMU2GB_WAKEUP_EN             ,mask for pmu2gb_wakeup signal: 1 = not masked; 0 = masked" "0,1"
        bitfld.long 0x00 20. "       MSA_L1_PDLVMC            ,gb l1 memory pdlvmc" "0,1"
        textline "                          "
        bitfld.long 0x00 19. "MSA_L1_PDFVSSM        ,gb l1 memory pdfvssm" "0,1"
        bitfld.long 0x00 17.--18. "       MSA_L1_RTC_SACMEM     ,gb l1 memory rtc" "0,1,2,3"
        bitfld.long 0x00 15.--16. "     MSA_L1_WTC_SACMEM            ,gb l1 memory wtc" "0,1,2,3"
        bitfld.long 0x00 14. "       MSA_TRANSACTION_FIX      ,0 = gb wrap transaction fix enable; 1 = old implementation" "0,1"
        textline "                          "
        bitfld.long 0x00 13. "MSA_AIB_GB_L2_RATIO   ,aib gb l2 sram clock ratio" "0,1"
        bitfld.long 0x00 9.--12. "       MSA_AIB_GB_L2_LATENCY ,aib gb l2 sram latency" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 8. "    CPSRAM_PDFVSSM               ," "0,1"
        bitfld.long 0x00 7. "       CPSRAM_PDLVMC            ," "0,1"
        textline "                          "
        bitfld.long 0x00 5.--6. "CP_SRAM_WTC           ," "0,1,2,3"
        bitfld.long 0x00 3.--4. "       CP_SRAM_RTC           ," "0,1,2,3"
        bitfld.long 0x00 2. "     CP_SRAM_FIX_PRIOR0           ," "0,1"
        bitfld.long 0x00 1. "       CP_SRAM_PIPE_MEM         ," "0,1"
        textline "                          "
        bitfld.long 0x00 0. "CP_SRAM_CLOCK_GATING  ," "0,1"

group d:0xD4051090++0x03
    line.long 0x00 "APCR_CLUSTER0,Marvell <var Processor: Application MP> Cluster 0 Power Control Register"
        bitfld.long 0x00 31. " MAI_AXISDD538         ,allow axi bus and agents to be shut down after marvell <var processor: comm>/ <var processor: application> cores enters idle state.  0 = axi shutdown not allowed  1 = axi shutdown allowed" "0,1"
        bitfld.long 0x00 30. "       MAI_DSPSD539          ,not used" "0,1"
        bitfld.long 0x00 29. "     MAI_SLPEN540                 ,allow pmu to switch the system to sleep mode once it reached system idle mode.  0 = sleep mode not allowed  1 = sleep mode allowed" "0,1"
        bitfld.long 0x00 27. "       MAI_DDRCORSD542          ,allow marvell <var processor: comm>/<var processor: application mp> core and tc ddr clocks shutdown. the clocks are halted when cpcr[ddrcorsd], apcr[ddrcorsd] & dpcr[ddrcorsd] are set and marvell <var processor: application mp> core is in idle mode   0 = marvell <var processor: comm>/<var processor: application mp> core and tc ddr clocks shutdown not allowed  1 = marvell <var processor: comm>/<var processor: application mp> core and tc ddr clocks shutdown allowed" "0,1"
        textline "                          "
        bitfld.long 0x00 26. "MAI_APBSD543          ,allow pmu to shut down apb clock to all of its recipients, overriding other per-module fields. the apb clock is actually shut down once the marvell <var processor: comm>/ <var processor: application> cores are idle and cpcr[apbsd], apcr[apbsd] & dpcr[apbsd] are set  0 = apb clock shutdown not allowed  1 = apb clock shutdown allowed" "0,1"
        bitfld.long 0x00 25. "       MAI_BBSD544           ,allow pmu to shut down all clocks provided to the baseband logic, except 32.768 khz clock. the baseband logic clocks are halted as soon as cpcr[bbsd], apcr[bbsd] & dpcr[bbsd] are set and pm_bb_clkres port is negated.  0 = bb clocks shutdown not allowed  1 = bb clocks shutdown allowed" "0,1"
        bitfld.long 0x00 19. "     MAI_VCTCXOSD546              ,allow vctcxo shutdown when system is in sleep mode. vctcxo is shutdown when cpcr[vctcxosd], apcr[vctcxosd] & dpcr[vctcxosd] are set & the system enters sleep mode  0 = vctcxo shutdown not allowed  1 = vctcxo shutdown allowed" "0,1"
        bitfld.long 0x00 14. "       MAI_MSASLPEN548          ,allow msa to switch msa subsystem to sleep mode once it reached msa sub system idle mode.the sleep mode is allowed when cpcr[msaslpen], apcr[msaslpen] & dpcr[msaslpen]  0 = msa sleep mode not allowed  1 = msa sleep mode allowed  base on the cpmu setting, msa subsystem may be powered down." "0,1"
        textline "                          "
        bitfld.long 0x00 13. "MAI_STBYEN549         ,allow apps subsystem to shutdown and go into udr-mode when ap subsystem is in sleep mode. udr is enabled when cpcr[stbyen], apcr[stbyen] are both set & ap subsystem enters ap sleep." "0,1"
        bitfld.long 0x00 3. "       LDMA_MASK551          ,ldma mask  this field is used to mask the lte dma hardware voting for ddr shutdown.  0 = lte dma hardware voting for ddr shutdown enabled  1 = lte dma hardware voting for ddr shutdown not allowed" "0,1"

group d:0xD4051094++0x03
    line.long 0x00 "APCR_CLUSTER1,Marvell <var Processor: Application MP> Cluster 1 Power Control Register"
        bitfld.long 0x00 31. " MAI_AXISDD560         ,allow axi bus and agents to be shut down after marvell <var processor: comm>/ <var processor: application> cores enters idle state.  0 = axi shutdown not allowed  1 = axi shutdown allowed" "0,1"
        bitfld.long 0x00 30. "       MAI_DSPSD561          ,not used" "0,1"
        bitfld.long 0x00 29. "     MAI_SLPEN562                 ,allow pmu to switch the system to sleep mode once it reached system idle mode.  0 = sleep mode not allowed  1 = sleep mode allowed" "0,1"
        bitfld.long 0x00 27. "       MAI_DDRCORSD564          ,allow marvell <var processor: comm>/<var processor: application mp> core and tc ddr clocks shutdown. the clocks are halted when cpcr[ddrcorsd], apcr[ddrcorsd] & dpcr[ddrcorsd] are set and marvell <var processor: application mp> core is in idle mode   0 = marvell <var processor: comm>/<var processor: application mp> core and tc ddr clocks shutdown not allowed  1 = marvell <var processor: comm>/<var processor: application mp> core and tc ddr clocks shutdown allowed" "0,1"
        textline "                          "
        bitfld.long 0x00 26. "MAI_APBSD565          ,allow pmu to shut down apb clock to all of its recipients, overriding other per-module fields. the apb clock is actually shut down once the marvell <var processor: comm>/ <var processor: application> cores are idle and cpcr[apbsd], apcr[apbsd] & dpcr[apbsd] are set  0 = apb clock shutdown not allowed  1 = apb clock shutdown allowed" "0,1"
        bitfld.long 0x00 25. "       MAI_BBSD566           ,allow pmu to shut down all clocks provided to the baseband logic, except 32.768 khz clock. the baseband logic clocks are halted as soon as cpcr[bbsd], apcr[bbsd] & dpcr[bbsd] are set and pm_bb_clkres port is negated.  0 = bb clocks shutdown not allowed  1 = bb clocks shutdown allowed" "0,1"
        bitfld.long 0x00 19. "     MAI_VCTCXOSD568              ,allow vctcxo shutdown when system is in sleep mode. vctcxo is shutdown when cpcr[vctcxosd], apcr[vctcxosd] & dpcr[vctcxosd] are set & the system enters sleep mode  0 = vctcxo shutdown not allowed  1 = vctcxo shutdown allowed" "0,1"
        bitfld.long 0x00 14. "       MAI_MSASLPEN570          ,allow msa to switch msa subsystem to sleep mode once it reached msa sub system idle mode.the sleep mode is allowed when cpcr[msaslpen], apcr[msaslpen] & dpcr[msaslpen]  0 = msa sleep mode not allowed  1 = msa sleep mode allowed  base on the cpmu setting, msa subsystem may be powered down." "0,1"
        textline "                          "
        bitfld.long 0x00 13. "MAI_STBYEN571         ,allow apps subsystem to shutdown and go into udr-mode when ap subsystem is in sleep mode. udr is enabled when cpcr[stbyen], apcr[stbyen] are both set & ap subsystem enters ap sleep." "0,1"
        bitfld.long 0x00 3. "       LDMA_MASK573          ,ldma mask  this field is used to mask the lte dma hardware voting for ddr shutdown.  0 = lte dma hardware voting for ddr shutdown enabled  1 = lte dma hardware voting for ddr shutdown not allowed" "0,1"

group d:0xD405109C++0x03
    line.long 0x00 "APCR_CLUSTER2,Marvell <var Processor: Application MP> Cluster 2 Power Control Register"
        bitfld.long 0x00 31. " MAI_AXISDD583         ,allow axi bus and agents to be shut down after marvell <var processor: comm>/ <var processor: application> cores enters idle state.  0 = axi shutdown not allowed  1 = axi shutdown allowed" "0,1"
        bitfld.long 0x00 30. "       MAI_DSPSD584          ,not used" "0,1"
        bitfld.long 0x00 29. "     MAI_SLPEN585                 ,allow pmu to switch the system to sleep mode once it reached system idle mode.  0 = sleep mode not allowed  1 = sleep mode allowed" "0,1"
        bitfld.long 0x00 27. "       MAI_DDRCORSD587          ,allow marvell <var processor: comm>/<var processor: application mp> core and tc ddr clocks shutdown. the clocks are halted when cpcr[ddrcorsd], apcr[ddrcorsd] & dpcr[ddrcorsd] are set and marvell <var processor: application mp> core is in idle mode   0 = marvell <var processor: comm>/<var processor: application mp> core and tc ddr clocks shutdown not allowed  1 = marvell <var processor: comm>/<var processor: application mp> core and tc ddr clocks shutdown allowed" "0,1"
        textline "                          "
        bitfld.long 0x00 26. "MAI_APBSD588          ,allow pmu to shut down apb clock to all of its recipients, overriding other per-module fields. the apb clock is actually shut down once the marvell <var processor: comm>/ <var processor: application> cores are idle and cpcr[apbsd], apcr[apbsd] & dpcr[apbsd] are set  0 = apb clock shutdown not allowed  1 = apb clock shutdown allowed" "0,1"
        bitfld.long 0x00 25. "       MAI_BBSD589           ,allow pmu to shut down all clocks provided to the baseband logic, except 32.768 khz clock. the baseband logic clocks are halted as soon as cpcr[bbsd], apcr[bbsd] & dpcr[bbsd] are set and pm_bb_clkres port is negated.  0 = bb clocks shutdown not allowed  1 = bb clocks shutdown allowed" "0,1"
        bitfld.long 0x00 19. "     MAI_VCTCXOSD591              ,allow vctcxo shutdown when system is in sleep mode. vctcxo is shutdown when cpcr[vctcxosd], apcr[vctcxosd] & dpcr[vctcxosd] are set & the system enters sleep mode  0 = vctcxo shutdown not allowed  1 = vctcxo shutdown allowed" "0,1"
        bitfld.long 0x00 14. "       MAI_MSASLPEN593          ,allow msa to switch msa subsystem to sleep mode once it reached msa sub system idle mode.the sleep mode is allowed when cpcr[msaslpen], apcr[msaslpen] & dpcr[msaslpen]  0 = msa sleep mode not allowed  1 = msa sleep mode allowed  base on the cpmu setting, msa subsystem may be powered down." "0,1"
        textline "                          "
        bitfld.long 0x00 13. "MAI_STBYEN594         ,allow apps subsystem to shutdown and go into udr-mode when ap subsystem is in sleep mode. udr is enabled when cpcr[stbyen], apcr[stbyen] are both set & ap subsystem enters ap sleep." "0,1"
        bitfld.long 0x00 3. "       LDMA_MASK596          ,ldma mask  this field is used to mask the lte dma hardware voting for ddr shutdown.  0 = lte dma hardware voting for ddr shutdown enabled  1 = lte dma hardware voting for ddr shutdown not allowed" "0,1"

group d:0xD4051098++0x03
    line.long 0x00 "APCR_PER,Marvell Peripheral 1 Power Control Register"
        bitfld.long 0x00 31. " MAI_AXISDD606         ,allow axi bus and agents to be shut down after marvell <var processor: comm>/ <var processor: application> cores enters idle state.  0 = axi shutdown not allowed  1 = axi shutdown allowed" "0,1"
        bitfld.long 0x00 30. "       MAI_DSPSD607          ,not used" "0,1"
        bitfld.long 0x00 29. "     MAI_SLPEN608                 ,allow pmu to switch the system to sleep mode once it reached system idle mode.  0 = sleep mode not allowed  1 = sleep mode allowed" "0,1"
        bitfld.long 0x00 27. "       MAI_DDRCORSD610          ,allow marvell <var processor: comm>/<var processor: application mp> core and tc ddr clocks shutdown. the clocks are halted when cpcr[ddrcorsd], apcr[ddrcorsd] & dpcr[ddrcorsd] are set and marvell <var processor: application mp> core is in idle mode   0 = marvell <var processor: comm>/<var processor: application mp> core and tc ddr clocks shutdown not allowed  1 = marvell <var processor: comm>/<var processor: application mp> core and tc ddr clocks shutdown allowed" "0,1"
        textline "                          "
        bitfld.long 0x00 26. "MAI_APBSD611          ,allow pmu to shut down apb clock to all of its recipients, overriding other per-module fields. the apb clock is actually shut down once the marvell <var processor: comm>/ <var processor: application> cores are idle and cpcr[apbsd], apcr[apbsd] & dpcr[apbsd] are set  0 = apb clock shutdown not allowed  1 = apb clock shutdown allowed" "0,1"
        bitfld.long 0x00 25. "       MAI_BBSD612           ,allow pmu to shut down all clocks provided to the baseband logic, except 32.768 khz clock. the baseband logic clocks are halted as soon as cpcr[bbsd], apcr[bbsd] & dpcr[bbsd] are set and pm_bb_clkres port is negated.  0 = bb clocks shutdown not allowed  1 = bb clocks shutdown allowed" "0,1"
        bitfld.long 0x00 19. "     MAI_VCTCXOSD614              ,allow vctcxo shutdown when system is in sleep mode. vctcxo is shutdown when cpcr[vctcxosd], apcr[vctcxosd] & dpcr[vctcxosd] are set & the system enters sleep mode  0 = vctcxo shutdown not allowed  1 = vctcxo shutdown allowed" "0,1"
        bitfld.long 0x00 14. "       MAI_MSASLPEN616          ,allow msa to switch msa subsystem to sleep mode once it reached msa sub system idle mode.the sleep mode is allowed when cpcr[msaslpen], apcr[msaslpen] & dpcr[msaslpen]  0 = msa sleep mode not allowed  1 = msa sleep mode allowed  base on the cpmu setting, msa subsystem may be powered down." "0,1"
        textline "                          "
        bitfld.long 0x00 13. "MAI_STBYEN617         ,allow apps subsystem to shutdown and go into udr-mode when ap subsystem is in sleep mode. udr is enabled when cpcr[stbyen], apcr[stbyen] are both set & ap subsystem enters ap sleep." "0,1"
        bitfld.long 0x00 3. "       LDMA_MASK619          ,ldma mask  this field is used to mask the lte dma hardware voting for ddr shutdown.  0 = lte dma hardware voting for ddr shutdown enabled  1 = lte dma hardware voting for ddr shutdown not allowed" "0,1"

group d:0xD4053000++0x03
    line.long 0x00 "SPRR,Marvell Secure Core Programmable Reset Register"
        bitfld.long 0x00 7. " WDTRST                ,system hot reset  when this field is set to 1, it equals a watchdog reset event and watchdog reset generated. this field can only be write with a value of 1. writes of 0 are ignored." "0,1"
        bitfld.long 0x00 4. "       MAI_WDTR631           ,negate hardware reset to wdt after system reset  this field is reset due to a wdt reset event  reading 0 = wdt reset is still asserted from the last system reset  reading 1 = wdt reset is negated  writing 0 = operation is ignored  writing 1 = negates the wdt reset" "0,1"
        bitfld.long 0x00 1. "     SPR                          ,this is read only bit - sp_wf_fuse  0 = secure core was not boot core  1 = secure core was the first core to boot" "0,1"
        bitfld.long 0x00 0. "       MAI_APR635               ,apply hardware reset to application processor  1 = core is held in reset.  0 = core is released from reset  the initial value of this bit is determined by sp_wf_fuse_not.  sp_wf_fuse = 1 (secure core is not first one to boot).  sp_wf_fuse is 0 when secure core is boot core." "0,1"

group d:0xD4051084++0x03
    line.long 0x00 "CRMR,CR7 DDR address remap"
        bitfld.long 0x00 24. " LRME                  ,lte ddr remap enable   0 = lte ddr remap disabled 1 = lte ddr remap enabled" "0,1"
        bitfld.long 0x00 16.--20. "       LRMADDR               ,lte ddr remap address.    when lte ddr remap is enabled, lte ddr address [32:28] is replaced with lrmaddr[4:0] in this field" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"
        bitfld.long 0x00 8. "    CRME                         ,cr7 ddr remap enable   0 = cr7 ddr remap disabled 1 = cr7 ddr remap enabled" "0,1"
        bitfld.long 0x00 0.--4. "       CRMADDR                  ,cr7 ddr remap address.    when cr7 ddr remap is enabled, cr7 ddr address [32:28] is replaced with crmaddr[4:0] in this field" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"

tree.end

tree "apbclock"

width 25.

group d:0xD4015000++0x03
    line.long 0x00 "APBC_UART1_CLK_RST,Clock/Reset Control Register for UART 1"
        bitfld.long 0x00 4.--6. " FNCLKSEL15          ,functional clock select  0x0 = 58.5 mhz  0x1 = 14.7456 mhz  all other values = reserved, do not use" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 2. "     RST17        ,uart reset generation  this field resets both apb and functional domains.  0 = no reset  1 = reset" "0,1"
        bitfld.long 0x00 1. "  FNCLK18      ,uart functional clock enable/disable  0 = clock off  1 = clock on" "0,1"
        bitfld.long 0x00 0. "  APBCLK19  ,uart  apb bus clock enable/disable  0 = clock off  1 = clock on" "0,1"

group d:0xD4015004++0x03
    line.long 0x00 "APBC_UART2_CLK_RST,Clock/Reset Control Register for UART 2"
        bitfld.long 0x00 4.--6. " FNCLKSEL27          ,functional clock select  0x0 = 58.5 mhz  0x1 = 14.7456 mhz  all other values = reserved, do not use" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 2. "     RST29        ,uart reset generation  this field resets both apb and functional domains.  0 = no reset  1 = reset" "0,1"
        bitfld.long 0x00 1. "  FNCLK30      ,uart functional clock enable/disable  0 = clock off  1 = clock on" "0,1"
        bitfld.long 0x00 0. "  APBCLK31  ,uart  apb bus clock enable/disable  0 = clock off  1 = clock on" "0,1"

group d:0xD4015008++0x03
    line.long 0x00 "APBC_GPIO_CLK_RST,Clock/Reset Control Register for GPIO"
        bitfld.long 0x00 4.--6. " FNCLKSEL39          ,functional clock select  0x0 to 0x7 = no clock" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 2. "     RST41        ,gpio reset generation  this field resets both the apb and functional domain.  0 = no reset  1 = reset" "0,1"
        bitfld.long 0x00 1. "  FNCLK42      ,gpio functional clock enable/disable  0 = clock off  1 = clock on" "0,1"
        bitfld.long 0x00 0. "  APBCLK43  ,gpio apb bus clock enable/disable  0 = clock off  1 = clock on" "0,1"

group d:0xD401500C++0x03
    line.long 0x00 "APBC_PWM0_CLK_RST,Clock/Reset Control Register for PWM 0"
        bitfld.long 0x00 4.--6. " FNCLKSEL52          ,functional clock select  0x0 = 13 mhz  0x1 = 32 khz  all other values = reserved, do not use" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 2. "     RST54        ,pwm 0 reset generation  this field resets both the apb and functional domain.  0 = no reset  1 = reset" "0,1"
        bitfld.long 0x00 1. "  FNCLK55      ,pwm 0 functional clock enable/disable  0 = clock off  1 = clock on" "0,1"
        bitfld.long 0x00 0. "  APBCLK56  ,pwm 0/1 apb bus clock enable/disable  0 = clock off  1 = clock on. this bit controls the apb clocks for both pwm0 and pwm1." "0,1"

group d:0xD4015010++0x03
    line.long 0x00 "APBC_PWM1_CLK_RST,Clock/Reset Control Register for PWM 1"
        bitfld.long 0x00 4.--6. " FNCLKSEL65          ,functional clock select  0x0 = 13 mhz  0x1 = 32 khz  all other values = reserved, do not use" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 2. "     RST67        ,pwm 1 reset generation  this field resets both the apb and functional domain.  0 = no reset  1 = reset" "0,1"
        bitfld.long 0x00 1. "  FNCLK68      ,pwm 1 functional clock enable/disable  0 = clock off  1 = clock on" "0,1"

group d:0xD4015014++0x03
    line.long 0x00 "APBC_PWM2_CLK_RST,Clock/Reset Control Register for PWM 2"
        bitfld.long 0x00 4.--6. " FNCLKSEL78          ,functional clock select  0x0 = 13 mhz  0x1 = 32 khz  all other values = reserved, do not use" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 2. "     RST80        ,pwm 2 reset generation  this field resets both the apb and functional domain.  0 = no reset  1 = reset" "0,1"
        bitfld.long 0x00 1. "  FNCLK81      ,pwm 2 functional clock enable/disable  0 = clock off  1 = clock on" "0,1"
        bitfld.long 0x00 0. "  APBCLK82  ,pwm 2/3 apb bus clock enable/disable  0 = clock off  1 = clock on. this bit controls the apb clocks for both pwm2 and pwm3." "0,1"

group d:0xD4015018++0x03
    line.long 0x00 "APBC_PWM3_CLK_RST,Clock/Reset Control Register for PWM 3"
        bitfld.long 0x00 4.--6. " FNCLKSEL91          ,functional clock select  0x0 = 13 mhz  0x1 = 32 khz  all other values = reserved, do not use" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 2. "     RST93        ,pwm 3 reset generation  this field resets both the apb and functional domain.  0 = no reset  1 = reset" "0,1"
        bitfld.long 0x00 1. "  FNCLK94      ,pwm 3 functional clock enable/disable  0 = clock off  1 = clock on" "0,1"

group d:0xD401501C++0x03
    line.long 0x00 "APBC_SSP0_CLK_RST,Clock/Reset Control Register for SSP 0"
        bitfld.long 0x00 7. " SEL_SSP_FUNC_CLK104 ,ac97 clock switch  this bit enables the ssp module to switch clocks internally." "0,1"
        bitfld.long 0x00 4.--6. "     FNCLKSEL105  ,functional clock select  0x0 = 6.5 mhz  0x1 = 13 mhz  0x2 = 26 mhz  0x3 = 52 mhz   0x4 = 3.25 mhz  0x5 = 1.625 mhz  0x6 = 812.5 khz  all other values = reserved, do not use" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 2. "  RST107       ,ssp 0 reset generation  this field resets both the apb and functional domain.  0 = no reset  1 = reset" "0,1"
        bitfld.long 0x00 1. "  FNCLK108  ,ssp 0 functional clock enable/disable  0 = clock off  1 = clock on" "0,1"
        textline "                                   "
        bitfld.long 0x00 0. "APBCLK109           ,ssp 0 apb bus clock enable/disable  0 = clock off  1 = clock on" "0,1"

group d:0xD4015024++0x03
    line.long 0x00 "APBC_IPC_CLK_RST,Clock/Reset Control Register for Inter-Processor Communication"
        bitfld.long 0x00 4.--6. " FNCLKSEL119         ,functional clock select  all values = no clock" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 2. "     RST121       ,inter-processor communication (ipc) reset generation  this field resets both the apb and functional domain.  0 = no reset  1 = reset" "0,1"
        bitfld.long 0x00 1. "  FNCLK122     ,ipc functional clock enable/disable  0 = clock off  1 = clock on" "0,1"
        bitfld.long 0x00 0. "  APBCLK123 ,ipc apb bus clock enable/disable  0 = clock off  1 = clock on" "0,1"

group d:0xD4015028++0x03
    line.long 0x00 "APBC_RTC_CLK_RST,Clock/Reset Control Register for RTC"
        bitfld.long 0x00 7. " PM_POWER_SENSOR     ,power enabled  this field enables the register read/writes for the rtc module by indicating power enable. set this field to 0x1 before enabling rtc operations." "0,1"
        bitfld.long 0x00 4.--6. "     FNCLKSEL132  ,functional clock select  0x0 = 32 khz  all other values = reserved, do not use" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 2. "  RST134       ,rtc reset generation  this field resets both the apb and functional domain.  0 = no reset  1 = reset" "0,1"
        bitfld.long 0x00 1. "  FNCLK135  ,rtc functional clock enable/disable  0 = clock off  1 = clock on" "0,1"
        textline "                                   "
        bitfld.long 0x00 0. "APBCLK136           ,rtc apb bus clock enable/disable  0 = clock off  1 = clock on" "0,1"

group d:0xD401502C++0x03
    line.long 0x00 "APBC_TWSI0_CLK_RST,Clock/Reset Control Register for TWSI0"
        bitfld.long 0x00 4.--6. " FNCLKSEL144         ,functional clock select  0x0 = 32 mhz  0x1 = 52 mhz  0x2 = 62.4 mhz  all other values = reserved, do not use" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 2. "     RST146       ,twsi reset generation  this field resets both the apb and functional domain.  0 = no reset  1 = reset" "0,1"
        bitfld.long 0x00 1. "  FNCLK147     ,twsi0 functional clock enable/disable  0 = clock off  1 = clock on" "0,1"
        bitfld.long 0x00 0. "  APBCLK148 ,twsi0 apb bus clock enable/disable  0 = clock off  1 = clock on" "0,1"

group d:0xD4015030++0x03
    line.long 0x00 "APBC_KPC_CLK_RST,Clock/Reset Control Register for Keypad Controller"
        bitfld.long 0x00 4.--6. " FNCLKSEL156         ,functional clock select  0x0 = 32 khz  0x1 = 16 khz  0x2 = 26 mhz  all other values = reserved, do not use" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 2. "     RST158       ,keypad controller reset generation  this field resets both the apb and functional domain.  0 = no reset  1 = reset" "0,1"
        bitfld.long 0x00 1. "  FNCLK159     ,keypad controller functional clock enable/disable  0 = clock off  1 = clock on" "0,1"
        bitfld.long 0x00 0. "  APBCLK160 ,keypad controller apb bus clock enable/disable  0 = clock off  1 = clock on" "0,1"

group d:0xD4015034++0x03
    line.long 0x00 "APBC_TIMERS_CLK_RST,Clock/Reset Control Register for Timer 0"
        bitfld.long 0x00 4.--6. " FNCLKSEL168         ,functional clock select  0x0 = 13 mhz  0x1 = 32 khz  0x2 = 6.5 mhz  0x3 = 3.25 mhz  0x4 = 1 mhz  all other values = reserved, do not use" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 2. "     RST170       ,timers reset generation  this field resets both the apb and functional domain.  0 = no reset  1 = reset" "0,1"
        bitfld.long 0x00 1. "  FNCLK171     ,timers functional clock enable/disable  0 = clock off  1 = clock on" "0,1"
        bitfld.long 0x00 0. "  APBCLK172 ,timers apb bus clock enable/disable  0 = clock off  1 = clock on" "0,1"

group d:0xD401503C++0x03
    line.long 0x00 "APBC_AIB_CLK_RST,Clock/Reset Control Register for AIB"
        bitfld.long 0x00 4.--6. " FNCLKSEL180         ,functional clock select  all values = no clock" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 2. "     RST182       ,aib reset generation  this field resets both the apb and functional domain.  0 = no reset  1 = reset" "0,1"
        bitfld.long 0x00 1. "  FNCLK183     ,aib functional clock enable/disable  0 = clock off  1 = clock on" "0,1"
        bitfld.long 0x00 0. "  APBCLK184 ,aib apb bus clock enable/disable  0 = clock off  1 = clock on" "0,1"

group d:0xD4015040++0x03
    line.long 0x00 "APBC_SW_JTAG_CLK_RST,Clock/Reset Control Register for JTAG Software Emulation"
        bitfld.long 0x00 4.--6. " FNCLKSEL192         ,functional clock select  all values = no clock" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 2. "     RST194       ,jtag software emulation reset generation  this field resets both the apb and functional domain.  0 = no reset  1 = reset" "0,1"
        bitfld.long 0x00 1. "  FNCLK195     ,jtag software emulation functional clock enable/disable  0 = clock off  1 = clock on" "0,1"
        bitfld.long 0x00 0. "  APBCLK196 ,jtag software emulation apb bus clock enable/disable  0 = clock off  1 = clock on" "0,1"

group d:0xD4015044++0x03
    line.long 0x00 "APBC_TIMERS1_CLK_RST,Clock/Reset Control Register for Timers 1"
        bitfld.long 0x00 4.--6. " FNCLKSEL204         ,functional clock select  0x0 = 13 mhz  0x1 = 32 khz  0x2 = 6.5 mhz  0x3 = 3.25 mhz  0x4 = 1 mhz  all other values = reserved, do not use" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 2. "     RST206       ,timers 1 reset generation  this field resets both the apb and functional domain.  0 = no reset  1 = reset" "0,1"
        bitfld.long 0x00 1. "  FNCLK207     ,timers 1 functional clock enable/disable  0 = clock off  1 = clock on" "0,1"
        bitfld.long 0x00 0. "  APBCLK208 ,timers 1 apb bus clock enable/disable  0 = clock off  1 = clock on" "0,1"

group d:0xD4015048++0x03
    line.long 0x00 "APBC_ONEWIRE_CLK_RST,Clock/Reset Control Register for One-Wire"
        bitfld.long 0x00 4.--6. " FNCLKSEL216         ,functional clock select  all values = no clock" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 2. "     RST218       ,one-wire reset generation  this field resets both the apb and functional domain.  0 = no reset  1 = reset" "0,1"
        bitfld.long 0x00 1. "  FNCLK219     ,one-wire functional clock enable/disable  0 = clock off  1 = clock on" "0,1"
        bitfld.long 0x00 0. "  APBCLK220 ,one-wire apb bus clock enable/disable  0 = clock off  1 = clock on" "0,1"

group d:0xD401504C++0x03
    line.long 0x00 "APBC_SSP2_CLK_RST,Clock/Reset Control Register for SSP 2"
        bitfld.long 0x00 7. " SEL_SSP_FUNC_CLK229 ,ac97 clock switch  this bit enables the ssp module to switch clocks internally." "0,1"
        bitfld.long 0x00 4.--6. "     FNCLKSEL230  ,functional clock select  0x0 = 6.5 mhz  0x1 = 13 mhz  0x2 = 26 mhz  0x3 = 52 mhz  all other values = reserved, do not use" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 2. "  RST232       ,ssp 2 reset generation  this field resets both the apb and functional domain.  0 = no reset  1 = reset" "0,1"
        bitfld.long 0x00 1. "  FNCLK233  ,ssp 2 functional clock enable/disable  0 = clock off  1 = clock on" "0,1"
        textline "                                   "
        bitfld.long 0x00 0. "APBCLK234           ,ssp 2 apb bus clock enable/disable  0 = clock off  1 = clock on" "0,1"

group d:0xD4015050++0x03
    line.long 0x00 "APBC_ASFAR,AIB Secure First Access Register"
        hexmask.long.word 0x00 0.--15. 1. " ASFAR               ,first access key  writing the value of 0xbaba to this register will match the key. this register will get cleared to 0x0 when one secure access is completed."

group d:0xD4015054++0x03
    line.long 0x00 "APBC_ASSAR,AIB Secure Second Access Register"
        hexmask.long.word 0x00 0.--15. 1. " ASSAR               ,section access key  writing the value of 0xeb10 to this register will match the key. this register will get cleared to 0x0 when one secure access is completed."

group d:0xD4015060++0x03
    line.long 0x00 "APBC_TWSI1_CLK_RST,Clock/Reset Control Register for TWSI1"
        bitfld.long 0x00 4.--6. " FNCLKSEL258         ,functional clock select  0x0 = 32 mhz  0x1 = 52 mhz  0x2 = 62.4 mhz  all other values = reserved, do not use" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 2. "     RST260       ,twsi reset generation  this field resets both the apb and functional domain.  0 = no reset  1 = reset" "0,1"
        bitfld.long 0x00 1. "  FNCLK261     ,twsi functional clock enable/disable  0 = clock off  1 = clock on" "0,1"
        bitfld.long 0x00 0. "  APBCLK262 ,twsi apb bus clock enable/disable  0 = clock off  1 = clock on" "0,1"

group d:0xD4015064++0x03
    line.long 0x00 "APBC_COUNTER_CLK_SEL,Clock Control Register for Generic Counter"
        hexmask.long.word 0x00 16.--31. 1. " LOW_FREQ_STEP       ,generic counter step of low frequency  under low frequency, this is the generic counter step value.  its default is 26 mhz/32768 = 0x319"
        bitfld.long 0x00 1. "  FREQ_SW_SEL  ,generic counter frequency software select  if freq_hw_en = 0 generic counter clock frequency select  0x0 = 26 mhz  1 = 32 khz" "0,1"
        bitfld.long 0x00 0. "  FREQ_HW_CTRL ,generic counter frequency controlled by hardware  0x0 = software freq_sw_sel bit  1 = hardware vctcxo_en signal  if vctcxo_en = 1, generic counter clock frequency is 26 mhz  if  vctcxo_en = 0, generic counter clock frequency is 32 khz" "0,1"

group d:0xD4015068++0x03
    line.long 0x00 "APBC_TIMERS2_CLK_RST,Clock/Reset Control Register for Timers 2"
        bitfld.long 0x00 4.--6. " FNCLKSEL281         ,functional clock select  0x0 = 13 mhz  0x1 = 32 khz  0x2 = 6.5 mhz  0x3 = 3.25 mhz  0x4 = 1 mhz  all other values = reserved, do not use" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 2. "     RST283       ,timers 1 reset generation  this field resets both the apb and functional domain.  0 = no reset  1 = reset" "0,1"
        bitfld.long 0x00 1. "  FNCLK284     ,timers 1 functional clock enable/disable  0 = clock off  1 = clock on" "0,1"
        bitfld.long 0x00 0. "  APBCLK285 ,timers 1 apb bus clock enable/disable  0 = clock off  1 = clock on" "0,1"

group d:0xD401506C++0x03
    line.long 0x00 "APBC_TSEN_CLK_RST,Clock/Reset Control Register for Temperature Sensor"
        bitfld.long 0x00 2. " TSEN_RST_EN         ,temperature sensor reset enable  0x0 = release reset  0x1 = reset temperature sensor" "0,1"
        bitfld.long 0x00 1. "     TSEN_FCLK_EN ,temperature sensor function clock enable  0x0 = disable temperature sensor function clock  1 = enable temperature sensor function clock" "0,1"
        bitfld.long 0x00 0. "  TSEN_PCLK_EN ,temperature sensor apb clock enable  0x0 = disable temperature sensor apb clock  1 = enable temperature sensor apb clock" "0,1"

group d:0xD4015070++0x03
    line.long 0x00 "APBC_TWSI2_CLK_RST,Clock/Reset Control Register for TWSI2"
        bitfld.long 0x00 4.--6. " FNCLKSEL303         ,functional clock select  0x0 = 32 mhz  0x1 = 52 mhz  0x2 = 62.4 mhz  all other values = reserved, do not use" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 2. "     RST305       ,twsi reset generation  this field resets both the apb and functional domain.  0 = no reset  1 = reset" "0,1"
        bitfld.long 0x00 1. "  FNCLK306     ,twsi functional clock enable/disable  0 = clock off  1 = clock on" "0,1"
        bitfld.long 0x00 0. "  APBCLK307 ,twsi apb bus clock enable/disable  0 = clock off  1 = clock on" "0,1"

group d:0xD4015074++0x03
    line.long 0x00 "APBC_TWSI3_CLK_RST,Clock/Reset Control Register for TWSI3"
        bitfld.long 0x00 4.--6. " FNCLKSEL315         ,functional clock select  0x0 = 32 mhz  0x1 = 52 mhz  0x2 = 62.4 mhz  all other values = reserved, do not use" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 2. "     RST317       ,twsi reset generation  this field resets both the apb and functional domain.  0 = no reset  1 = reset" "0,1"
        bitfld.long 0x00 1. "  FNCLK318     ,twsi functional clock enable/disable  0 = clock off  1 = clock on" "0,1"
        bitfld.long 0x00 0. "  APBCLK319 ,twsi apb bus clock enable/disable  0 = clock off  1 = clock on" "0,1"

group d:0xD4015078++0x03
    line.long 0x00 "APBC_UART3_CLK_RST,Clock/Reset Control Register for UART 3"
        bitfld.long 0x00 4.--6. " FNCLKSEL327         ,functional clock select  0x0 = 58.5 mhz  0x1 = 14.7456 mhz  all other values = reserved, do not use" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 2. "     RST329       ,uart reset generation  this field resets both apb and functional domains.  0 = no reset  1 = reset" "0,1"
        bitfld.long 0x00 1. "  FNCLK330     ,uart functional clock enable/disable  0 = clock off  1 = clock on" "0,1"
        bitfld.long 0x00 0. "  APBCLK331 ,uart  apb bus clock enable/disable  0 = clock off  1 = clock on" "0,1"

group d:0xD401507C++0x03
    line.long 0x00 "APBC_TWSI4_CLK_RST,Clock/Reset Control Register for TWSI4"
        bitfld.long 0x00 4.--6. " FNCLKSEL339         ,functional clock select  0x0 = 32 mhz  0x1 = 52 mhz  0x2 = 62.4 mhz  all other values = reserved, do not use" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 2. "     RST341       ,twsi reset generation  this field resets both the apb and functional domain.  0 = no reset  1 = reset" "0,1"
        bitfld.long 0x00 1. "  FNCLK342     ,twsi functional clock enable/disable  0 = clock off  1 = clock on" "0,1"
        bitfld.long 0x00 0. "  APBCLK343 ,twsi apb bus clock enable/disable  0 = clock off  1 = clock on" "0,1"

group d:0xD4015080++0x03
    line.long 0x00 "APBC_TWSI5_CLK_RST,Clock/Reset Control Register for TWSI5"
        bitfld.long 0x00 4.--6. " FNCLKSEL351         ,functional clock select  0x0 = 32 mhz  0x1 = 52 mhz  0x2 = 62.4 mhz  all other values = reserved, do not use" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 2. "     RST353       ,twsi reset generation  this field resets both the apb and functional domain.  0 = no reset  1 = reset" "0,1"
        bitfld.long 0x00 1. "  FNCLK354     ,twsi functional clock enable/disable  0 = clock off  1 = clock on" "0,1"
        bitfld.long 0x00 0. "  APBCLK355 ,twsi apb bus clock enable/disable  0 = clock off  1 = clock on" "0,1"

group d:0xD4015084++0x03
    line.long 0x00 "APBC_TWSI6_CLK_RST,Clock/Reset Control Register for TWSI6"
        bitfld.long 0x00 4.--6. " FNCLKSEL363         ,functional clock select  0x0 = 32 mhz  0x1 = 52 mhz  0x2 = 62.4 mhz  all other values = reserved, do not use" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 2. "     RST365       ,twsi reset generation  this field resets both the apb and functional domain.  0 = no reset  1 = reset" "0,1"
        bitfld.long 0x00 1. "  FNCLK366     ,twsi functional clock enable/disable  0 = clock off  1 = clock on" "0,1"
        bitfld.long 0x00 0. "  APBCLK367 ,twsi apb bus clock enable/disable  0 = clock off  1 = clock on" "0,1"

group d:0xD4015088++0x03
    line.long 0x00 "APBC_TWSI7_CLK_RST,Clock/Reset Control Register for TWSI7"
        bitfld.long 0x00 4.--6. " FNCLKSEL375         ,functional clock select  0x0 = 32 mhz  0x1 = 52 mhz  0x2 = 62.4 mhz  all other values = reserved, do not use" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 2. "     RST377       ,twsi reset generation  this field resets both the apb and functional domain.  0 = no reset  1 = reset" "0,1"
        bitfld.long 0x00 1. "  FNCLK378     ,twsi functional clock enable/disable  0 = clock off  1 = clock on" "0,1"
        bitfld.long 0x00 0. "  APBCLK379 ,twsi apb bus clock enable/disable  0 = clock off  1 = clock on" "0,1"

group d:0xD401508C++0x03
    line.long 0x00 "APBC_TWSI8_CLK_RST,Clock/Reset Control Register for TWSI8"
        bitfld.long 0x00 4.--6. " FNCLKSEL387         ,functional clock select  0x0 = 32 mhz  0x1 = 52 mhz  0x2 = 62.4 mhz  all other values = reserved, do not use" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 2. "     RST389       ,twsi reset generation  this field resets both the apb and functional domain.  0 = no reset  1 = reset" "0,1"
        bitfld.long 0x00 1. "  FNCLK390     ,twsi functional clock enable/disable  0 = clock off  1 = clock on" "0,1"
        bitfld.long 0x00 0. "  APBCLK391 ,twsi apb bus clock enable/disable  0 = clock off  1 = clock on" "0,1"

group d:0xD4015090++0x03
    line.long 0x00 "APBC_IPC_AP2AUD_CLK_RST,Clock/Reset Control Register for Inter-Processor Communication（AP to Audio）"
        bitfld.long 0x00 4.--6. " FNCLKSEL399         ,functional clock select  all values = no clock" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 2. "     RST401       ,inter-processor communication (ipc) reset generation  this field resets both the apb and functional domain.  0 = no reset  1 = reset" "0,1"
        bitfld.long 0x00 1. "  FNCLK402     ,ipc functional clock enable/disable  0 = clock off  1 = clock on" "0,1"
        bitfld.long 0x00 0. "  APBCLK403 ,ipc apb bus clock enable/disable  0 = clock off  1 = clock on" "0,1"

tree.end

tree "apbcontrol"

width 13.

group d:0xD023B000++0x03
    line.long 0x00 "TCTS,TCU Clock Trigger Control Register"
        bitfld.long 0x00 0. " TCU_CLOCK_TRIGGER_SELECT        ,tcu clock trigger select  1 = trigger from wideband  0 = trigger from slow clock" "0,1"

group d:0xD023B004++0x03
    line.long 0x00 "THALT,TCU HALT Mode Control Register"
        bitfld.long 0x00 0. " TCU_HALT_MODE_SELECT            ,tcu halt mode select  1 = on  0 = off" "0,1"

group d:0xD023B00C++0x03
    line.long 0x00 "GBS,GSSP Bus Interface Select Register"
        bitfld.long 0x00 0. " GSSP_BUS_SELECT                 ,gssp bus select  this field selects which bus connects to the gssp.  1 = apb  0 = gpb" "0,1"

group d:0xD023B010++0x03
    line.long 0x00 "APB_GAMPMCR,APB CP Peripherals Monitor Control Register"
        bitfld.long 0x00 29.--31. " TEST_POINT_OUTPUT_SELECT        ,test point output select  this field selects which test points to output. it selects one of eight possible test point combinations.  default = 0" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 16. "   38                      ,enable apb peripheral monitor  1 = enable  0 = disable all monitoring  default = 0" "0,1"
        bitfld.long 0x00 12.--15. "   39                      ,bits [31:24] in monitor mux output select  0x0 = e-cipher  0x1 = airq  0x2 = tcu  0x3 = usim 1  0x4 = usim 2  0x5 = uart  0x6 = twsi  0x7 = gssp   0x8 = timers  all other values are reserved.  default = 0" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 8.--11. "  40                    ,bits [23:16] in monitor mux output select  0x0 = e-cipher  0x1 = airq  0x2 = tcu  0x3 = usim 1  0x4 = usim 2  0x5 = uart  0x6 = twsi  0x7 = gssp   0x8 = timers  all other values are reserved.  default = 0" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        textline "                       "
        bitfld.long 0x00 4.--7. "41                              ,bits [15:8] in monitor mux output select  0x0 = e-cipher  0x1 = airq  0x2 = tcu  0x3 = usim 1  0x4 = usim 2  0x5 = uart  0x6 = twsi  0x7 = gssp   0x8 = timers  all other values are reserved.  default = 0" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 0.--3. "  42                      ,bits [7:0] in monitor mux output select  0x0 = e-cipher  0x1 = airq  0x2 = tcu  0x3 = usim 1  0x4 = usim 2  0x5 = uart  0x6 = twsi  0x7 = gssp   0x8 = timers  all other values are reserved.  default = 0" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"

group d:0xD023B014++0x03
    line.long 0x00 "TCER,TCU Clock Control Register"
        bitfld.long 0x00 2. " SW_RESET50                      ,software reset  0 = normal operation  1 = reset peripheral" "0,1"
        bitfld.long 0x00 1. "   CLOCK_ENABLE51          ,clock enable  0 = off  1 = on" "0,1"

group d:0xD023B018++0x03
    line.long 0x00 "ACER,AIRQ Clock Control Register"
        bitfld.long 0x00 2. " SW_RESET60                      ,software reset  0 = normal operation  1 = reset peripheral" "0,1"
        bitfld.long 0x00 1. "   CLOCK_ENABLE61          ,clock enable  0 = off  1 = on" "0,1"

group d:0xD023B01C++0x03
    line.long 0x00 "UCER,UART Clock Control Register"
        bitfld.long 0x00 2. " SW_RESET70                      ,software reset  0 = normal operation  1 = reset peripheral" "0,1"
        bitfld.long 0x00 1. "   CLOCK_ENABLE71          ,clock enable  0 = off  1 = on" "0,1"
        bitfld.long 0x00 0. "   BUS_CLOCK_ENABLE72      ,bus clock enable  0 = off  1 = on" "0,1"

group d:0xD023B020++0x03
    line.long 0x00 "USCER1,USIM 1 Clock Control Register"
        bitfld.long 0x00 2. " SW_RESET80                      ,software reset  0 = normal operation  1 = reset peripheral" "0,1"
        bitfld.long 0x00 1. "   CLOCK_ENABLE81          ,clock enable  0 = off  1 = on" "0,1"
        bitfld.long 0x00 0. "   BUS_CLOCK_ENABLE82      ,bus clock enable  0 = off  1 = on" "0,1"

group d:0xD023B024++0x03
    line.long 0x00 "USCER2,USIM 2 Clock Control Register"
        bitfld.long 0x00 2. " SW_RESET90                      ,software reset  0 = normal operation  1 = reset peripheral" "0,1"
        bitfld.long 0x00 1. "   CLOCK_ENABLE91          ,clock enable  0 = off  1 = on" "0,1"
        bitfld.long 0x00 0. "   BUS_CLOCK_ENABLE92      ,bus clock enable  0 = off  1 = on" "0,1"

group d:0xD023B028++0x03
    line.long 0x00 "ICER,TWSI Clock Control Register"
        bitfld.long 0x00 3.--4. " FN_SEL                          ,clock select  0x0 = 32 mhz  0x1 = 52 mhz  0x2 = 62.4 mhz  0x03 = 62.4 mhz" "0,1,2,3"
        bitfld.long 0x00 2. "   SW_RESET101             ,software reset  0 = normal operation  1 = reset peripheral" "0,1"
        bitfld.long 0x00 1. "   CLOCK_ENABLE102         ,clock enable  0 = off  1 = on" "0,1"
        bitfld.long 0x00 0. "   BUS_CLOCK_ENABLE103   ,bus clock enable  0 = off  1 = on" "0,1"

group d:0xD023B02C++0x03
    line.long 0x00 "ECCER,APB E-Cipher Clock Control Register"
        bitfld.long 0x00 2. " SW_RESET111                     ,software reset  0 = normal operation  1 = reset peripheral" "0,1"
        bitfld.long 0x00 1. "   CLOCK_ENABLE112         ,clock enable  0 = off  1 = on" "0,1"

group d:0xD023B030++0x03
    line.long 0x00 "TICER,APB Timers Clock Control Register"
        bitfld.long 0x00 2. " SW_RESET121                     ,software reset  0 = normal operation  1 = reset peripheral" "0,1"
        bitfld.long 0x00 1. "   CLOCK_ENABLE122         ,clock enable  0 = off  1 = on" "0,1"
        bitfld.long 0x00 0. "   BUS_CLOCK_ENABLE123     ,bus clock enable  0 = off  1 = on" "0,1"

group d:0xD023B034++0x03
    line.long 0x00 "GCER,GSSP Clock Control Register"
        bitfld.long 0x00 8.--9. " GSSP1_CLOCK_SEL                 ,gssp1 clock select  0x0 = i<super 2>s clk  0x1 = sys clk  0x2 = ext clk  0x3 = 26 mhz" "0,1,2,3"
        bitfld.long 0x00 6.--7. "   GSSP2_CLOCK_SEL         ,gssp2 clock select  0x0 = i<super 2>s clk  0x1 = sys clk  0x2 = ext clk  0x3 = 26 mhz" "0,1,2,3"
        bitfld.long 0x00 5. "   APBCO_GSSP2_SW_RESET133 ,gssp2 software reset  0 = normal operation  1 = reset peripheral" "0,1"
        bitfld.long 0x00 4. "   GSSP2_CLOCK_ENABLE    ,gssp2 clock enable  0 = off  1 = on" "0,1"
        textline "                       "
        bitfld.long 0x00 3. "APBCO_GSSP2_BUS_CLOCK_ENABLE135 ,gssp2_bus clock enable  0 = off  1 = on" "0,1"
        bitfld.long 0x00 2. "   APBCO_GSSP1_SW_RESET136 ,gssp1 software reset  0 = normal operation  1 = reset peripheral" "0,1"
        bitfld.long 0x00 1. "   GSSP1_CLOCK_ENABLE      ,gssp1 clock enable  0 = off  1 = on" "0,1"
        bitfld.long 0x00 0. "   GSSP1BUS_CLOCK_ENABLE ,gssp1 bus clock enable  0 = off  1 = on" "0,1"

group d:0xD023B038++0x03
    line.long 0x00 "AICER,IPC/RIPC Clock Control Register"
        bitfld.long 0x00 2. " SW_RESET146                     ,software reset  0 = normal operation  1 = reset peripheral" "0,1"
        bitfld.long 0x00 1. "   CLOCK_ENABLE147         ,clock enable  0 = off  1 = on" "0,1"

group d:0xD023B03C++0x03
    line.long 0x00 "SCCR,Slow Clock Clock Control Register"
        bitfld.long 0x00 4. " 156                             ,gsm slow-clock (sck) functional clock frequency select  this register is not used.  sck receives a fixed 26-mhz clock." "0,1"
        bitfld.long 0x00 2. "   SW_RESET158             ,sw reset  0 = normal operation  1 = reset peripheral" "0,1"
        bitfld.long 0x00 1. "   CLOCK_ENABLE160         ,clock enable  0 = off  1 = on  this register is not used  sck receives the low-power 26-mhz clock controlled by m regs" "0,1"

tree.end

tree "pmucp"

width 22.

group d:0xD0201800++0x03
    line.long 0x00 "STIKY_CLR0,AIRQ Interrupt Clear 0 Register"
        hexmask.long 0x00 0.--31. 1. " CP_PM_AIRQ_INT_CLR_013      ,airq interrupt clear 0  to clear the interrupt sticky-bit, write 1.  there is no need to write 0, since the register clears itself (one-shot).  when level interrupt function is selected, these registers have no effect.  bit [0] refers to interrupt 0, bit [1] refers to interrupt 1, etc."

group d:0xD0201804++0x03
    line.long 0x00 "STIKY_CLR1,AIRQ Interrupt Clear 1 Register"
        hexmask.long 0x00 0.--31. 1. " CP_PM_AIRQ_INT_CLR_121      ,airq interrupt clear 1  to clear the interrupt sticky-bit, write 1.  there is no need to write 0, since the register clears itself (one-shot).  when level interrupt function is selected, these registers have no effect.  bit [0] refers to interrupt 32, bit [1] refers to interrupt 33, etc."

group d:0xD0201808++0x03
    line.long 0x00 "EDGE_OR_LEVEL0,AIRQ Interrupt Sensitivity 0 Register"
        hexmask.long 0x00 0.--31. 1. " CP_PM_AIRQ_EDGE_LEVEL_029   ,airq edge level 0  0 = originally level-sensitive interrupt (no sticky bit needed)  1 = originally edge-sensitive interrupt (sticky bit needed)  bit [0] refers to interrupt 0, bit [1] refers to interrupt 1, etc."

group d:0xD020180C++0x03
    line.long 0x00 "EDGE_OR_LEVEL1,AIRQ Interrupt Sensitivity 1 Register"
        hexmask.long 0x00 0.--31. 1. " CP_PM_AIRQ_EDGE_LEVEL_137   ,airq edge level 1  0 = originally level-sensitive interrupt (no sticky bit needed)  1 = originally edge-sensitive interrupt (sticky bit needed)  bit [0] refers to interrupt 32, bit [1] refers to interrupt 33, and so on."

group d:0xD0201810++0x03
    line.long 0x00 "EDGE_OR_LEVEL2,AIRQ Interrupt Sensitivity 1 Register"
        hexmask.long.word 0x00 0.--15. 1. " AIRQ_EDGE_LEVEL_2           ,airq edge level 1  0 = originally level-sensitive interrupt (no sticky bit needed)  1 = originally edge-sensitive interrupt (sticky bit needed)  bit [0] refers to interrupt 64, bit [1] refers to interrupt 65, and so on."

group d:0xD0201818++0x03
    line.long 0x00 "STIKY_CLR2,AIRQ Interrupt Clear 2 Register"
        hexmask.long.word 0x00 0.--15. 1. " AIRQ_INT_CLR_2              ,airq interrupt clear 1  to clear the interrupt sticky-bit, write 1.  there is no need to write 0, since the register clears itself (one-shot).  when level interrupt function is selected, these registers have no effect.  bit [0] refers to interrupt 64, bit [1] refers to interrupt 65, etc."

group d:0xD0201820++0x03
    line.long 0x00 "DDR_REQ_CTRL_SG,DDR Request Control Register for <var Processor: Comm>"
        bitfld.long 0x00 31. " DDRC_RDY_EN61               ,  1 = 1= axi transactions to ddrc are sent without considering ddrc's status   0 =  0= axi transactions to ddrc are only sent when ddrc is ready" "0,1"
        hexmask.long.word 0x00 21.--30. 1. "         CP_PM_62                     ,"
        bitfld.long 0x00 20. "      FBDMA_DDRC_REQ_EN63            ,  0x1= if fb dma is active, request ddrc resource<p>0x0 = ddrc resource will not be requested because fb dma's is active" "0,1"
        bitfld.long 0x00 19. "     DTC_DDRC_REQ_EN64                 ,  0x1= if dtc is active, request ddrc resource<p>0x0 = ddrc resource will not be requested because dtc's is active" "0,1"
        textline "                                "
        bitfld.long 0x00 18. "CPDMA_DDRC_REQ_EN65         ,  0x1= if cp dma is active, request ddrc resource<p>0x0 = ddrc resource will not be requested because cp dma is actvie" "0,1"
        bitfld.long 0x00 17. "         MSA_DDRC_REQ_EN66            ,  0x1= if msa is active, request ddrc resource<p>0x0 = ddrc resource will not be requested because msa is active" "0,1"
        bitfld.long 0x00 16. "         SG_DDRC_REQ_EN67               ,  0x1= if <var processor: comm> is active, request ddrc resource<p>0x0 = ddrc resource will not be requested because <var processor: comm> is active" "0,1"
        bitfld.long 0x00 15. "     GSM_DDRC_REQ_EN68                 ,  0x1= if gsm is active, request ddrc resource<p>0x0 = ddrc resource will not be requested because gsm is active" "0,1"
        textline "                                "
        bitfld.long 0x00 14. "CP_PM_69                    ," "0,1"
        bitfld.long 0x00 13. "         FB_MODEM_DDRC_REQ_EN70       ,  0x1= if modem is active, request ddrc resource<p>0x0 = ddrc resource will not be requested because modem is active" "0,1"
        bitfld.long 0x00 12. "         PWR_MODE_DDRC_REQ_EN71         ,  0x1= if pwr_mode is 2'b00, request ddrc resource<p>0x0 = ddrc resource will not be requested because pwr_mode is 2'b00" "0,1"
        hexmask.long.byte 0x00 4.--11. 1. "     CP_PM_72                          ,"
        textline "                                "
        bitfld.long 0x00 3. "DTCMSD73                    ,ddr is ready for cp access   1 = ddr is ready <0>ddr is not ready" "0,1"
        bitfld.long 0x00 0.--2. "         CP_PM_74                     ," "0,1,2,3,4,5,6,7"

group d:0xD0201824++0x03
    line.long 0x00 "SG_SLEEP_CTRL,<var Processor: Comm> Sleep Control Register"
        bitfld.long 0x00 31. " WAKEUP_GLOBAL_MASK          ,0 =  enable wakeup source; 1 = cp wakeup source disabled. this bit should be set before issue wfi with sg_idle_cfg[1 or 0] set, and it will be auto-cleared after cp enters either external_clock_gating or power_down mode" "0,1"
        bitfld.long 0x00 30. "         WAKEUP_GLOBAL_MASK2          ,0 =  enable wakeup source; 1 = cp wakeup source disabled. this bit should be set before issue wfi with sg_idle_cfg[1 or 0] set, and it will be auto-cleared after cp enters either external_clock_gating or power_down mode. this is intended to be used with firq, but are not needed right now." "0,1"
        hexmask.long.word 0x00 16.--29. 1. "         CP_PM_84                       ,"
        hexmask.long.word 0x00 0.--15. 1. "  CP_PM_85                          ,reserved for future use"

group d:0xD0201828++0x03
    line.long 0x00 "MSA_RST,MSA Reset Register"
        bitfld.long 0x00 31. " MSA_IDLE                    ,msa in idle or not   0x1=msa is in idle" "0,1"
        bitfld.long 0x00 29.--30. "         MSA_LPM_VOTE                 ,msa vote for sleep,   0x0= normal   0x1=d2 mode   0x2=d2 with control from modem  11= reserved" "0,1,2,3"
        bitfld.long 0x00 28. "         FB_DMA_BUSY                    ,fb dma is busy or not" "0,1"
        bitfld.long 0x00 3. "     MSA_RST_STATUS                    ,msa reset status    0x0= msa is released from reset   0x1= msa is in reset" "0,1"
        textline "                                "
        bitfld.long 0x00 2. "MSA_SILENT_RST_MODE         ,enable or disable silent reset mode. combined to be used with bit1.   0x0=silent reset mode is disabled   0x1=silent reset mode is enabled" "0,1"
        bitfld.long 0x00 1. "         MSA_SW_RST                   ,msa software reset. write 1 to this bit to reset msa subsystem   0x0=release msa subsystem from reset   0x1=reset msa subsystem.when bit2 is 1, silent reset msa subsystem. when bit2 is 0, immediate reset msa subsystem" "0,1"
        bitfld.long 0x00 0. "         MSA_RST_HOLD                   ,reset hold control upon wakeup   =0x0 msa will be released from reset after wakeup   =0x1 msa will be hold in reset state after wakeup" "0,1"

group d:0xD020182C++0x03
    line.long 0x00 "SG_INT_REG,<var Processor: Comm> interrupt selection register"
        hexmask.long 0x00 2.--31. 1. " CP_PM_106                   ,"
        bitfld.long 0x00 1. "  CP_PM_107                    ,when this bit is 1,mark the frq to <var processor: comm> from airq" "0,1"
        bitfld.long 0x00 0. "         CP_PM_108                      ,when this bit is 1, mark the irq to <var processor: comm> from airq" "0,1"

group d:0xD0201834++0x03
    line.long 0x00 "CPSS_HW_GATE_CTRL_SG,CPSS Hardware Clock Gating Control for <var Processor: Comm>"
        hexmask.long.word 0x00 23.--31. 1. " CP_PM_116                   ,reserved"
        bitfld.long 0x00 22. "      CP_PM_117                    ,   0x1= clock enabled    0x0= clock disabled" "0,1"
        bitfld.long 0x00 21. "         CP_PM_118                      ,   0x1= clock enabled    0x0= clock disabled" "0,1"
        bitfld.long 0x00 20. "     CP_PM_119                         ,   0x1= clock enabled    0x0= clock disabled" "0,1"
        textline "                                "
        bitfld.long 0x00 19. "CP_PM_120                   ,   0x1= clock enabled    0x0= clock disabled" "0,1"
        bitfld.long 0x00 18. "         CP_PM_121                    ,not used" "0,1"
        bitfld.long 0x00 17. "         CP_PM_122                      ,   0x1= clock enabled    0x0= clock disabled" "0,1"
        bitfld.long 0x00 16. "     CP_PM_123                         ,   0x1= clock enabled    0x0= clock disabled" "0,1"
        textline "                                "
        bitfld.long 0x00 15. "CP_PM_124                   ,reserved" "0,1"
        bitfld.long 0x00 14. "         CP_PM_125                    ,   0x1= clock enabled    0x0= clock disabled" "0,1"
        bitfld.long 0x00 13. "         CP_PM_126                      ,   0x1= clock enabled    0x0= clock disabled" "0,1"
        bitfld.long 0x00 12. "     CP_PM_127                         ,   0x1= clock enabled    0x0= clock disabled" "0,1"
        textline "                                "
        bitfld.long 0x00 11. "CP_PM_128                   ,   0x1= clock enabled    0x0= clock disabled" "0,1"
        bitfld.long 0x00 10. "         CP_PM_129                    ,   0x1= clock enabled    0x0= clock disabled" "0,1"
        bitfld.long 0x00 9. "         CP_PM_130                      ,   0x1= clock enabled    0x0= clock disabled" "0,1"
        bitfld.long 0x00 8. "     CP_PM_131                         ,   0x1= clock enabled    0x0= clock disabled" "0,1"
        textline "                                "
        bitfld.long 0x00 7. "CP_PM_132                   ,reserved" "0,1"
        bitfld.long 0x00 6. "         CP_PM_133                    ,reserved" "0,1"
        bitfld.long 0x00 5. "         CP_PM_134                      ,   0x1= clock enabled    0x0= clock disabled" "0,1"
        bitfld.long 0x00 4. "     CP_PM_135                         ,not used" "0,1"
        textline "                                "
        bitfld.long 0x00 3. "CP_PM_136                   ,   0x1= clock enabled    0x0= clock disabled" "0,1"
        bitfld.long 0x00 2. "         CP_PM_137                    ,must be set to 1 or deadlock" "0,1"
        bitfld.long 0x00 1. "         CP_PM_138                      ,   0x1= clock enabled    0x0= clock disabled" "0,1"
        bitfld.long 0x00 0. "     CP_PM_139                         ,must be set to 1 or deadlock" "0,1"

group d:0xD0201838++0x03
    line.long 0x00 "AP_status_reg,AP FSM Status Register"
        bitfld.long 0x00 31. " CP_PM_146                   ,1 is audio on" "0,1"
        hexmask.long 0x00 6.--30. 1. "         CP_PM_147                    ,"
        hexmask.long.byte 0x00 0.--5. 1. "  CP_PM_148                      ,the power status for ap-:  bit [5] is always '0' 0: ap reset, 1: idle(normal operation) 5'b01011:wakup sp, 2: dma idle, 4: disable bus, 5: clock gate, 3: memory controller idle, 7: ap sleep, 5'b10011: ap d2"

group d:0xD0201848++0x03
    line.long 0x00 "SG__TIMER,<var Processor: Comm>  Timer Register"
        hexmask.long.byte 0x00 16.--23. 1. " CP_PM_PWR_CLK_PRE156        ,clock divider prescaler for the timer count.  0 = divider by one.  1 = divide by 1.  2= divider by 2.>p> rest incremental divider."
        hexmask.long.byte 0x00 8.--15. 1. "        CP_PM_PWR_UP_STBL_TIMER157   ,power up stable timer  stable time for the power up during core idle mode in 26 mhz unit"
        hexmask.long.byte 0x00 0.--7. 1. "        CP_PM_PWR_DWN_STBL_TIMER158    ,power down stable timer  stable time for the power down during core idle mode in 26 mhz unit"

group d:0xD020184C++0x03
    line.long 0x00 "SG_IDLE_CFG,<var Processor: Comm> Idle  Configuration Register"
        bitfld.long 0x00 20.--21. " CP_PM_PSW_MODE166           ,cr5 core has both big macro power switch and distributed power switch. this field select different power swith mode    2'b00 both big macro switches and distributed switches will be used. during power up – first power up the big macro switches followed by distributed switches.during power down – first power down the distributed switches followed by big macro switches.    2'b01 only big macro switch is used. distributed switches will be permanently shut off    2'b10 only distributed switches in the core is used and big macro switches will be off. distributed switches turn on simultaneously which will cause a big power surge. to reduce the power surge, first turn on all the big macro switches, then turn on distributed switches and finally turn off the big macro switches leaving only the distributed switches on" "0,1,2,3"
        bitfld.long 0x00 19. "         DIS_CORE_L2_SLP              ,disable the core l2 sram power switch sleep power down during core power down mode.  1 = disable core l2 power switch sleep." "0,1"
        bitfld.long 0x00 18. "         CP_PM_DIS_CORE_L1_SLP168       ,disable the core l1 sram power switch sleep power down during core power down mode.  1 = disable core l1 power switch sleep." "0,1"
        bitfld.long 0x00 17. "     CP_PM_DIS_CORE_SLP169             ,disable the core power switch sleep power down during core power down mode.  1 = disable core power switch sleep" "0,1"
        textline "                                "
        bitfld.long 0x00 11. "CP_PM_MASK_CLK_OFF_CHECK171 ,mask core clock off  check during core idle process." "0,1"
        bitfld.long 0x00 10. "         CP_PM_MASK_CLK_STBL_CHECK172 ,mask core clock stable check during core wakeup." "0,1"
        bitfld.long 0x00 9. "         CP_PM_MASK_JTAG_IDLE_CHECK173  ,mask the jtag idle check during mp idle entry   1 = mask the jtag idle check." "0,1"
        bitfld.long 0x00 8. "     CP_PM_MASK_CORE_WFI_IDLE_CHECK174 ,debug only - it should be 0 during normal opration mask core wfi idle check   1 = status check masked  0 = status check not masked" "0,1"
        textline "                                "
        bitfld.long 0x00 5. "CP_PM_DIS_MC_SW_REQ176      ,disable the mc entry to idle mode using the mc sleep request bits. mc will always enter into idle mode based on the hardware sm request.  0 = enable the idle entry using sw register bits.  1 = disable the idle entry using the sw register bits." "0,1"
        bitfld.long 0x00 4. "         CP_PM_SEA_MC_WAKE_EN177      ,wake up the mc when <var processor: comm> wake up from core idle mode. mc will be waked up before the interrupt to the core is released.  0 = mc wake disabled.  1 = mc wake up enabled on <var processor: comm> wake." "0,1"
        bitfld.long 0x00 3. "         CORE_L2_SRAM_PWRDWN            ,l2 is powered off or not when core is powered off <0> l2 is retained <1> l2 is powered off" "0,1"
        bitfld.long 0x00 2. "     CP_PM_CORE_L1_SRAM_PWRDWN179      ,l1 is powered off or not when core is powered off <0> l1 is retained <1> l1 is powered off" "0,1"
        textline "                                "
        bitfld.long 0x00 1. "CP_PM_CORE_PWRDWN180        ,core power down. this bit does not takes effect if core_idle is 0.   1 = when core issue wfi idle, core will go into deep sleep mode and power will be turned off. this bit will not take effect  if cap dbgnopwrdwn is set" "0,1"
        bitfld.long 0x00 0. "         CP_PM_CORE_IDLE181           ,core idle  1 = when core issue wfi idle, the core clock will be gated externally. this bit will not take effect if cr5 dbgnopwrdwn is set" "0,1"

group d:0xD0201870++0x03
    line.long 0x00 "AXISD_HW_SG,AXISD HW Control Register"
        hexmask.long.tbyte 0x00 8.--31. 1. " CP_PM_279                   ,"
        bitfld.long 0x00 7. "    SG_AXISD_CTRL280             ,hardware voting control for axisd   0x1= if <var processor: comm> is active, do not allow axi shut down<p>0x0 = do not care <var processor: comm>'s status" "0,1"
        bitfld.long 0x00 6. "         MSA_AXISD_CTRL281              ,hardware voting control for axisd   0x1= if msa is active, do not allow axi shut down<p>0x0 = do not care msa's status" "0,1"
        bitfld.long 0x00 5. "     CP_DMAC_AXISD_CTRL282             ,hardware voting control for axisd   0x1= if cp dmac is active, do not allow axi shut down<p>0x0 = do not care cp dmac's status" "0,1"
        textline "                                "
        bitfld.long 0x00 4. "DTC_AXISD_CTRL283           ,hardware voting control for axisd   0x1= if dtc is active, do not allow axi shut down<p>0x0 = do not care dtc's status" "0,1"
        bitfld.long 0x00 3. "         PWR_MODE_AXISD_CTRL284       ,hardware voting control for axisd   0x1= if pwr_mode is 2'b00, do not allow axi shut down<p>0x0 = do not care pwr_mode" "0,1"
        bitfld.long 0x00 2. "         FB_DMAC_AXISD_CTRL285          ,hardware voting control for axisd   0x1= if fb dmac is active, do not allow axi shut down<p>0x0 = do not care fb dmac's status" "0,1"
        bitfld.long 0x00 1. "     FB_AXISD_CTRL286                  ,hardware voting control for axisd   0x1= if fb modem is active, do not allow axi shut down<p>0x0 = do not care fb modem's status" "0,1"
        textline "                                "
        bitfld.long 0x00 0. "GSM_AXISD_CTRL287           ,hardware voting control for axisd   0x1= if gsm is active, do not allow axi shut down<p>0x0 = do not care gsm's status" "0,1"

group d:0xD0201874++0x03
    line.long 0x00 "CP_ACLKDIV_HW_CTRL,CPSS Fabric ACLK Clock Divider HW Control"
        hexmask.long 0x00 4.--31. 1. " CP_PM_294                   ,"
        bitfld.long 0x00 3. "  SW_ACLKDIV_DIS_VOTE          ,cp fabric clock divider auto disable sw    0x1 = sw allow cp fabric clock divider to be automatically disabled by hw     0x0 = sw disallow cp fabric clock divider to be automatically disabled by hw" "0,1"
        bitfld.long 0x00 2. "         CPDMA_ACLKDIV_DIS_VOTE         ,cp fabric clock divider auto disable when msa is c2/d2    0x1 = when seagull is in c2/d2, cp fabric clock divider is automatically disabled" "0,1"
        bitfld.long 0x00 1. "     MSA_ACLKDIV_DIS_VOTE              ,cp fabric clock divider auto disable when msa is c2/d2    0x1 = when seagull is in c2/d2, cp fabric clock divider is automatically disabled" "0,1"
        textline "                                "
        bitfld.long 0x00 0. "SG_ACLKDIV_DIS_VOTE         ,cp fabric clock divider auto disable when seagull is c2/d2    0x1 = when seagull is in c2/d2, cp fabric clock divider is automatically disabled" "0,1"

group d:0xD0201880++0x03
    line.long 0x00 "DVC_CP,<var Processor: Comm> Dynamic Voltage Change Register"
        bitfld.long 0x00 31. " VC_INT305                   ,dvc interrupt status   0x1=dvc interrupt   0x0=no dvc interrupt" "0,1"
        bitfld.long 0x00 30. "         VC_INT_EN306                 ,enable/disable dvc interrupt   0x0=disabled    0x1=enabled" "0,1"
        bitfld.long 0x00 29. "         VC_INT_CLR307                  ,clear the dvc interrupt.this bit is auto cleared when interrupt is cleared   0x1= clear interrupt" "0,1"
        bitfld.long 0x00 23. "     LPM_D2_AVC_EN                     ,automatic voltage change enable in low power mode  0 = automatic voltage change is disabled  1 = automatic voltage change is enabled  when comm_top enters or exits d2 mode,  hardware automatically triggers a voltage change request" "0,1"
        textline "                                "
        bitfld.long 0x00 16.--19. "LPM_D2_VL3:0                ,required voltage level by  in d2 low power mode" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 15. "        VC_REQ312                    ,voltage change request in active mode  software can write 1 to this bit to trigger a voltage change request. hardware will automaticly clear this bit when dvc is done. writes of 0 to this bit are ignored." "0,1"
        bitfld.long 0x00 8.--11. "         VL3:0314                       ,voltage level in active mode  required voltage level by <var processor: comm> in active mode  this voltage level can be dynamically changed due to a frequency change." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 7. "    LPM_C2_AVC_EN                     ,automatic voltage change enable in low power mode  0 = automatic voltage change is disabled  1 = automatic voltage change is enabled  when <var processor: comm> enters or exit c2 mode,  hardware automatically triggers a voltage change request" "0,1"
        textline "                                "
        bitfld.long 0x00 0.--3. "LPM_C2_VL3:0                ,required voltage level  in cp c2 low power mode" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"

group d:0xD0201884++0x03
    line.long 0x00 "DVC_DP,"
        bitfld.long 0x00 31. " VC_INT323                   ,dvc interrupt status   0x1=dvc interrupt   0x0=no dvc interrupt" "0,1"
        bitfld.long 0x00 30. "         VC_INT_EN324                 ,enable/disable dvc interrupt   0x0=disabled    0x1=enabled" "0,1"
        bitfld.long 0x00 29. "         VC_INT_CLR325                  ,clear the dvc interrupt.this bit is auto cleared when interrupt is cleared   0x1= clear interrupt" "0,1"
        bitfld.long 0x00 15. "     VC_REQ327                         ,voltage change request in active mode  software can write 1 to this bit to trigger a voltage change request. hardware will automaticly clear this bit when dvc is done. writes of 0 to this bit are ignored." "0,1"
        textline "                                "
        bitfld.long 0x00 8.--11. "VL3:0329                    ,voltage level in active mode  required voltage level by msa in active  mode  this voltage level can be dynamically changed due to a frequency change." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 7. "        CP_PM_LPM_AVC_EN330          ,automatic voltage change enable in low power mode  0 = automatic voltage change is disabled  1 = automatic voltage change is enabled  when msa enters or exit c2 mode,  hardware automatically triggers a voltage change request" "0,1"
        bitfld.long 0x00 0.--3. "         CP_PM_LPM_VL3:0332             ,required voltage level  in dp c2 low power mode" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"

group d:0xD0201888++0x03
    line.long 0x00 "DVC_STATUS,Dynamic Voltage Change Status Register"
        bitfld.long 0x00 24.--27. " CP_PM_CAUSE340              ,dvc cause  this field is the cause of the current ongoing dvc. it is only valid when the <voltage change status> field is 1.   0x1 = <var processor: application mp> software-triggered dvc  0x2 = <var processor: comm> software- triggered dvc   0x4 = <var processor: msa> software- triggered dvc    0x8 = hw-dfc triggered dvc    others = lpm entry/exit trigger dvc" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 16.--19. "        CP_PM_TVL3:0342              ,target voltage level of vcc_main" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 8.--11. "        CP_PM_CVL3:0344                ,current voltage level of vcc_main" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 0. "    CP_PM_DVC_STATUS346               ,voltage change status  the voltage change may be triggered in active state or entering low power mode.  0 = there is no voltage change or a voltage change has finished  1 = voltage change is in progress" "0,1"

group d:0xD0201890++0x03
    line.long 0x00 "DFC_CP,<var Processor: Comm> DCLK Dynamic Freq Change Control Register"
        bitfld.long 0x00 31. " DFC_INT353                  ,dfc interrupt status   0x1=dfc interrupt   0x0=no dfc interrupt" "0,1"
        bitfld.long 0x00 30. "         DFC_INT_EN354                ,enable/disable dfc interrupt   0x0=disabled    0x1=enabled" "0,1"
        bitfld.long 0x00 29. "         DFC_INT_CLR355                 ,clear the dfc interrupt. this bit is auto cleared when interrupt is cleared   0x1= clear interrupt" "0,1"
        bitfld.long 0x00 15. "     DCLK_FC_VOTE357                   ,dfc/dclk frequency change voting bits   0x1 = cp allows dclk /dfc frequency change   0x0 = cp disallows dclk /dfc frequency change" "0,1"
        textline "                                "
        bitfld.long 0x00 12.--14. "LPM_D2_FL                   ,required dclk freq level by comm_top d2 low power mode" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 9.--11. "         LPM_C2_FL                    ,required dclk freq level by <var processor: comm> c2 low power mode" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 8. "         LPM_C2_DFC_EN                  ,dclk hardware freq change enable upon c2 low power mode exit/entry   0 = dclk hw-dfc is disabled upon c2 mode entry/exit  1 = dclk hw-dfc is enabled upon c2 mode entry/exit" "0,1"
        bitfld.long 0x00 7. "     LPM_D2_DFC_EN                     ,dclk hardware freq change enabled upon comm_top d2 low power mode exit/entry   0 = dclk hw-dfc is disabled upon comm_top d2 mode entry/exit  1 = dclk hw-dfc is enabled upon comm_top d2 mode entry/exit" "0,1"
        textline "                                "
        bitfld.long 0x00 1.--3. "CP_PM_FL363                 ,dclk freq level in active mode  required dclk freq level by <var processor: comm> in ative mode" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 0. "         CP_PM_DFC_REQ364             ,dclk dfc request in active mode   dclk dfc for <var processor: comm> in active  mode  software can write 1 to this bit to trigger a dclk dfc request. hardware will automaticly clear this bit when dfc is done. writes of 0 to this bit are ignored." "0,1"

group d:0xD0201894++0x03
    line.long 0x00 "DFC_DP,<var Processor: MSA> DCLK Dynamic Freq Change Control Register"
        bitfld.long 0x00 31. " DFC_INT371                  ,dfc interrupt status   0x1=dfc interrupt   0x0=no dfc interrupt" "0,1"
        bitfld.long 0x00 30. "         DFC_INT_EN372                ,enable/disable dfc interrupt   0x0=disabled    0x1=enabled" "0,1"
        bitfld.long 0x00 29. "         DFC_INT_CLR373                 ,clear the dfc interrupt. this bit is auto cleared when interrupt is cleared   0x1= clear interrupt" "0,1"
        bitfld.long 0x00 15. "     DCLK_FC_VOTE375                   ,dfc/dclk frequency change voting bits   0x1 = <var processor: msa> allows dclk /dfc frequency change   0x0 = <var processor: msa> disallows dclk /dfc frequency change" "0,1"
        textline "                                "
        bitfld.long 0x00 9.--11. "LPM_FL                      ,required dclk freq level by <var processor: seagull/msa> in c2 low power mode" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 8. "         LPM_DFC_EN                   ,dclk hardware freq change enable upon low power mode exit/entry   0 = dclk dfc is disabled upon c2 mode entry/exit  1 = dclk dfc request is enabled. when both <var processor: comm> and msa enters c2 mode or when either <var processor: comm> or msa exits c2 mode, dfc request will automatically be triggered" "0,1"
        bitfld.long 0x00 1.--3. "         CP_PM_FL380                    ,dclk freq level in active mode  required dclk freq level by <var processor: comm> in ative mode" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 0. "     CP_PM_DFC_REQ381                  ,dclk dfc request in active mode   dclk dfc for <var processor: comm> in active  mode  software can write 1 to this bit to trigger a dclk dfc request. hardware will automaticly clear this bit when dfc is done. writes of 0 to this bit are ignored." "0,1"

group d:0xD0201898++0x03
    line.long 0x00 "DFC_STATUS,DCLK Hardware Freq Change Status Register"
        bitfld.long 0x00 15.--17. " CP_PM_DFC_CAUSE389          ,dclk dfc cause  this field is the cause of the current ongoing dfc. it is only valid when the <dclk_dfc_status> field is 1.   0x1 = <var processor: application mp> triggered dfc  0x2 = <var processor: comm>  triggered dfc in active mode  0x4 = <var processor: msa>  triggered dfc in active mode   others   = lpm entry/exit trigger dfc" "0,1,2,3,4,5,6,7"
        hexmask.long.byte 0x00 8.--14. 1. "         CP_PM_TFL390                 ,target freq level of dclk"
        hexmask.long.byte 0x00 1.--7. 1. "        CP_PM_CFL391                   ,current freq level of dclk"
        bitfld.long 0x00 0. "    CP_PM_DFC_STATUS392               ,dclk dfc status  the dclk dfc may be triggered in active state or <var processor: seagull/msa> entering low power mode.  0 = there is no dfc or dfc has finished  1 = dfc is in progress" "0,1"

group d:0xD020189C++0x03
    line.long 0x00 "_DEBUG, Debug Register"
        bitfld.long 0x00 1. " MASK_DVC_CHECK              ,mask dvc check in por13 state machine   0 = check is enabled   1 = check is disabled" "0,1"
        bitfld.long 0x00 0. "         MASK_SG_IDLE_CHECK           ,mask <var processor: comm> idle check in por13 state machine   0 = check is enabled   1 = check is disabled" "0,1"

group d:0xD02018A0++0x03
    line.long 0x00 "CP_S_GATE_CTRL,cp source clock gating"
        hexmask.long 0x00 5.--31. 1. " CP_PM_408                   ,reserved"
        bitfld.long 0x00 4. "  CP_PM_409                    ,1: disable 499m source clock when d2" "0,1"
        bitfld.long 0x00 3. "         CP_PM_410                      ,1: disable 624m source clock when d2" "0,1"
        bitfld.long 0x00 2. "     CP_PM_411                         ,1: disable 832m source clock when d2" "0,1"
        textline "                                "
        bitfld.long 0x00 1. "CP_PM_412                   ,1:disable 416m source clock when d2" "0,1"
        bitfld.long 0x00 0. "         CP_PM_413                    ,1:disable 312m source clock when d2" "0,1"

group d:0xD02018A4++0x03
    line.long 0x00 "CR7_INIT_CFG,CR7 init configuration"
        hexmask.long.word 0x00 22.--31. 1. " CP_PM_420                   ,reserved"
        bitfld.long 0x00 21. "      CPUCLKOFF_MASK               ,   1 = enable cpuclkoff control during cpu boot.    0 = cpuclkoff never asserted during cpu boot" "0,1"
        bitfld.long 0x00 20. "         DBGCLKOFF_MASK                 ,   1 = enable dbgclkoff control    0 = dbgclkoff never asserted during cpu boot" "0,1"
        bitfld.long 0x00 19. "     CP_PM_CFGEND423                   ,cr7 cfgend input" "0,1"
        textline "                                "
        bitfld.long 0x00 18. "CP_PM_CFGEND424             ,cr7 cfgnmfi input" "0,1"
        bitfld.long 0x00 17. "         CP_PM_VINITHI425             ,cr7 vinithi input" "0,1"
        bitfld.long 0x00 16. "         INITRAM0                       ,cr7 initram0 input" "0,1"
        bitfld.long 0x00 15. "     CP_PM_TEINIT427                   ,cr7 teinit input" "0,1"
        textline "                                "
        bitfld.long 0x00 14. "CP_PM_DBGEN428              ,cr7 dbgen input" "0,1"
        bitfld.long 0x00 13. "         CP_PM_NIDEN429               ,cr7 niden input" "0,1"
        bitfld.long 0x00 12. "         L2C_S1_CLKEN                   ,this bit must be set to 0 when cr7 configure the pl310." "0,1"
        bitfld.long 0x00 11. "     CP_PM_SPNIDEN431                  ,cr7 spniden input" "0,1"
        textline "                                "
        hexmask.long.word 0x00 0.--10. 1. "CP_PM_432                   ,reserved"

group d:0xD02018A8++0x03
    line.long 0x00 "CSWER,Communication Subsystem general purpose wakeup enable"
        bitfld.long 0x00 15. " CP_PM_441                   ,allow ripc interrupts as wakeup source   1 = allow ripc interrupt as wakeup source when cwesr_wake_en is asserted <0>not allow ripc interrupt as wakeup source" "0,1"
        bitfld.long 0x00 14. "         CP_PM_442                    ,allow cp timer3 interrupt as wakeup source   1 = allow cp timer3 interrupt as wakeup source when cwesr_wake_en is asserted <0>not allow cp timer3 interrupt as wakeup source" "0,1"
        bitfld.long 0x00 13. "         CP_PM_443                      ,allow cp timer2 interrupt as wakeup source   1 = allow cp timer2 interrupt as wakeup source when cwesr_wake_en is asserted <0>not allow cp timer2 interrupt as wakeup source" "0,1"
        bitfld.long 0x00 12. "     CP_PM_444                         ,allow dap as wakeup source   1 = allow dap as wakeup source when cwesr_wake_en is asserted <0>not allow dap as wakeup source" "0,1"
        textline "                                "
        bitfld.long 0x00 11. "CP_PM_445                   ,allow gpio as wakeup source   1 = allow gpio as wakeup source when cwesr_wake_en is asserted <0>not allow gpio as wakeup source" "0,1"
        bitfld.long 0x00 10. "         CP_PM_446                    ,allow icusb as wakeup source   1 = allow icusb as wakeup source when cwesr_wake_en is asserted <0>not allow icusb timer interrupt as wakeup source" "0,1"
        bitfld.long 0x00 8. "         CP_PM_448                      ,allow airq interrupt as wakeup source   1 = allow airq interrupt as wakeup source when cwesr_wake_en is asserted <0>not allow airq timer interrupt as wakeup source" "0,1"
        bitfld.long 0x00 7. "     CP_PM_449                         ,allow ipc interrupt from ap as wakeup source   1 = allow ipc interrupt from ap as wakeup source when cwesr_wake_en is asserted <0>not allow ipc interrupt from ap as wakeup source" "0,1"
        textline "                                "
        bitfld.long 0x00 6. "CP_PM_450                   ,allow cp timer1 interrupt as wakeup source   1 = allow cp timer1 interrupt as wakeup source when cwesr_wake_en is asserted <0>not allow cp timer1 interrupt as wakeup source" "0,1"
        bitfld.long 0x00 5. "         CP_PM_451                    ,allow pmic interrupt as wakeup source   1 = allow pmic interrupt as wakeup source when cwesr_wake_en is asserted <0>not allow pmic interrupt as wakeup source" "0,1"
        bitfld.long 0x00 4. "         CP_PM_452                      ,allow soc watchdog as wakeup source   1 = allow soc watchdog as wakeup source when cwesr_wake_en is asserted <0>not allow soc watchdog as wakeup source" "0,1"
        bitfld.long 0x00 0. "     CP_PM_454                         ,allow cgpio as wakeup source   1 = allow cgpio as wakeup source when cwesr_wake_en is asserted <0>not allow cgpio as wakeup source" "0,1"

group d:0xD02018AC++0x03
    line.long 0x00 "CSWCR,Communication Subsystem general wakeup global enable"
        bitfld.long 0x00 31. " RESET_WAKEUP_EVENT          ,reset the maskable wakeup events to cp_  1 = wakeup events are reset   0 = wakeup events are kept" "0,1"
        bitfld.long 0x00 30. "         CWESR_WAKE_EN                ,the global wake enable signal for general purpose wakeup events   1 = enabled   0 = disabled" "0,1"
        bitfld.long 0x00 29. "         D2_EXIT_STICKY_CLR             ,  1 = clear d2_exit_sticky" "0,1"
        bitfld.long 0x00 28. "     D2_EXIT_STICKY                    ," "0,1"
        textline "                                "
        bitfld.long 0x00 20. "CAPTURED_UWU                ,status of un-maskable wakeup sources" "0,1"
        bitfld.long 0x00 15. "         CP_PM_469                    ,status of ripc wakeup" "0,1"
        bitfld.long 0x00 14. "         C_TIMER_3_IRQ                  ,status of c timer3 wakeup" "0,1"
        bitfld.long 0x00 13. "     C_TIMER_2_IRQ                     ,status of c timer2 wakeup" "0,1"
        textline "                                "
        bitfld.long 0x00 12. "CP_PM_472                   ,status of dap wakeup" "0,1"
        bitfld.long 0x00 11. "         M1_GPIO_INT_CP               ,status of gpio wakeup" "0,1"
        bitfld.long 0x00 10. "         SPH_USB_WAKEUP                 ,status of ic_usb wakeup" "0,1"
        bitfld.long 0x00 9. "     IPC1_S2A_INT_0                    ,status of ipc wakeup, no used" "0,1"
        textline "                                "
        bitfld.long 0x00 8. "AIRQ                        ,status of airq wakeup" "0,1"
        bitfld.long 0x00 7. "         IPC0_S2A_INT_0               ,status of ipc wakeup from ap" "0,1"
        bitfld.long 0x00 6. "         C_TIMER_1_IRQ                  ,status of c timer1 wakeup" "0,1"
        bitfld.long 0x00 5. "     M1_WUCR_PMIC_WAKEUP_INT           ,status of pmic wakeup" "0,1"
        textline "                                "
        bitfld.long 0x00 4. "M1_WDT_IRQ                  ,status of watchdog wakeup" "0,1"
        bitfld.long 0x00 3. "         M1_CRXD_WAKEUP_INT           ,not used" "0,1"
        bitfld.long 0x00 2. "         M1_GSSP1_WAKEUP                ,not used" "0,1"
        bitfld.long 0x00 1. "     M1_I2C_WAKEUP_INT                 ,status of i2c wakeup" "0,1"
        textline "                                "
        bitfld.long 0x00 0. "M1_CGPIO_WAKEUP_MASK_OR     ,status of cgpio wakeup, not used" "0,1"

group d:0xD02018B0++0x03
    line.long 0x00 "SPH_USB_WK,ICUSB wakeup source control register "
        bitfld.long 0x00 3. " SPH_DM_WK_CLR               ,1=clear icusb dm wakeup source" "0,1"
        bitfld.long 0x00 2. "         SPH_DP_WK_CLR                ,1= clear icusb dp wakeup source" "0,1"
        bitfld.long 0x00 1. "         SPH_DM_WK_EN                   ,1= enable icusb dm wakeup" "0,1"
        bitfld.long 0x00 0. "     SPH_DP_WK_EN                      ,1= enable icusb dp wakeup" "0,1"

group d:0xD02018BC++0x03
    line.long 0x00 "CPSR,Marvell <var Processor: Comm> Power Status Register"
        bitfld.long 0x00 31. " CP_PM_DSPIDL504             ,reflects the state of the marvell msa core (not marvell msa subsystem). the availability of the marvell msa subsystem memories and peripheral bus to the marvell <var processor: comm> core is still governed by means of mpcrx[dspsd], and is not reflected by this bit.  0 = marvell msa core is currently not in idle state  1 = marvell msa core is currently in idle state" "0,1"
        bitfld.long 0x00 28. "         CP_PM_DSPAVL506              ,marvell msa subsystem availability indication. this field should be read after mpcrx[dspsd] is deasserted, to verify the clock is resumed  0 = marvell msa subsystem clock is not running  1 = marvell msa subsystem clock is running" "0,1"
        bitfld.long 0x00 24. "         CP_PM_COMM_TOP_D2508           ,reflects the power state of comm_top   1 = comm_top is in d2 mode. in this mode, msa/seagull are powered off" "0,1"
        bitfld.long 0x00 5. "     SG_WFI_FLAG                       , seagull wfi flag. it reflects the wfi flag that is directly output from seagull. when seagull enters wfi, this field will be set." "0,1"
        textline "                                "
        bitfld.long 0x00 4. "CP_PM_SG_IDLE511            ,1 = <var processor: comm> is idle   0 = <var processor: comm> is active" "0,1"
        bitfld.long 0x00 0.--3. "         CP_PM_COMM_TOP_STATE512      ,comm_top low power state   0x8=comm_top is in d0 state    0xb=comm_top is in d2 state" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"

group d:0xD02018C0++0x03
    line.long 0x00 "CPRR,Marvell <var Processor: Comm> Programmable Reset Register"
        bitfld.long 0x00 6. " CP_PM_SLAVE_R521            ,slave_reset_out pin sw reset control  1 = slave_reset_out is low.  0 = slave_reset_out may be high base on reset_in and wdt reset." "0,1"
        bitfld.long 0x00 5. "         CP_PM_DSRAMINT522            ,this signal hold the msa from start execution after released from reset. it will be used to hold msa from start execution till his boot address in sram will be initial with valid code.  1 = execution is hold  0 = msa is running" "0,1"
        bitfld.long 0x00 4. "         WDTR523                        ,negate hardware reset to the wdt after system reset. this field is reset due to a wdt reset event  reading 0 = wdt reset is still asserted from the last system reset  reading 1 = wdt reset is negated  writing 0 = operation is ignored  writing 1 = negates the wdt reset  the actual release of the wdt reset signal might be delayed by up to 11/2 cycles of the 32.768 khz clock" "0,1"
        bitfld.long 0x00 3. "     CP_PM_BBR524                      ,apply global hardware reset to the baseband logic  0 = hardware reset is negated  1 = hardware reset is asserted  the baseband logic reset is effected also from dprr register." "0,1"
        textline "                                "
        bitfld.long 0x00 2. "CP_PM_DSPR525               ,apply global hardware reset to the whole marvell msa subsystem.  0 = hardware reset is negated - msa subsystem is released from reset.  1 = hardware reset is asserted - msa subsystem is hold in reset" "0,1"
        bitfld.long 0x00 1. "         CP_PM_APR526                 ,apply hardware reset to the application processor .  0 = hardware reset is negated - core is released from reset.  1 = hardware reset is asserted - core is hold in reset.  the initial value of this bit is determined by cp_wf_fuse not  cp_wf_fuse = 1 (<var processor: comm> core is the first one to boot).  cp_wf_fose not is 0 when <var processor: comm> wakeup first" "0,1"
        bitfld.long 0x00 0. "         CP_PM_CPR527                   ,this is read only bit, depending on cp_wf_fuse   0 = <var processor: comm> core was the first core to boot  1 = <var processor: comm> core was the second core to boot." "0,1"

group d:0xD02018C4++0x03
    line.long 0x00 "CPCR,Marvell <var Processor: Comm> Power Control Register"
        bitfld.long 0x00 31. " CP_PM_AXISDD535             ,allow axi bus and agents to be shut down after marvell <var processor: comm> cores enters idle state.  0  axi shutdown not allowed  1 = axi shutdown allowed" "0,1"
        bitfld.long 0x00 30. "         CP_PM_DSPSD536               ,not used" "0,1"
        bitfld.long 0x00 29. "         CP_PM_SLPEN537                 ,allow  to switch the system to sleep mode once it reached system idle mode.  0  sleep mode not allowed  1 = sleep mode allowed" "0,1"
        bitfld.long 0x00 28. "     DTCMSD538                         ,allow dtcm access path from main axi to be shut down when marvell <var processor: comm> core enters idle state.  0  dtcm path shutdown not allowed  1 = dtcm shutdown allowed" "0,1"
        textline "                                "
        bitfld.long 0x00 27. "CP_PM_DDRCORSD539           ,allow marvell <var processor: comm>/mohawk core and tc ddr clocks shutdown. the clocks are halted when cpcr[ddrcorsd], apcr[ddrcorsd] & dpcr[ddrcorsd] are set and marvell mohawk core is in idle mode   0  marvell <var processor: comm> core and tc ddr clocks shutdown not allowed  1 = marvell <var processor: comm>/mohawk core and tc ddr clocks shutdown allowed" "0,1"
        bitfld.long 0x00 26. "         CP_PM_APBSD540               ,allow  to shut down apb clock to all of its recipients, overriding other per-module fields. the apb clock is actually shut down once the marvell <var processor: comm> & mohawk cores are idle and cpcr[apbsd], apcr[apbsd] & dpcr[apbsd] are set  0 = apb clock shutdown not allowed  1 = apb clock shutdown allowed" "0,1"
        bitfld.long 0x00 25. "         CP_PM_BBSD541                  ,allow  to shut down all clocks provided to the baseband logic, except 32.768 khz clock. the baseband logic clocks are halted as soon as cpcr[bbsd], apcr[bbsd] & dpcr[bbsd] are set and pm_bb_clkres port is negated.  0 = bb clocks shutdown not allowed  1 = bb clocks shutdown allowed" "0,1"
        bitfld.long 0x00 24. "     CP_PM_INTCLR542                   ,interrupt clear register.   a write of 1 followed by a write of 0 to this field clears the pm_moh_wakeup_int output of .  the read value is the last value written to this field." "0,1"
        textline "                                "
        bitfld.long 0x00 23. "CP_PM_SLPWP0543             ,sleep mode wake-up decoder port 0 disable  0 = wake-up port 0 is enabled  1 = wake-up port 0 is disabled" "0,1"
        bitfld.long 0x00 22. "         CP_PM_SLPWP1544              ,sleep mode wake-up decoder port 1 disable  0 = wake-up port 1 is enabled  1 = wake-up port 1 is disabled" "0,1"
        bitfld.long 0x00 21. "         CP_PM_SLPWP2545                ,sleep mode wake-up decoder port 2 disable  0 = wake-up port 2 is enabled  1 = wake-up port 2 is disabled" "0,1"
        bitfld.long 0x00 20. "     CP_PM_SLPWP3546                   ,sleep mode wake-up decoder port 3 disable  0 = wake-up port 3 is enabled  1 = wake-up port 3 is disabled" "0,1"
        textline "                                "
        bitfld.long 0x00 19. "CP_PM_VCTCXOSD547           ,allow vctcxo shutdown when system is in sleep mode. vctcxo is shutdown when cpcr[vctcxosd], apcr[vctcxosd] & dpcr[vctcxosd] are set & the system enters sleep mode  0 = vctcxo shutdown not allowed  1 = vctcxo shutdown allowed" "0,1"
        bitfld.long 0x00 18. "         CP_PM_SLPWP4548              ,sleep mode wake-up decoder port 4 disable  0 = wake-up port 4 is enabled  1 = wake-up port 4 is disabled" "0,1"
        bitfld.long 0x00 17. "         CP_PM_SLPWP5549                ,sleep mode wake-up decoder port 5 disable  0 = wake-up port 5 is enabled  1 = wake-up port 5 is disabled" "0,1"
        bitfld.long 0x00 16. "     CP_PM_SLPWP6550                   ,sleep mode wake-up decoder port 6 disable  0 = wake-up port 6 is enabled  1 = wake-up port 6 is disabled" "0,1"
        textline "                                "
        bitfld.long 0x00 15. "CP_PM_SLPWP7551             ,sleep mode wake-up decoder port 7 disable  0 = wake-up port 7 is enabled  1 = wake-up port 7 is disabled" "0,1"
        bitfld.long 0x00 14. "         CP_PM_MSASLPEN552            ,allow msa to switch msa subsystem to sleep mode once it reached msa sub system idle mode.the sleep mode is allowed when cpcr[msaslpen], apcr[msaslpen] & dpcr[msaslpen]  0 = msa sleep mode not allowed  1 = msa sleep mode allowed  base on the c setting, msa subsystem may be powered down." "0,1"
        bitfld.long 0x00 13. "         CP_PM_STBYEN553                ,allow apps subsystem to shutdown and go into udr-mode when ap subsystem is in sleep mode.  udr is enabled when cpcr[stbyen], apcr[stbyen] are both set & ap subsystem enters ap sleep." "0,1"
        bitfld.long 0x00 3. "     CP_VOTE_AP_SLPEN                  ,cp vote apmu sleep enable" "0,1"

group d:0xD02018C8++0x03
    line.long 0x00 "CCGR,Marvell <var Processor: Comm> Clock Gating Register"
        bitfld.long 0x00 19. " CP_PM_WDT_13M565            ,enable the functional 13 mhz clock output of the main  to the watchdogtimer.  0 = clock not enabled  1 = clock enabled" "0,1"
        bitfld.long 0x00 16. "         CP_PM_CLK_1248M567           ,enable the functional 1248 mhz clock output.   0 = clock not enabled  1 = clock enabled" "0,1"
        bitfld.long 0x00 15. "         CP_PM_CLK_624M568              ,enable the functional 624 mhz clock output.   0 = clock not enabled  1 = clock enabled" "0,1"
        bitfld.long 0x00 14. "     CP_PM_CLK_832M569                 ,enable the functional 832 mhz clock output.  0 = clock not enabled  1 = clock enabled" "0,1"
        textline "                                "
        bitfld.long 0x00 13. "CP_PM_CLK_312M570           ,enable the functional 312 mhz clock output.  0 = clock not enabled  1 = clock enabled" "0,1"
        bitfld.long 0x00 12. "         CP_PM_CLK_104M571            ,enable the functional 104 mhz clock output.  0 = clock not enabled  1 = clock enabled" "0,1"
        bitfld.long 0x00 11. "         CLK_52M572                     ,enable the functional 52 mhz clock output for ap pmu and ap perihrals.  0 = clock not enabled  1 = clock enabled" "0,1"
        bitfld.long 0x00 10. "     CP_PM_CLK_48M573                  ,enable the functional 48 mhz clock output.  0 = clock not enabled  1 = clock enabled" "0,1"
        textline "                                "
        bitfld.long 0x00 9. "CP_PM_GPC574                ,enable the m/n clock generator of the vcxo clockconfigured through gpcr, the clcok is output to vcxo_out pad func3  0 = clock not enabled  1 = clock enabled" "0,1"
        bitfld.long 0x00 8. "         CP_PM_AP_FUART575            ,enable the functional fast uart clock output (58.5 mhz) of the main  to the application processor apb portion.  0 = clock not enabled  1 = clock enabled" "0,1"
        bitfld.long 0x00 7. "         CLK_52M576                     ,enable the functional 52 mhz clock output for apb peripherals  0 = clock not enabled  1 = clock enabled" "0,1"
        bitfld.long 0x00 6. "     CP_PM_AP_TWSI577                  ,enable the 32m clock of the functional twsi clock output of the main  to the application processor apb portion.  0 = clock not enabled  1 = clock enabled" "0,1"
        textline "                                "
        bitfld.long 0x00 5. "CP_PM_CLK_208M578           ,enable the functional 208 mhz clock output.  0 = clock not enabled  1 = clock enabled" "0,1"
        bitfld.long 0x00 4. "         CP_PM_CLK_26M579             ,enable the functional 26 mhz clock output.  0 = clock not enabled  1 = clock enabled" "0,1"
        bitfld.long 0x00 3. "         CP_PM_CLK_13M580               ,enable the functional 13 mhz clock output.  0 = clock not enabled  1 = clock enabled" "0,1"
        bitfld.long 0x00 2. "     CP_PM_CLK_6.5M581                 ,enable the functional 6.5 mhz clock output.  0 = clock not enabled  1 = clock enabled" "0,1"
        textline "                                "
        bitfld.long 0x00 1. "CP_PM_AP_SUART582           ,enable the functional m/n slow uart clock output (configured through succr) of the main  to the application processor apb portion. it's just uart slow clock(14.17m) source enable   0 = clock not enabled  1 = clock enabled." "0,1"
        bitfld.long 0x00 0. "         CP_PM_CLK_416M583            ,enable the functional 416 mhz clock output.   0 = clock not enabled  1 = clock enabled" "0,1"

group d:0xD02018CC++0x03
    line.long 0x00 "CWUCRM,Wakeup and Clock Resume Lines Mask Register"
        bitfld.long 0x00 31. " CP_PM_AUDIO_WAKEUP590       ,mask audio_wakeup" "0,1"
        bitfld.long 0x00 30. "         CP_PM_AP_GT_WAKEUP591        ,mask ap generic timer wakeup" "0,1"
        bitfld.long 0x00 29. "         CP_PM_GSM_WAKEUPWMX592         ,mask gsm wakeup from pm_clkres" "0,1"
        bitfld.long 0x00 28. "     CP_PM_FB_WAKEUPX593               ,mask fb wakeup from pm_clkres" "0,1"
        textline "                                "
        bitfld.long 0x00 27. "CP_PM_GSM_WAKEUPWM594       ,mask gsm wakeup from msa_wake" "0,1"
        bitfld.long 0x00 26. "         CP_PM_FB_WAKEUPWM595         ,mask fb wakeup rom msa_wake" "0,1"
        bitfld.long 0x00 25. "         AP_ASYNC_INT596                ,mask ap async int from pm_clkres" "0,1"
        bitfld.long 0x00 24. "     AP_FULL_IDLE597                   ,mask ap full idle from pm_clkres" "0,1"
        textline "                                "
        bitfld.long 0x00 23. "SDH1_AUDIO598               ,mask sdh1/audio wakeup" "0,1"
        bitfld.long 0x00 22. "         SDH2599                      ,mask sdh2 wakeup" "0,1"
        bitfld.long 0x00 21. "         KEYPRESS600                    ,mask keypress wakeup" "0,1"
        bitfld.long 0x00 20. "     TRACKBALL601                      ,mask trackball wakeup" "0,1"
        textline "                                "
        bitfld.long 0x00 19. "NEWROTARY602                ,mask newrotary wakeup" "0,1"
        bitfld.long 0x00 18. "         WDT603                       ,mask wdt wakeup" "0,1"
        bitfld.long 0x00 17. "         RTC_ALARM604                   ,mask rtc alarm wakeup" "0,1"
        bitfld.long 0x00 16. "     CP_TIMER_3605                     ,mask cp timer int3 wakeup" "0,1"
        textline "                                "
        bitfld.long 0x00 15. "CP_TIMER_2606               ,mask cp timer int2 wakeup" "0,1"
        bitfld.long 0x00 14. "         CP_TIMER_1607                ,mask cp timer int1 wakeup" "0,1"
        bitfld.long 0x00 13. "         AP1_TIMER_3608                 ,mask ap timer1 int3 wakeup" "0,1"
        bitfld.long 0x00 12. "     AP1_TIMER_2609                    ,mask ap timer1 int2 wakeup" "0,1"
        textline "                                "
        bitfld.long 0x00 11. "AP1_TIMER_1610              ,mask ap timer1 int1 wakeup" "0,1"
        bitfld.long 0x00 10. "         AP0_2_TIMER_3611             ,mask ap timer0 and ap timer2 int3 wakeup" "0,1"
        bitfld.long 0x00 9. "         AP0_2_TIMER_2612               ,mask ap timer0 and ap timer2 int2 wakeup" "0,1"
        bitfld.long 0x00 8. "     AP0_2_TIMER_1613                  ,mask ap timer0 and ap timer2 int1 wakeup" "0,1"
        textline "                                "
        bitfld.long 0x00 7. "WAKEUP7614                  ,mask wakeup7 input to pm_clkres" "0,1"
        bitfld.long 0x00 6. "         WAKEUP6615                   ,mask wakeup6 input to pm_clkres" "0,1"
        bitfld.long 0x00 5. "         WAKEUP5616                     ,mask wakeup5 input to pm_clkres" "0,1"
        bitfld.long 0x00 4. "     WAKEUP4617                        ,mask wakeup4 input to pm_clkres" "0,1"
        textline "                                "
        bitfld.long 0x00 3. "WAKEUP3618                  ,mask wakeup3 input to pm_clkres" "0,1"
        bitfld.long 0x00 2. "         WAKEUP2619                   ,mask wakeup2 input to pm_clkres" "0,1"
        bitfld.long 0x00 1. "         WAKEUP1620                     ,mask wakeup1input to pm_clkres" "0,1"
        bitfld.long 0x00 0. "     WAKEUP0621                        ,mask wakeup0 input to pm_clkres" "0,1"

group d:0xD02018D0++0x03
    line.long 0x00 "CWUCRS,Wakeup and Clock Resume Lines Status Register"
        bitfld.long 0x00 31. " CP_PM_BB_DROWSY_EN628       ,bb_drowsy_en" "0,1"
        bitfld.long 0x00 30. "         CP_PM_BB_VCTCXO_REQ629       ,bb_vctcxo_req" "0,1"
        bitfld.long 0x00 29. "         CP_PM_MSA_WAKE_PM_BB_CLKRES630 ,msa_wake/pm_bb_clkres" "0,1"
        bitfld.long 0x00 28. "     CP_PM_PM_CLKRES631                ,pm_clkres" "0,1"
        textline "                                "
        bitfld.long 0x00 27. "CP_PM_GSM_WAKEUP632         ,gsm wakeup" "0,1"
        bitfld.long 0x00 26. "         CP_PM_FB_WAKEUP633           ,fb wakeup" "0,1"
        bitfld.long 0x00 25. "         AP_ASYNC_INT634                ,ap async int" "0,1"
        bitfld.long 0x00 24. "     AP_FULL_IDLE635                   ,ap full idle" "0,1"
        textline "                                "
        bitfld.long 0x00 23. "SDH1_AUDIO636               ,sdh1/audio wakeup" "0,1"
        bitfld.long 0x00 22. "         SDH2637                      ,sdh2 wakeup" "0,1"
        bitfld.long 0x00 21. "         KEYPRESS638                    ,keypress" "0,1"
        bitfld.long 0x00 20. "     TRACKBALL639                      ,trackball" "0,1"
        textline "                                "
        bitfld.long 0x00 19. "NEWROTARY640                ,newrotary" "0,1"
        bitfld.long 0x00 18. "         WDT641                       ,wdt" "0,1"
        bitfld.long 0x00 17. "         RTC_ALARM642                   ,rtc alarm" "0,1"
        bitfld.long 0x00 16. "     CP_TIMER_3643                     ,cp timer 3" "0,1"
        textline "                                "
        bitfld.long 0x00 15. "CP_TIMER_2644               ,cp timer 2" "0,1"
        bitfld.long 0x00 14. "         CP_TIMER_1645                ,cp timer 1" "0,1"
        bitfld.long 0x00 13. "         AP1_TIMER_3646                 ,ap1 timer 3" "0,1"
        bitfld.long 0x00 12. "     AP1_TIMER_2647                    ,ap1 timer 2" "0,1"
        textline "                                "
        bitfld.long 0x00 11. "AP1_TIMER_1648              ,ap1 timer 1" "0,1"
        bitfld.long 0x00 10. "         AP0_2_TIMER_3649             ,ap0 timer 3 and ap2 timer 3" "0,1"
        bitfld.long 0x00 9. "         AP0_2_TIMER_2650               ,ap0 timer 2 and ap2 timer 2" "0,1"
        bitfld.long 0x00 8. "     AP0_2_TIMER_1651                  ,ap0 timer 1 and ap2 timer 1" "0,1"
        textline "                                "
        bitfld.long 0x00 8. "WAKEUP7652                  ,wakeup7 line in status" "0,1"
        bitfld.long 0x00 6. "         WAKEUP6653                   ,wakeup6 line in status" "0,1"
        bitfld.long 0x00 5. "         WAKEUP5654                     ,wakeup5 line in status" "0,1"
        bitfld.long 0x00 4. "     WAKEUP4655                        ,wakeup4 line in status" "0,1"
        textline "                                "
        bitfld.long 0x00 3. "WAKEUP3656                  ,wakeup3 line in status" "0,1"
        bitfld.long 0x00 2. "         WAKEUP2657                   ,wakeup2 line in status" "0,1"
        bitfld.long 0x00 1. "         WAKEUP1658                     ,wakeup1 line in status" "0,1"
        bitfld.long 0x00 0. "     WAKEUP0659                        ,wakeup0 line in status" "0,1"

group d:0xD02018D4++0x03
    line.long 0x00 "CRSR,Marvell <var Processor: Comm>/Mohawk Reset Status Register"
        bitfld.long 0x00 8.--11. " CP_PM_SWR668                ,software controlled, reset events tracking field. this field may be written (and read) to any value between 0x0 and 0xf.   this field's content does not affect  functionality in any way" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 2. "        WDTR670                      ,indicates whether the last system reset was caused by a watchdog timer reset event  0 = last system reset was not caused by watchdog timer reset  1 = last system reset was caused by watchdog timer reset  depending on the type of reset the device has experienced, one of the reset values in [2:0] is 1 and the others are 0." "0,1"
        bitfld.long 0x00 1. "         CP_PM_EMR671                   ,indicates whether the last system reset was caused by an external master reset event  0 = last system reset was not caused by external master reset  1 = last system reset was caused by external master reset  depending on the type of reset the device has experienced, one of the reset values in [2:0] is 1 and the others are 0." "0,1"
        bitfld.long 0x00 0. "     CP_PM_POR672                      ,indicates whether the last system reset was caused by a power on reset  event  0 = last system reset was not caused by power on reset  1 = last system reset was caused by power on reset  depending on the type of reset the device has experienced, one of the reset values in [2:0] is 1 and the others are 0." "0,1"

group d:0xD02018DC++0x03
    line.long 0x00 "CUCCR,CP UART Clock and  reset Control Register"
        hexmask.long 0x00 6.--31. 1. " CP_PM_RESERVED679           ,reserved"
        bitfld.long 0x00 5. "  CP_UART_RESET_EN             ,0x1 =  reset asserted" "0,1"
        bitfld.long 0x00 4. "         CP_UART_APB_EN                 ,0x1 = clock enable" "0,1"
        bitfld.long 0x00 3. "     CP_UART_FCLK_EN                   ,0x1 =  clock enable" "0,1"
        textline "                                "
        bitfld.long 0x00 0.--2. "CP_UART_CLK_SEL             ,uart clock selection: 0x0 = fast 48mhz clock (312m div 5p3), 0x1 = slow m/n divider clock (generated by the main pmu 156m m/n divider  in succr register). other selection reserved" "0,1,2,3,4,5,6,7"

group d:0xD02018E0++0x03
    line.long 0x00 "DMA_INT_MSK,DMA Interrupt Mask Register"
        hexmask.long 0x00 0.--31. 1. " DMA_INT_MSK                 ,cp dma interrupt mask  this field contains one bit for each dma channel interrupt mask.  1 = interrupt is masked"

group d:0xD02018E4++0x03
    line.long 0x00 "DMA_INT_STATUS,DMA Interrupt Status Register"
        hexmask.long 0x00 0.--31. 1. " CP_DMA_INT_STATUS           ,cp dma interrupt status   this field contains one bit for each dma channel interrupt that is pending (after masking).    0x1= interrupt is pending"

group d:0xD02018E8++0x03
    line.long 0x00 "DMA_XTC_CTRL,DMA WTC RTC Control Register"
        bitfld.long 0x00 12.--15. " CP_DMA_WTCB                 ,cp_dma_wtcb" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 8.--11. "        CP_DMA_RTCB                  ,cp_dma_rtcb" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 4.--7. "        CP_DMA_WTC                     ,cp_dma_wtc" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 0.--3. "    CP_DMA_RTC                        ,cp_dma_rtc" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"

group d:0xD02018F0++0x03
    line.long 0x00 "DYN_CLK_GATE_CTRL,Dynamic Clock Gating Control"
        bitfld.long 0x00 16. " DTC_DYN_CG_EN               ,dynamic clock gating control enable for dtc.when enabled, when dtc is inatcive, dtc clkgen will be disabled to save more power    0x0=disabled    0x1=enabled" "0,1"
        bitfld.long 0x00 5. "         CR5FAB_DYN_CG_EN             ,cr5 2x1 fabric dynamic clock gating control enable. when enable, cr5 2x1 fabric axi clock will be gated dynamically to save more power    0x0=disabled    0x1=enabled" "0,1"
        bitfld.long 0x00 4. "         FBFAB_DYN_CG_EN                ,fb 2x1 fabric dynamic clock gating control enable. when enable, fb 2x1 fabric axi clock will be gated dynamically to save more power    0x0=disabled    0x1=enabled" "0,1"
        bitfld.long 0x00 3. "     GBDEC_DYN_CG_EN                   ,gb decoder dynamic clock gating control enable. when enable, gb decoder axi clock will be gated dynamically to save more power    0x0=disabled    0x1=enabled" "0,1"
        textline "                                "
        bitfld.long 0x00 2. "GBPRT_DYN_CG_EN             ,cpss fabric gb port dynamic clock gating control enable. when enabled, gb port axi clock on cpss fabric will be gated dynamically to save more power    0x0=disabled    0x1=enabled" "0,1"
        bitfld.long 0x00 1. "         CR5PRT_DYN_CG_EN             ,cpss fabric cr5 port dynamic clock gating control enable. when enabled, cr5 port axi clock on cpss fabric will be gated dynamically to save more power    0x0=disabled    0x1=enabled" "0,1"
        bitfld.long 0x00 0. "         CPFAB_DYN_CG_EN                ,cpss fabric dynamic clock gating control enable. when enabled, cpss fabric axi clock will be gated dynamically to save more power    0x0=disabled    0x1=enabled" "0,1"

group d:0xD02018F4++0x03
    line.long 0x00 "FABRIC_QoS_CTRL,Fabric QoS  Control"
        bitfld.long 0x00 28.--31. " DTC_MST_AR_QOS              ,cr5 2x1 fabric dtc master read channel qos value" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 24.--27. "        DTC_MST_AW_QOS               ,cr5 2x1 fabric dtc master write channel qos value" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 20.--23. "        CR5_MST_AR_QOS                 ,cr5 2x1 fabric cr5 master read channel qos value" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 16.--19. "    CR5_MST_AW_QOS                    ,cr5 2x1 fabric cr5 master write channel qos value" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        textline "                                "
        bitfld.long 0x00 12.--15. "GB_MST_AR_QOS               ,fb 2x1 fabric gb master read channel qos value" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 8.--11. "        GB_MST_AW_QOS                ,fb 2x1 fabric gb master write channel qos value" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 4.--7. "        FB_MST_AR_QOS                  ,fb 2x1 fabric fb master read channel qos value" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 0.--3. "    FB_MST_AW_QOS                     ,fb 2x1 fabric fb master write channel qos value" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"

group d:0xD0201900++0x03
    line.long 0x00 "DDR_REQ_CTRL_GB,DDR Request Control Register for GB"
        hexmask.long 0x00 4.--31. 1. " CP_PM_745                   ,"
        bitfld.long 0x00 31. "  DDRC_RDY_EN746               ,  1 = 1= axi transactions to ddrc are sent without considering ddrc's status   0 =  0= axi transactions to ddrc are only sent when ddrc is ready" "0,1"
        hexmask.long.word 0x00 21.--30. 1. "         CP_PM_747                      ,"
        bitfld.long 0x00 20. "  FBDMA_DDRC_REQ_EN748              ,  0x1= if fb dma is active, request ddrc resource<p>0x0 = ddrc resource will not be requested because fb dma's is active" "0,1"
        textline "                                "
        bitfld.long 0x00 19. "DTC_DDRC_REQ_EN749          ,  0x1= if dtc is active, request ddrc resource<p>0x0 = ddrc resource will not be requested because dtc's is active" "0,1"
        bitfld.long 0x00 18. "         CPDMA_DDRC_REQ_EN750         ,  0x1= if cp dma is active, request ddrc resource<p>0x0 = ddrc resource will not be requested because cp dma is actvie" "0,1"
        bitfld.long 0x00 17. "         MSA_DDRC_REQ_EN751             ,  0x1= if msa is active, request ddrc resource<p>0x0 = ddrc resource will not be requested because msa is active" "0,1"
        bitfld.long 0x00 16. "     SG_DDRC_REQ_EN752                 ,  0x1= if <var processor: comm> is active, request ddrc resource<p>0x0 = ddrc resource will not be requested because <var processor: comm> is active" "0,1"
        textline "                                "
        bitfld.long 0x00 15. "GSM_DDRC_REQ_EN753          ,  0x1= if gsm is active, request ddrc resource<p>0x0 = ddrc resource will not be requested because gsm is active" "0,1"
        bitfld.long 0x00 14. "         CP_PM_754                    ," "0,1"
        bitfld.long 0x00 13. "         FB_MODEM_DDRC_REQ_EN755        ,  0x1= if modem is active, request ddrc resource<p>0x0 = ddrc resource will not be requested because modem is active" "0,1"
        bitfld.long 0x00 12. "     PWR_MODE_DDRC_REQ_EN756           ,  0x1= if pwr_mode is 2'b00, request ddrc resource<p>0x0 = ddrc resource will not be requested because pwr_mode is 2'b00" "0,1"
        textline "                                "
        hexmask.long.byte 0x00 4.--11. 1. "CP_PM_757                   ,"
        bitfld.long 0x00 3. "        DTCMSD758                    ,ddr is ready for cp access   1 = ddr is ready <0>ddr is not ready" "0,1"
        bitfld.long 0x00 0.--2. "         CP_PM_759                      ," "0,1,2,3,4,5,6,7"

group d:0xD0201904++0x03
    line.long 0x00 "AXISD_HW_GB,AXISD HW Control Register"
        hexmask.long.tbyte 0x00 8.--31. 1. " CP_PM_766                   ,"
        bitfld.long 0x00 7. "    SG_AXISD_CTRL767             ,hardware voting control for axisd   0x1= if <var processor: comm> is active, do not allow axi shut down<p>0x0 = do not care <var processor: comm>'s status" "0,1"
        bitfld.long 0x00 6. "         MSA_AXISD_CTRL768              ,hardware voting control for axisd   0x1= if msa is active, do not allow axi shut down<p>0x0 = do not care msa's status" "0,1"
        bitfld.long 0x00 5. "     CP_DMAC_AXISD_CTRL769             ,hardware voting control for axisd   0x1= if cp dmac is active, do not allow axi shut down<p>0x0 = do not care cp dmac's status" "0,1"
        textline "                                "
        bitfld.long 0x00 4. "DTC_AXISD_CTRL770           ,hardware voting control for axisd   0x1= if dtc is active, do not allow axi shut down<p>0x0 = do not care dtc's status" "0,1"
        bitfld.long 0x00 3. "         PWR_MODE_AXISD_CTRL771       ,hardware voting control for axisd   0x1= if pwr_mode is 2'b00, do not allow axi shut down<p>0x0 = do not care pwr_mode" "0,1"
        bitfld.long 0x00 2. "         FB_DMAC_AXISD_CTRL772          ,hardware voting control for axisd   0x1= if fb dmac is active, do not allow axi shut down<p>0x0 = do not care fb dmac's status" "0,1"
        bitfld.long 0x00 1. "     FB_AXISD_CTRL773                  ,hardware voting control for axisd   0x1= if fb modem is active, do not allow axi shut down<p>0x0 = do not care fb modem's status" "0,1"
        textline "                                "
        bitfld.long 0x00 0. "GSM_AXISD_CTRL774           ,hardware voting control for axisd   0x1= if gsm is active, do not allow axi shut down<p>0x0 = do not care gsm's status" "0,1"

group d:0xD0201924++0x03
    line.long 0x00 "CP_Timer_CTRL,CP Timer Control Register"
        hexmask.long 0x00 2.--31. 1. " CP_PM_819                   ,reserved"
        bitfld.long 0x00 5. "  CP_TIMER_RESET_EN            ,1 =  reset" "0,1"
        bitfld.long 0x00 4. "         CP_TIMER_APB_CLKEN             ,1 =  clock enable" "0,1"
        bitfld.long 0x00 3. "     CP_TIMER_FUNC_CLKEN               ,1 = clock enable" "0,1"
        textline "                                "
        bitfld.long 0x00 0.--2. "CP_TIMER_FAST_CLK_SEL       ,0 = 13mhz clock; 1 =  32k clock; 2 = 6.5mhz clock, 3 = 3.25mhz clock, 4 = 1mhz clock, 5~7: reserved" "0,1,2,3,4,5,6,7"

group d:0xD0201928++0x03
    line.long 0x00 "CP_I2SCCRx,CP I2S Clock Generation Control Register"
        bitfld.long 0x00 31. " CP_PM_SYSCLK_EN830          ,enables the i2s clock input to sysclkn generator as well as the output of the generator." "0,1"
        bitfld.long 0x00 30. "         CP_PM_SYSCLK_BASE831         ,selects the i2s m/n divider input clock frequency:  0 = sysclkn generator base clock rate is 26 mhz  1 = sysclkn generator base clock rate is 156 mhz." "0,1"
        bitfld.long 0x00 29. "         CP_PM_BITCLK_EN832             ,enables the i2s clock input to the bit clock generator." "0,1"
        bitfld.long 0x00 27.--28. "     CP_PM_BITCLK_DIV_468833           ,determine bitclk1:sysclk1 relation:  0x0 = reserved  0x1 = bitclk1 rate is the sysclk1 rate divide by 4  0x2 = bitclk1 rate is the sysclk1 rate divide by 6  0x3 = bitclk1 rate is the sysclk1 rate divide by 8" "0,1,2,3"
        textline "                                "
        hexmask.long.word 0x00 15.--26. 1. "CP_PM_DENOM834              ,i2s clock generation programmable divider denominator value.  the i2s sysclk is generated using a fractional divider. see section 1.5.2.4, i2s clock divider programming, on page 74 for calculating the required values."
        hexmask.long.word 0x00 0.--14. 1. "      CP_PM_NOM835                 ,i2s clock generation programmable divider numerator value.  the i2s sysclk is generated using a fractional divider. see section 1.5.2.4, i2s clock divider programming, on page 74 for calculating the required values."

tree.end

tree "timerspmu"

width 11.

group d:0xD4080000++0x03
    line.long 0x00 "TMR_CCR,Timer Clock Control Register"
        bitfld.long 0x00 5.--6. " TM_CS_226      ,1. cp timers and watchdog timer(0xd403_a000) and gpb timers and watchdog timer(0xf020_9000): clock source for timer #2  0x0 or 0x3=1 3 mhz fast clock  0x1 or 0x2 = 32.768 khz.                                                     2.  timers and watchdog timer( 0xd408_0000): clock source for timer #2  0x0 = 13mhz fast clock    0x1 = 32.768 khz  0x2 = 32.768 khz  0x3 = 13mhz fast clock" "0,1,2,3"
        bitfld.long 0x00 2.--3. "         TM_CS_128    ,1. cp timers and watchdog timer(0xd403_a000) and gpb timers and watchdog timer(0xf020_9000): clock source for timer #1  0x0 or 0x3=1 3 mhz fast clock  0x1 or 0x2 = 32.768 khz.                                                     2.  timers and watchdog timer( 0xd408_0000):clock source for timer #1  0x0 = 13mhz fast clock    0x1 = 32.768 khz  0x2 = 32.768 khz  0x3 = ext.clock -udc sof clock" "0,1,2,3"
        bitfld.long 0x00 0.--1. "  TM_CS_029    ,1. cp timers and watchdog timer(0xd403_a000) and gpb timers and watchdog timer(0xf020_9000): clock source for timer #0  0x0 or 0x3=1 3 mhz fast clock  0x1 or 0x2 = 32.768 khz.                                                     2.  timers and watchdog timer( 0xd408_0000):clock source for timer #0  0x0 = 13mhz fast clock    0x1 = 32.768 khz  0x2 = ext. clock-udc sof clock  0x3 = 13mhz fast clock" "0,1,2,3"

group d:0xD4080004++0x03
    line.long 0x00 "TMR_Tn_Mm,Timer Match Registers"
        hexmask.long 0x00 0.--31. 1. " TM_TMR_TN_MM36 ,timer n match register m value"

group d:0xD4080028++0x03
    line.long 0x00 "TMR_CRn,Timer Count Registers"
        hexmask.long 0x00 0.--31. 1. " TM_TCRN57      ,timer n count register  the counter is incremented at the rising edge of the selected clock. these registers are read under risk of metastability. read the timer counters value write for read request register to avoid metastability."

group d:0xD4080034++0x03
    line.long 0x00 "TMR_SRn,Timer Status Registers"
        bitfld.long 0x00 2. " TM_M266        ,match status of tmr_tn_m2  0 = timer match register tmr_tn_m2 has not matched the counter since the last interrupt clear  1 = timer match register tmr_tn_m2 has matched the counter since the last interrupt clear" "0,1"
        bitfld.long 0x00 1. "         TM_M167      ,match status of tmr_tn_m1  0 = timer match register tmr_tn_m1 has not matched the counter since the last interrupt clear  1 = timer match register tmr_tn_m1 has matched the counter since the last interrupt clear" "0,1"
        bitfld.long 0x00 0. "  TM_M068      ,match status of tmr_tn_m0  0 = timer match register tmr_tn_m0 has not matched the counter since the last interrupt clear  1 = timer match register tmr_tn_m0 has matched the counter since the last interrupt clear" "0,1"

group d:0xD4080040++0x03
    line.long 0x00 "TMR_IERn,Timer Interrupt Enable Registers"
        bitfld.long 0x00 2. " TM_IE277       ,interrupt enable for match comparator 2  0 = do not allow a match between match register 2 to its os timer to assert interrupt bit m2 in the corresponding timer status register or assert timer#_irq output  1 = allow a match between match register 2 to its os timer to assert interrupt bit m2 in the corresponding tsrn or assert timer#_irq output" "0,1"
        bitfld.long 0x00 1. "         TM_IE178     ,interrupt enable for match comparator 1  0 = do not allow a match between match register 1 to its os timer to assert interrupt bit m1 in the corresponding timer status register or assert timer#_irq output  1 = allow a match between match register 1 to its os timer to assert interrupt bit m1 in the corresponding tsrn or assert timer#_irq output" "0,1"
        bitfld.long 0x00 0. "  TM_IE079     ,interrupt enable for match comparator 0  0 = do not allow a match between match register 0 to its os timer to assert interrupt bit m0 in the corresponding timer status register or assert timer#_irq output  1 = allow a match between match register 0 to its os timer to assert interrupt bit m0 in the corresponding timer status register or assert timer#_irq output" "0,1"

group d:0xD408004C++0x03
    line.long 0x00 "TMR_PLVRn,Timer Preload Value Registers"
        hexmask.long 0x00 0.--31. 1. " TM_TPLVRN87    ,timer n preload value that is loaded into timer count register when a match occurs between tmr_tn_tm and timer count registers. the corresponding timer preload control register selects the match comparator."

group d:0xD4080058++0x03
    line.long 0x00 "TMR_PLCRn,Timer Preload Control Registers"
        bitfld.long 0x00 0.--1. " TM_MCS96       ,match comparator select  0x0 = free running mode (up to max value)  0x1 = enable preload with match comparator 0  0x2 = enable preload with match comparator 1  0x3 = enable preload with match comparator 2" "0,1,2,3"

group d:0xD4080064++0x03
    line.long 0x00 "TMR_WMER,Timers Watchdog Match Enable Register"
        bitfld.long 0x00 1. " TM_WRIE105     ,watchdog reset/interrupt enable  0 = watchdog timer expiration generates a watchdog interrupt, a watchdog timer reset is not generated  1 = watchdog timer expiration generates a watchdog timer reset, a watchdog interrupt is not generated" "0,1"
        bitfld.long 0x00 0. "         TM_WE106     ,wdt count enable  0 = disable wdt count, reset wdt's value to zero  1 = enable counting, the wdt always starts from zero  due to the chain of synchronizers that transform this signal from domain to domain, the wdt timer enable and disable operation do not occur immediately" "0,1"

group d:0xD4080068++0x03
    line.long 0x00 "TMR_WMR,Timers Watchdog Match Register"
        hexmask.long.word 0x00 0.--15. 1. " TM_WTM115      ,16-bit watchdog timer match"

group d:0xD408006C++0x03
    line.long 0x00 "TMR_WVR,Timers Watchdog Value Register"
        hexmask.long.word 0x00 0.--15. 1. " TM_WTV123      ,watchdog timer value    read the current value of wdt. the value may be read while the register is in transition, so the reading must be completed in a double read procedure and a comparison of the two read values."

group d:0xD4080070++0x03
    line.long 0x00 "TMR_WSR,Timers Watchdog Status Register"
        bitfld.long 0x00 0. " TM_WTS132      ,watchdog timer reset indication  indicates that reset was caused by the wdt.  read:  0 = watchdog timer did not cause reset because this bit was cleared  1 = watchdog timer caused reset    write:  0 = clear the wdt reset status  1 = no affect" "0,1"

group d:0xD4080074++0x03
    line.long 0x00 "TMR_ICRn,Timer Interrupt Clear Registers"
        bitfld.long 0x00 2. " TM_TCLR2141    ,interrupt clear for match comparator 2  write:  0 = no affect  1 = clear level interrupt and corresponding status bit" "0,1"
        bitfld.long 0x00 1. "         TM_TCLR1142  ,interrupt clear for match comparator 1  write:  0 = no affect  1 = clear level interrupt and corresponding status bit" "0,1"
        bitfld.long 0x00 0. "  TM_TCLR0143  ,interrupt clear for match comparator 0  write:  0 = no affect  1 = clear level interrupt and corresponding status bit" "0,1"

group d:0xD4080080++0x03
    line.long 0x00 "TMR_WICR,Timers Watchdog Interrupt Clear Register"
        bitfld.long 0x00 0. " TM_WICLR152    ,wdt interrupt clear  write:  0 = no affect  1 = clear interrupt" "0,1"

group d:0xD4080084++0x03
    line.long 0x00 "TMR_CER,Timers Count Enable Register"
        bitfld.long 0x00 2. " TM_T2EN161     ,timer #2 count enable  0 = count is disabled  1 = count is enabled  due to the chain of synchronizers that transform this signal from domain to domain, the timers enable and disable operation does not occur immediately." "0,1"
        bitfld.long 0x00 1. "         TM_T1EN162   ,timer #1 count enable  0 = count is disabled  1 = count is enabled  due to the chain of synchronizers that transform this signal from domain to domain, the timers enable and disable operation does not occur immediately." "0,1"
        bitfld.long 0x00 0. "  TM_T0EN163   ,timer #0 count enable  0 = count is disabled  1 = count is enabled  due to the chain of synchronizers that transform this signal from domain to domain, the timers enable and disable operation does not occur immediately." "0,1"

group d:0xD4080088++0x03
    line.long 0x00 "TMR_CMR,Timers Count Mode Register"
        bitfld.long 0x00 2. " TM_T2MODE172   ,timer #2 count mode  0 = periodic timer mode  1 = free-run mode, wraps around to 0 when it hits 0xffffffff" "0,1"
        bitfld.long 0x00 1. "         TM_T1MODE173 ,timer #1 count mode  0 = periodic timer mode  1 = free-run mode, wraps around to 0 when it hits 0xffffffff" "0,1"
        bitfld.long 0x00 0. "  TM_T0MODE174 ,timer #0 count mode  0 = periodic timer mode  1 = free-run mode, wraps around to 0 when it hits 0xffffffff" "0,1"

group d:0xD408008C++0x03
    line.long 0x00 "TMR_ILRn,Timer Interrupt Length Registers"
        bitfld.long 0x00 2. " TNIL2          ,interrupt length for match comparator 2  0 = level interrupt, lasts more then one timer clock.   status of this interrupt can be read in tsrn[2]. the interrupt should be cleared via writing logical 1 to ticlrn[2]  1 = reserved" "0,1"
        bitfld.long 0x00 1. "         TNIL1        ,interrupt length for match comparator 1  0 = level interrupt, lasts more then one timer clock.   status of this interrupt can be read in tsrn[1]. the interrupt should be cleared via writing logical 1 to ticlrn[1]  1 = reserved" "0,1"
        bitfld.long 0x00 0. "  TNIL0        ,interrupt length for match comparator 0  0 = level interrupt, lasts more then one timer clock.   status of this interrupt can be read in tsrn[0]. the interrupt should be cleared via writing logical 1 to ticlrn[0]  1 = reserved" "0,1"

group d:0xD4080098++0x03
    line.long 0x00 "TMR_WCR,Timers Watchdog Counter Reset Register"
        bitfld.long 0x00 0. " TM_WCR195      ,watchdog timer counter value reset  write:  0 = no effect  1 = clears the value of wdt counter" "0,1"

group d:0xD408009C++0x03
    line.long 0x00 "TMR_WFAR,Timers Watchdog First Access Register"
        hexmask.long.word 0x00 0.--15. 1. " TM_KEY209      ,watchdog access key  writing the value of 0xbaba to this register matches the key"

group d:0xD40800A0++0x03
    line.long 0x00 "TMR_WSAR,Timers Watchdog Second Access Register"
        hexmask.long.word 0x00 0.--15. 1. " TM_KEY217      ,watchdog access key  writing the value of 0xeb10 to this register matches the key"

group d:0xD40800A4++0x03
    line.long 0x00 "TMR_CVWRn,Timer Counters Value Write for Read Request Register"
        hexmask.long 0x00 0.--31. 1. " TCVWR          ,this register prevents the risk of instability on counter value reading  write:   0 = no effect  1 = capture value of tcrn  read:  returns the captured value of the timer count register."

tree.end

tree "aibmfpr"

width 7.

group d:0xD401E001++0x03
    line.long 0x00 "MFPRx,Multi-Function Pin Control Register x"
        bitfld.long 0x00 15. " PULL_SEL     ,pull sel  this field selects between two sets of controls for the pull-up and pull-down functionality.  0 = the pull-up and pull-down resistors are controlled by the selected alternate function for the pin  1 = the pull-up and pull-down resistors are controlled by the <pullup en> and <pulldn en> fields in this register, overriding the function indicated by the selected alternate function.   during low-power states, this field is overridden to 1 and controlled by the <pullup en> and <pulldn en> fields. in these low-power states, this field is effectively 1, although the register value is not changed. (see section 7.7.8, low-power (sleep) mode operation for more information)." "0,1"
        bitfld.long 0x00 14. "  PULLUP_EN    ,pullup en  this field bit controls the output function while the <pull sel> field is set to 1 (or is effectively 1).  0 = the internal pull-up resistor of the pin is disabled  1 = the internal pull-up resistor of the pin is enabled" "0,1"
        bitfld.long 0x00 13. "  PULLDN_EN ,pulldn en  this field bit controls the output function while <pull sel> is set to 1 (or is effectively 1).  0 = the internal pull-down resistor of the pin is disabled  1 = the internal pull-down resistor of the pin is enabled" "0,1"
        bitfld.long 0x00 11.--12. "  DRIVE      ,drive  this field defines the drive strength and slew rate for this pin (in functional mode when the pin is driving high or low value).  0x0 = slow  0x1 = slow   0x2 = medium  0x3 = fast  (see section 7.8.5.1, drive configuration for more information.)" "0,1,2,3"
        textline "                 "
        bitfld.long 0x00 9. "SLEEP_SEL0   ,sleep sel[1:0] = 3, pad will goto sleep_mode if vctcxo_en is de-asserted. sleep_sel = 0, do not enable sleep_mode control. sleep_sel = 1 or 2, reserved" "0,1"
        bitfld.long 0x00 8. "  SLEEP_DATA   ,sleep_mode output value if sleep_dir = 0." "0,1"
        bitfld.long 0x00 7. "  SLEEPDIR  ,sleep_mode pad i/o direction. 0: output, 1: input" "0,1"
        bitfld.long 0x00 6. "  EDGE_CLEAR ,edge_clear  this field defines enables/disables edge-detection logic.  0 = the edge-detection logic is enabled and ready to detect an edge  1 = the edge-detection logic is disabled and no edge is detected  this is an enable for the <edge_fall_en> and <edge_rise_en> control fields.   (see section 7.8.7, edge-detect operation for more information.)" "0,1"
        textline "                 "
        bitfld.long 0x00 5. "EDGE_FALL_EN ,edge_fall_en  0 = do not detect a falling edge  1 = detect a falling edge  to detect a falling edge on this pin, the pin need not be an output, this field must be set to 1, and the <edge_clear> field must be set to 0.   (see section 7.8.7, edge-detect operation for more information.)" "0,1"
        bitfld.long 0x00 4. "  EDGE_RISE_EN ,edge_rise_en  0 = do not detect a rising edge   1 = detect a rising edge  to detect a rising edge on this pin, the pin need not be an output, this field must be set to 1, and the <edge_clear> field must be set to 0.  (see section 7.8.7, edge-detect operation for more information.)" "0,1"
        bitfld.long 0x00 3. "  SLEEPSEL1 ,sleep sel[1:0] = 3, pad will goto sleep_mode if vctcxo_en is de-asserted. sleep_sel = 0, do not enable sleep_mode control. sleep_sel = 1 or 2, reserved" "0,1"
        bitfld.long 0x00 0.--2. "  AF_SEL     ,af sel  this field is used for alternate function selection for a pin. it selects between the eight possible alternate functions for the pin. alternate function 0 is always the reset case.  0x0 = alternate function 0 (primary function at reset)  0x1 = alternate function 1  0x2 = alternate function 2  0x3 = alternate function 3  0x4 = alternate function 4  0x5 = alternate function 5  0x6 = alternate function 6  0x7 = alternate function 7" "0,1,2,3,4,5,6,7"

tree.end

tree "apb_spare"

width 17.

group d:0xD4090000++0x03
    line.long 0x00 "APB_spare0_reg,APB spare0 Register"
        bitfld.long 0x00 1. " CP_PWRSW_DLY            ,gb/wb/lte power switch delay control selection. leave it to 0" "0,1"
        bitfld.long 0x00 0. "       CP_AP_SEL           ,gsram selection: 1 = cp, 0 = ap. never set to 0" "0,1"

group d:0xD409000C++0x03
    line.long 0x00 "Sensor_v18_reg,Sensor_v18_out Register"
        bitfld.long 0x00 0. " NAND_SENSOR_V18         ,nand voltage sensor v18 output" "0,1"

group d:0xD4090100++0x03
    line.long 0x00 "APB_spare1_reg,PLL1 SW control Register"
        bitfld.long 0x00 31. " PU_CTRL_BY_CLKOUT_EN31  ,pu_ctrl_by_clkout_en    0x0= pll pu is controlled by hw enable and sw pll power on    0x1=  pll pu is forced to be on." "0,1"
        bitfld.long 0x00 30. "       CLKOUT_DIV5_EN32    ,clkout_div5_en" "0,1"
        bitfld.long 0x00 29. "     CLKOUT_DIV4_EN33   ,clkout_div4_en" "0,1"
        bitfld.long 0x00 28. "       CLKOUT_DIV3_EN34        ,clkout_div3_en" "0,1"
        textline "                           "
        bitfld.long 0x00 27. "CLKOUT_DIV2_EN35        ,clkout_div2_en" "0,1"
        bitfld.long 0x00 26. "       CLKOUT_DIV1_EN36    ,clkout_div1_en" "0,1"
        bitfld.long 0x00 25. "     DIG_TEST_OEN37     ,digital test output enable" "0,1"
        bitfld.long 0x00 24. "       ANA_TEST_OEN38          ,analog test output enable" "0,1"
        textline "                           "
        bitfld.long 0x00 22.--23. "TE_SEL39                ,analog/digital testing control select    analog    digital 00: vref06,   ckbfb_buf 01: vdd_cln2, ckbref_buf 10:vreg_vco,  pll_lk 11:vx_vco,   no_ck" "0,1,2,3"
        bitfld.long 0x00 21. "       PLL_LOCK_SEL40      ,pll locking mode select 0: fractional 1: integer" "0,1"
        bitfld.long 0x00 20. "     PLL__FORCE_LOCK41  ,pll force lock 0: disable 1: enable" "0,1"
        bitfld.long 0x00 17.--19. "       PLL_LOCK_DELAY42        ,pll locking signal delay setting      integer  fractional 001:128*tref   256*tref 010:256*tref   512*tref                      100:512*tref  1024*tref tref is the period of ckrefin." "0,1,2,3,4,5,6,7"
        textline "                           "
        bitfld.long 0x00 16. "BYPASS43                ,bypass pll power down signal and power up pll 1: bypass en_pll 0: not bypass en_pll" "0,1"
        bitfld.long 0x00 14.--15. "       REG_VOLT44          ,regulator output voltage select 00:1.352v 01:1.38v 10:1.408v 11:1.436v" "0,1,2,3"
        bitfld.long 0x00 11.--13. "     KVCO45             ,vco frequency range select /hz        hb      lb 000: ~1.59g   ~0.61g 001: ~1.75g   ~0.76g 010: ~1.89g   ~0.89g 011: ~2.05g   ~1.05g 100: ~2.24g   ~1.23g 101: ~2.4g    ~1.38g 110: ~2.54g   ~1.52g 111:~2.7g    ~1.68g hb: high band lb: low band" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 10. "       FAST_LOCK46             ,pll fast lock 0: disable 1: enable" "0,1"
        textline "                           "
        bitfld.long 0x00 8.--9. "CHARGE_PUMP47           ,charge pump current setting 00:0.5ua*factor 01:1ua*factor 10:1.5ua*factor 11:2ua*factor factor=0.9" "0,1,2,3"
        bitfld.long 0x00 7. "       BAND_SEL48          ,pll band select 0: low band div_by_2 disabled 1: high band div_by_2 enabled" "0,1"
        hexmask.long.byte 0x00 0.--6. 1. "     APB_S_49           ,"

group d:0xD4090104++0x03
    line.long 0x00 "APB_spare2_reg,PLL2 SW control Register"
        bitfld.long 0x00 31. " PU_CTRL_BY_CLKOUT_EN56  ,pu_ctrl_by_clkout_en    0x0= pll pu is controlled by hw enable and sw pll power on    0x1=  pll pu is forced to be on." "0,1"
        bitfld.long 0x00 30. "       CLKOUT_DIV5_EN57    ,clkout_div5_en" "0,1"
        bitfld.long 0x00 29. "     CLKOUT_DIV4_EN58   ,clkout_div4_en" "0,1"
        bitfld.long 0x00 28. "       CLKOUT_DIV3_EN59        ,clkout_div3_en" "0,1"
        textline "                           "
        bitfld.long 0x00 27. "CLKOUT_DIV2_EN60        ,clkout_div2_en" "0,1"
        bitfld.long 0x00 26. "       CLKOUT_DIV1_EN61    ,clkout_div1_en" "0,1"
        bitfld.long 0x00 25. "     DIG_TEST_OEN62     ,digital test output enable" "0,1"
        bitfld.long 0x00 24. "       ANA_TEST_OEN63          ,analog test output enable" "0,1"
        textline "                           "
        bitfld.long 0x00 22.--23. "TE_SEL64                ,analog/digital testing control select    analog    digital 00: vref06,   ckbfb_buf 01: vdd_cln2, ckbref_buf 10:vreg_vco,  pll_lk 11:vx_vco,   no_ck" "0,1,2,3"
        bitfld.long 0x00 21. "       PLL_LOCK_SEL65      ,pll locking mode select 0: fractional 1: integer" "0,1"
        bitfld.long 0x00 20. "     PLL__FORCE_LOCK66  ,pll force lock 0: disable 1: enable" "0,1"
        bitfld.long 0x00 17.--19. "       PLL_LOCK_DELAY67        ,pll locking signal delay setting      integer  fractional 001:128*tref   256*tref 010:256*tref   512*tref                      100:512*tref  1024*tref tref is the period of ckrefin." "0,1,2,3,4,5,6,7"
        textline "                           "
        bitfld.long 0x00 16. "BYPASS68                ,bypass pll power down signal and power up pll 1: bypass en_pll 0: not bypass en_pll" "0,1"
        bitfld.long 0x00 14.--15. "       REG_VOLT69          ,regulator output voltage select 00:1.352v 01:1.38v 10:1.408v 11:1.436v" "0,1,2,3"
        bitfld.long 0x00 11.--13. "     KVCO70             ,vco frequency range select /hz        hb      lb 000: ~1.59g   ~0.61g 001: ~1.75g   ~0.76g 010: ~1.89g   ~0.89g 011: ~2.05g   ~1.05g 100: ~2.24g   ~1.23g 101: ~2.4g    ~1.38g 110: ~2.54g   ~1.52g 111:~2.7g    ~1.68g hb: high band lb: low band" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 10. "       FAST_LOCK71             ,pll fast lock 0: disable 1: enable" "0,1"
        textline "                           "
        bitfld.long 0x00 8.--9. "CHARGE_PUMP72           ,charge pump current setting 00:0.5ua*factor 01:1ua*factor 10:1.5ua*factor 11:2ua*factor factor=0.9" "0,1,2,3"
        bitfld.long 0x00 7. "       BAND_SEL73          ,pll band select 0: low band div_by_2 disabled 1: high band div_by_2 enabled" "0,1"
        hexmask.long.byte 0x00 0.--6. 1. "     APB_S_74           ,"

group d:0xD4090108++0x03
    line.long 0x00 "APB_spare3_reg,PLL3 SW control Register"
        bitfld.long 0x00 31. " PU_CTRL_BY_CLKOUT_EN81  ,pu_ctrl_by_clkout_en    0x0= pll pu is controlled by hw enable and sw pll power on    0x1=  pll pu is forced to be on." "0,1"
        bitfld.long 0x00 30. "       CLKOUT_DIV5_EN82    ,clkout_div5_en" "0,1"
        bitfld.long 0x00 29. "     CLKOUT_DIV4_EN83   ,clkout_div4_en" "0,1"
        bitfld.long 0x00 28. "       CLKOUT_DIV3_EN84        ,clkout_div3_en" "0,1"
        textline "                           "
        bitfld.long 0x00 27. "CLKOUT_DIV2_EN85        ,clkout_div2_en" "0,1"
        bitfld.long 0x00 26. "       CLKOUT_DIV1_EN86    ,clkout_div1_en" "0,1"
        bitfld.long 0x00 25. "     DIG_TEST_OEN87     ,digital test output enable" "0,1"
        bitfld.long 0x00 24. "       ANA_TEST_OEN88          ,analog test output enable" "0,1"
        textline "                           "
        bitfld.long 0x00 22.--23. "TE_SEL89                ,analog/digital testing control select    analog    digital 00: vref06,   ckbfb_buf 01: vdd_cln2, ckbref_buf 10:vreg_vco,  pll_lk 11:vx_vco,   no_ck" "0,1,2,3"
        bitfld.long 0x00 21. "       PLL_LOCK_SEL90      ,pll locking mode select 0: fractional 1: integer" "0,1"
        bitfld.long 0x00 20. "     PLL__FORCE_LOCK91  ,pll force lock 0: disable 1: enable" "0,1"
        bitfld.long 0x00 17.--19. "       PLL_LOCK_DELAY92        ,pll locking signal delay setting      integer  fractional 001:128*tref   256*tref 010:256*tref   512*tref                      100:512*tref  1024*tref tref is the period of ckrefin." "0,1,2,3,4,5,6,7"
        textline "                           "
        bitfld.long 0x00 16. "BYPASS93                ,bypass pll power down signal and power up pll 1: bypass en_pll 0: not bypass en_pll" "0,1"
        bitfld.long 0x00 14.--15. "       REG_VOLT94          ,regulator output voltage select 00:1.352v 01:1.38v 10:1.408v 11:1.436v" "0,1,2,3"
        bitfld.long 0x00 11.--13. "     KVCO95             ,vco frequency range select /hz        hb      lb 000: ~1.59g   ~0.61g 001: ~1.75g   ~0.76g 010: ~1.89g   ~0.89g 011: ~2.05g   ~1.05g 100: ~2.24g   ~1.23g 101: ~2.4g    ~1.38g 110: ~2.54g   ~1.52g 111:~2.7g    ~1.68g hb: high band lb: low band" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 10. "       FAST_LOCK96             ,pll fast lock 0: disable 1: enable" "0,1"
        textline "                           "
        bitfld.long 0x00 8.--9. "CHARGE_PUMP97           ,charge pump current setting 00:0.5ua*factor 01:1ua*factor 10:1.5ua*factor 11:2ua*factor factor=0.9" "0,1,2,3"
        bitfld.long 0x00 7. "       BAND_SEL98          ,pll band select 0: low band div_by_2 disabled 1: high band div_by_2 enabled" "0,1"
        hexmask.long.byte 0x00 0.--6. 1. "     APB_S_99           ,"

group d:0xD409010C++0x03
    line.long 0x00 "APB_SPARE4,APB Spare 4 Register"
        bitfld.long 0x00 31. " PU_AUXADC               ,power-up, active high" "0,1"
        bitfld.long 0x00 30. "       AUXADC_MODE         ,select auxadc conversion mode 0, single conversion 1, continuous conversion" "0,1"
        bitfld.long 0x00 29. "     AUXADC_SOC         ,start of conversion, acitive high" "0,1"
        bitfld.long 0x00 24.--28. "       AUXADC_SELIN            ,select auxadc input 00001, input inaux1 00010, input inaux2 00100, input inaux3 01000, input inaux4 10000, input inaux5" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"
        textline "                           "
        bitfld.long 0x00 25. "DIG_TEST_OEN110         ,digital test output enable" "0,1"
        bitfld.long 0x00 24. "       ANA_TEST_OEN111     ,analog test output enable" "0,1"
        bitfld.long 0x00 21. "     AUX_CTRL2          ,auxadc self-test mode, active high" "0,1"
        bitfld.long 0x00 20. "       AUX_CTRL1               ,auto-zero function of comparator, active high" "0,1"
        textline "                           "
        bitfld.long 0x00 13.--15. "INT_PLL_SEL             ,internal pll_reg1 select  xx0: use external pll_reg1<7:0> 0x1: force pll_reg1=8'b11000001 1x1: force pll_reg1=8'b10110000 --- ck_afe_19p2 output select 00x: 19.2mhz from pll 01x: external refckin_pad 1xx: 19.2mhz from pll" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 10.--12. "       OUT_CTRL2           ,bandgap output control" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 8.--9. "     OUT_CTRL1          ,bandgap output control" "0,1,2,3"
        bitfld.long 0x00 4.--7. "       INT_VOLT_SEL            ,select internal test voltage for inaux0 0000, 0v ~ 1111, 1.125v, 75mv/step" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        textline "                           "
        bitfld.long 0x00 2.--3. "BIAS_CURRENT            ,bias current for comparator 00, 30ua 01, 40ua 10, 50ua 11, 60ua" "0,1,2,3"
        bitfld.long 0x00 0.--1. "       CLK_DIV_SEL         ,select clock divider 00, no divider 01, divide by 2 10, divide by 4 11, divide by 8" "0,1,2,3"

group d:0xD4090110++0x03
    line.long 0x00 "APB_spare5_reg,APB spare5 register"
        hexmask.long.tbyte 0x00 13.--31. 1. " APB_S_128               ,reserved"
        bitfld.long 0x00 12. "  APB_S_129           ,ic_usb_p_slp_di. sleep mode output" "0,1"
        bitfld.long 0x00 11. "     APB_S_130          ,ic_usb_p_pu_en. pull-up enable" "0,1"
        bitfld.long 0x00 10. "       APB_S_131               ,ic_usb_p_pd_en. pull-down enable" "0,1"
        textline "                           "
        bitfld.long 0x00 8.--9. "APB_S_132               ,ic_usb_p_sr[1:0]. drive strength" "0,1,2,3"
        bitfld.long 0x00 5.--7. "       APB_S_133           ,reserved" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 4. "     APB_S_134          ,ic_usb_n_slp_di. sleep mode output" "0,1"
        bitfld.long 0x00 3. "       APB_S_135               ,ic_usb_n_pu_en. pull-up enable" "0,1"
        textline "                           "
        bitfld.long 0x00 2. "APB_S_136               ,ic_usb_n_pd_en. pull-down enable" "0,1"
        bitfld.long 0x00 0.--1. "       APB_S_137           ,ic_usb_n_sr[1:0]. drive strength" "0,1,2,3"

group d:0xD4090114++0x03
    line.long 0x00 "APB_spare6_reg,PLL5 SW control Register"
        bitfld.long 0x00 31. " PU_CTRL_BY_CLKOUT_EN144 ,pu_ctrl_by_clkout_en    0x0= pll pu is controlled by hw enable and sw pll power on    0x1=  pll pu is forced to be on." "0,1"
        bitfld.long 0x00 30. "       CLKOUT_DIV5_EN145   ,clkout_div5_en" "0,1"
        bitfld.long 0x00 29. "     CLKOUT_DIV4_EN146  ,clkout_div4_en" "0,1"
        bitfld.long 0x00 28. "       CLKOUT_DIV3_EN147       ,clkout_div3_en" "0,1"
        textline "                           "
        bitfld.long 0x00 27. "CLKOUT_DIV2_EN148       ,clkout_div2_en" "0,1"
        bitfld.long 0x00 26. "       CLKOUT_DIV1_EN149   ,clkout_div1_en" "0,1"
        bitfld.long 0x00 25. "     DIG_TEST_OEN150    ,digital test output enable" "0,1"
        bitfld.long 0x00 24. "       ANA_TEST_OEN151         ,analog test output enable" "0,1"
        textline "                           "
        bitfld.long 0x00 22.--23. "TE_SEL152               ,analog/digital testing control select    analog    digital 00: vref06,   ckbfb_buf 01: vdd_cln2, ckbref_buf 10:vreg_vco,  pll_lk 11:vx_vco,   no_ck" "0,1,2,3"
        bitfld.long 0x00 21. "       PLL_LOCK_SEL153     ,pll locking mode select 0: fractional 1: integer" "0,1"
        bitfld.long 0x00 20. "     PLL__FORCE_LOCK154 ,pll force lock 0: disable 1: enable" "0,1"
        bitfld.long 0x00 17.--19. "       PLL_LOCK_DELAY155       ,pll locking signal delay setting      integer  fractional 001:128*tref   256*tref 010:256*tref   512*tref                      100:512*tref  1024*tref tref is the period of ckrefin." "0,1,2,3,4,5,6,7"
        textline "                           "
        bitfld.long 0x00 16. "BYPASS156               ,bypass pll power down signal and power up pll 1: bypass en_pll 0: not bypass en_pll" "0,1"
        bitfld.long 0x00 14.--15. "       REG_VOLT157         ,regulator output voltage select 00:1.352v 01:1.38v 10:1.408v 11:1.436v" "0,1,2,3"
        bitfld.long 0x00 11.--13. "     KVCO158            ,vco frequency range select /hz        hb      lb 000: ~1.59g   ~0.61g 001: ~1.75g   ~0.76g 010: ~1.89g   ~0.89g 011: ~2.05g   ~1.05g 100: ~2.24g   ~1.23g 101: ~2.4g    ~1.38g 110: ~2.54g   ~1.52g 111:~2.7g    ~1.68g hb: high band lb: low band" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 10. "       FAST_LOCK159            ,pll fast lock 0: disable 1: enable" "0,1"
        textline "                           "
        bitfld.long 0x00 8.--9. "CHARGE_PUMP160          ,charge pump current setting 00:0.5ua*factor 01:1ua*factor 10:1.5ua*factor 11:2ua*factor factor=0.9" "0,1,2,3"
        bitfld.long 0x00 7. "       BAND_SEL161         ,pll band select 0: low band div_by_2 disabled 1: high band div_by_2 enabled" "0,1"
        hexmask.long.byte 0x00 0.--6. 1. "     APB_S_162          ,"

group d:0xD4090118++0x03
    line.long 0x00 "APB_spare7_reg,APB spare7 register"
        hexmask.long.tbyte 0x00 8.--31. 1. " APB_S_169               ,reserved"
        hexmask.long.byte 0x00 0.--7. 1. "  APB_S_170           ,pll1 reserve_in"

group d:0xD409011C++0x03
    line.long 0x00 "APB_spare8_reg,APB spare8 register"
        hexmask.long.word 0x00 16.--31. 1. " APB_S_177               ,reserved"
        hexmask.long.byte 0x00 8.--15. 1. "    APB_S_178           ,reg_osc<7:4>: xtal_core current trimming 0001: add 20ua 0010: add 40ua 0100: add 80ua 1000: add 160ua 1111: add 300ua  reg_osc<3:1>: xtal output buffer drive level trimming 001: 200 ohm loading 010: 100 ohm loading 011: 66 ohm loading 100: 66 ohm loading 101: 50 ohm loading 110: 40 ohm loading 111: 33 ohm loading"
        bitfld.long 0x00 3.--7. "    APB_S_179          ,reserved" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"
        bitfld.long 0x00 2. "      APB_S_180               ,power-up signal for the ref_clk buf 0: power down; 1: power up" "0,1"
        textline "                           "
        bitfld.long 0x00 1. "APB_S_181               ,power-up signal for the xtal osc 0: power down; 1: power up" "0,1"
        bitfld.long 0x00 0. "       APB_S_182           ,power-up the output clock buffer for ckoref_pad 0: power down; 1: power up" "0,1"

group d:0xD4090120++0x03
    line.long 0x00 "APB_spare9_reg,APB spare9 register"
        bitfld.long 0x00 31. " VCXO_DIG_GATE_EN        ,   0x0= clk gating is disabled.    0x1= clk gating enabled when system in d1/d2.  this is in order to gate more vctcxo clk tree for lp audio playback application." "0,1"
        bitfld.long 0x00 30. "       GNSS_HW_CTRL_PU_EN  ,gnss hw control ana_grp pu enable or disable   0x0=disable   0x1= gnss hw will automatcially power off ana_grp when gnss is powered off" "0,1"
        bitfld.long 0x00 25.--29. "     APB_S_191          ,reserved" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"
        bitfld.long 0x00 21.--24. "      TEST_ANA                ,test_ana" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        textline "                           "
        hexmask.long.word 0x00 11.--20. 1. "RESERVE_IN              ,reserve_in"
        bitfld.long 0x00 8.--10. "    VREG_1P05V_SEL_PECL ,vreg_1p05v_sel_pecl" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 6.--7. "     VREG_1P2V_SEL      ,vreg_1p2v_sel" "0,1,2,3"
        bitfld.long 0x00 4.--5. "       ICC_ADJ                 ,icc_adj" "0,1,2,3"
        textline "                           "
        bitfld.long 0x00 2.--3. "IPP_ADJ                 ,ipp_adj" "0,1,2,3"
        bitfld.long 0x00 1. "       PU_LIMITER          ,software control of  limiter power up/dwon.   =0x0 write 0 to this bit has no effect and limiter's power is controled by hardware     0x1= write 1 is to force limiter is powered up" "0,1"
        bitfld.long 0x00 0. "     APB_S_PU199        ,software control of  anagrp power up/down    =0x0 write 0 to this bit has no effect and anagrp's power is controled by hardware     0x1= write 1 is to force anagrp is powered up" "0,1"

group d:0xD4090124++0x03
    line.long 0x00 "APB_spare10_reg,PLL4 SW control Register"
        bitfld.long 0x00 31. " PU_CTRL_BY_CLKOUT_EN206 ,pu_ctrl_by_clkout_en    0x0= pll pu is controlled by hw enable and sw pll power on    0x1=  pll pu is forced to be on." "0,1"
        bitfld.long 0x00 30. "       CLKOUT_DIV5_EN207   ,clkout_div5_en" "0,1"
        bitfld.long 0x00 29. "     CLKOUT_DIV4_EN208  ,clkout_div4_en" "0,1"
        bitfld.long 0x00 28. "       CLKOUT_DIV3_EN209       ,clkout_div3_en" "0,1"
        textline "                           "
        bitfld.long 0x00 27. "CLKOUT_DIV2_EN210       ,clkout_div2_en" "0,1"
        bitfld.long 0x00 26. "       CLKOUT_DIV1_EN211   ,clkout_div1_en" "0,1"
        bitfld.long 0x00 25. "     DIG_TEST_OEN212    ,digital test output enable" "0,1"
        bitfld.long 0x00 24. "       ANA_TEST_OEN213         ,analog test output enable" "0,1"
        textline "                           "
        bitfld.long 0x00 22.--23. "TE_SEL214               ,analog/digital testing control select    analog    digital 00: vref06,   ckbfb_buf 01: vdd_cln2, ckbref_buf 10:vreg_vco,  pll_lk 11:vx_vco,   no_ck" "0,1,2,3"
        bitfld.long 0x00 21. "       PLL_LOCK_SEL215     ,pll locking mode select 0: fractional 1: integer" "0,1"
        bitfld.long 0x00 20. "     PLL__FORCE_LOCK216 ,pll force lock 0: disable 1: enable" "0,1"
        bitfld.long 0x00 17.--19. "       PLL_LOCK_DELAY217       ,pll locking signal delay setting      integer  fractional 001:128*tref   256*tref 010:256*tref   512*tref                      100:512*tref  1024*tref tref is the period of ckrefin." "0,1,2,3,4,5,6,7"
        textline "                           "
        bitfld.long 0x00 16. "BYPASS218               ,bypass pll power down signal and power up pll 1: bypass en_pll 0: not bypass en_pll" "0,1"
        bitfld.long 0x00 14.--15. "       REG_VOLT219         ,regulator output voltage select 00:1.352v 01:1.38v 10:1.408v 11:1.436v" "0,1,2,3"
        bitfld.long 0x00 11.--13. "     KVCO220            ,vco frequency range select /hz        hb      lb 000: ~1.59g   ~0.61g 001: ~1.75g   ~0.76g 010: ~1.89g   ~0.89g 011: ~2.05g   ~1.05g 100: ~2.24g   ~1.23g 101: ~2.4g    ~1.38g 110: ~2.54g   ~1.52g 111:~2.7g    ~1.68g hb: high band lb: low band" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 10. "       FAST_LOCK221            ,pll fast lock 0: disable 1: enable" "0,1"
        textline "                           "
        bitfld.long 0x00 8.--9. "CHARGE_PUMP222          ,charge pump current setting 00:0.5ua*factor 01:1ua*factor 10:1.5ua*factor 11:2ua*factor factor=0.9" "0,1,2,3"
        bitfld.long 0x00 7. "       BAND_SEL223         ,pll band select 0: low band div_by_2 disabled 1: high band div_by_2 enabled" "0,1"
        hexmask.long.byte 0x00 0.--6. 1. "     APB_S_224          ,"

group d:0xD4090130++0x03
    line.long 0x00 "PLLx_SSC_CTRL0,PLLx SSC Control Register"

group d:0xD409013C++0x03
    line.long 0x00 "PLLx_SSC_CTRL1,PLLx SSC Control Register"

group d:0xD4090148++0x03
    line.long 0x00 "PLLx_SSC_CTRL2,PLLx SSC Control Register"
        hexmask.long.byte 0x00 24.--31. 1. " APB_S_231               ,reserve in"
        bitfld.long 0x00 20.--22. "      INTPR               ,phase interpolator resistor select" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 16.--19. "     INTPI              ,phase interpolator bias current select  0x5 = vco:1.5 ~ 2 ghz  0x6 = vco:2 ~ 2.5 ghz  0x8 = vco:2.5 ~ 3ghz" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 6. "      CLK_DET_EN              ,pi output clock enable  this selection enables the pi output clock for the internal reset circuit.  1 = regular use" "0,1"
        textline "                           "
        bitfld.long 0x00 5. "PI_LOOP_MODE            ,phase interpolator loop control  1 = pi is in the pll loop  0 = pi is out of the pll loop" "0,1"
        bitfld.long 0x00 4. "       RESET_SSC           ,ssc reset, active high  both of ssc and frequency offset logic is controlled by this field.  make sure this field is 0 when ssc or frequency offset is valid" "0,1"
        bitfld.long 0x00 3. "     SSC_CLK_EN         ,ssc clock enable  enables pi output clock for ssc digital logic.  set this field to 1 if ssc is enabled." "0,1"
        bitfld.long 0x00 2. "       SSC_MODE                ,ssc mode selection  0 = center spread  1 = down spread" "0,1"
        textline "                           "
        bitfld.long 0x00 1. "RESET_PI                ,external interpolator reset signal  1 = reset  0 = no reset" "0,1"
        bitfld.long 0x00 0. "       PI_EN               ,phase interpolator loop control  set to 1 if ssc is enabled  0 = disable phase interpolator  1 = enable phase interpolator" "0,1"

group d:0xD4090134++0x03
    line.long 0x00 "PLLx_SSC_CONF0,PLLx SSC Configuration Register"

group d:0xD4090140++0x03
    line.long 0x00 "PLLx_SSC_CONF1,PLLx SSC Configuration Register"

group d:0xD409014C++0x03
    line.long 0x00 "PLLx_SSC_CONF2,PLLx SSC Configuration Register"
        hexmask.long.word 0x00 16.--31. 1. " SSC_FREQ_DIV            ,ssc frequency selection  for zero average frequency offset, keep ssc_freq_div[3:0] = 0 and set ssc_freq_div[15:4] to change the ssc frequency."
        hexmask.long.word 0x00 0.--10. 1. "    SSC_RNGE            ,ssc range select  ssc_rnge[10:0] = desired ssc amplitude /(ssc_freq_div[14:0]*2^(-26))   rounding to integer required"

group d:0xD409013C++0x03
    line.long 0x00 "APB_spare16_reg,PLL6 SW control Register_1"
        bitfld.long 0x00 31. " PLL6_PU                 ,pll6 power on  0 = pll6 off  1 = pll on; pll6 is automatically off whenever pll is off." "0,1"
        bitfld.long 0x00 30. "       CLKOUT_DIV5_EN260   ,clkout_div5_en" "0,1"
        bitfld.long 0x00 29. "     CLKOUT_DIV4_EN261  ,clkout_div4_en" "0,1"
        bitfld.long 0x00 28. "       CLKOUT_DIV3_EN262       ,clkout_div3_en" "0,1"
        textline "                           "
        bitfld.long 0x00 27. "CLKOUT_DIV2_EN263       ,clkout_div2_en" "0,1"
        bitfld.long 0x00 26. "       CLKOUT_DIV1_EN264   ,clkout_div1_en" "0,1"
        bitfld.long 0x00 25. "     DIG_TEST_OEN265    ,digital test output enable" "0,1"
        bitfld.long 0x00 24. "       ANA_TEST_OEN266         ,analog test output enable" "0,1"
        textline "                           "
        bitfld.long 0x00 22.--23. "TE_SEL267               ,analog/digital testing control select    analog    digital 00: vref06,   ckbfb_buf 01: vdd_cln2, ckbref_buf 10:vreg_vco,  pll_lk 11:vx_vco,   no_ck" "0,1,2,3"
        bitfld.long 0x00 21. "       PLL_LOCK_SEL268     ,pll locking mode select 0: fractional 1: integer" "0,1"
        bitfld.long 0x00 20. "     PLL__FORCE_LOCK269 ,pll force lock 0: disable 1: enable" "0,1"
        bitfld.long 0x00 17.--19. "       PLL_LOCK_DELAY270       ,pll locking signal delay setting      integer  fractional 001:128*tref   256*tref 010:256*tref   512*tref                      100:512*tref  1024*tref tref is the period of ckrefin." "0,1,2,3,4,5,6,7"
        textline "                           "
        bitfld.long 0x00 16. "BYPASS271               ,bypass pll power down signal and power up pll 1: bypass en_pll 0: not bypass en_pll" "0,1"
        bitfld.long 0x00 14.--15. "       REG_VOLT272         ,regulator output voltage select 00:1.352v 01:1.38v 10:1.408v 11:1.436v" "0,1,2,3"
        bitfld.long 0x00 11.--13. "     KVCO273            ,vco frequency range select /hz        hb      lb 000: ~1.59g   ~0.61g 001: ~1.75g   ~0.76g 010: ~1.89g   ~0.89g 011: ~2.05g   ~1.05g 100: ~2.24g   ~1.23g 101: ~2.4g    ~1.38g 110: ~2.54g   ~1.52g 111:~2.7g    ~1.68g hb: high band lb: low band" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 10. "       FAST_LOCK274            ,pll fast lock 0: disable 1: enable" "0,1"
        textline "                           "
        bitfld.long 0x00 8.--9. "CHARGE_PUMP275          ,charge pump current setting 00:0.5ua*factor 01:1ua*factor 10:1.5ua*factor 11:2ua*factor factor=0.9" "0,1,2,3"
        bitfld.long 0x00 7. "       BAND_SEL276         ,pll band select 0: low band div_by_2 disabled 1: high band div_by_2 enabled" "0,1"
        hexmask.long.byte 0x00 0.--6. 1. "     PLL6_FBDIV         ,pll6 fbdiv"

group d:0xD4090140++0x03
    line.long 0x00 "APB_spare17_reg,PLL6 SW control Register_2"
        bitfld.long 0x00 31. " APB_S_PLL_LOCK284       ,pll6_lock status" "0,1"
        hexmask.long.word 0x00 16.--30. 1. "       APB_S_285           ,"
        bitfld.long 0x00 14.--15. "  PLL6SSC_MODE       ,spectrum spread mode 00: center-spread 01: up-spread 10: down-spread 11: down-spread" "0,1,2,3"
        bitfld.long 0x00 13. "       APB_S_SSC_FORCE_LOCK287 ,set pll force lock  0: disable 1: enable, when reg3<4>=0, set force lock to pll_lk signal" "0,1"
        textline "                           "
        bitfld.long 0x00 12. "APB_S_SPRD_DEP_STEP288  ,increase spectrum spread depth by 2 0: disable 1: spread depth x2" "0,1"
        bitfld.long 0x00 8.--11. "       APB_S_SPRD_DEP289   ,set spectrum spread depth(peak-peak) 0000: no ssc 0001: 500ppm 0010: 1000ppm 0011: 1500ppm 0100: 2000ppm 0101: 2500ppm 0110: 3000ppm 0111: 3500ppm 1000: 4000ppm 1001: 4500ppm 1010: 5000ppm 1011: 5500ppm 1100: 6000ppm 1101: 6000ppm 1110: 6000ppm 1111: 6000ppm" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        hexmask.long.byte 0x00 0.--7. 1. "    PLL6_FRCDIV        ,pll6  frcdiv"

group d:0xD4090148++0x03
    line.long 0x00 "APB_spare20_reg,PLL7 SW control Register_1"
        bitfld.long 0x00 31. " PLL7_PU                 ,pll7 power on  0 = pll7 off  1 = pll on; pll7 is automatically off whenever pll is off." "0,1"
        bitfld.long 0x00 30. "       CLKOUT_DIV5_EN298   ,clkout_div5_en" "0,1"
        bitfld.long 0x00 29. "     CLKOUT_DIV4_EN299  ,clkout_div4_en" "0,1"
        bitfld.long 0x00 28. "       CLKOUT_DIV3_EN300       ,clkout_div3_en" "0,1"
        textline "                           "
        bitfld.long 0x00 27. "CLKOUT_DIV2_EN301       ,clkout_div2_en" "0,1"
        bitfld.long 0x00 26. "       CLKOUT_DIV1_EN302   ,clkout_div1_en" "0,1"
        bitfld.long 0x00 25. "     DIG_TEST_OEN303    ,digital test output enable" "0,1"
        bitfld.long 0x00 24. "       ANA_TEST_OEN304         ,analog test output enable" "0,1"
        textline "                           "
        bitfld.long 0x00 22.--23. "TE_SEL305               ,analog/digital testing control select    analog    digital 00: vref06,   ckbfb_buf 01: vdd_cln2, ckbref_buf 10:vreg_vco,  pll_lk 11:vx_vco,   no_ck" "0,1,2,3"
        bitfld.long 0x00 21. "       PLL_LOCK_SEL306     ,pll locking mode select 0: fractional 1: integer" "0,1"
        bitfld.long 0x00 20. "     PLL__FORCE_LOCK307 ,pll force lock 0: disable 1: enable" "0,1"
        bitfld.long 0x00 17.--19. "       PLL_LOCK_DELAY308       ,pll locking signal delay setting      integer  fractional 001:128*tref   256*tref 010:256*tref   512*tref                      100:512*tref  1024*tref tref is the period of ckrefin." "0,1,2,3,4,5,6,7"
        textline "                           "
        bitfld.long 0x00 16. "BYPASS309               ,bypass pll power down signal and power up pll 1: bypass en_pll 0: not bypass en_pll" "0,1"
        bitfld.long 0x00 14.--15. "       REG_VOLT310         ,regulator output voltage select 00:1.352v 01:1.38v 10:1.408v 11:1.436v" "0,1,2,3"
        bitfld.long 0x00 11.--13. "     KVCO311            ,vco frequency range select /hz        hb      lb 000: ~1.59g   ~0.61g 001: ~1.75g   ~0.76g 010: ~1.89g   ~0.89g 011: ~2.05g   ~1.05g 100: ~2.24g   ~1.23g 101: ~2.4g    ~1.38g 110: ~2.54g   ~1.52g 111:~2.7g    ~1.68g hb: high band lb: low band" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 10. "       FAST_LOCK312            ,pll fast lock 0: disable 1: enable" "0,1"
        textline "                           "
        bitfld.long 0x00 8.--9. "CHARGE_PUMP313          ,charge pump current setting 00:0.5ua*factor 01:1ua*factor 10:1.5ua*factor 11:2ua*factor factor=0.9" "0,1,2,3"
        bitfld.long 0x00 7. "       BAND_SEL314         ,pll band select 0: low band div_by_2 disabled 1: high band div_by_2 enabled" "0,1"
        hexmask.long.byte 0x00 0.--6. 1. "     PLL7_FBDIV         ,pll7 fbdiv"

group d:0xD409014C++0x03
    line.long 0x00 "APB_spare21_reg,PLL7 SW control Register_2"
        bitfld.long 0x00 31. " APB_S_322               ,locked status of pll7" "0,1"
        hexmask.long.byte 0x00 24.--30. 1. "       APB_S_323           ,"
        hexmask.long.tbyte 0x00 0.--23. 1. "    PLL7_FRCDIV        ,frac_num<21:14> 00000000:0 00000001:1/64 00000010:1/32 00000100:1/16 00001000:1/8 00010000:1/4 00100000:1/2 01000000:1 11111111:-1/64 11111110:-1/32 11111100:-1/16 11111000:-1/8 11110000:-1/4 11100000:-1/2 11000000:-1"

tree.end

tree "apbaux"

width 24.

group d:0xD0270000++0x03
    line.long 0x00 "COEL_APB_MSA_BOOT,MSA Boot Address Register"
        hexmask.long 0x00 0.--31. 1. " MSA_BOOT             ,msa boot address (ddr)"

group d:0xD0270008++0x03
    line.long 0x00 "APB_RF_CONT_MUX,Continuity Multiplexer Register"
        bitfld.long 0x00 9. " RF_CONT_MUX_9        ,rf_cont_mux_9  0 = rf_cont 11  1 = gpoa 9" "0,1"
        bitfld.long 0x00 8. "         RF_CONT_MUX_8                 ,rf_cont_mux_8  0 = rf_cont 10  1 = gpoa 8" "0,1"
        bitfld.long 0x00 7. "   RF_CONT_MUX_7                       ,rf_cont_mux_7  0 = rf_cont 9  1 = gpoa 7" "0,1"
        bitfld.long 0x00 6. "  RF_CONT_MUX_6      ,rf_cont_mux_6  0 = rf_cont 8  1 = gpoa 6" "0,1"
        textline "                                  "
        bitfld.long 0x00 5. "RF_CONT_MUX_5        ,rf_cont_mux_5  0 = rf_cont 7  1 = gpoa 5" "0,1"
        bitfld.long 0x00 4. "         RF_CONT_MUX_4                 ,rf_cont_mux_4  0 = rf_cont 6  1 = gpoa 4" "0,1"
        bitfld.long 0x00 3. "   RF_CONT_MUX_3                       ,rf_cont_mux_3  0 = rf_cont 5  1 = gpoa 3" "0,1"
        bitfld.long 0x00 2. "  RF_CONT_MUX_2      ,rf_cont_mux_2  0 = rf_cont 4  1 = gpoa 2" "0,1"
        textline "                                  "
        bitfld.long 0x00 1. "RF_CONT_MUX_1        ,rf_cont_mux_1  0 = rf_cont 3  1 = gpoa 1" "0,1"
        bitfld.long 0x00 0. "         RF_CONT_MUX_0                 ,rf_cont_mux_0  0 = rf_cont 2  1 = gpoa 0" "0,1"

group d:0xD027000C++0x03
    line.long 0x00 "COEL_APB_CLK_GATE,Clock Gate Register"
        bitfld.long 0x00 1. " DTC_SW_RESET         ,dtc software reset" "0,1"
        bitfld.long 0x00 0. "         DTC_GATE                      ,dtc clock gating control" "0,1"

group d:0xD0270010++0x03
    line.long 0x00 "COEL_APB_GSM_WB_CHOOSE,Select Active Sleep Timer Register"
        bitfld.long 0x00 0. " GSM_WB_CHOOSE        ,gsm_wb_choose  this field selects the active sleep timer.  0 = selects the gsm modem slow clock  1 = selects the wb modem sleep timer" "0,1"

group d:0xD0270014++0x03
    line.long 0x00 "COEL_APB_RTU_CLKEN,RTU Clock Enable Register"
        bitfld.long 0x00 0. " RTU_CLK_EN           ,rtu clock enable  0 = disable rtu clock  1 = enable rtu clock" "0,1"

group d:0xD0270018++0x03
    line.long 0x00 "COEL_APB_SPARE1,APB Spare Register 1"
        bitfld.long 0x00 10. " CG_SW_EN             ,software clock gating enable for memory clocks" "0,1"
        bitfld.long 0x00 7.--9. "         SHUTDOWN_CLK_AROUND_RST_PARAM ,shutdown_clk_around_rst_param" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 6. "   SHUTDOWN_CLK_AROUND_RST_BYPASS_CTRL ,shutdown_clk_around_rst_bypass_ctrl" "0,1"
        bitfld.long 0x00 5. "  APB_GB_L2_CTRL_SEL ,selection for gb l2 sram control  0 = aib_gb_l2_*   1 = apb_gb_l2_*" "0,1"
        textline "                                  "
        bitfld.long 0x00 4. "APB_GB_L2_RATIO      ,apb gb l2 sram ratio" "0,1"
        bitfld.long 0x00 0.--3. "         APB_GB_L2_LATENCY             ,apb gb l2 sram latency" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"

group d:0xD027001C++0x03
    line.long 0x00 "COEL_APB_SPARE2,APB Spare Register 2"
        bitfld.long 0x00 13. " FB_WAKEUP_STICKY_CLR ,clear fb_wakeup_sticky_clr interrupt  1 = clear interrupt" "0,1"
        bitfld.long 0x00 11. "         FB_WAKEUP_MASK                ,fb_wakeup_mask  1 = mask" "0,1"
        bitfld.long 0x00 10. "   D2_WAKEUP_MASK                      ,d2_wakeup_mask  1 = mask" "0,1"
        hexmask.long.byte 0x00 3.--8. 1. "  GB_GATER_DELAY     ,<var subsystem: msa> async bridge port clock idle off delay"
        textline "                                  "
        bitfld.long 0x00 1.--2. "GB_GATER_SW_CTRL     ,<var subsystem: msa> async bridge port clock gating software control  0x1 =  hardware control  0x0 = always on  0x2 = always on  0x3 = always on" "0,1,2,3"
        bitfld.long 0x00 0. "         GBM_GATER_SW_CTRL             ,<var subsystem: msa> async bridge master port clock gating software enable" "0,1"

group d:0xD0270020++0x03
    line.long 0x00 "COEL_APB_CONTROL,APB Control Register"
        bitfld.long 0x00 3.--7. " APB_EXT_CYCLE_NUM    ,apb_ext_cycle_num  this field sets the number of cycles for an external apb clock cycle." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"
        bitfld.long 0x00 2. "        COEL_APB_EXT_IF2              ,coel_apb_ext_if[2]  chicken bit for external clock" "0,1"
        bitfld.long 0x00 0.--1. "   COEL_APB_EXT_IF1                    ,coel_apb_ext_if[1]  0x1 = monitor  0x3 = ext r/w" "0,1,2,3"

group d:0xD0290000++0x03
    line.long 0x00 "GSRAM_CP_AP_SEL,GSRAM Shared Memory Control Register"
        bitfld.long 0x00 0. " GSRAM_CNTL           ,gsram_cntl  this field determines if gsram shared 64k memory (sram 2) will be controlled by  1 = comm (default)  0 = app" "0,1"

group d:0xD029000C++0x03
    line.long 0x00 "SENSOR_V18_OUT_REG,V18 Sensor Output Register"
        bitfld.long 0x00 0. " V18_OUT_SENSOR_CNT   ,read enable for the sensor pads v18en output value  this field is the vcc i/o nand sensor pad v18 en output value." "0,1"

tree.end

tree "apbec"

width 25.

group d:0xD0234000++0x03
    line.long 0x00 "AR_CIP_OB,E-Cipher Output Buffer Register"
        hexmask.long 0x00 0.--31. 1. " APBEC_OUTPUT_BUFFER16 ,output buffer  memory"

group d:0xD0235004++0x03
    line.long 0x00 "AR_CIP_SW_RESET,Software Reset Register"
        bitfld.long 0x00 0. " APBEC_SW_RESET25      ,this bit resets the e-cipher unit by software. the software reset affects all e-cipher registers except the config and data registers.  to perform a software reset:" "0,1"

group d:0xD0235008++0x03
    line.long 0x00 "AR_CIP_ALG_THR,Algorithm Threshold Register"
        bitfld.long 0x00 7.--9. " APBEC_THRESHOLD37     ,memory size threshold  defines the memory threshold upon which the e-cipher issues a request to empty its internal memory.  0x0 = 64x64 bits - full memory size  0x1 = 32x64 bits - half memory size  0x2 = 16x64 bits - quarter memory size  0x3 = 8x64 bits  0x4 = 4x64 bits  0x5 = 2x64 bits  0x6 = 1x64 bits" "0,1,2,3,4,5,6,7"
        hexmask.long.byte 0x00 0.--6. 1. "         APBEC_ALGORITHM38 ,algorithm type  selects the algorithm type implemented by the gsm e-cipher.  0x00 = no algorithm selected, e-cipher is disabled  0x01 = a5/1  0x2 = a5/20  0x04 = gea  0x08 = gea2  0x10 = a5/3  0x20 = ecsd a5/3  0x40 = gea3  any other value is illegal and will place the e-cipher in an unpredictable state."

group d:0xD023500C++0x03
    line.long 0x00 "AR_CIP_ASPEC,E-Cipher ASPEC Enable Register"
        bitfld.long 0x00 1. " APBEC_INVERT_ON47     ,invert on  setting this bit inverts the order of the cipher output stream." "0,1"
        bitfld.long 0x00 0. "         APBEC_ASPEC_EN48  ,aspec register configuration enable  setting this bit enables write operations to the following registers:" "0,1"

group d:0xD0235010++0x03
    line.long 0x00 "AR_CIP_DIRECTION,E-Cipher Length Direction Register"
        bitfld.long 0x00 20. " APBEC_DIRECTION61     ,direction of transmission indicator  required only for algorithms: gea, gea2, gea3" "0,1"
        hexmask.long.tbyte 0x00 0.--19. 1. "         APBEC_LENGTH62    ,length  this field is the number of required output bits.  for gea and gea2 algorithms, this number must be an integer number of octets."

group d:0xD0235014++0x03
    line.long 0x00 "AR_CIP_COUNT,E-Cipher Count Register"
        hexmask.long.tbyte 0x00 0.--21. 1. " APBEC_COUNT71         ,frame-dependent input count  required only for algorithms: a5/1, a5/2, a5/3"

group d:0xD0235018++0x03
    line.long 0x00 "AR_CIP_INPUT,E-Cipher Input Register"
        hexmask.long 0x00 0.--31. 1. " APBEC_INPUT79         ,frame-dependent input count  required for algorithms: gea, gea2, gea3"

group d:0xD023501C++0x03
    line.long 0x00 "AR_CIP_KC_XX,E-Cipher Key Register"
        hexmask.long 0x00 0.--31. 1. " APBEC_KC_L87          ,key cipher, l, bits [31:0]"

group d:0xD023502C++0x03
    line.long 0x00 "AR_CIP_RUNUP_CYCLES,E-Cipher Runup Register"
        hexmask.long.byte 0x00 0.--7. 1. " APBEC_RUNUP104        ,number of runup cycles  required only for algorithms: a5/1, a5/2  this field should be set to 100 decimal (0x64)."

group d:0xD0235030++0x03
    line.long 0x00 "AR_CIP_STIR_CYCLES,E-Cipher Stirring Register"
        hexmask.long.byte 0x00 0.--7. 1. " APBEC_STIRRING113     ,number of stirring cycles  required only for algorithms: gea, gea2  set to 128 decimal (0x80) for gea.  set to 194 decimal (0xc2) for gea2."

group d:0xD0235034++0x03
    line.long 0x00 "AR_CIP_INIT,E-Cipher Init Register"
        hexmask.long.byte 0x00 0.--7. 1. " APBEC_INIT122         ,init  this field is the number of cycles required for register initialization and is required only for algorithms: gea, gea2  set to 64 decimal (0x40) for gea.  set to 97 decimal (0x61) for gea2."

group d:0xD0235038++0x03
    line.long 0x00 "AR_CIP_START,E-Cipher Start Cipher Register"
        bitfld.long 0x00 0. " APBEC_START_CIPHER131 ,start cipher  1 = start ciphering process" "0,1"

group d:0xD023503C++0x03
    line.long 0x00 "AR_CIP_DSP_DONE,E-Cipher ARM Done Register"
        bitfld.long 0x00 0. " ARM_DONE              ,arm done  this field indicates that arm has finished reading the e-cipher internal memory.  when working with interrupts (without dma), this bit must be set when the arm has finished reading from the internal memory (according to the threshold size). this bit is self cleared." "0,1"

group d:0xD0235050++0x03
    line.long 0x00 "AR_CIP_DMA_ACK_BYP_CTRL,E-Cipher DMA_ACK, Bypass Control Register"
        bitfld.long 0x00 8. " DMA_ACK_BYPASS        ,dma_ack bypass  0 = normal  1 = bypass mode" "0,1"
        hexmask.long.byte 0x00 0.--7. 1. "         DMA_READ_ACCESSES ,dma read accesses  this field selects how many dma read accesses are carried out before issuing a dma_ack.  valid values are 0x00 to 0xff"

group d:0xD0234100++0x03
    line.long 0x00 "AR_CIP_OB_FOR_DMA,E-Cipher Output Buffer DMA Register"
        hexmask.long 0x00 0.--31. 1. " OUTPUT_BUFFER_DMA     ,output buffer dma"

tree.end

tree "aspaux"

width 22.

group d:0xFFB00000++0x03
    line.long 0x00 "MCTL,MCTL Control Register"
        bitfld.long 0x00 5.--6. " IVG_14_CNTL            ,control ivg 14 4-to-1 mux  0x0 = option 0  0x1 = option 1  0x2 = option 2  0x3 = option 3" "0,1,2,3"
        bitfld.long 0x00 0.--1. "         IVG_7_CNTL             ,control ivg 7 4-to-1 mux  0x0 = option 0  0x1 = option 1  0x2 = option 2  0x3 = option 3" "0,1,2,3"

group d:0xFFB00004++0x03
    line.long 0x00 "SIHS0_1,Second Interrupt High Select Mux 0/1 Register"
        hexmask.long 0x00 0.--31. 1. " MUX22                  ,mux"

group d:0xFFB0000C++0x03
    line.long 0x00 "SIHS0_1,Second Interrup Low Select Mux 0/1 Register"
        hexmask.long 0x00 0.--31. 1. " MUX29                  ,mux"

group d:0xFFB00014++0x03
    line.long 0x00 "C1DM,DMA C1 Mux Control Register"
        hexmask.long 0x00 0.--31. 1. " C1DM_MUX               ,c1dm mux control"

group d:0xFFB00018++0x03
    line.long 0x00 "DMAC1_EOCINH_WR,GB DMAC 1 EOC Inhibit Register"
        hexmask.long 0x00 0.--31. 1. " DMAC1_EOCINH           ,gb dmac 1 eoc inhibit"

group d:0xFFB0001C++0x03
    line.long 0x00 "COEL_ASP_CONTROL,COEL ASP Control Register"
        bitfld.long 0x00 0.--1. " COEL_APB_EXT_IF1:0     ,coel_apb_ext_if[1]  0x1 = aspec monitor only   0x3 = ext r/w" "0,1,2,3"

group d:0xFFB00020++0x03
    line.long 0x00 "COEL_ASP_DIGRF_GP1,ASP_DIGRF_GP1 Register"
        bitfld.long 0x00 0. " M1_TX_WB_LCT           ,output to the digrf m1_tx_wb_lct" "0,1"

group d:0xFFB00024++0x03
    line.long 0x00 "COEL_ASP_DIGRF_GP2,ASP_DIGRF_GP2 Register"
        bitfld.long 0x00 0. " M1_TX_WB_WR_EN         ,output to the digrf m1_tx_wb_wr_en" "0,1"

group d:0xFFB00028++0x03
    line.long 0x00 "COEL_ASP_DIGRF_GP3,ASP_DIGRF_GP3 Register"
        bitfld.long 0x00 0. " M1_RX_HW_DATA_C_RDEN   ,output to the digrf m1_rx_hw_data_c_rden" "0,1"

group d:0xFFB0002C++0x03
    line.long 0x00 "COEL_ASP_DIGRF_GP4,ASP_DIGRF_GP4 Register"
        bitfld.long 0x00 0. " TX_WB_SM_RE            ,output to the digrf_tx_wb_sm_reset  0x0 = asserted  0x1 = de-asserted" "0,1"

group d:0xFFB00030++0x03
    line.long 0x00 "COEL_ASP_DIGRF_CLKEN,ASP_DIGRF Clock Enable Register"
        bitfld.long 0x00 0. " COEL_ASP_DIGRF_CLKEN   ,coel_asp_digrf_clken" "0,1"

group d:0xFFB00034++0x03
    line.long 0x00 "COEL_ASP_SPARE1,ASP_SPARE1 Register"
        bitfld.long 0x00 0.--2. " DIGRF4_WB_TX_LCT       ,digrf4 wb_tx_lct signals" "0,1,2,3,4,5,6,7"

group d:0xFFB00038++0x03
    line.long 0x00 "COEL_ASP_SPARE2,ASP_SPARE2 Register"
        bitfld.long 0x00 14.--15. " TCU_TIME_SIG_SEL_15_14 ,select tcu signals [15:14]  this field is used to select tcu_gpob signals to be m_tcu_time_signals[7] to super_log in fb modem.  0 = m1_tcu_gpob[3]  0 = m1_tcu_gpob[7]  0 = m1_tcu_gpob[11]  0 = m1_tcu_gpob[15]" "0,1,2,3"
        bitfld.long 0x00 12.--13. "         TCU_TIME_SIG_SEL_13_12 ,select tcu signals [13:12]  this field is used to select tcu_gpob signals to be m_tcu_time_signals[6] to super_log in fb modem.  0 = m1_tcu_gpob[2]  0 = m1_tcu_gpob[6]  0 = m1_tcu_gpob[10]  0 = m1_tcu_gpob[14]" "0,1,2,3"
        bitfld.long 0x00 10.--11. "  TCU_TIME_SIG_SEL_11_10 ,select tcu signals [11:10]  this field is used to select tcu_gpob signals to be m_tcu_time_signals[5] to super_log in fb modem.  0 = m1_tcu_gpob[1]  0 = m1_tcu_gpob[5]  0 = m1_tcu_gpob[8]  0 = m1_tcu_gpob[13]" "0,1,2,3"
        bitfld.long 0x00 8.--9. "  TCU_TIME_SIG_SEL_9_8 ,select tcu signals [9:8]  this field is used to select tcu_gpob signals to be m_tcu_time_signals[4] to super_log in fb modem.  0 = m1_tcu_gpob[0]  0 = m1_tcu_gpob[4]  0 = m1_tcu_gpob[8]  0 = m1_tcu_gpob[12]" "0,1,2,3"
        textline "                                "
        bitfld.long 0x00 6.--7. "TCU_TIME_SIG_SEL_7_6   ,select tcu signals [7:6]  this field is used to select tcu_gpoa signals to be m_tcu_time_signals[3] to super_log in fb modem.  0 = m1_tcu_gpoa[3]  0 = m1_tcu_gpoa[7]  0 = m1_tcu_gpoa[11]  0 = m1_tcu_gpoa[15]" "0,1,2,3"
        bitfld.long 0x00 4.--5. "         TCU_TIME_SIG_SEL_5_4   ,select tcu signals [5:4]  this field is used to select tcu_gpoa signals to be m_tcu_time_signals[2] to super_log in fb modem:   0 = m1_tcu_gpoa[2]  0 = m1_tcu_gpoa[6]  0 = m1_tcu_gpoa[10]  0 = m1_tcu_gpoa[14]" "0,1,2,3"
        bitfld.long 0x00 2.--3. "  TCU_TIME_SIG_SEL_3_2   ,select tcu signals [3:2]  this field is used to select tcu_gpoa signals to be m_tcu_time_signals[1] to super_log in fb modem.  0 = m1_tcu_gpoa[1]  0 = m1_tcu_gpoa[5]  0 = m1_tcu_gpoa[8]  0 = m1_tcu_gpoa[13]" "0,1,2,3"
        bitfld.long 0x00 0.--1. "  TCU_TIME_SIG_SEL_1_0 ,select tcu signals [1:0]  this field is used to select tcu_gpoa signals to be m_tcu_time_signals[0] to super_log in fb modem.  0 = m1_tcu_gpoa[0]  0 = m1_tcu_gpoa[4]  0 = m1_tcu_gpoa[8]  0 = m1_tcu_gpoa[12]" "0,1,2,3"

tree.end

tree "aspec"

width 18.

group d:0xFFA00004++0x03
    line.long 0x00 "CIP_SW_RESET,E-Cipher Software Reset Register"
        bitfld.long 0x00 0. " ASPEC_SW_RESET17      ,sw_reset  this field resets the e-cipher unit by software. the software reset affects all e-cipher registers except the config and data registers. to perform a software reset:" "0,1"

group d:0xFFA00008++0x03
    line.long 0x00 "CIP_ALG_THR,E-Cipher Algorithm Threshold Register"
        bitfld.long 0x00 7.--9. " ASPEC_THRESHOLD29     ,memory size threshold  this field defines the memory threshold upon which the e-cipher issues a request to empty its internal memory.  0x0 = 64x64 bits - full memory size  0x1 = 32x64 bits - half memory size  0x2 = 16x64 bits - quarter memory size  0x3 = 8x64 bits  0x4 = 4x64 bits  0x5 = 2x64 bits  0x6 = 1x64 bits" "0,1,2,3,4,5,6,7"
        hexmask.long.byte 0x00 0.--6. 1. "         ASPEC_ALGORITHM30 ,algorithm type  this field selects the algorithm type implemented by the gsm e-cipher.  0x00 = no algorithm selected, e-cipher is disabled  0x01 = a5/1  0x02 = a5/20  0x04 = gea  0x08 = gea2  0x10 = a5/3  0x20 = ecsd a5/3  0x40 = gea3  any other value is illegal and will place the e-cipher in an unpredictable state."

group d:0xFFA0000C++0x03
    line.long 0x00 "CIP_ASPEC,E-Cipher ASPEC Enable Register"
        bitfld.long 0x00 1. " ASPEC_INVERT_ON39     ,invert_on  setting this field inverts the order of the cipher output stream." "0,1"
        bitfld.long 0x00 0. "         ASPEC_ASPEC_EN40  ,register configuration enable  setting this bit enables write operations to the following registers:" "0,1"

group d:0xFFA00010++0x03
    line.long 0x00 "CIP_DIRECTION,E-Cipher Length Direction Register"
        bitfld.long 0x00 20. " ASPEC_DIRECTION53     ,direction of transmission indicator  this is only required for algorithms: gea, gea2, and gea3." "0,1"
        hexmask.long.tbyte 0x00 0.--19. 1. "         ASPEC_LENGTH54    ,the number of required output bits  for gea and gea2 algorithms, this number must be an integer number of octets."

group d:0xFFA00014++0x03
    line.long 0x00 "CIP_COUNT,E-Cipher Count Register"
        hexmask.long.tbyte 0x00 0.--21. 1. " ASPEC_COUNT63         ,frame-dependent input  this is only required for algorithms: a5/1, a5/2, and a5/3."

group d:0xFFA00018++0x03
    line.long 0x00 "CIP_INPUT,E-Cipher Input Register"
        hexmask.long 0x00 0.--31. 1. " ASPEC_INPUT71         ,frame-dependent input  this is only required for algorithms: gea, gea2, and gea3."

group d:0xFFA0001C++0x03
    line.long 0x00 "CIP_KC_XX,E-Cipher KC_xx Register"
        hexmask.long 0x00 0.--31. 1. " ASPEC_KC_L79          ,cipher key, bits [31:0]"

group d:0xFFA0002C++0x03
    line.long 0x00 "CIP_RUNUP_CYCLES,E-Cipher Runup Register"
        hexmask.long.byte 0x00 0.--7. 1. " ASPEC_RUNUP96         ,number of run-up cycles  this is only required for algorithms: a5/1 and a5/2. it should be set to 100 decimal (0x64)."

group d:0xFFA00030++0x03
    line.long 0x00 "CIP_STIR_CYCLES,E-Cipher Stirring Register"
        hexmask.long.byte 0x00 0.--7. 1. " ASPEC_STIRRING105     ,number of stirring cycles  this is only required for algorithms: gea and gea2. it should be set to 128 decimal (0x80) for gea and 194 decimal (0xc2) for gea2."

group d:0xFFA00034++0x03
    line.long 0x00 "CIP_INIT,E-Cipher Init Register"
        hexmask.long.byte 0x00 0.--7. 1. " ASPEC_INIT114         ,number of cycles required for register initialization  this is only required for algorithms: gea and gea2. it should be set to 64 decimal (0x40) for gea and 97 decimal (0x61) for gea2."

group d:0xFFA00038++0x03
    line.long 0x00 "CIP_START,E-Cipher Start Cipher Register"
        bitfld.long 0x00 0. " ASPEC_START_CIPHER123 ,start_cipher  set this bit to start the ciphering process." "0,1"

group d:0xFFA0003C++0x03
    line.long 0x00 "CIP_DSP_DONE,E-Cipher DSP Done Register"
        bitfld.long 0x00 0. " DSP_DONE              ,dsp finished reading e-cipher internal memory  when working with interrupts (without dma), this field must be set, when the dsp has finished reading from the internal memory, according to the threshold size. this field is self clearing." "0,1"

tree.end

tree "aspeq"

width 21.

group d:0xFFA02000++0x03
    line.long 0x00 "EQU_Hx_SLOT1_REG,Causal Half-slot Channel Tap Register"
        hexmask.long.word 0x00 20.--31. 1. " HX_S1_Q           ,hx_s1_q  this field contains the 2's complement channel taps values for the causal half slot (q)."
        hexmask.long.word 0x00 4.--15. 1. "      HX_S1_I           ,hx_s1_i  this field contains the 2's complement channel taps values for the causal half slot (i)."

group d:0xFFA0201C++0x03
    line.long 0x00 "EQU_Hx_SQR_REG_S1,Causal Half-slot Channel Tap Square Root Register"
        hexmask.long.word 0x00 20.--31. 1. " HX_SQR_S1_Q       ,hx_sqr_s1_q  sqrt(2)/2*hx_s1_q"
        hexmask.long.word 0x00 4.--15. 1. "      HX_SQR_S1_I       ,hx_sqr_s1_i  sqrt(2)/2*hx_s1_i"

group d:0xFFA02038++0x03
    line.long 0x00 "EQU_Hx_SLOT2_REG,Anti-causal Half-slot Channel Tap Register"
        hexmask.long.word 0x00 20.--31. 1. " HX_S2_Q           ,hx_s2_q  this field contains the 2's complement channel taps values for the anti-causal half slot (q)."
        hexmask.long.word 0x00 4.--15. 1. "      HX_S2_I           ,hx_s2_i  this field contains the 2's complement channel taps values for the anti-causal half slot (i)."

group d:0xFFA02054++0x03
    line.long 0x00 "EQU_Hx_SQR_REG_S2,Anti-causal Half-slot Channel Tap Square Root Register"
        hexmask.long.word 0x00 20.--31. 1. " HX_SQR_S2_Q       ,hx_sqr_s2_q  sqrt(2)/2*hx_reg_s2_q"
        hexmask.long.word 0x00 4.--15. 1. "      HX_SQR_S2_I       ,hx_sqr_s2_i  sqrt(2)/2*hx_reg_s2_i"

group d:0xFFA02070++0x03
    line.long 0x00 "EQU_MU0_REG,<mu>0 Register"
        bitfld.long 0x00 25.--29. " <MU>5             ,<mu>5" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"
        bitfld.long 0x00 20.--24. "        <MU>4             ,<mu>4" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"
        bitfld.long 0x00 15.--19. "    <MU>3                 ,<mu>3" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"
        bitfld.long 0x00 10.--14. "  <MU>2               ,<mu>2" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"
        textline "                               "
        bitfld.long 0x00 5.--9. "<MU>1             ,<mu>1" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"
        bitfld.long 0x00 0.--4. "        <MU>0             ,<mu>0" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"

group d:0xFFA02074++0x03
    line.long 0x00 "EQU_MU6_REG,<mu>1 Register"
        bitfld.long 0x00 0.--4. " <MU>6             ,<mu>6" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"

group d:0xFFA02078++0x03
    line.long 0x00 "EQU_HD_S1_REGx,Causal Half-slot Hard Decision Register"
        hexmask.long 0x00 0.--29. 1. " HD_X_S1           ,hd_x_s1  this field stores the hard decision for the equalized symbol of the causal half-slot."

group d:0xFFA02090++0x03
    line.long 0x00 "EQU_HD_S2_REGx,Anti-causal Half-slot Hard Decision Register"
        hexmask.long 0x00 0.--29. 1. " HD_X_S2           ,hd_x_s2  this field stores the hard decision for the equalized symbol of the causal half-slot."

group d:0xFFA020A8++0x03
    line.long 0x00 "EQU_SWRES_REG,Software Reset Register"
        bitfld.long 0x00 0. " ASPEQ_SW_RESET132 ,software reset  1 = software reset  0 = no software reset" "0,1"

group d:0xFFA020AC++0x03
    line.long 0x00 "EQU_CONT_REG,Equalizer Control Register"
        bitfld.long 0x00 3. " EQUALIZER_GO      ,equalizer go  1 = equalizer go  0 = equalizer no go" "0,1"
        bitfld.long 0x00 2. "         DEBUG_MODE_ON     ,debug mode on  1 = debug mode enabled - equalizer enters debug mode every eight processed symbols (hardware/software reset to exit)  0 = debug mode disabled" "0,1"
        bitfld.long 0x00 1. "     CHANNEL_TRACKING_ON   ,channel tracking on  1 = channel tracking and update of channel taps enabled  0 = channel tracking and update of channel taps disabled" "0,1"
        bitfld.long 0x00 0. "   SOFT_METRIC_ON      ,soft metric on  1 = soft metric llr calculation enabled  0 = soft metric llr calculation disabled" "0,1"

group d:0xFFA020B0++0x03
    line.long 0x00 "EQU_STATUS_REG,Equalizer Status Register"
        bitfld.long 0x00 7. " NEW_OLD_MEMORY    ,new/old memory  this field indicates which memory is read during debug mode." "0,1"
        bitfld.long 0x00 6. "         SEQUENCER_ERROR   ,sequencer error  this field is set when a forbidden state occurs. for example: not enough symbols to start equalization (at least 13 for 8psk, 8 for gmsk)" "0,1"
        bitfld.long 0x00 5. "     DEBUG_STANDBY         ,debug standby  this field is set when the equalizer waits for data request. when data request is given, this field is cleared." "0,1"
        bitfld.long 0x00 4. "   DEBUG_DATA_READY    ,debug data ready  this field is set when debug data is ready." "0,1"
        textline "                               "
        bitfld.long 0x00 3. "MIDDLE_OF_EQU2    ,middle of equ2  for causal and anti-causal half slot: this field is set to 1 when a given number of symbols, as defined in the equalizer mode 0 register, have been processed." "0,1"
        bitfld.long 0x00 2. "         MIDDLE_OF_EQU1    ," "0,1"
        bitfld.long 0x00 1. "     DATA_VALID            ,data valid  the equalization process has started, and some valid data is presented in the llr memories." "0,1"
        bitfld.long 0x00 0. "   END_OF_EQUALIZATION ,end of equalization  this field is set when all symbols have been processed." "0,1"

group d:0xFFA020B4++0x03
    line.long 0x00 "EQU_MODE0_REG,Equalizer Mode 0 Register"
        bitfld.long 0x00 30. " INDEPENDENT_TAPS  ,independent taps  1 = h0/6_s2 are written independently  when set to 1, the anti-causal taps have no dependency on the causal taps written to registers hx_reg_s1.  0 = h0/6_s2 are the complex conjugate of h0/6_s1  when set to 0, the anti-causal taps in registers hx_reg_s2 are automatically set by hardware as complex conjugates of the causal taps - when writing tap values to hxreg_s1. this involves negating the q part of the complex causal taps. in this case, register hx_reg_s2 should not be written." "0,1"
        bitfld.long 0x00 29. "         DEBUG_THRESHOLD   ,debug threshold  during debug mode, a debug standby interrupt is given every symbol if it is 0 or every eight symbols if it is 1." "0,1"
        bitfld.long 0x00 28. "     EQUALIZATION_TYPE     ,equalization type  1 = 8psk  0 = gmsk" "0,1"
        bitfld.long 0x00 26.--27. "   GMSK_CTU_RATE       ,gmsk ctu rate  this field is used for the gmsk channel tracking rate (ctu) of taps update (1,2,4,8) for equalizer metrics calculation." "0,1,2,3"
        textline "                               "
        bitfld.long 0x00 23.--25. "SM_LAST_STATE_S2  ,sm last state s2  this field is used for the state before final state when close equ mode s2 is set." "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 20.--22. "         LAST_STATE_S2     ,last state s2  this field is used for the final state when close equ mode s2 is set." "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 19. "     CLOSE_EQU_MODE_S2     ,the equalization finished in 2 known states (as defined in last state s2 and sm last state 2)" "0,1"
        bitfld.long 0x00 16.--18. "   SM_LAST_STATE_S1    ,state before final state when close equ mode s1 is set" "0,1,2,3,4,5,6,7"
        textline "                               "
        bitfld.long 0x00 13.--15. "LAST_STATE_S1     ,last state s1  this field is used for the final state when close equ mode s1 is set." "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 12. "         CLOSE_EQU_MODE_S1 ,close equ mode s1  the equalization finished in two known states (as defined in <last state s1> and <sm last state s1>)." "0,1"
        hexmask.long.byte 0x00 6.--11. 1. "     NUM_OF_SYMB_2_1ST_INT ,number of symbols to first interrupt"
        hexmask.long.byte 0x00 0.--5. 1. "  NUM_OF_SYMB_2_EQU   ,number of symbols to equalize for each half slot"

group d:0xFFA020B8++0x03
    line.long 0x00 "EQU_MODE1_SLOT1_REG,Equalizer Mode 1 S1 Register"
        hexmask.long.tbyte 0x00 3.--20. 1. " INIT_STATE_S1     ,init state s1  for 8psk mode: 6 x 3-bit  for gmsk mode: 5-bit of initial state and 12-bit of initial path metric value (two 0 bits are concatenated at the lsb for calculation)"
        bitfld.long 0x00 0.--2. "    CHANNEL_LENGTH    ,length of channel -1  010 to 110 (3 to 7) for 8psk, always 6 for gmsk" "0,1,2,3,4,5,6,7"

group d:0xFFA020BC++0x03
    line.long 0x00 "EQU_MODE1_SLOT2_REG,Equalizer Mode 1 S2 Register"
        hexmask.long.tbyte 0x00 0.--17. 1. " INIT_STATE        ,init state  for 8psk mode: 6 x 3-bit  for gmsk mode: 5-bit of initial state and 12-bit of initial path metric value (two 0 bits are concatenated at the lsb for calculation)"

group d:0xFFA020C0++0x03
    line.long 0x00 "EQU_DBG_DATA_REG,Equalizer Debug Data Read Register"
        hexmask.long 0x00 0.--31. 1. " DBG_DATA          ,debug data read register"

group d:0xFFA020C4++0x03
    line.long 0x00 "EQU_RESUME_REG,Equalizer Debug Standby Resume Register"
        bitfld.long 0x00 0. " ASPEQ_RESUME218   ,debug standby resume" "0,1"

group d:0xFFA020C8++0x03
    line.long 0x00 "EQU_REQ_REG,Equalizer Debug Data Request Register"
        bitfld.long 0x00 9.--11. " DBG_MEM           ,dbg_mem  this field defines the memory to be read:  0x0 = branch metric memory (8psk) / delta memory (gmsk): 512 x 12/11-bit (9-bit of dbg_addr[8:0])  0x1 = path metric memory (8psk): 64 -bit x 14-bit (address defined by dbg_addr[5:0])  0x2 = old trellis memory (8psk) (new if <new/old memory> field in the equalizer status register is 1): 8 x 18-bit (address defined by dbg_addr[2:0])  0x3 = new trellis memory (8psk) (old if <new/old memory> field is 1): 8 x 18-bit (address defined by dbg_addr[2:0])  0x4 = old path metric memory 0 (gmsk) (new if <new/old memory> field is 1): 16 x 14 bit (address defined by dbg_addr[3:0])  0x5 = new path metric memory 1 (gmsk) (old if <new/old memory> field is 1): 16 x 14 bit (address defined by dbg_addr[3:0])  0x6 = old path metric memory 2 (gmsk) (new if <new/old memory> field is 1): 16 x 14 bit (address defined by dbg_addr[3:0])  0x7 = new path metric memory 3 (gmsk) (old if <new/old memory> field is 1): 16 x 14 bit (address defined by dbg_addr[3:0])" "0,1,2,3,4,5,6,7"
        hexmask.long.word 0x00 0.--8. 1. "         DBG_ADDR          ,dbg_addr  defines the address in memory to be ready"

group d:0xFFA020CC++0x03
    line.long 0x00 "EQU_CURR_SYM_REG,Current Symbol Register"
        hexmask.long.word 0x00 22.--31. 1. " CURRENT_SYMBOL236 ,current symbol q value"
        hexmask.long.word 0x00 6.--15. 1. "      CURRENT_SYMBOL238 ,current symbol i value"

group d:0xFFA020D0++0x03
    line.long 0x00 "EQU_NV_SLOT1_REG0,Causal Half-slot Noise Variance 0 Register"
        hexmask.long.word 0x00 0.--13. 1. " NV_0_S1           ,minimum pm"

group d:0xFFA020D4++0x03
    line.long 0x00 "EQU_NV_SLOT1_REG1,Causal Half-slot Noise Variance 1 Register"
        bitfld.long 0x00 14.--18. " 5-BIT_COUNTER257  ,5-bit counter" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"
        hexmask.long.word 0x00 0.--13. 1. "        ZERO_STATE_PM258  ,zero state pm"

group d:0xFFA020D8++0x03
    line.long 0x00 "EQU_NV_SLOT2_REG0,Anti-causal Half-slot Noise Variance 0 Register"
        hexmask.long.word 0x00 0.--13. 1. " NV0_S2            ,minimum pm"

group d:0xFFA020DC++0x03
    line.long 0x00 "EQU_NV_SLOT2_REG1,Anti-causal Half-slot Noise Variance 1 Register"
        bitfld.long 0x00 14.--18. " 5-BIT_COUNTER276  ,5-bit counter" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"
        hexmask.long.word 0x00 0.--13. 1. "        ZERO_STATE_PM277  ,zero state pm"

group d:0xFFA02100++0x03
    line.long 0x00 "EQU_LLR_REG_S1,Causal Half-slot 44 Soft Metrics Registers"
        hexmask.long.byte 0x00 24.--31. 1. " LLR3287           ,llr3 value"
        hexmask.long.byte 0x00 16.--23. 1. "        LLR2288           ,llr2 value"
        hexmask.long.byte 0x00 8.--15. 1. "    LLR1289               ,llr1 value 1"
        hexmask.long.byte 0x00 0.--7. 1. "  LLR00               ,llr0 value"

group d:0xFFA02200++0x03
    line.long 0x00 "EQU_LLR_REG_S2,Anti-causal Half-slot 44 Soft Metrics Register"
        hexmask.long.byte 0x00 24.--31. 1. " LLR3305           ,llr3 value"
        hexmask.long.byte 0x00 16.--23. 1. "        LLR2306           ,llr2 value"
        hexmask.long.byte 0x00 8.--15. 1. "    LLR1307               ,llr1 value"
        hexmask.long.byte 0x00 0.--7. 1. "  LLR0                ,llr0 value"

group d:0xFFA02001++0x03
    line.long 0x00 "DUMMY_REGISTER,This is a Dummy Register"
        hexmask.long 0x00 0.--31. 1. " ASPEQ_DUMMY320    ,this is a dummy register used as a workaround to fix an issue with the rev 2.21 perl script that requires another register follow the last include file (shown above). ignore this register as it will not show up in documentation anyway. (mclark)"

tree.end

tree "aspmirq"

width 22.

group d:0xFFA03800++0x03
    line.long 0x00 "MIRQ_INT_CLRnn,MIRQ Interrupt Clear n Register"
        bitfld.long 0x00 0. " MIRQ_INT_CLR         ,1 = the sticky-bit is held in reset   to clear the interrupt sticky-bit, write 1 and then 0.   when level interrupt function is selected, these registers have no effect." "0,1"

group d:0xFFA038F8++0x03
    line.long 0x00 "MIRQ_EDGE_LEVEL_LO24,MIRQ Low-24 Interrupt Sensitivity Register"
        hexmask.long.tbyte 0x00 0.--23. 1. " MIRQ_EDGE_LEVEL_LO24 ,0 = originally level-sensitive interrupt (no sticky bit needed)   1 = originally edge-sensitive interrupt (sticky bit needed)   bit [0] refers to interrupt 0, and bit [23] refers to interrupt 23."

group d:0xFFA038FC++0x03
    line.long 0x00 "MIRQ_EDGE_LEVEL_HI24,MIRQ Hi-24 Interrupt Sensitivity Register"
        hexmask.long.tbyte 0x00 0.--23. 1. " MIRQ_EDGE_LEVEL_HI24 ,0 = originally level-sensitive interrupt (no sticky bit needed)   1 = originally edge-sensitive interrupt (sticky bit needed)   bit [0] refers to interrupt 24, and bit [23] refers to interrupt 47."

tree.end

tree "aspv"

width 19.

group d:0xFFA01000++0x03
    line.long 0x00 "VD_SW_RST,Viterbi Decoder SW Reset Register"
        bitfld.long 0x00 0. " VD_SW_RST                 ,viterbi decoder software reset. this bit is used to reset the viterbi unit by software. configuration registers and input buffer are not affected by a software reset.  to reset, perform the following:" "0,1"

group d:0xFFA01004++0x03
    line.long 0x00 "VD_CTL,Viterbi Decoder Control Register"
        bitfld.long 0x00 14. " GPB_BIT_ORDER             ,output buffer bit ordering on gpb  1 = msb on d0 ... lsb on d31  0 = msb on d31 ... lsb on d0" "0,1"
        bitfld.long 0x00 13. "         DEBUG_MODE                 ,1 = debug mode enabled, reading the input buffer content is allowed via the input buffer read register. viterbi calculation is disabled  0 = debug mode disabled. viterbi calculation is enabled" "0,1"
        bitfld.long 0x00 11.--12. "     TRACEBACK_EMPTY_ ,this field defines the number of valid symbols (bits) per middle block traceback." "0,1,2,3"
        bitfld.long 0x00 10. "  GPB_CLOCK_ENABLE ,user should enable the gpb clock before accessing the viterbi buffers  1 = gpb clock to viterbi is enabled  0 = gpb clock to viterbi is disabled" "0,1"
        textline "                             "
        bitfld.long 0x00 9. "CRC_BIT_ORDER             ,crc result bit order on aspec bus:  1 = msb on d0 ... lsb on d31  0 = msb on d31 ... lsb on d0" "0,1"
        bitfld.long 0x00 8. "         TRACEBACK_START_INDEX35    ,1 = traceback start index is the calculated most reliable index.  0 = traceback start index is a programmable value from traceback start index field in the traceback start register." "0,1"
        bitfld.long 0x00 7. "     ASPVI_HW_MODE36  ,hw mode allows the wcdma modem hw to write the viterbi input buffer directly.  1 = wcdma modem writes to the viterbi input buffer.  0 = grayback or grayback dma can write to the viterbi input buffer (via gpb)" "0,1"
        bitfld.long 0x00 6. "  CONTINUOUS_MODE  ,continuous mode allows to perform several decode calculations over the same block which is kept in the input buffer.  for example: in a blind rate detection, the block size is unknown, continuous mode allows to perform several calculations with different block sizes over the same block.  to abort a continuous mode calculation, perform a software reset.  to resume a calculation, refer to the viterbi resume register.  1 = continuous mode enabled  0 = continuous mode disabled" "0,1"
        textline "                             "
        bitfld.long 0x00 5. "FORCE_ZERO_STATE          ,force the first k-1 stages to zero state  1 = force to zero state  0 = don't force to zero state" "0,1"
        bitfld.long 0x00 4. "         CRC_EN                     ,enables the rsc/crc calculation  1 = rsc/crc calculation is enabled  0 = rsc/crc calculation is disabled" "0,1"
        bitfld.long 0x00 2.--3. "     CONSTRAINT       ,viterbi constraint length  0x0 for k = 5  0x1 for k = 7  0x2 for k = 9  0x3 = reserved" "0,1,2,3"
        bitfld.long 0x00 0.--1. "  ASPVI_RATE41     ,viterbi rate  0x0 for decoding rate of 1/2  0x1 for decoding rate of 1/3  0x2 = for decoding rate of 1/4  0x3 = reserved" "0,1,2,3"

group d:0xFFA01008++0x03
    line.long 0x00 "VD_BSZ,Viterbi Decoder Block Size and Last Word Register"
        hexmask.long.word 0x00 16.--26. 1. " LAST_WORD_INDEX           ,this field contains the number of words to be written to the viterbi input buffer. the viterbi starts its calculation after the last word is written.  last word value depends on the rate as follows:  for rate 1/2: last word = blocksize/3  for rate 1/3: last word = blocksize/2  for rate 1/4: last word = blocksize"
        hexmask.long.word 0x00 0.--9. 1. "      ASPVI_BLOCK_SIZE53         ,this field contains the number of symbols in the current block.  format: value in this field is number of symbols -1. for example: 1024 symbols value is 0x3ff  the value of block size to be written to the register should be reduced by one from the actual block size value that is calculated from the above example.  valid values: k=5 [0x004:0x3ff], k=7 [0x006:0x3ff], k=9 [0x009:0x3ff]"

group d:0xFFA0100C++0x03
    line.long 0x00 "VD_MPE01,Viterbi Decoder Mask Polynomial (C0/C1) Register"
        hexmask.long.word 0x00 16.--24. 1. " C1_MASK_POLYNOMIAL        ,mask polynomial for code bit c1"
        hexmask.long.word 0x00 0.--8. 1. "      C0_MASK_POLYNOMIAL         ,mask polynomial for code bit c0"

group d:0xFFA01010++0x03
    line.long 0x00 "VD_MPE23,Viterbi Decoder Mask Polynomial (C2/C3) Register"
        hexmask.long.word 0x00 16.--24. 1. " C3_MASK_POLYNOMIAL        ,mask polynomial for code bit c3"
        hexmask.long.word 0x00 0.--8. 1. "      C2_MASK_POLYNOMIAL         ,mask polynomial for code bit c2"

group d:0xFFA01014++0x03
    line.long 0x00 "VD_RSCM,Viterbi Decoder RSC Mask Polynomial Register"
        hexmask.long.word 0x00 0.--8. 1. " RSC_MASK                  ,rsc mask polynomial"

group d:0xFFA01018++0x03
    line.long 0x00 "VD_CFL,Viterbi Decoder CRC First and Last Bits Register"
        hexmask.long.word 0x00 16.--25. 1. " LAST_BIT_INDEX            ,index of last bit for crc calculation  valid values: 0x001 to 0x3ff where   first crc bit index < last crc bit index <= block size"
        hexmask.long.word 0x00 0.--9. 1. "      FIRST_BIT_INDEX            ,index of first bit for crc calculation  valid values: 0x000 to 0x3fe"

group d:0xFFA0101C++0x03
    line.long 0x00 "VD_CRCI,Viterbi Decoder CRC Initial Value Register"
        hexmask.long 0x00 0.--31. 1. " CRC_INITIAL_VALUE         ,crc initial value"

group d:0xFFA01020++0x03
    line.long 0x00 "VD_CRCM,Viterbi Decoder CRC Mask Polynomial Register"
        hexmask.long 0x00 0.--31. 1. " CRC_MASK_POLYNOMIAL       ,crc mask polynomial"

group d:0xFFA01024++0x03
    line.long 0x00 "VD_TBST,Viterbi Decoder TraceBack Start and Index Register"
        hexmask.long.byte 0x00 16.--23. 1. " TRACEBACK_START_INDEX120  ,when the traceback start index bit in the control register is 0, the traceback calculation starts from the state index as defined in this field.  valid values:  for k=9: 0x00 to 0xff  for k=7: 0x00 to 0x3f  for k=5: 0x00 to 0x0f"
        hexmask.long.word 0x00 0.--9. 1. "        TRACEBACK_START_SYMBOL     ,this field contains the number of first symbol to start the traceback calculation.  valid values for cyclic traceback are:  for k=9: 0x000 to 0x07f  for k=7: 0x000 to 0x1ff  for k=5: 0x000 to 0x3ff"

group d:0xFFA01028++0x03
    line.long 0x00 "VD_OBRA,Viterbi Decoder Random Access Load Address Register"
        bitfld.long 0x00 5.--9. " INPUT_BUFFER_READ_ADDRESS ,this field contains the start address when reading the input buffer.  whenever this field is different from 0x00 and a dummy read from the input buffer is performed, this field is loaded to the input buffer address register.   when this field equals to 0x00, each read from the input buffer increments the input buffer address register." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"
        bitfld.long 0x00 0.--4. "        OUTPUT_BUFFER_READ_ADDRESS ,this field contains the start address when reading the output buffer.  whenever this field is different from 0x00 and a dummy read from the output buffer is performed, this field is loaded to the output buffer address register.   when this field equals to 0x00, each read from the output buffer increments the output buffer address register." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"

group d:0xFFA0102C++0x03
    line.long 0x00 "VD_RSM,Viterbi Decoder Resume Register"
        bitfld.long 0x00 2. " CRC_RESTART               ,the viterbi decoder supports multiple crc calculations over the same block which resides in the output buffer. setting this bit restarts a crc calculation.  the user must reconfigure the crc parameters (init, mask, first and last) before restart of the crc calculation.  the user must clear this bit before setting it again." "0,1"
        bitfld.long 0x00 1. "         RECALCULATE                ,setting this bit starts a viterbi calculation over the existing data block in the input buffer.   perform this sequence between calculations:" "0,1"
        bitfld.long 0x00 0. "     ASPVI_RESUME147  ,setting this bit resumes a continuous-mode calculation (viterbi resumes its calculation from the point it has stopped and according to the new configuration).   to resume another calculation, clear this bit, and then set it. this bit has effect only when viterbi is configured to continuous mode." "0,1"

group d:0xFFA01030++0x03
    line.long 0x00 "VD_IBR,Viterbi Decoder Input Buffer Read Register"
        hexmask.long 0x00 0.--29. 1. " INPUT_BUFFER_READ_DATA    ,this field contains the current word the was read from the input buffer."

group d:0xFFA01034++0x03
    line.long 0x00 "VD_MRLR,Viterbi Decoder Most/Least Reliable State Metric Register"
        hexmask.long.word 0x00 16.--25. 1. " LEAST_RELIABLE            ,this field contains the least reliable state metric value. this is the maximum state metric value for current symbol."
        hexmask.long.word 0x00 0.--9. 1. "      MOST_RELIABLE              ,this field contains the most reliable state metric value."

group d:0xFFA01038++0x03
    line.long 0x00 "VD_MRIDZSM,Viterbi Decoder Most Reliable State Metric Index and State Zero Register"
        hexmask.long.word 0x00 16.--25. 1. " ZERO_STATE_METRIC         ,this field contains the state metric value of state zero."
        hexmask.long.byte 0x00 0.--7. 1. "      MOST_RELIABLE_INDEX        ,this field contains the most reliable index."

group d:0xFFA0103C++0x03
    line.long 0x00 "VD_MDL,Viterbi Decoder Modulo Wrap-Around Results Register"
        hexmask.long.byte 0x00 0.--6. 1. " MODULO                    ,this field contains the modulo counter value."

group d:0xFFA01040++0x03
    line.long 0x00 "VD_CRCR,Viterbi Decoder CRC Result Register"
        hexmask.long 0x00 0.--31. 1. " CRC_RESULT                ,this field contains the crc result. crc result bit ordering is as defined in the crc bit order bit in the control register."

group d:0xFFA01044++0x03
    line.long 0x00 "VD_STATUS,Viterbi Decoder Status Register"
        bitfld.long 0x00 0. " ASPVI_STATUS210           ,1 = viterbi is active  0 = viterbi is idle" "0,1"

group d:0xFFA01080++0x03
    line.long 0x00 "VD_ASPEC_OB_START,Viterbi Decoder Output Buffer on ASPEC Register"
        hexmask.long 0x00 0.--31. 1. " OUTPUT_BUFFER_ON_ASPEC    ,read data from output buffer according to address offset value (0 < offset < 31)."

tree.end

tree "ciu"

width 27.

group d:0xD4282C00++0x03
    line.long 0x00 "CHIP_ID,Chip ID Register"
        hexmask.long.byte 0x00 16.--23. 1. " REV_ID                     ,revision id"
        hexmask.long.word 0x00 0.--15. 1. "        CHIP_ID                   ,chip id"

group d:0xD4282C04++0x03
    line.long 0x00 "CP_CPU_CONF,<var Processor: Comm> CPU Configuration Register"
        bitfld.long 0x00 31. " REMAP_EN                   ,ddr shadow re-map enable  default to set if <var processor: comm> is selected to boot from chip reset. ddr memory shadow is removed if this bit and the corresponding bit from <var processor: ap> is cleared." "0,1"
        bitfld.long 0x00 14. "         SLBTCMSB0                 ,b1tcm selection  1 = use most significant bit of btcm address to select b1tcm  0 = use bit [3] of the btcm address" "0,1"
        bitfld.long 0x00 13. "     NCPUHALT0                 ,processor halt after reset  1 = processor starts fetching instructions from reset vector address in normal way  0 = while the processor is in reset, it stops fetching and executing instructions after coming out of reset" "0,1"
        bitfld.long 0x00 12. "     CFGNMFI0                  ,nonmaskable fi enable  1 = enable nonmaskable fast interrupts  reflected in the nmfi field." "0,1"
        textline "                                     "
        bitfld.long 0x00 11. "LOCZRAMA0                  ,tcm location  1 = indicates atcm initial base address is 0 and btcm base address is defined by implementation  0 = indicates btcm initial base address is 0 and atcm base address is defined by implementation" "0,1"
        bitfld.long 0x00 10. "         INITRAMB0                 ,btcm0 enable  reset value of btcm bit  1 = indicates tightly-coupled memory b, btcm, is enabled at reset" "0,1"
        bitfld.long 0x00 9. "     INITRAMA0                 ,atcm0 enable  reset value of atcm enable bit  1 = indicates tightly-coupled memory a, atcm, is enabled at reset" "0,1"
        bitfld.long 0x00 8. "     VINITHI0                  ,vector init high  if this processor is selected to boot from chip reset, this field gets its value from strap input. otherwise (if this processor is not selected to boot from chip reset):   0 = vector table placed low  1 = vector table placed high (only this option is supported)" "0,1"
        textline "                                     "
        bitfld.long 0x00 6. "CI_TEINIT33                ,reset te-bit value  determines exception handling state at reset  0 = arm  1 = thumb" "0,1"
        bitfld.long 0x00 5. "         CFGIE                     ,instruction side endianness  1 = indicates that big endian instruction fetch is used" "0,1"
        bitfld.long 0x00 4. "     CFGEE                     ,reset ee-bit value  1 = indicates implementation uses be-8 mode for exceptions at reset" "0,1"

group d:0xD4282C08++0x03
    line.long 0x00 "SW_CONFIG,Software Configuration Register"
        bitfld.long 0x00 19.--23. " SW_USE44                   ,sw usage  this field is used by software." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"
        bitfld.long 0x00 18. "        SP_BRANCH                 ,<var processor: secure> branch  this field is used in rom to determine the secure core branch." "0,1"
        bitfld.long 0x00 17. "     SW_USE46                  ,sw usage  this field is used by software." "0,1"

group d:0xD4282C0C++0x03
    line.long 0x00 "CP_CPU_SRAM_SPD,<var Processor: Comm> CPU SRAM Speed Config Register"
        bitfld.long 0x00 30.--31. " ITAG_RTC                   ,l1 i-cache tag sram read timing" "0,1,2,3"
        bitfld.long 0x00 28.--29. "         ITAG_WTC                  ,l1 i-cache tag sram write timing" "0,1,2,3"
        bitfld.long 0x00 26.--27. "     IDATA_RTC                 ,l1 i-cache data read timing" "0,1,2,3"
        bitfld.long 0x00 24.--25. "     IDATA_WTC                 ,l1 i-cache data write timing" "0,1,2,3"
        textline "                                     "
        bitfld.long 0x00 22.--23. "DDIRTY_RTC                 ,l1 d-cache dirty read timing" "0,1,2,3"
        bitfld.long 0x00 20.--21. "         DDIRTY_WTC                ,l1 d-cache dirty write timing" "0,1,2,3"
        bitfld.long 0x00 18.--19. "     DTAG_RTC                  ,l1 d-cache tag sram read timing" "0,1,2,3"
        bitfld.long 0x00 16.--17. "     DTAG_WTC                  ,l1 d-cache tag sram write timing" "0,1,2,3"
        textline "                                     "
        bitfld.long 0x00 14.--15. "DDATA_RTC                  ,l1 d-cache data sram read timing" "0,1,2,3"
        bitfld.long 0x00 12.--13. "         DDATA_WTC                 ,l1 d-cache data sram write timing" "0,1,2,3"
        hexmask.long.word 0x00 0.--11. 1. "     BTCM_RTC                  ,btcm sram read timing"
        bitfld.long 0x00 8.--9. "  BTCM_WTC                  ,btcm sram write timing" "0,1,2,3"
        textline "                                     "
        bitfld.long 0x00 6.--7. "ATCM_RTC                   ,atcm sram read timing" "0,1,2,3"
        bitfld.long 0x00 4.--5. "         ATCM_WTC                  ,atcm sram write timing" "0,1,2,3"
        bitfld.long 0x00 2.--3. "     BTCM_DLY                  ,btcm sram delay cycle  this field defines how many cycles to get read data from the sram after a read request is active. as a result, sram is able to run at a lower frequency compared with the <var processor: comm> core.  0x0 = no delay  0x1 = read data avaliable after 1 pclk cycle of read request  0x2 = read data available after 2 pclk cycles of read request  0x3 = read data avaliable after 3 pclk cycles of read request" "0,1,2,3"
        bitfld.long 0x00 0.--1. "     ATCM_DLY                  ,atcm sram delay cycle  this field defines how many cycles to get read data from the sram after a read request is active. as a result, sram is able to run at a lower frequency compared with the <var processor: comm> core.  0x0 = no delay  0x1 = read data avaliable after 1 pclk cycle of read request  0x2 = read data available after 2 pclk cycles of read request  0x3 = read data avaliable after 3 pclk cycles of read request" "0,1,2,3"

group d:0xD4282C10++0x03
    line.long 0x00 "CR5_PPX_CONF,<var Processor: Comm> AXI Peripheral Interface Configuration Register"
        hexmask.long.tbyte 0x00 12.--31. 1. " PPXBASE0                   ,base address of axi peripheral interface  must be size aligned"
        bitfld.long 0x00 5. "    INITPPX0                  ,axi peripheral interface enable  indicates whether the axi peripheral interface is enabled when out of reset  0x0 = disabled  0x1 = enabled" "0,1"
        bitfld.long 0x00 0.--4. "     PPXSIZE079                ,base address of axi peripheral interface  0x3 = 4 kb  0x4 = 8 kb  0x5 = 16 kb  0x6 = 32 kb  0x7 = 64 kb  0x8 = 128 kb  0x9 = 256 kb  0xa = 512 kb  0xb = 1 mb  0xc = 2 mb    0xd = 4 mb  0xe = 8 mb  0xf = 16 mb  0x10 = 32 mb  0x1 = 64 mb  0x12 = 128 mb  0x13 = 256 mb  0x14 = 512 mb  0x15 = 1 gb  0x16 = 2 gb  0x17 = 4 gb" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"

group d:0xD4282C14++0x03
    line.long 0x00 "CR5_PPV_CONF,<var Processor: Comm> Virtual AXI Peripheral Interface Configuration Register"
        hexmask.long.tbyte 0x00 12.--31. 1. " PPVBASE031:12              ,base address of virtual axi peripheral interface  must be size aligned"
        bitfld.long 0x00 0.--4. "    PPXSIZE088                ,base address of virtual axi peripheral interface  0x3 = 4 kb  0x4 = 8 kb  0x5 = 16 kb  0x6 = 32 kb  0x7 = 64 kb  0x8 = 128 kb  0x9 = 256 kb  0xa = 512 kb  0xb = 1 mb  0xc = 2 mb    0xd = 4 mb  0xe = 8 mb  0xf = 16 mb  0x10 = 32 mb  0x1 = 64 mb  0x12 = 128 mb  0x13 = 256 mb  0x14 = 512 mb  0x15 = 1 gb  0x16 = 2 gb  0x17 = 4 gb" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"

group d:0xD4282C18++0x03
    line.long 0x00 "CP_L2C_ADDR_FILTER_CONF,<var Processor: Comm> L2 Cache Address Filter Config Register"
        bitfld.long 0x00 31. " CP_L2C_FILTER_EN           ,address filter enable  0 = disable  1 = enable" "0,1"
        hexmask.long.word 0x00 16.--27. 1. "         CP_L2C_FILTER_END31:20    ,address filter end address"
        hexmask.long.word 0x00 0.--11. 1. "  CP_L2C_FILTER_START31:20  ,address filter start address"

group d:0xD4282C1C++0x03
    line.long 0x00 "MC_QOS_CTRL,Memory Controller QoS Configuration Register"
        bitfld.long 0x00 31. " SC2_QOS_SEL                ,sc2 to memory controller axi qos select  1 = sc2 qos is controlled by the sc2 module itself  by default, sc2 qos is controlled by the <camera to memory controller axi qos> field" "0,1"
        bitfld.long 0x00 30. "         DC4_QOS_SEL               ,dc4 to memory controller axi qos select   1 = dc4 qos is controlled by the dc4 module itself  by default, dc4 qos is controlled by the <lcd to memory controller axi qos> field" "0,1"
        bitfld.long 0x00 26.--27. "     VPU_AXI_QOS               ,vpu to memory controller axi qos  0x3 = critical  0x2 = high  0x1= low  0x0 = low" "0,1,2,3"
        bitfld.long 0x00 24.--25. "     LCD_AXI_QOS               ,lcd to memory controller axi qos  0x3 = critical  0x2 = high  0x1= low  0x0 = low" "0,1,2,3"
        textline "                                     "
        bitfld.long 0x00 22.--23. "DRAGON_AXI_QOS             ,<var processor: app> to memory controller axi qos  0x3 = critical  0x2 = high  0x1= low  0x0 = low" "0,1,2,3"
        bitfld.long 0x00 20.--21. "         CP_AXI_QOS                ,<var processor: comm> to memory controller axi qos  0x3 = critical  0x2 = high  0x1= low  0x0 = low" "0,1,2,3"
        bitfld.long 0x00 18.--19. "     GC_AXI_QOS                ,2d/3d gpu to memory controller axi qos  0x3 = critical  0x2 = high  0x1= low  0x0 = low" "0,1,2,3"
        bitfld.long 0x00 16.--17. "     ISP_AXI_QOS               ,camera to memory controller axi qos  0x3 = critical  0x2 = high  0x1= low  0x0 = low" "0,1,2,3"
        textline "                                     "
        bitfld.long 0x00 14.--15. "LTEDMA_AXI_QOS             ,ltedma to memory controller axi qos  0x3 = critical  0x2 = high  0x1= low  0x0 = low" "0,1,2,3"
        bitfld.long 0x00 12.--13. "         GNSS_AXI_QOS              ,gnss to memory controller axi qos  0x3 = critical  0x2 = high  0x1= low  0x0 = low" "0,1,2,3"
        bitfld.long 0x00 10.--11. "     WTM_AXI_QOS               ,wtm to memory controller axi qos  0x3 = critical  0x2 = high  0x1= low  0x0 = low" "0,1,2,3"
        bitfld.long 0x00 8.--9. "     USB_DEV_AXI_QOS           ,fabric 2 to memory controller axi qos  0x3 = critical  0x2 = high  0x1= low  0x0 = low" "0,1,2,3"
        textline "                                     "
        bitfld.long 0x00 4.--5. "DTC_AXI_QOS                ,dtc (fabric 1 s5) to memory controller axi qos  0x3 = critical  0x2 = high  0x1= low  0x0 = low" "0,1,2,3"
        bitfld.long 0x00 2.--3. "         DMA_AXI_QOS_S5            ,dma (fabric 1 s5) to memory controller axi qos  0x3 = critical  0x2 = high  0x1= low  0x0 = low" "0,1,2,3"
        bitfld.long 0x00 0.--1. "     MSA_AXI_QOS               ,msa (fabric 1 s5) to memory controller axi qos  0x3 = critical  0x2 = high  0x1= low  0x0 = low" "0,1,2,3"

group d:0xD4282C20++0x03
    line.long 0x00 "SYS_BOOT_CNTRL,System Boot Control Register"
        bitfld.long 0x00 31. " RPMB                       ,rpmb bit (fuse ctrl)" "0,1"
        bitfld.long 0x00 30. "         DOWN_KEY_DIS              ,download key disable bit (fuse ctrl)" "0,1"
        bitfld.long 0x00 28.--29. "     EMMC_CLK_SRC              ,emmc clock source bit (fuse ctrl)" "0,1,2,3"
        bitfld.long 0x00 21. "     EMMC_PHY                  ,emmc phy bypass bit (fuse and strap pin ctrl)" "0,1"
        textline "                                     "
        bitfld.long 0x00 18.--20. "EMMC_DIV                   ,emmc timing divider bits (fuse  ctrl)" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 15.--17. "         TIMER_FREQ                ,timer freq bits (fuse ctrl)" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 14. "     TIMER_MODE                ,timer mode bits(fuse ctrl)" "0,1"
        bitfld.long 0x00 13. "     ENCRYPT_BOOT              ,encrypted boot bit (fuse and strap pin ctrl)" "0,1"
        textline "                                     "
        bitfld.long 0x00 12. "ANTI_ROLLBACK              ,anti roll back bit (fuse and strap pin ctrl)" "0,1"
        bitfld.long 0x00 9.--11. "         BOOTROM_OPER_MODE         ,bootrom operation mode, only controlled by strap pin" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 7.--8. "     DISABLE_DFT_SCAN          ,bit0 disable dft scan, which can be opened by keycertificate, bit1 disable dft scan forever. (fuse ctrl)" "0,1,2,3"
        bitfld.long 0x00 5.--6. "     DISABLE_AP_JTAG           ,bit0 disable ap jtag, which can be opened by keycertificate, bit1 disable ap jtag forever. (fuse and strap pin ctrl)" "0,1,2,3"

group d:0xD4282C24++0x03
    line.long 0x00 "SW_BRANCH_ADDR,Software Branch Address Register"
        hexmask.long 0x00 0.--31. 1. " BRANCH_ADDR                ,branch address  this field is used by software to set the branch address for cpus."

group d:0xD4282C28++0x03
    line.long 0x00 "CP_L2C_CONF,<var Processor: Comm>  L2C Config Register"
        hexmask.long.tbyte 0x00 12.--31. 1. " CP_L2C_REGFILEBASE31:12    ,l2 cache register base address"
        bitfld.long 0x00 1. "    CP_L2C_BEARLYEN           ,l2 cache write early response enable  0 = early write response of <var processor: comm> l2 cache is not alllowed  1 = early write response of <var processor: comm> l2 cache is alllowed (by setting the early bresp enable bit in the auxiliary control register, bit[30])" "0,1"
        bitfld.long 0x00 0. "     CP_L2C_CFGBIGEND          ,l2 cache big endian enable  1 = enable big endian mode for accessing configuration registers out of reset  0 = enable little endian mode for accessing configuration registers out of reset" "0,1"

group d:0xD4282C2C++0x03
    line.long 0x00 "CP_L2C_SRAM_CONF,<var Processor: Comm>  L2C SRAM Timing Configuration Register"
        bitfld.long 0x00 6.--7. " CP_L2C_TAG_RTC             ,l2 cache tag sram read timing" "0,1,2,3"
        bitfld.long 0x00 4.--5. "         CP_L2C_TAG_WTC            ,l2 cache tag sram write timing" "0,1,2,3"
        bitfld.long 0x00 2.--3. "     CP_L2C_DATA_RTC           ,l2 cache data sram read timing" "0,1,2,3"
        bitfld.long 0x00 0.--1. "     CP_L2C_DATA_WTC           ,l2 cache data sram write timing" "0,1,2,3"

group d:0xD4282C34++0x03
    line.long 0x00 "BROM_IPCx0,Boot ROM IPC x Register"

group d:0xD4282C38++0x03
    line.long 0x00 "BROM_IPCx1,Boot ROM IPC x Register"

group d:0xD4282C3C++0x03
    line.long 0x00 "BROM_IPCx2,Boot ROM IPC x Register"
        hexmask.long 0x00 0.--31. 1. " BROM_IPC0                  ,boot rom ipc x  this field stores information for the boot rom."

group d:0xD4282C40++0x03
    line.long 0x00 "MC_CONF,Memory Controller Configuration Register"
        bitfld.long 0x00 31. " DQ_MUX_EN                  ,memory controller dq mux byte order enable" "0,1"
        bitfld.long 0x00 30. "         CAP_FAB_ACLKM0_GATE_EN    ,<var processor: app> fabric m0 port axi clock dynamic gating enable  0 = disable hardware dynamic gating  1 = enable hardware dynamic gating" "0,1"
        bitfld.long 0x00 29. "     CAP_FAB_ACLK_GATE_EN      ,<var processor: app> fabric axi clock dynamic gating enable  0 = disable hardware dynamic gating  1 = enable hardware dynamic gating" "0,1"
        bitfld.long 0x00 27. "     FBRC2_ACLK_GATE_EN        ,fabric2 axi clock dynamic gating enable  0 = disable hardware dynamic gating  1 = enable hardware dynamic gating" "0,1"
        textline "                                     "
        bitfld.long 0x00 26. "FBRC1_ACLK_GATE_EN         ,fabric1 axi clock dynamic gating enable  0 = disable hardware dynamic gating  1 = enable hardware dynamic gating" "0,1"
        bitfld.long 0x00 21. "         CSAP_ACLK_GATE_EN         ,csap fabric axi clock dynamic gating enable  0 = disable hardware dynamic gating  1 = enable hardware dynamic gating" "0,1"
        bitfld.long 0x00 20. "     SP_ACLK_GATE_EN           ,sp fabric axi clock dynamic gating enable  0 = disable hardware dynamic gating  1 = enable hardware dynamic gating" "0,1"
        bitfld.long 0x00 19. "     MC_DCLK_GATE_EN           ,memory controller dclk gating enable  1 = disable hardware dynamic gating  0 = enable hardware dynamic gating" "0,1"
        textline "                                     "
        bitfld.long 0x00 18. "FBRC1_CP_ACLK_GATE_EN      ,fabric1 cp axi clock dynamic gating enable  0 = disable hardware dynamic gating  1 = enable hardware dynamic gating." "0,1"
        bitfld.long 0x00 17. "         FBRC1_AP_ACLK_GATE_EN     ,fabric1 ap axi clock dynamic gating enable  0 = disable hardware dynamic gating  1 = enable hardware dynamic gating" "0,1"
        bitfld.long 0x00 16. "     CP_FAB_ACLK_GATE_EN       ,<var processor: comm> fabric1x2 clock dynamic gating enable  0 = disable hardware dynamic gating  1 = enable hardware dynamic gating" "0,1"
        bitfld.long 0x00 15. "     MC_P7_ACLK_GATE_EN        ,mc p7 axi clock dynamic gating enable  0 = disable hardware dynamic gating  1 = enable hardware dynamic gating" "0,1"
        textline "                                     "
        bitfld.long 0x00 14. "MC_P6_ACLK_GATE_EN         ,mc p6 axi clock dynamic gating enable  0 = disable hardware dynamic gating  1 = enable hardware dynamic gating" "0,1"
        bitfld.long 0x00 13. "         MC_P5_ACLK_GATE_EN        ,mc p5 axi clock dynamic gating enable  0 = disable hardware dynamic gating  1 = enable hardware dynamic gating" "0,1"
        bitfld.long 0x00 12. "     MC_P4_ACLK_GATE_EN        ,mc p4 axi clock dynamic gating enable  0 = disable hardware dynamic gating  1 = enable hardware dynamic gating" "0,1"
        bitfld.long 0x00 11. "     MC_P3_ACLK_GATE_EN        ,mc p3 axi clock dynamic gating enable  0 = disable hardware dynamic gating  1 = enable hardware dynamic gating" "0,1"
        textline "                                     "
        bitfld.long 0x00 10. "MC_P2_ACLK_GATE_EN         ,mc p2 axi clock dynamic gating enable  0 = disable hardware dynamic gating  1 = enable hardware dynamic gating" "0,1"
        bitfld.long 0x00 9. "         MC_P1_ACLK_GATE_EN        ,mc p1 axi clock dynamic gating enable  0 = disable hardware dynamic gating  1 = enable hardware dynamic gating" "0,1"
        bitfld.long 0x00 8. "     MC_P0_ACLK_GATE_EN        ,mc p0 axi clock dynamic gating enable  0 = disable hardware dynamic gating  1 = enable hardware dynamic gating" "0,1"
        bitfld.long 0x00 6. "     MC_PHY_RST_MASK           ,memory controller axi port clock gating disable  1=disable dynamic clock gating, free running aclk  0=enable dynamic clock gating" "0,1"
        textline "                                     "
        bitfld.long 0x00 5. "MC_PHY_DLL_DIS             ,memory controller phy dll disable  this field disables the soc override to the memory controller phy dll." "0,1"
        bitfld.long 0x00 4. "         MC_PHY_PLL_DIS            ,memory controller phy pll disable  this field disables the soc override to the memory controller phy pll." "0,1"
        bitfld.long 0x00 2. "     MC_PDFVSSM                ,memory controller pdfvssm" "0,1"
        bitfld.long 0x00 1. "     MC_PDLVMC                 ,memory controller pdlvmc" "0,1"
        textline "                                     "
        bitfld.long 0x00 0. "MC_PDWN                    ,memory controller pdwn" "0,1"

group d:0xD4282C44++0x03
    line.long 0x00 "TOP_MEM_RTC_WTC_SPD,App Top Memory RTC/WTC Speed Register"
        bitfld.long 0x00 20.--21. " DMA_AXI_MEM_WTC            ,dma axi memory wtc" "0,1,2,3"
        bitfld.long 0x00 16.--17. "         DMA_AXI_MEM_RTC           ,dma axi memory rtc" "0,1,2,3"

group d:0xD4282C4C++0x03
    line.long 0x00 "CS_CONF,CoreSight Configuration Register"
        bitfld.long 0x00 17. " AUDIO_SW_ATRESETN          ,audio software atresetn  0 = software atresetn issued to audio atclk domain logic" "0,1"
        bitfld.long 0x00 16. "         AUDIO_SW_PRESETDBGN       ,audio software presetdbgn  0 = software presetdbgn issued to audio pclkdbg domain logic" "0,1"
        bitfld.long 0x00 14. "     ETF_PDWN                  ,etf sram powerdown parameter  this field defines the pdwn value for etb memory." "0,1"
        bitfld.long 0x00 11.--12. "     ETF_EMAW                  ,etf sram emaw parameter  this field defines the emaw value for etb memory." "0,1,2,3"
        textline "                                     "
        bitfld.long 0x00 8.--10. "ETF_EMA                    ,etf sram ema parameter  this field defines the ema value for etb memory." "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 0.--4. "         TPIUPMAX                  ,tpiu data out bit width  this field defines the data width for tpiu trace data out." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"

group d:0xD4282C50++0x03
    line.long 0x00 "CS_DEBUG_CONF,CoreSight Debug Configuration Register"
        bitfld.long 0x00 20. " DBGEN254                   ,invasive debug enable  0 = not enabled  1 = enabled" "0,1"
        bitfld.long 0x00 19. "         SPIDEN255                 ,secure privileged invasive debug enable  0 = not enabled  1 = enabled" "0,1"
        bitfld.long 0x00 18. "     SPNIDEN256                ,secure non-invasive debug enable  0 = not enabled  1 = enabled" "0,1"
        bitfld.long 0x00 17. "     NIDEN257                  ,non-invasive debug enable  0 = not enabled  1 = enabled" "0,1"
        textline "                                     "
        bitfld.long 0x00 16. "DBGSWENANBLE               ,dbgswenanble  this field is asserted to block system access to the debug register file through the memory-mapped and extended cp14 interfaces." "0,1"
        bitfld.long 0x00 0. "         DAP_APB_SECURE_EN         ,dap secure protection enable  0 = both secure and non-secure apb transaction are able to access dap  1 = only secure apb transaction is able to access dap" "0,1"

group d:0xD4282C58++0x03
    line.long 0x00 "MC_AXI_URGENT,"
        bitfld.long 0x00 16.--19. " DMC_AWURGENT               ,0: awurgent=0, 1: awurgent=1 each bit indicate an axi port of dmc" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 0.--3. "        DMC_ARURGENT              ,0: arurgent=0, 1: arurgent=1 each bit indicate an axi port of dmc be careful of the use of this bit, it would break the arbitration policy in dmc and may make total performance worse" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"

group d:0xD4282C5C++0x03
    line.long 0x00 "SYSSEC_CTRL_1,System Security Control Register 1"
        bitfld.long 0x00 31. " PMU_SEC_EN                 ,pmu secure write enable  when this bit is set, the pmu wtm clk/rst register only can be written by secured <var processor: app> or <var processor: secure>" "0,1"
        bitfld.long 0x00 28. "         I2C8_SEC                  ,i2c8 secure enable" "0,1"
        bitfld.long 0x00 27. "     I2C7_SEC                  ,i2c7 secure enable" "0,1"
        bitfld.long 0x00 26. "     I2C5_SEC                  ,i2c5 secure enable" "0,1"
        textline "                                     "
        bitfld.long 0x00 25. "SSP2_SEC                   ,ssp2 secure enable" "0,1"
        bitfld.long 0x00 24. "         DIS_PREADY_SEL            ,disable pready sel for cp and audio apb (for debug)" "0,1"
        bitfld.long 0x00 23. "     GEC_SEC                   ,genric counter secure enable" "0,1"
        bitfld.long 0x00 22. "     SEL_SSK_AES_KEY           ,select key for aes engine inside bcm (1:ssk key 0:aes key" "0,1"
        textline "                                     "
        bitfld.long 0x00 21. "XM4_SQU_SEC                ,xm4 dtcm (squ) secure" "0,1"
        bitfld.long 0x00 16. "         KEYPAD_SEC                ,keypad secure enable" "0,1"
        bitfld.long 0x00 15. "     I2C3_SEC                  ,i2c3 secure enable" "0,1"
        bitfld.long 0x00 14. "     SEC_RTC_SEC               ,sec rtc (0xd4010400) secure enable" "0,1"
        textline "                                     "
        bitfld.long 0x00 13. "SSP0_SEC                   ,ssp0 secure enable" "0,1"
        bitfld.long 0x00 12. "         NDR_TIMER_SEC             ,pmu ndr timer with watchdog secure enable" "0,1"
        bitfld.long 0x00 11. "     TIMER1_SEC                ,timer1 secure enable" "0,1"
        bitfld.long 0x00 10. "     UART1_SEC                 ,uart1  secure enable" "0,1"
        textline "                                     "
        bitfld.long 0x00 8. "DMA_SEC                    ,dma secure enable" "0,1"
        bitfld.long 0x00 5. "         NONSEC_AP_2_XM4_DIS       ,non-sec ap can't access xm4 registers if this bit is set to 1 (except for xm4 dtcm)" "0,1"
        bitfld.long 0x00 4. "     XM4_2_ISP_DIS             ,xm4 can't access isp if this bit is set to 1" "0,1"
        bitfld.long 0x00 3. "     ISP_2_XM4_DIS             ,isp can't access xm4 if this bit is set to 1" "0,1"
        textline "                                     "
        bitfld.long 0x00 2. "AUDIO_SLAVE_SEC            ,audio system as a slave works in secure mode, only secure master can access audio subsystem" "0,1"
        bitfld.long 0x00 1. "         AUDIO_MASTER_SEC          ,audio system as a axi/apb master works in secure mode" "0,1"
        bitfld.long 0x00 0. "     CP_SEC                    ,<var processor: comm> secure enable" "0,1"

group d:0xD4282C6C++0x03
    line.long 0x00 "SYSSEC_CTRL_2,System Security Control Register 2"
        hexmask.long.word 0x00 16.--31. 1. " DMA_SEC_CH                 ,dma secure channels  each bit in this register corresponds to a bit for each channel when dma is working in secure mode. (dma has 16 channels, and each bit for one channel)  1= related channel is secure  0 = related channel is non-secure"
        bitfld.long 0x00 12.--15. "      FPID_EN                   ,enable fpid for tzc, each bit for one tzc port" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 7. "    FUSE_READ_CLK_EN          ,fuse read clock enable  this field is used to enable the signal for fuse read state machine." "0,1"
        bitfld.long 0x00 4.--6. "     FUSE_READ_CLK_DIV_VAL     ,fuse read clock divider value  the clock divider value is used to select the clock frequency of the fuse serial clock.  0x0 = clock = pm_vctcxo clock /1024  0x1 = clock = pm_vctcxo clock / 512  0x2 = pm_vctcxo clock = pm_vctcxo clock / 256  0x3 = clock = pm_vctcxo clock / 32  0x4 = clock = pm_vctcxo clock / 4  other = clock = pm_vctcxo clock / 8" "0,1,2,3,4,5,6,7"
        textline "                                     "
        bitfld.long 0x00 0. "UP_4G                      ,if ddr device is less than 4g, can set this bit to 1'b0 to map 0x1_0000_0000 to 0x1_ffff_ffff system addr to 0x0000_0000 to 0xffff_ffff in ddr controller side. the default value of this bit is 1'b1 (doesn't remap)" "0,1"

group d:0xD4282C8C++0x03
    line.long 0x00 "MCB_CONFIG2,MCB Configuration 2 Register"
        bitfld.long 0x00 11. " GPU_POSTED_WRSP_EN         ,gpu posted write response enable  1 = 2d/3d gpu can generate posted write transactions to the mcb for faster write response generation  0 = mcb will consider all write transactions from 2d/3d gpu as non-posted" "0,1"
        bitfld.long 0x00 10. "         FABRIC2_S7_POSTED_WRSP_EN ,fabric 2 s7 posted write response enable  1 = fabric2 s7 can generate posted write transactions to the mcb for faster write response generation  0 = mcb will consider all write transactions from fabric2 s7 port as non-posted" "0,1"
        bitfld.long 0x00 9. "     FABRIC1_S5_POSTED_WRSP_EN ,fabric 1 s5 posted write response enable  1 = fabric1 s5 port can generate posted write transactions to the mcb for faster write response generation  0 = mcb will consider all write transactions from fabric 1 port s5 as non-posted" "0,1"
        bitfld.long 0x00 8. "     FABRIC1_S0_POSTED_WRSP_EN ,fabric 1 s0 posted write response enable  1 = fabric1 s0 port can generate posted write transactions to the mcb for faster write response generation  0 = mcb will consider all write transactions from fabric 1 port s0 as non-posted" "0,1"
        textline "                                     "
        bitfld.long 0x00 7. "GC_FAST_EN                 ,2d/3d gpu fast enable  when enabled, 2d/3d gpu will access mcb/memory controller fast queue  1 = enable" "0,1"
        bitfld.long 0x00 6. "         FABRIC1_S5_FAST_EN        ,fabric 1 s5 fast enable  when enabled, fabric1 s5 port will access mcb/memory controller fast queue  1 = enable" "0,1"
        bitfld.long 0x00 5. "     FABRIC1_S0_FAST_EN        ,fabric 1 s0 fast enable  when enabled, fabric1 s0 port will access mcb/mc fast queue  1 = enable" "0,1"
        bitfld.long 0x00 4. "     FABRIC2_VPU_FAST_EN       ,fabric 2 vpu fast enable   when enabled, video vpu master on fabric 2 will access mcb/mc fast queue  1 = enable" "0,1"
        textline "                                     "
        bitfld.long 0x00 3. "FABRIC2_USB1_FAST_EN339    ,fabric 2 usb2 fast enable  when enabled, usb2 master on fabric 2 will access mcb/mc fast queue  1 = enable" "0,1"
        bitfld.long 0x00 2. "         FABRIC2_SD_FAST_EN        ,fabric 2 sd fast enable  when enabled, sd master on fabric 2 will access mcb/mc fast queue  1 = enable" "0,1"
        bitfld.long 0x00 1. "     FABRIC2_USB1_FAST_EN341   ,fabric 2 usb1 fast enable  when enabled, usb1 master on fabric 2 will access mcb/mc fast queue  1 = enable" "0,1"
        bitfld.long 0x00 0. "     FABRIC2_IRE_FAST_EN       ,fabric 2 ire fast enable  when enabled, ire master on fabric 2 will access mcb/mc fast queue  1 = enable" "0,1"

group d:0xD4282CA0++0x03
    line.long 0x00 "GPU_COHERENCY_FEATURE,GPU Coherency Feature Control Register"
        bitfld.long 0x00 0.--1. " GPU_COHERENCY_FEATURE      ,gpu coherency feature bit 0: ace-lite support,  bit 1: full ace support" "0,1,2,3"

group d:0xD4282CA4++0x03
    line.long 0x00 "GPU_MEM_XTC,GPU Memory Timing Control Register"
        bitfld.long 0x00 20. " GPU_MEM_PDWN               ,gpu memory powerdown control  1 = pdwn asserted. leave it to set to 0." "0,1"
        bitfld.long 0x00 18.--19. "         GPU_RF2P_FAST_WTC         ,gpu rf2p fast memory wtc  fast memory used" "0,1,2,3"
        bitfld.long 0x00 16.--17. "     GPU_RF2P_FAST_RTC         ,gpu rf2p fast memory rtc  fast memory used" "0,1,2,3"
        bitfld.long 0x00 14.--15. "     GPU_RF2P_GRP2_WTC         ,gpu rf2p_grp_2 memory wtc" "0,1,2,3"
        textline "                                     "
        bitfld.long 0x00 12.--13. "GPU_RF2P_GRP2_RTC          ,gpu rf2p_grp_2 memory rtc" "0,1,2,3"
        bitfld.long 0x00 10.--11. "         GPU_RF2P_GRP1_WTC         ,gpu rf2p_grp_1 memory wtc" "0,1,2,3"
        bitfld.long 0x00 8.--9. "     GPU_RF2P_GRP1_RTC         ,gpu rf2p_grp_1 memory rtc" "0,1,2,3"
        bitfld.long 0x00 6.--7. "     GPU_RF1P_GRP2_WTC         ,gpu rf1p_grp_2 memory wtc" "0,1,2,3"
        textline "                                     "
        bitfld.long 0x00 4.--5. "GPU_RF1P_GRP2_RTC          ,gpu rf1p_grp_2 memory rtc" "0,1,2,3"
        bitfld.long 0x00 2.--3. "         GPU_RF1P_GRP1_WTC         ,gpu rf1p_grp_1 memory wtc" "0,1,2,3"
        bitfld.long 0x00 0.--1. "     GPU_RF1P_GRP1_RTC         ,gpu rf1p_grp_1 memory rtc" "0,1,2,3"

group d:0xD4282CA8++0x03
    line.long 0x00 "VPU_XTC,VPU Memory Timing Control Register"
        bitfld.long 0x00 24. " VPU_ROM_PDWN               ,vpu rom powerdown  1 = pdwn asserted" "0,1"
        bitfld.long 0x00 22.--23. "         VPU_ROM_RTC_REF           ,vpu rom rtc_ref" "0,1,2,3"
        bitfld.long 0x00 19.--21. "     VPU_ROM_RTC               ,vpu rom rtc" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 18. "     VPU_RAM_PDFVSSM           ,vpu memory pdfvssm  leave this field set to 0." "0,1"
        textline "                                     "
        bitfld.long 0x00 17. "VPU_RAM_PDFVMC             ,vpu memory pdfvmc  leave this field set to 0." "0,1"
        bitfld.long 0x00 16. "         VPU_RAM_PDWN              ,vpu memory pdwn  1 = pdwn asserted  leave this field set to 0." "0,1"
        bitfld.long 0x00 14.--15. "     VPU_SR2P_WTC              ,vpu sr2p wtc" "0,1,2,3"
        bitfld.long 0x00 12.--13. "     VPU_SR2P_RTC              ,vpu sr2p rtc" "0,1,2,3"
        textline "                                     "
        bitfld.long 0x00 10.--11. "VPU_SR1P_WTC               ,vpu sr1p wtc" "0,1,2,3"
        bitfld.long 0x00 8.--9. "         VPU_SR1P_RTC              ,vpu sr1p rtc" "0,1,2,3"
        bitfld.long 0x00 6.--7. "     VPU_RF2P_WTC              ,vpu rf2p wtc" "0,1,2,3"
        bitfld.long 0x00 4.--5. "     VPU_RF2P_RTC              ,vpu rf2p rtc" "0,1,2,3"
        textline "                                     "
        bitfld.long 0x00 2.--3. "VPU_RF1P_WTC               ,vpu rf1p wtc" "0,1,2,3"
        bitfld.long 0x00 0.--1. "         VPU_RF1P_RTC              ,vpu rf1p rtc" "0,1,2,3"

group d:0xD4282CAC++0x03
    line.long 0x00 "AUDIO_XTC,Audio Memory Timing Control Register"
        bitfld.long 0x00 30. " AUDIO_DUMMY_CLOCK_SELECT   ,audio dummy clock select  0 = hardware automatically uses the system vctcxo_clk for audio memory dummy clk  1 = software writes the <audio mem dummy clock> field for audio memory dummy clk" "0,1"
        bitfld.long 0x00 27.--29. "         AUDIO_RTC_ROM             ,audio rtc rom" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 25.--26. "     AUDIO_RTC_REF             ,audio rtc ref" "0,1,2,3"
        bitfld.long 0x00 22. "     AUDIO_MEM_CLKGATE_BYPASS  ,audio mem clkgate bypass  1 = bypass the mem clock gate" "0,1"
        textline "                                     "
        bitfld.long 0x00 20.--21. "AUDIO_MEM_DUMMY_CLK        ,audio mem dummy clock  if <audio mem clkgate bypass> is 0 and at the same time <audio dummy clock select> is 1, the following bit sequence must be written before the audio interface will operate" "0,1,2,3"
        bitfld.long 0x00 19. "         AUDIO_MEM_PDWM            ,audio mem powerdown  1 = pdwn asserted  leave this field set to 0" "0,1"
        bitfld.long 0x00 18. "     AUDIO_MEM_PDLVMC          ,audio mem pdlvmc  leave this field set to 0" "0,1"
        bitfld.long 0x00 17. "     AUDIO_MEM_PDFVSSM         ,audio mem pdfvssm  leave this field set to 0" "0,1"
        textline "                                     "
        bitfld.long 0x00 16. "AUDIO_MEM_FWALLBAR         ,audio mem fwallbar" "0,1"
        bitfld.long 0x00 14.--15. "         AUDIO_MEM_RTC_RF1P        ,audio mem rtc rf1p" "0,1,2,3"
        bitfld.long 0x00 12.--13. "     AUDIO_MEM_WTC_RF1P        ,audio mem wtc rf1p" "0,1,2,3"
        bitfld.long 0x00 10.--11. "     AUDIO_MEM_RTC_RF2P        ,audio mem rtc rf2p" "0,1,2,3"
        textline "                                     "
        bitfld.long 0x00 8.--9. "AUDIO_MEM_WTC_RF2P         ,audio mem wtc rf2p" "0,1,2,3"
        bitfld.long 0x00 6.--7. "         AUDIO_MEM_RTC_SR1P        ,audio mem rtc sr1p" "0,1,2,3"
        bitfld.long 0x00 4.--5. "     AUDIO_MEM_WTC_SR1P        ,audio mem wtc sr1p" "0,1,2,3"
        bitfld.long 0x00 2.--3. "     AUDIO_MEM_RTC_SR1PR       ,audio mem rtc sr1pr" "0,1,2,3"
        textline "                                     "
        bitfld.long 0x00 0.--1. "AUDIO_MEM_WTC_SR1PR        ,audio mem wtc sr1pr" "0,1,2,3"

group d:0xD4282CB0++0x03
    line.long 0x00 "CAP_CPU_CONF_ADDR_FILTER,<var Processor: App> CPU Address Filter Config Register"

group d:0xD4282CD0++0x03
    line.long 0x00 "CLUSTER0_COREx_CONF0,<var Processor: App (single)> Cluster 0 Core x Configuration Register"

group d:0xD4282CE0++0x03
    line.long 0x00 "CLUSTER0_COREx_CONF1,<var Processor: App (single)> Cluster 0 Core x Configuration Register"

group d:0xD4282CF0++0x03
    line.long 0x00 "CLUSTER0_COREx_CONF2,<var Processor: App (single)> Cluster 0 Core x Configuration Register"

group d:0xD4282CF8++0x03
    line.long 0x00 "CLUSTER0_COREx_CONF3,<var Processor: App (single)> Cluster 0 Core x Configuration Register"
        bitfld.long 0x00 28. " AARCH64432                 ,boot from aarch64  1= boot from aarch64  0 = boot from aarch32" "0,1"
        bitfld.long 0x00 24. "         DBGEN434                  ,invasive debug enable  0 = disabled  1 = enabled" "0,1"
        bitfld.long 0x00 23. "     NIDEN435                  ,non-invasive debug enable  0 = disabled  1 = enabled" "0,1"
        bitfld.long 0x00 22. "     SPIDEN436                 ,secure privileged invasive debug enable  0 = disabled  1 = enabled" "0,1"
        textline "                                     "
        bitfld.long 0x00 21. "SPNIDEN437                 ,secure privileged non-invasive debug enable  0 = disabled  1 = enabled" "0,1"
        bitfld.long 0x00 19. "         VINITHI439                ,vector init high  if this processor is selected to boot from chip reset, this field gets its value from strap input. otherwise (if this processor is not selected to boot from chip reset):  0 = vector table placed low  1 = vector table placed high (only this option is supported)" "0,1"

group d:0xD4282CD4++0x03
    line.long 0x00 "CLUSTER1_COREx_CONF0,<var Processor: App (single)> Cluster 1 Core x Configuration Register"

group d:0xD4282CE4++0x03
    line.long 0x00 "CLUSTER1_COREx_CONF1,<var Processor: App (single)> Cluster 1 Core x Configuration Register"

group d:0xD4282CF4++0x03
    line.long 0x00 "CLUSTER1_COREx_CONF2,<var Processor: App (single)> Cluster 1 Core x Configuration Register"

group d:0xD4282CFC++0x03
    line.long 0x00 "CLUSTER1_COREx_CONF3,<var Processor: App (single)> Cluster 1 Core x Configuration Register"
        bitfld.long 0x00 28. " AARCH64448                 ,boot from aarch64  1= boot from aarch64  0 = boot from aarch32" "0,1"
        bitfld.long 0x00 24. "         DBGEN450                  ,invasive debug enable  0 = disabled  1 = enabled" "0,1"
        bitfld.long 0x00 23. "     NIDEN451                  ,non-invasive debug enable  0 = disabled  1 = enabled" "0,1"
        bitfld.long 0x00 22. "     SPIDEN452                 ,secure privileged invasive debug enable  0 = disabled  1 = enabled" "0,1"
        textline "                                     "
        bitfld.long 0x00 21. "SPNIDEN453                 ,secure privileged non-invasive debug enable  0 = disabled  1 = enabled" "0,1"
        bitfld.long 0x00 19. "         VINITHI455                ,vector init high  if this processor is selected to boot from chip reset, this field gets its value from strap input. otherwise (if this processor is not selected to boot from chip reset):  0 = vector table placed low  1 = vector table placed high (only this option is supported)" "0,1"

group d:0xD4282CD8++0x03
    line.long 0x00 "CAP_WARM_RESET_VECTOR,<var Processor: App> Warm Reset Vector Register"
        hexmask.long 0x00 0.--31. 1. " CAP_WARM_RESET_VECTOR      ,cap warm reset vector register address  warm reset include <var processor: app> software reset and sleep wakeup reset"

group d:0xD4282CE8++0x03
    line.long 0x00 "SW_SCRATCH,Software Scratch Register"
        hexmask.long 0x00 0.--31. 1. " SW_SCRATCH                 ,software scratch register  this register has no effect on hardware logic"

group d:0xD4282D00++0x03
    line.long 0x00 "VPU_MMU_CKG_CTRL,VPU MMU Clock Gate Control Register"
        hexmask.long 0x00 2.--31. 1. " CI_477                     ,reserved for future use"
        bitfld.long 0x00 1. "  BBLK_GATE_DISABLE         ,bclk gate disable  this field is used to disable the page table walk block dynamic clock gate.  1 = disable dynamic clock gate  0 = clock always on" "0,1"
        bitfld.long 0x00 0. "     CCLK_GATE_DISABLE         ,cclk gate disable  this field is used to disable address translation block dynamic clock gate.  1 = disable dynamic clock gate  0 = clock always on" "0,1"

group d:0xD4282D04++0x03
    line.long 0x00 "VPU_MMU_SEC_CTRL,VPU MMU Security Control Register"
        hexmask.long 0x00 5.--31. 1. " CI_486                     ,reserved for future use"
        bitfld.long 0x00 4. "  VPU_AXI_SEC_SEL           ,vpu axi secure control select  1 = vpu axi secure is controlled by vpu mmu   0 = vpu axi secure is controlled by vpu_sec_axi bit in ciu_reg_5c[3]" "0,1"
        bitfld.long 0x00 3. "     CI_488                    ,reserved for future use" "0,1"
        bitfld.long 0x00 2. "     SPNIDEN489                ,security event control  this field is used to secure event counting by the performance monitors.  1 = enable  0 = disable" "0,1"
        textline "                                     "
        bitfld.long 0x00 1. "RSB_NS_S                   ,read security range disable  1 = all reads are non-secure write  0 = all reads in read security range are secure reads. all reads in security range are not translated." "0,1"
        bitfld.long 0x00 0. "         WSB_NS_S                  ,write security range disable  1 = all writes are non-secure write  0 = all writes in write security range are security writes. all writes in security range are not translated." "0,1"

group d:0xD4282D08++0x03
    line.long 0x00 "VPU_MMU_SEC_RSA,VPU MMU Security Read Start Address Register"
        hexmask.long.tbyte 0x00 12.--31. 1. " RSB_ST_ADDR                ,read security range start address"

group d:0xD4282D0C++0x03
    line.long 0x00 "VPU_MMU_SEC_REA,VPU MMU Security Read End Address Register"
        hexmask.long.tbyte 0x00 12.--31. 1. " RSB_END_ADDR               ,read security range end address"

group d:0xD4282D10++0x03
    line.long 0x00 "VPU_MMU_SEC_WSA,VPU MMU Security Write Start Address Register"
        hexmask.long.tbyte 0x00 12.--31. 1. " WSB_ST_ADDR                ,write security range start address"

group d:0xD4282D14++0x03
    line.long 0x00 "VPU_MMU_SEC_WEA,VPU MMU Security Write End Address Register"
        hexmask.long.tbyte 0x00 12.--31. 1. " WSB_END_ADDR               ,write security range end address"

group d:0xD4282D18++0x03
    line.long 0x00 "FBRC_QOS_CTRL1,AXI Fabric QoS Control 1 Register"
        bitfld.long 0x00 28.--31. " F1_M3_AR_QOS               ,fabric1 master3 read channel qos value" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 24.--27. "        F1_M3_AW_QOS              ,fabric1 master3 write channel qos value" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 20.--23. "    F1_M2_AR_QOS              ,fabric1 master2 read channel qos value" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 16.--19. "    F1_M2_AW_QOS              ,fabric1 master2 write channel qos value" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        textline "                                     "
        bitfld.long 0x00 12.--15. "F1_M1_AR_QOS               ,fabric1 master1 read channel qos value" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 8.--11. "        F1_M1_AW_QOS              ,fabric1 master1 write channel qos value" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 4.--7. "    F1_M0_AR_QOS              ,fabric1 master0 read channel qos value" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 0.--3. "    F1_M0_AW_QOS              ,fabric1 master0 write channel qos value" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"

group d:0xD4282D1C++0x03
    line.long 0x00 "FBRC_QOS_CTRL2,AXI Fabric QoS Control 2 Register"
        bitfld.long 0x00 20.--23. " F1_M6_AR_QOS               ,fabric1 master6 read channel qos value" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 16.--19. "        F1_M6_AW_QOS              ,fabric1 master6 write channel qos value" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 12.--15. "    F1_M5_AR_QOS              ,fabric1 master5 read channel qos value" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 8.--11. "    F1_M5_AW_QOS              ,fabric1 master5 write channel qos value" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        textline "                                     "
        bitfld.long 0x00 4.--7. "F1_M4_AR_QOS               ,fabric1 master4 read channel qos value" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 0.--3. "        F1_M4_AW_QOS              ,fabric1 master4 write channel qos value" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"

group d:0xD4282D20++0x03
    line.long 0x00 "FBRC_QOS_CTRL3,AXI Fabric QoS Control 3 Register"
        bitfld.long 0x00 28.--31. " F2_M3_AR_QOS               ,fabric2 master3 read channel qos value" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 24.--27. "        F2_M3_AW_QOS              ,fabric2 master3 write channel qos value" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 20.--23. "    LTE_AW_QOS                ,lte write channel qos value" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 16.--19. "    LTE_AR_QOS                ,lte read channel qos value" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        textline "                                     "
        bitfld.long 0x00 12.--15. "AUDIO_AW_QOS               ,audio write channel qos value" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 8.--11. "        AUDIO_AR_QOS              ,audio read channel qos value" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 4.--7. "    CP_AW_QOS                 ,cp write channel qos value" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 0.--3. "    CP_AR_QOS                 ,cp read channel qos value" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"

group d:0xD4282D24++0x03
    line.long 0x00 "FBRC_QOS_CTRL4,AXI Fabric QoS Control4 Register"
        bitfld.long 0x00 20.--23. " VPU_AW_QOS                 ,vpu write channel qos value" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 16.--19. "        VPU_AR_QOS                ,vpu read channel qos value" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 12.--15. "    GNSS_AW_QOS               ,gnss write channel qos value. does not support dynamic changing, please init this value before transaction" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 8.--11. "    GNSS_AR_QOS               ,gnss read channel qos value. does not support dynamic changing, please init this value before transaction" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        textline "                                     "
        bitfld.long 0x00 4.--7. "FABRIC1_AW_QOS             ,fabric1 write channel qos value" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 0.--3. "        FABRIC1_AR_QOS            ,fabric1 read channel qos value" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"

group d:0xD4282D28++0x03
    line.long 0x00 "APDMA_XTC,AP DMA Memory Timing Control Register"
        bitfld.long 0x00 11. " APDMA_DUMMY_CLOCK_SELECT   ,ap dma dummy clock select  0 = hardware automatically uses the system vctcxo_clk for ap dma memory dummy clk  1 = software writes the <ap dma mem dummy clock> field for ap dma memory dummy clk" "0,1"
        bitfld.long 0x00 10. "         APDMA_MEM_CLKGATE_BYPASS  ,ap dma mem clkgate bypass  1 = bypass the mem clock gate" "0,1"
        bitfld.long 0x00 8.--9. "     APDMA_MEM_DUMMY_CLK       ,ap dma mem dummy clock  if <ap dma mem clkgate bypass> is 0 and at the same time <ap dma dummy clock select> is 1, the following bit sequence must be written before the audio interface will operate" "0,1,2,3"
        bitfld.long 0x00 7. "     APDMA_MEM_PDWM            ,ap dma mem powerdown  1 = pdwn asserted  leave this field set to 0" "0,1"
        textline "                                     "
        bitfld.long 0x00 6. "APDMA_MEM_PDLVMC           ,ap dma mem pdlvmc  leave this field set to 0" "0,1"
        bitfld.long 0x00 5. "         APDMA_MEM_PDFVSSM         ,apdma mem pdfvssm  leave this field set to 0" "0,1"
        bitfld.long 0x00 4. "     APDMA_MEM_FWALLBAR        ,ap dma mem fwallbar" "0,1"
        bitfld.long 0x00 2.--3. "     APDMA_MEM_RTC_RF2P        ,ap dma mem rtc rf2p" "0,1,2,3"
        textline "                                     "
        bitfld.long 0x00 0.--1. "APDMA_MEM_WTC_RF2P         ,ap dma mem wtc rf2p" "0,1,2,3"

group d:0xD4282D2C++0x03
    line.long 0x00 "LCD_SMMU_CFG,LCD SMMU Config"
        bitfld.long 0x00 4. " LCD_PARALLEL_IF_EN         ,lcd parallel interface enable   0 = disable<1> = enable" "0,1"
        bitfld.long 0x00 3. "         LCD_SMMU_INTEG_OVERRIDE   ,lcd smmu integ second override   0 = disable<1>1 = enable" "0,1"
        bitfld.long 0x00 2. "     LCD_SMMU_CFG_NORMAL       ,lcd smmu cfg normalize   0 = disable<1>1 = enable" "0,1"
        bitfld.long 0x00 1. "     LCD_SMMU_CFG_CTTW         ,lcd smmu cfg cttw   0 = disable<1>1 = enable" "0,1"
        textline "                                     "
        bitfld.long 0x00 0. "LCD_SMMU_SPNIDEN           ,lcd smmu spniden   0 = disable<1>1 = enable" "0,1"

group d:0xD4282D30++0x03
    line.long 0x00 "LCD_MEM_EMA,LCD Memory Extra Margin Adjustment"
        bitfld.long 0x00 31. " RET1N_DISABLE              ,ret1n disable   1 = diable   0 = enable" "0,1"
        bitfld.long 0x00 30. "         SRDP_EMASB621             ,srdp emasb" "0,1"
        bitfld.long 0x00 28.--29. "     SRDP_EMAWB622             ,srdp emawb" "0,1,2,3"
        bitfld.long 0x00 25.--27. "     SRDP_EMAB623              ,srdp emab" "0,1,2,3,4,5,6,7"
        textline "                                     "
        bitfld.long 0x00 24. "SRDP_EMASA624              ,srdp emasa" "0,1"
        bitfld.long 0x00 22.--23. "         SRDP_EMAWA625             ,srdp emawa" "0,1,2,3"
        bitfld.long 0x00 19.--21. "     SRDP_EMAA626              ,srdp emaa" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 18. "     SR1P_EMAS627              ,sr1p emas" "0,1"
        textline "                                     "
        bitfld.long 0x00 16.--17. "SR1P_EMAW628               ,sr1p emaw" "0,1,2,3"
        bitfld.long 0x00 13.--15. "         SR1P_EMA629               ,sr1p ema" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 12. "     RF2P_EMASA630             ,rf2p emasa" "0,1"
        bitfld.long 0x00 9.--11. "     RF2P_EMAB631              ,rf2p emab" "0,1,2,3,4,5,6,7"
        textline "                                     "
        bitfld.long 0x00 6.--8. "RF2P_EMAA632               ,rf2p emaa" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 5. "         RF1P_EMAS633              ,rf1p emas" "0,1"
        bitfld.long 0x00 3.--4. "     RF1P_EMAW634              ,rf1p emaw" "0,1,2,3"
        bitfld.long 0x00 0.--2. "     RF1P_EMA635               ,rf1p ema" "0,1,2,3,4,5,6,7"

group d:0xD4282D34++0x03
    line.long 0x00 "USB_OTG_MEM_EMA,USB OTG Memory Extra Margin Adjustment"
        bitfld.long 0x00 30. " SRDP_EMASB643              ,srdp emasb" "0,1"
        bitfld.long 0x00 28.--29. "         SRDP_EMAWB644             ,srdp emawb" "0,1,2,3"
        bitfld.long 0x00 25.--27. "     SRDP_EMAB645              ,srdp emab" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 24. "     SRDP_EMASA646             ,srdp emasa" "0,1"
        textline "                                     "
        bitfld.long 0x00 22.--23. "SRDP_EMAWA647              ,srdp emawa" "0,1,2,3"
        bitfld.long 0x00 19.--21. "         SRDP_EMAA648              ,srdp emaa" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 18. "     SR1P_EMAS649              ,sr1p emas" "0,1"
        bitfld.long 0x00 16.--17. "     SR1P_EMAW650              ,sr1p emaw" "0,1,2,3"
        textline "                                     "
        bitfld.long 0x00 13.--15. "SR1P_EMA651                ,sr1p ema" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 12. "         RF2P_EMASA652             ,rf2p emasa" "0,1"
        bitfld.long 0x00 9.--11. "     RF2P_EMAB653              ,rf2p emab" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 6.--8. "     RF2P_EMAA654              ,rf2p emaa" "0,1,2,3,4,5,6,7"
        textline "                                     "
        bitfld.long 0x00 5. "RF1P_EMAS655               ,rf1p emas" "0,1"
        bitfld.long 0x00 3.--4. "         RF1P_EMAW656              ,rf1p emaw" "0,1,2,3"
        bitfld.long 0x00 0.--2. "     RF1P_EMA657               ,rf1p ema" "0,1,2,3,4,5,6,7"

group d:0xD4282D40++0x03
    line.long 0x00 "SEC_ONETIME_PROG,Secure OneTime Program Register"
        bitfld.long 0x00 31. " ONE_PROG                   ,if this bit is 1, it mean this register has been written and can't be changed." "0,1"
        bitfld.long 0x00 4. "         DFT_JTAG_EN               ,enable dft scan jtag chain if fuse disable dft scan bit 0 is set." "0,1"
        bitfld.long 0x00 2. "     NORMAL_JTAG_EN            ,enable normal ap jtag if fuse disable jtag bit 0 is set." "0,1"
        bitfld.long 0x00 1. "     SEC_JTAG_EN               ,enable secure ap jtag if fuse disable jtag bit 0 is set." "0,1"
        textline "                                     "
        bitfld.long 0x00 0. "JTAG_EN                    ,enable ap jtag if fuse disable jtag bit 0 is set." "0,1"

group d:0xD4282D44++0x03
    line.long 0x00 "DDRC_MEM_EMA,DDRC MEM EMA CFG Register"
        hexmask.long 0x00 0.--31. 1. " DDRC_MEM_EMA               ,ddrc mem ema configuration"

group d:0xD4282D48++0x03
    line.long 0x00 "BCM_MEM_EMA,BCM MEM EMA CFG Register"
        hexmask.long 0x00 0.--31. 1. " BCM_MEM_EMA                ,bcm mem ema configuration"

group d:0xD4282D4C++0x03
    line.long 0x00 "DMA_MEM_EMA,DMA MEM EMA CFG Register"
        hexmask.long 0x00 0.--31. 1. " DMA_MEM_EMA                ,dma mem ema configuration"

group d:0xD4282D50++0x03
    line.long 0x00 "NSAID_SETTING,NSAID Setting Register"
        bitfld.long 0x00 8.--11. " XM4_NSAID                  ,nsaid value for ceva xm4 module" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 4.--7. "        ISP_NSAID                 ,nsaid value for isp module" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 0.--3. "    GPU_NSAID                 ,nsaid value for gpu module" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"

group d:0xD4282D54++0x03
    line.long 0x00 "GPIO_SEC_0,GPIO Secure Register 0"
        hexmask.long 0x00 0.--31. 1. " GPIO_SEC_0                 ,gpio secure bits [31:0]  one bit for each gpio. when related bit is set, the corresponding gpio port is in secure mode."

group d:0xD4282D58++0x03
    line.long 0x00 "GPIO_SEC_1,GPIO Secure Register 1"
        hexmask.long 0x00 0.--31. 1. " GPIO_SEC_1                 ,gpio secure bits [63:32]  one bit for each gpio. when related bit is set, the corresponding gpio port is in secure mode."

group d:0xD4282D5C++0x03
    line.long 0x00 "GPIO_SEC_2,GPIO Secure Register 2"
        hexmask.long 0x00 0.--31. 1. " GPIO_SEC_2                 ,gpio secure bits [95:64]  one bit for each gpio. when related bit is set, the corresponding gpio port is in secure mode."

group d:0xD4282D60++0x03
    line.long 0x00 "GPIO_SEC_3,GPIO Secure Register 3"
        hexmask.long 0x00 0.--31. 1. " GPIO_SEC_3                 ,gpio secure bits [127:96]  one bit for each gpio. when related bit is set, the corresponding gpio port is in secure mode."

group d:0xD4282D64++0x03
    line.long 0x00 "CPU_ETB_SET,CPU ETB Memory Setup Register"
        hexmask.long 0x00 0.--31. 1. " CI_736                     ,cpu etb memory setup"

group d:0xD4282D68++0x03
    line.long 0x00 "GNSS_CODE_INIT,GNSS Code Initialization Register"
        bitfld.long 0x00 1. " GNSS_CODE_INIT_RDY         ,gnss ready for code initialization  1 = ready   0 = not ready" "0,1"
        bitfld.long 0x00 0. "         GNSS_CODE_INIT_DONE       ,gnss code initialization complete  1 = complete   0 = not complete" "0,1"

group d:0xD4282D6C++0x03
    line.long 0x00 "GNSS_SQU_START_ADDR,GNSS SQU Start Address Register"
        hexmask.long.tbyte 0x00 13.--31. 1. " GNSS_SQU_SA                ,gnss squ start address  this field is the start address of squ area pre-allocated for gnss m3 use.  the pre-allocated area must be 8 kb-aligned, and the lower 13-bit must be ignored. if the end address is equal to the start address, the 8 kb starting from the start address is allocated for gnss m3 use."

group d:0xD4282D70++0x03
    line.long 0x00 "GNSS_SQU_END_ADDR,GNSS SQU End Address Register"
        hexmask.long.tbyte 0x00 13.--31. 1. " GNSS_SQU_EA                ,gnss squ end address  this field is the end address of squ area pre-allocated for gnss m3 use.   the pre-allocated area must be 8 kb-aligned, and the lower 13-bit must be ignored. if the end address is equal to the start address, the 8 kb starting from the start address is allocated for gnss m3 use."

group d:0xD4282D74++0x03
    line.long 0x00 "GNSS_DDR_START_ADDR,GNSS DDR Start Address Register"
        hexmask.long.byte 0x00 24.--31. 1. " GNSS_DDR_SA                ,gnss ddr start address  this field is the start address of ddr area pre-allocated for gnss m3 use.   the pre-allocated area must be 16 mb-aligned, and the lower 24-bit must be ignored. if the end address is equal to the start address, the 16 mb starting from the start address is allocated for gnss m3 use."

group d:0xD4282D78++0x03
    line.long 0x00 "GNSS_DDR_END_ADDR,GNSS DDR End Address Register"
        hexmask.long.byte 0x00 24.--31. 1. " GNSS_DDR_EA                ,gnss ddr end address  this field is the end address of ddr area pre-allocated for gnss m3 use.  the pre-allocated area must be 16 mb-aligned, and the lower 24-bit must be ignored. if the end address is equal to the start address, the 16mb starting from the start address is allocated for gnss m3 use."

group d:0xD4282D7C++0x03
    line.long 0x00 "GNSS_DMA_DDR_START_ADDR,GNSS DMA DDR Start Address Register"
        hexmask.long.byte 0x00 24.--31. 1. " GNSS_DMA_DDR_SA            ,gnss dma ddr start address  this field is the start address of ddr area pre-allocated for gnss dma use.  the pre-allocated area must be 16 mb-aligned, and the lower 24-bit must be ignored. if the end address is equal to the start address, the 16 mb starting from the start address is allocated for gnss dma use."

group d:0xD4282D80++0x03
    line.long 0x00 "GNSS_DMA_DDR_END_ADDR,GNSS DDR End Address Register"
        hexmask.long.byte 0x00 24.--31. 1. " GNSS_DMA_DDR_EA            ,gnss dma ddr end address  this field is the end address of ddr area pre-allocated for gnss dma use.  the pre-allocated area must be 16 mb-aligned, and the lower 24-bit must be ignored. if the end address is equal to the start address, the 16 mb starting from the start address is allocated for gnss dma use."

group d:0xD4282D84++0x03
    line.long 0x00 "GNSS_IRQ,GNSS IRQ Register"
        bitfld.long 0x00 1. " GNSS_IRQ_OUT_ST            ,gnss module interrupt request status  1 = gnss interrupt is pending  0 = no gnss interrupt is pending" "0,1"
        bitfld.long 0x00 0. "         GNSS_IRQ_CLR              ,application processor acknowledges interrupt from gnss  it can only be asserted when the interrupt from gnss is active. it is cleared by hardware when gnss get an acknowledge from the application processor and de-asserts the interrupt.  1 = application processor gets interrupt and is about to clear it  0 = no handshake" "0,1"

group d:0xD4282D88++0x03
    line.long 0x00 "GNSS_WAKEUP,GNSS Wakeup Register"
        bitfld.long 0x00 0. " AP_GNSS_WAKEUP             ,application processor sends wake-up event to gnss   it will be cleared by hardware when gnss acknowledges the event.  1= wake-up event generated  0 = wake-up event not generated" "0,1"

group d:0xD4282D98++0x03
    line.long 0x00 "MC_ADDR_HASH_EN,Address hash for DDR channel enable Register"
        hexmask.long.byte 0x00 8.--15. 1. " ADDR_HASH_EN               ,for addr_hash control corespond to addr[14:7], addr[6] is always select for xor default is ddr_addr[6]= addr[6] ^ addr[7] ^ addr[8] ^ addr[11] ^ addr[13]"
        hexmask.long.byte 0x00 0.--7. 1. "        HASH_EN                   ,bit0 0: hash disable, 1: hash enable"

group d:0xD4282DB0++0x03
    line.long 0x00 "RST_VEC_BASE_ADDRESS,<var Processor: App> AARCH64 Reset Vector Base Address"
        hexmask.long 0x00 2.--31. 1. " RVBARADDR                  ,reset vector base address  this is used for executing in 64-bit state. this pin is sampled only during reset of the <var processor: app>."

group d:0xD4282DB4++0x03
    line.long 0x00 "RST_VEC_BASE_ADDRESS_HIGH,<var Processor: App> AARCH64 Reset Vector Base Address High"
        hexmask.long.byte 0x00 0.--7. 1. " RVBARADDRH0                ,core 0 reset vector base address  high 8-bits for executing in 64-bit state  this pin is sampled only during reset of the <var processor: app>."

group d:0xD4282DB8++0x03
    line.long 0x00 "CLUSTERxBOOT_STATE0,<var Processor: App (single)> Cluster x Boot State Register"

group d:0xD4282DBC++0x03
    line.long 0x00 "CLUSTERxBOOT_STATE1,<var Processor: App (single)> Cluster x Boot State Register"

group d:0xD4282DCC++0x03
    line.long 0x00 "CLUSTERxBOOT_STATE2,<var Processor: App (single)> Cluster x Boot State Register"
        bitfld.long 0x00 6. " DVMENABLE                  ,dvm messabe enable  1=enable  0=disable" "0,1"
        bitfld.long 0x00 5. "         QOSOVERRIDE               ,cci qos override  1 = internally-generated values override the arqos and awqos inputs" "0,1"
        bitfld.long 0x00 4. "     ACCHANNELEN               ,cci ac request enable  0 = ac requests are never issued on the corresponding cci slave interface" "0,1"
        bitfld.long 0x00 3. "     SYSBARDISABLE             ,disable broadcasting of barriers onto system bus  0 = barriers are broadcast onto system bus  1 = barriers are not broadcast onto the system bus.  this pin is sampled only during reset of the cortex-a53 processor." "0,1"
        textline "                                     "
        bitfld.long 0x00 2. "BROADCASTOUTER             ,enable broadcasting of outer shareable transactions  0 = outer shareable transactions are not broadcast externally  1 = outer shareable transactions are broadcast externally  this pin is sampled only during reset of <var processor: app>." "0,1"
        bitfld.long 0x00 1. "         BROADCASTINNER            ,enable broadcasting of inner shareable transactions  0 = inner shareable transactions are not broadcast externally  1 = inner shareable transactions are broadcast externally  if broadcastinner is tied high, broadcastouter must also be tied high.  this pin is sampled only during reset." "0,1"
        bitfld.long 0x00 0. "     BROADCASTCACHEMAINT       ,enable broadcasting of cache maintenance operations to downstream caches  0 = cache maintenance operations are not broadcast to downstream caches  1 = cache maintenance operations are broadcast to downstream caches  this pin is sampled only during reset." "0,1"

group d:0xD4282DD0++0x03
    line.long 0x00 "CLUSTER2_COREx_CONF0,<var Processor: App (single)> Cluster 2 Core x Configuration Register"

group d:0xD4282DD4++0x03
    line.long 0x00 "CLUSTER2_COREx_CONF1,<var Processor: App (single)> Cluster 2 Core x Configuration Register"

group d:0xD4282DD8++0x03
    line.long 0x00 "CLUSTER2_COREx_CONF2,<var Processor: App (single)> Cluster 2 Core x Configuration Register"

group d:0xD4282DDC++0x03
    line.long 0x00 "CLUSTER2_COREx_CONF3,<var Processor: App (single)> Cluster 2 Core x Configuration Register"
        bitfld.long 0x00 28. " AARCH64884                 ,boot from aarch64  1= boot from aarch64  0 = boot from aarch32" "0,1"
        bitfld.long 0x00 24. "         DBGEN886                  ,invasive debug enable  0 = disabled  1 = enabled" "0,1"
        bitfld.long 0x00 23. "     NIDEN887                  ,non-invasive debug enable  0 = disabled  1 = enabled" "0,1"
        bitfld.long 0x00 22. "     SPIDEN888                 ,secure privileged invasive debug enable  0 = disabled  1 = enabled" "0,1"
        textline "                                     "
        bitfld.long 0x00 21. "SPNIDEN889                 ,secure privileged non-invasive debug enable  0 = disabled  1 = enabled" "0,1"
        bitfld.long 0x00 19. "         VINITHI891                ,vector init high  if this processor is selected to boot from chip reset, this field gets its value from strap input. otherwise (if this processor is not selected to boot from chip reset):  0 = vector table placed low  1 = vector table placed high (only this option is supported)" "0,1"

group d:0xD4282DF8++0x03
    line.long 0x00 "CLUSTER2_COREx_CONF,<var Processor: App (single)> Cluster 2 Core x Configuration Register"
        bitfld.long 0x00 0. " ISP_AP_HARDMUX_CTRL        , [0] =0x0, ap to xm4 edap  [0] =0x1, isp to xm4 edap" "0,1"

group d:0xD4282E30++0x03
    line.long 0x00 "FAB_TIMEOUT_CTRL,AXI Fabric Timeout Control Register"
        bitfld.long 0x00 31. " CI_AUTORESP_TYPE907        ,timeout auto response type  0 = auto response type is slverr  1 = auto response type is okay" "0,1"
        bitfld.long 0x00 30. "         CI_AUTORESP_EN908         ,timeout auto response enable  0 = disable auto response when fabric timeout happens  1 = enable auto response when fabric timeout happens" "0,1"
        bitfld.long 0x00 29. "     CI_TIMEOUT_INT_MSK910     ,timeout interrupt mask  0 = interrupt is not masked  1 = interrupt is masked" "0,1"
        bitfld.long 0x00 28. "     CI_FAB_MON_RST913         ,fabric monitor reset  0 = reset fabric monitor  1 = release fabric monitor" "0,1"
        textline "                                     "
        bitfld.long 0x00 27. "CI_FAB_MON_CLR914          ,clear the information saved when last time timeout occurs  0 = the relevant registers are kept   1 = the relevant registers are cleared" "0,1"
        hexmask.long.word 0x00 0.--15. 1. "         CI_TIMEOUT_VAL916         ,axi fabric timeout value  this field indicates the timeout value for axi fabric. the unit of measure is one axi clock cycle."

group d:0xD4282E34++0x03
    line.long 0x00 "STATE_HOLD_CTRL,State Hold Ctrl Register"
        bitfld.long 0x00 0. " CI_STATE_HOLD_CTRL926      ,controlling bit of holding the registers' contents after functional reset.   0 = the registers will not update the status in real time and the values in the registers are not valid.    1 = the registers will be updated to the read state in time. once reset is asserted, the state_hold_ctrl[0] will be cleared and the registers will hold the values just before reset." "0,1"

group d:0xD4282E38++0x03
    line.long 0x00 "FAB_TIMEOUT_ID_RT,Real Time AXI Fabric Timeout Transaction ID Register"
        bitfld.long 0x00 31. " WR_TIMEOUT_IND934          ,write timeout indicator  0 = no write request timeout  1 = write request timeout happens" "0,1"
        hexmask.long.byte 0x00 16.--21. 1. "         TIMEOUT_TX_WID936         ,the wid of write transaction which causes first timeout event. it is only valid when bit[31], wr_timeout_ind is asserted"
        bitfld.long 0x00 15. "    RD_TIMEOUT_IND937         ,read timeout indicator  0 = no read request timeout  1 = read request timeout happens" "0,1"
        hexmask.long.byte 0x00 0.--5. 1. "     TIMEOUT_TX_RID939         ,the rid of read transaction which causes first timeout event. it is only valid when bit[15], rd_timeout_ind is asserted"

group d:0xD4282E3C++0x03
    line.long 0x00 "FAB_TIMEOUT_STATUS0_RT,Real Time AXI Fabric Timeout Status0 Register"
        hexmask.long 0x00 2.--31. 1. " TIMEOUT_WADDR947           ,the write address being accessing which has caused the first write timeout event."
        bitfld.long 0x00 0. "  WR_TIMEOUT_IND949         ,write timeout indicator  0 = no write request timeout  1 = write request timeout happens" "0,1"

group d:0xD4282E40++0x03
    line.long 0x00 "FAB_TIMEOUT_STATUS1_RT,Real Time AXI Fabric Timeout Status1 Register"
        hexmask.long 0x00 2.--31. 1. " TIMEOUT_RADDR957           ,the read address being accessing which has caused the first write timeout event."
        bitfld.long 0x00 0. "  RD_TIMEOUT_IND959         ,read timeout indicator  0 = no read request timeout  1 = read request timeout happens" "0,1"

group d:0xD4282E44++0x03
    line.long 0x00 "DVC_STATUS_RT,Real Time DVC Status Register"
        bitfld.long 0x00 24.--27. " CAUSE968                   ,dvc cause  this field is the cause of the current ongoing dvc. it is only valid when the <voltage change status> field is 1.   0x1 = ap software-triggered dvc  0x2 = cp software- triggered dvc   0x4 = msa software- triggered dvc    0x8 = hw-dfc triggered dvc    others = lpm entry/exit trigger dvc" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 16.--19. "        TVL970                    ,target voltage level of vcc_main" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 8.--11. "    CVL972                    ,current voltage level of vcc_main" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 0. "    DVC_STATUS974             ,voltage change status  the voltage change may be triggered in active state or entering low power mode.  0 = there is no voltage change or a voltage change has finished  1 = voltage change is in progress" "0,1"

group d:0xD4282E48++0x03
    line.long 0x00 "DFC_STATUS_RT,Real Time DCLK Hardware FC Status Register"
        bitfld.long 0x00 15.--18. " DFC_CAUSE983               ,dclk dfc cause  this field is the cause of the current ongoing dfc. it is only valid when the <dclk_dfc_status> field is 1.  0x1 = <var processor: application mp> triggered dfc  0x2 = <var processor: comm> triggered dfc in active mode  0x4 = msa trigged dfc in active mode    0x8 = rsvd    others = low power mode entry/exit triggered dfc" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        hexmask.long.byte 0x00 8.--14. 1. "        TFL984                    ,target freq level of dclk"
        hexmask.long.byte 0x00 1.--7. 1. "    CFL985                    ,current freq level of dclk"
        bitfld.long 0x00 0. "    DFC_STATUS986             ,dclk dfc status  the dclk dfc may be triggered in active state or <var processor: seagull/msa> entering low power mode.  0 = there is no dfc or dfc has finished  1 = dfc is in progress" "0,1"

group d:0xD4282E4C++0x03
    line.long 0x00 "FC_DONE_STATUS_RT,Real Time FC Done Status Register"
        bitfld.long 0x00 10. " GIC500_ECC_FATAL_ERROR995  ,gic500 ecc fatal error" "0,1"
        bitfld.long 0x00 9. "         AP_C2_FC_DONE996          ,ap c2 fc done indicator" "0,1"
        bitfld.long 0x00 8. "     AP_C1_FC_DONE997          ,ap c1 fc done indicator" "0,1"
        bitfld.long 0x00 6. "     AP_C0_FC_DONE999          ,ap c0 fc done indicator" "0,1"
        textline "                                     "
        bitfld.long 0x00 5. "DCLK_FC_DONE1000           ,dclk fc done indicator" "0,1"
        bitfld.long 0x00 4. "         ACLK_FC_DONE1001          ,aclk fc done indicator" "0,1"
        bitfld.long 0x00 0.--3. "     DFC_STATE1002             ,apmu dfc fsm state" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"

group d:0xD4282E50++0x03
    line.long 0x00 "SPAPDPCP_PM_STATE_REG_RT,Real Time SPAPDPCP PM State Register"
        bitfld.long 0x00 18.--22. " SP_STATE1011               ,sp pmu state" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"
        bitfld.long 0x00 13.--17. "        AP_STATE1012              ,ap pmu state" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"
        bitfld.long 0x00 8.--12. "    CP_STATE1013              ,cp pmu state" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"
        bitfld.long 0x00 0.--3. "    WFSTATE1015               ,main pmu state" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"

group d:0xD4282E54++0x03
    line.long 0x00 "PLL_STATUS_REG_RT,Real Time PLL Status Register"
        bitfld.long 0x00 31. " PLL4_LOCK1023              ,pll4 lock indicator" "0,1"
        bitfld.long 0x00 30. "         PLL3_LOCK1024             ,pll3 lock indicator" "0,1"
        bitfld.long 0x00 29. "     PLL2_LOCK1025             ,pll2 lock indicator" "0,1"
        bitfld.long 0x00 28. "     PLL1_LOCK1026             ,pll1 lock indicator" "0,1"
        textline "                                     "
        hexmask.long.word 0x00 15.--27. 1. "CLK_DIV_INFO1027           ,clock divider information  {                                                                                                                                                  core2_c1_pclk_div[0],       dclk_div[2:0],       aclk_div[2:0],       3'b0,       core2_c0_pclk_div[2:0] };"
        hexmask.long.word 0x00 0.--14. 1. "      PLL_SEL_INFO1028          ,pll selection information {        core2_c2_pll_sel[1:0],        core2_c1_pll_sel[2:0],        dclk_pll_sel[2:0],        aclk_pll_sel[1:0],        2'b0,        core2_c0_pll_sel[2:0]        };"

group d:0xD4282E58++0x03
    line.long 0x00 "APC0_PM_STATE_REG_RT,Real Time APC0 PM State Register"
        hexmask.long 0x00 0.--25. 1. " C0_PM_STATE1037            ,ap cluster 0 lpm state {     core3_state[4:0],     core2_state[4:0],     core1_state[4:0],     core0_state[4:0],     c0_mp_state[5:0]    }"

group d:0xD4282E5C++0x03
    line.long 0x00 "APC1_PM_STATE_REG_RT,Real Time APC1 PM State Register"
        hexmask.long 0x00 0.--25. 1. " C1_PM_STATE1046            ,ap cluster 1 lpm state {     core7_state[4:0],     core6_state[4:0],     core5_state[4:0],     core4_state[4:0],     c1_mp_state[5:0]    }"

group d:0xD4282E60++0x03
    line.long 0x00 "FAB_TIMEOUT_ID_TO,AXI Fabric Timeout Transaction ID Register"
        bitfld.long 0x00 31. " WR_TIMEOUT_IND1054         ,write timeout indicator  0 = no write request timeout  1 = write request timeout happens" "0,1"
        hexmask.long.byte 0x00 16.--21. 1. "         TIMEOUT_TX_WID1056        ,the wid of write transaction which causes first timeout event. it is only valid when bit[31], wr_timeout_ind is asserted"
        bitfld.long 0x00 15. "    RD_TIMEOUT_IND1057        ,read timeout indicator  0 = no read request timeout  1 = read request timeout happens" "0,1"
        hexmask.long.byte 0x00 0.--5. 1. "     TIMEOUT_TX_RID1059        ,the rid of read transaction which causes first timeout event. it is only valid when bit[15], rd_timeout_ind is asserted"

group d:0xD4282E64++0x03
    line.long 0x00 "FAB_TIMEOUT_STATUS0_TO,AXI Fabric Timeout Status0 Register"
        hexmask.long 0x00 2.--31. 1. " TIMEOUT_WADDR1067          ,the write address being accessing which has caused the first write timeout event."
        bitfld.long 0x00 0. "  WR_TIMEOUT_IND1069        ,write timeout indicator  0 = no write request timeout  1 = write request timeout happens" "0,1"

group d:0xD4282E68++0x03
    line.long 0x00 "FAB_TIMEOUT_STATUS1_TO,AXI Fabric Timeout Status1 Register"
        hexmask.long 0x00 2.--31. 1. " TIMEOUT_RADDR1077          ,the read address being accessing which has caused the first write timeout event."
        bitfld.long 0x00 0. "  RD_TIMEOUT_IND1079        ,read timeout indicator  0 = no read request timeout  1 = read request timeout happens" "0,1"

group d:0xD4282E6C++0x03
    line.long 0x00 "DVC_STATUS_TO,DVC Status Register"
        bitfld.long 0x00 24.--27. " CAUSE1088                  ,dvc cause  this field is the cause of the current ongoing dvc. it is only valid when the <voltage change status> field is 1.   0x1 = ap software-triggered dvc  0x2 = cp software- triggered dvc   0x4 = msa software- triggered dvc    0x8 = hw-dfc triggered dvc    others = lpm entry/exit trigger dvc" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 16.--19. "        TVL1090                   ,target voltage level of vcc_main" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 8.--11. "    CVL1092                   ,current voltage level of vcc_main" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 0. "    DVC_STATUS1094            ,voltage change status  the voltage change may be triggered in active state or entering low power mode.  0 = there is no voltage change or a voltage change has finished  1 = voltage change is in progress" "0,1"

group d:0xD4282E70++0x03
    line.long 0x00 "DFC_STATUS_TO,DCLK Hardware FC Status Register"
        bitfld.long 0x00 15.--18. " DFC_CAUSE1103              ,dclk dfc cause  this field is the cause of the current ongoing dfc. it is only valid when the <dclk_dfc_status> field is 1.  0x1 = <var processor: application mp> triggered dfc  0x2 = <var processor: comm> triggered dfc in active mode  0x4 = msa trigged dfc in active mode    0x8 = rsvd    others = low power mode entry/exit triggered dfc" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        hexmask.long.byte 0x00 8.--14. 1. "        TFL1104                   ,target freq level of dclk"
        hexmask.long.byte 0x00 1.--7. 1. "    CFL1105                   ,current freq level of dclk"
        bitfld.long 0x00 0. "    DFC_STATUS1106            ,dclk dfc status  the dclk dfc may be triggered in active state or <var processor: seagull/msa> entering low power mode.  0 = there is no dfc or dfc has finished  1 = dfc is in progress" "0,1"

group d:0xD4282E74++0x03
    line.long 0x00 "FC_DONE_STATUS_TO,FC Done Status Register"
        bitfld.long 0x00 10. " GIC500_ECC_FATAL_ERROR1115 ,gic500 ecc fatal error" "0,1"
        bitfld.long 0x00 9. "         AP_C2_FC_DONE1116         ,ap c2 fc done indicator" "0,1"
        bitfld.long 0x00 8. "     AP_C1_FC_DONE1117         ,ap c1 fc done indicator" "0,1"
        bitfld.long 0x00 6. "     AP_C0_FC_DONE1119         ,ap c0 fc done indicator" "0,1"
        textline "                                     "
        bitfld.long 0x00 5. "DCLK_FC_DONE1120           ,dclk fc done indicator" "0,1"
        bitfld.long 0x00 4. "         ACLK_FC_DONE1121          ,aclk fc done indicator" "0,1"
        bitfld.long 0x00 0.--3. "     DFC_STATE1122             ,apmu dfc fsm state" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"

group d:0xD4282E78++0x03
    line.long 0x00 "SPAPDPCP_PM_STATE_REG_TO,SPAPDPCP PM State Register"
        bitfld.long 0x00 18.--22. " SP_STATE1131               ,sp pmu state" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"
        bitfld.long 0x00 13.--17. "        AP_STATE1132              ,ap pmu state" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"
        bitfld.long 0x00 8.--12. "    CP_STATE1133              ,cp pmu state" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"
        bitfld.long 0x00 0.--3. "    WFSTATE1135               ,main pmu state" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"

group d:0xD4282E7C++0x03
    line.long 0x00 "PLL_STATUS_REG_TO,PLL Status Register"
        bitfld.long 0x00 31. " PLL4_LOCK1143              ,pll4 lock indicator" "0,1"
        bitfld.long 0x00 30. "         PLL3_LOCK1144             ,pll3 lock indicator" "0,1"
        bitfld.long 0x00 29. "     PLL2_LOCK1145             ,pll2 lock indicator" "0,1"
        bitfld.long 0x00 28. "     PLL1_LOCK1146             ,pll1 lock indicator" "0,1"
        textline "                                     "
        hexmask.long.word 0x00 15.--27. 1. "CLK_DIV_INFO1147           ,clock divider information  {                                                                                                                                                  core2_c1_pclk_div[0],       dclk_div[2:0],       aclk_div[2:0],       3'b0,       core2_c0_pclk_div[2:0] };"
        hexmask.long.word 0x00 0.--14. 1. "      PLL_SEL_INFO1148          ,pll selection information {        core2_c2_pll_sel[1:0],        core2_c1_pll_sel[2:0],        dclk_pll_sel[2:0],        aclk_pll_sel[1:0],        2'b0,        core2_c0_pll_sel[2:0]        };"

group d:0xD4282E80++0x03
    line.long 0x00 "APC0_PM_STATE_REG_TO,APC0 PM State Register"
        hexmask.long 0x00 0.--25. 1. " C0_PM_STATE1157            ,ap cluster 0 lpm state {     core3_state[4:0],     core2_state[4:0],     core1_state[4:0],     core0_state[4:0],     c0_mp_state[5:0]    }"

group d:0xD4282E84++0x03
    line.long 0x00 "APC1_PM_STATE_REG_TO,APC1 PM State Register"
        hexmask.long 0x00 0.--25. 1. " C1_PM_STATE1166            ,ap cluster 1 lpm state {     core7_state[4:0],     core6_state[4:0],     core5_state[4:0],     core4_state[4:0],     c1_mp_state[5:0]    }"

group d:0xD4282E88++0x03
    line.long 0x00 "FAB_TIMEOUT_ID_HD,Real Time AXI Fabric Timeout Transaction ID Register"
        bitfld.long 0x00 31. " WR_TIMEOUT_IND1174         ,write timeout indicator  0 = no write request timeout  1 = write request timeout happens" "0,1"
        hexmask.long.byte 0x00 16.--21. 1. "         TIMEOUT_TX_WID1176        ,the wid of write transaction which causes first timeout event. it is only valid when bit[31], wr_timeout_ind is asserted"
        bitfld.long 0x00 15. "    RD_TIMEOUT_IND1177        ,read timeout indicator  0 = no read request timeout  1 = read request timeout happens" "0,1"
        hexmask.long.byte 0x00 0.--5. 1. "     TIMEOUT_TX_RID1179        ,the rid of read transaction which causes first timeout event. it is only valid when bit[15], rd_timeout_ind is asserted"

group d:0xD4282E8C++0x03
    line.long 0x00 "FAB_TIMEOUT_STATUS0_HD,Real Time AXI Fabric Timeout Status0 Register"
        hexmask.long 0x00 2.--31. 1. " TIMEOUT_WADDR1187          ,the write address being accessing which has caused the first write timeout event."
        bitfld.long 0x00 0. "  WR_TIMEOUT_IND1189        ,write timeout indicator  0 = no write request timeout  1 = write request timeout happens" "0,1"

group d:0xD4282E90++0x03
    line.long 0x00 "FAB_TIMEOUT_STATUS1_HD,Real Time AXI Fabric Timeout Status1 Register"
        hexmask.long 0x00 2.--31. 1. " TIMEOUT_RADDR1197          ,the read address being accessing which has caused the first write timeout event."
        bitfld.long 0x00 0. "  RD_TIMEOUT_IND1199        ,read timeout indicator  0 = no read request timeout  1 = read request timeout happens" "0,1"

group d:0xD4282E94++0x03
    line.long 0x00 "DVC_STATUS_HD,Real Time DVC Status Register"
        bitfld.long 0x00 24.--27. " CAUSE1208                  ,dvc cause  this field is the cause of the current ongoing dvc. it is only valid when the <voltage change status> field is 1.   0x1 = ap software-triggered dvc  0x2 = cp software- triggered dvc   0x4 = msa software- triggered dvc    0x8 = hw-dfc triggered dvc    others = lpm entry/exit trigger dvc" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 16.--19. "        TVL1210                   ,target voltage level of vcc_main" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 8.--11. "    CVL1212                   ,current voltage level of vcc_main" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 0. "    DVC_STATUS1214            ,voltage change status  the voltage change may be triggered in active state or entering low power mode.  0 = there is no voltage change or a voltage change has finished  1 = voltage change is in progress" "0,1"

group d:0xD4282E98++0x03
    line.long 0x00 "DFC_STATUS_HD,Real Time DCLK Hardware FC Status Register"
        bitfld.long 0x00 15.--18. " DFC_CAUSE1223              ,dclk dfc cause  this field is the cause of the current ongoing dfc. it is only valid when the <dclk_dfc_status> field is 1.  0x1 = <var processor: application mp> triggered dfc  0x2 = <var processor: comm> triggered dfc in active mode  0x4 = msa trigged dfc in active mode    0x8 = rsvd    others = low power mode entry/exit triggered dfc" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        hexmask.long.byte 0x00 8.--14. 1. "        TFL1224                   ,target freq level of dclk"
        hexmask.long.byte 0x00 1.--7. 1. "    CFL1225                   ,current freq level of dclk"
        bitfld.long 0x00 0. "    DFC_STATUS1226            ,dclk dfc status  the dclk dfc may be triggered in active state or <var processor: seagull/msa> entering low power mode.  0 = there is no dfc or dfc has finished  1 = dfc is in progress" "0,1"

group d:0xD4282E9C++0x03
    line.long 0x00 "FC_DONE_STATUS_HD,Real Time FC Done Status Register"
        bitfld.long 0x00 10. " GIC500_ECC_FATAL_ERROR1235 ,gic500 ecc fatal error" "0,1"
        bitfld.long 0x00 9. "         AP_C2_FC_DONE1236         ,ap c2 fc done indicator" "0,1"
        bitfld.long 0x00 8. "     AP_C1_FC_DONE1237         ,ap c1 fc done indicator" "0,1"
        bitfld.long 0x00 6. "     AP_C0_FC_DONE1239         ,ap c0 fc done indicator" "0,1"
        textline "                                     "
        bitfld.long 0x00 5. "DCLK_FC_DONE1240           ,dclk fc done indicator" "0,1"
        bitfld.long 0x00 4. "         ACLK_FC_DONE1241          ,aclk fc done indicator" "0,1"
        bitfld.long 0x00 0.--3. "     DFC_STATE1242             ,apmu dfc fsm state" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"

group d:0xD4282EA0++0x03
    line.long 0x00 "SPAPDPCP_PM_STATE_REG_HD,Real Time SPAPDPCP PM State Register"
        bitfld.long 0x00 18.--22. " SP_STATE1251               ,sp pmu state" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"
        bitfld.long 0x00 13.--17. "        AP_STATE1252              ,ap pmu state" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"
        bitfld.long 0x00 8.--12. "    CP_STATE1253              ,cp pmu state" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"
        bitfld.long 0x00 0.--3. "    WFSTATE1255               ,main pmu state" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"

group d:0xD4282EA4++0x03
    line.long 0x00 "PLL_STATUS_REG_HD,Real Time PLL Status Register"
        bitfld.long 0x00 31. " PLL4_LOCK1263              ,pll4 lock indicator" "0,1"
        bitfld.long 0x00 30. "         PLL3_LOCK1264             ,pll3 lock indicator" "0,1"
        bitfld.long 0x00 29. "     PLL2_LOCK1265             ,pll2 lock indicator" "0,1"
        bitfld.long 0x00 28. "     PLL1_LOCK1266             ,pll1 lock indicator" "0,1"
        textline "                                     "
        hexmask.long.word 0x00 15.--27. 1. "CLK_DIV_INFO1267           ,clock divider information  {                                                                                                                                                  core2_c1_pclk_div[0],       dclk_div[2:0],       aclk_div[2:0],       3'b0,       core2_c0_pclk_div[2:0] };"
        hexmask.long.word 0x00 0.--14. 1. "      PLL_SEL_INFO1268          ,pll selection information {        core2_c2_pll_sel[1:0],        core2_c1_pll_sel[2:0],        dclk_pll_sel[2:0],        aclk_pll_sel[1:0],        2'b0,        core2_c0_pll_sel[2:0]        };"

group d:0xD4282EA8++0x03
    line.long 0x00 "APC0_PM_STATE_REG_HD,Real Time APC0 PM State Register"
        hexmask.long 0x00 0.--25. 1. " C0_PM_STATE1277            ,ap cluster 0 lpm state {     core3_state[4:0],     core2_state[4:0],     core1_state[4:0],     core0_state[4:0],     c0_mp_state[5:0]    }"

group d:0xD4282EAC++0x03
    line.long 0x00 "APC1_PM_STATE_REG_HD,Real Time APC1 PM State Register"
        hexmask.long 0x00 0.--25. 1. " C1_PM_STATE1286            ,ap cluster 1 lpm state {     core7_state[4:0],     core6_state[4:0],     core5_state[4:0],     core4_state[4:0],     c1_mp_state[5:0]    }"

group d:0xD4282EB0++0x03
    line.long 0x00 "APC2_PM_STATE_REG_RT,Real Time APC2 PM State Register"
        hexmask.long 0x00 0.--25. 1. " C2_PM_STATE1295            ,ap cluster 2 lpm state {    10'b0,     core9_state[4:0],     core8_state[4:0],     c2_mp_state[5:0]    }"

group d:0xD4282EB4++0x03
    line.long 0x00 "APC2_PM_STATE_REG_TO,APC2 PM State Register"
        hexmask.long 0x00 0.--25. 1. " C2_PM_STATE1303            ,ap cluster 2 lpm state {    10'b0,     core9_state[4:0],     core8_state[4:0],     c2_mp_state[5:0]    }"

group d:0xD4282EB8++0x03
    line.long 0x00 "APC2_PM_STATE_REG_HD,Real Time APC2 PM State Register"
        hexmask.long 0x00 0.--25. 1. " C2_PM_STATE1311            ,ap cluster 2 lpm state {    10'b0,     core9_state[4:0],     core8_state[4:0],     c2_mp_state[5:0]    }"

group d:0xD4282EBC++0x03
    line.long 0x00 "PLL_STATUS2_REG_RT,Real Time PLL Status2 Register"
        bitfld.long 0x00 3.--5. " C2_CLK_DIV_INFO1320        ,cpu c2 clock divider information(has some issue in aquila, will fix it in next project)" "0,1,2,3,4,5,6,7"

group d:0xD4282EC0++0x03
    line.long 0x00 "PLL_STATUS2_REG_TO,PLL Status2 Register"
        bitfld.long 0x00 3.--5. " C2_CLK_DIV_INFO1330        ,cpu c2 clock divider information(has some issue in aquila, will fix it in next project)" "0,1,2,3,4,5,6,7"

group d:0xD4282EC4++0x03
    line.long 0x00 "PLL_STATUS2_REG_HD,Real Time PLL Status2 Register"
        bitfld.long 0x00 3.--5. " C2_CLK_DIV_INFO1340        ,cpu c2 clock divider information(has some issue in aquila, will fix it in next project)" "0,1,2,3,4,5,6,7"

group d:0xD4282EC8++0x03
    line.long 0x00 "SW_SPINLOCK_REG,"
        hexmask.long 0x00 0.--31. 1. " SW_SPINLOCK                ,only used for sw spinlock. this register can only be writted data when its value is 0"

group d:0xD4282ECC++0x03
    line.long 0x00 "SW_SPINLOCKREG_CLEAR,"
        bitfld.long 0x00 0. " SW_SPINLOCK_CLEAR          , sw_spinlock_clear   1=clear the value of sw spinlock register to 0    0=un used" "0,1"

group d:0xD4282ED0++0x03
    line.long 0x00 "MFPR_Disable_0,MFPR Disable Register 0"
        hexmask.long 0x00 0.--31. 1. " MFPR_DIS_0                 ,mfpr disable bits [31:0]  one bit for each pad. when related bit is set, the corresponding pad mfpr can't be changed."

group d:0xD4282ED4++0x03
    line.long 0x00 "MFPR_Disable_1,MFPR Disable Register 1"
        hexmask.long 0x00 0.--31. 1. " MFPR_DIS_1                 ,mfpr disable bits [63:32]  one bit for each pad. when related bit is set, the corresponding pad mfpr can't be changed."

group d:0xD4282ED8++0x03
    line.long 0x00 "MFPR_Disable_2,MFPR Disable Register 2"
        hexmask.long 0x00 0.--31. 1. " MFPR_DIS_2                 ,mfpr disable bits [95:64]  one bit for each pad. when related bit is set, the corresponding pad mfpr can't be changed."

group d:0xD4282EDC++0x03
    line.long 0x00 "MFPR_Disable_3,MFPR Disable Register 3"
        hexmask.long 0x00 0.--31. 1. " MFPR_DIS_3                 ,mfpr disable bits [127:96]  one bit for each pad. when related bit is set, the corresponding pad mfpr can't be changed."

group d:0xD4282EE0++0x03
    line.long 0x00 "MFPR_Disable_4,MFPR Disable Register 4"
        hexmask.long 0x00 0.--31. 1. " MFPR_DIS_4                 ,mfpr disable bits [159:128]  one bit for each pad. when related bit is set, the corresponding pad mfpr can't be changed."

group d:0xD4282EE4++0x03
    line.long 0x00 "MFPR_Disable_5,MFPR Disable Register 5"
        hexmask.long 0x00 0.--31. 1. " MFPR_DIS_5                 ,mfpr disable bits [191:160]  one bit for each pad. when related bit is set, the corresponding pad mfpr can't be changed."

group d:0xD4282EE8++0x03
    line.long 0x00 "MFPR_Disable_6,MFPR Disable Register 6"
        hexmask.long 0x00 0.--31. 1. " MFPR_DIS_6                 ,mfpr disable bits [223:192]  one bit for each pad. when related bit is set, the corresponding pad mfpr can't be changed."

group d:0xD4282EEC++0x03
    line.long 0x00 "MFPR_Disable_7,MFPR Disable Register 7"
        hexmask.long 0x00 0.--31. 1. " MFPR_DIS_7                 ,mfpr disable bits [255:224]  one bit for each pad. when related bit is set, the corresponding pad mfpr can't be changed."

tree.end

tree "ciudragon"

width 30.

group d:0xD8440000++0x03
    line.long 0x00 "CLUSTER0_CPUx_CFG0,Cluster 0 Core x Config Registers"

group d:0xD8440004++0x03
    line.long 0x00 "CLUSTER0_CPUx_CFG1,Cluster 0 Core x Config Registers"

group d:0xD8440008++0x03
    line.long 0x00 "CLUSTER0_CPUx_CFG2,Cluster 0 Core x Config Registers"

group d:0xD844000C++0x03
    line.long 0x00 "CLUSTER0_CPUx_CFG3,Cluster 0 Core x Config Registers"
        bitfld.long 0x00 29. " CRYPTODISABLE15                    ,crypto disable  this field is used to disable the cryptography extension.  1 = disable  0 = enable" "0,1"
        bitfld.long 0x00 27. "         CFGEND17                           ,ee bit config  this field controls the state of the ee bit in the cp15 system control register.  0 = ee bit is low  1 = ee bit is high" "0,1"
        bitfld.long 0x00 25. "     CFGTE19                            ,processor out-of-reset exception handling state  0 = arm  1 = thumb" "0,1"
        bitfld.long 0x00 18. "   CP15SDISABLE21                  ,cp15 coprocessor register non-secure write disable  1 = attempts to write to cp15 secure-state registers will result in an undefined instruction exception  0 = writes to cp15 secure-state registers are allowed and will not result in an undefined instruction exception" "0,1"

group d:0xD8440010++0x03
    line.long 0x00 "CLUSTERx_CTRL0,Cluster x Control Registers"

group d:0xD8440050++0x03
    line.long 0x00 "CLUSTERx_CTRL1,Cluster x Control Registers"

group d:0xD84400D8++0x03
    line.long 0x00 "CLUSTERx_CTRL2,Cluster x Control Registers"
        hexmask.long.word 0x00 16.--31. 1. " EVENTO_PENDDING_COUNT              ,evento pending count"
        bitfld.long 0x00 6. "      DBGL1RSTDISABLE                    ,debug only: disable l1 cache reset" "0,1"
        bitfld.long 0x00 5. "     EVENTO_PENDDING_COUNT_CLR          ,evento pending count clear  1=clear. need first write to 1, then write to 0 to clear" "0,1"
        bitfld.long 0x00 4. "   EVENTI_MASK_1                   ,eventi mask bit1  1= mask. for x=0, it mask evento from cluster2;   for x=1, it mask evento from cluster2; for x=2, it mask evento from cluster1;" "0,1"
        textline "                                        "
        bitfld.long 0x00 3. "EVENTI_MASK_0                      ,eventi mask bit0  1= mask. for x=0, it mask evento from cluster1;   for x=1, it mask evento from cluster0; for x=2, it mask evento from cluster0;" "0,1"
        bitfld.long 0x00 2. "         EVENT_OUT_EN                       ,event sent to other cluster enable  1 = this cluster cpu execution of 'sev' will wake up other cluster cpus which are in 'wait for event' (wfe) state" "0,1"
        bitfld.long 0x00 0. "     ACINACTM                           ,snoop interface control  this field indicates whether snoop interface is active or is inactive and not participating in coherency.  0 = snoop interface is active  1 = snoop interface is inactive" "0,1"

group d:0xD8440014++0x03
    line.long 0x00 "CLUSTERx_CPU_SRAM_CTRL0,Cluster x CPU SRAM Control Registers"

group d:0xD8440054++0x03
    line.long 0x00 "CLUSTERx_CPU_SRAM_CTRL1,Cluster x CPU SRAM Control Registers"

group d:0xD84400DC++0x03
    line.long 0x00 "CLUSTERx_CPU_SRAM_CTRL2,Cluster x CPU SRAM Control Registers"
        bitfld.long 0x00 30. " L1_SRDP_EMASB                      ,l1_srdp_emasb" "0,1"
        bitfld.long 0x00 28.--29. "         L1_SRDP_EMAWB                      ,l1_srdp_emawb" "0,1,2,3"
        bitfld.long 0x00 25.--27. "     L1_SRDP_EMAB                       ,l1_srdp_emab" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 24. "   L1_SRDP_EMASA                   ,l1_srdp_emasa" "0,1"
        textline "                                        "
        bitfld.long 0x00 22.--23. "L1_SRDP_EMAWA                      ,l1_srdp_emawa" "0,1,2,3"
        bitfld.long 0x00 19.--21. "         L1_SRDP_EMAA                       ,l1_srdp_emaa" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 18. "     L1_SR1P_EMAS                       ,l1_sr1p_emas" "0,1"
        bitfld.long 0x00 16.--17. "   L1_SR1P_EMAW                    ,l1_sr1p_emaw" "0,1,2,3"
        textline "                                        "
        bitfld.long 0x00 13.--15. "L1_SR1P_EMA                        ,l1_sr1p_ema" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 12. "         L1_RF2P_EMASA                      ,l1_rf2p_emasa" "0,1"
        bitfld.long 0x00 9.--11. "     L1_RF2P_EMAB                       ,l1_rf2p_emab" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 6.--8. "   L1_RF2P_EMAA                    ,l1_rf2p_emaa" "0,1,2,3,4,5,6,7"
        textline "                                        "
        bitfld.long 0x00 5. "L1_RF1P_EMAS                       ,l1_rf1p_emas" "0,1"
        bitfld.long 0x00 3.--4. "         L1_RF1P_EMAW                       ,l1_rf1p_emaw" "0,1,2,3"
        bitfld.long 0x00 0.--2. "     L1_RF1P_EMA                        ,l1_rf1p_ema" "0,1,2,3,4,5,6,7"

group d:0xD8440018++0x03
    line.long 0x00 "CLUSTERx_MP_SRAM_CTRL0,Cluster x MP SRAM Control Registers"

group d:0xD8440058++0x03
    line.long 0x00 "CLUSTERx_MP_SRAM_CTRL1,Cluster x MP SRAM Control Registers"

group d:0xD84400E0++0x03
    line.long 0x00 "CLUSTERx_MP_SRAM_CTRL2,Cluster x MP SRAM Control Registers"
        bitfld.long 0x00 30. " L2_SRDP_EMASB                      ,l2_srdp_emasb" "0,1"
        bitfld.long 0x00 28.--29. "         L2_SRDP_EMAWB                      ,l2_srdp_emawb" "0,1,2,3"
        bitfld.long 0x00 25.--27. "     L2_SRDP_EMAB                       ,l2_srdp_emab" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 24. "   L2_SRDP_EMASA                   ,l2_srdp_emasa" "0,1"
        textline "                                        "
        bitfld.long 0x00 22.--23. "L2_SRDP_EMAWA                      ,l2_srdp_emawa" "0,1,2,3"
        bitfld.long 0x00 19.--21. "         L2_SRDP_EMAA                       ,l2_srdp_emaa" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 18. "     L2_SR1P_EMAS                       ,l2_sr1p_emas" "0,1"
        bitfld.long 0x00 16.--17. "   L2_SR1P_EMAW                    ,l2_sr1p_emaw" "0,1,2,3"
        textline "                                        "
        bitfld.long 0x00 13.--15. "L2_SR1P_EMA                        ,l2_sr1p_ema" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 12. "         L2_RF2P_EMASA                      ,l2_rf2p_emasa" "0,1"
        bitfld.long 0x00 9.--11. "     L2_RF2P_EMAB                       ,l2_rf2p_emab" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 6.--8. "   L2_RF2P_EMAA                    ,l2_rf2p_emaa" "0,1,2,3,4,5,6,7"
        textline "                                        "
        bitfld.long 0x00 5. "L2_RF1P_EMAS                       ,l2_rf1p_emas" "0,1"
        bitfld.long 0x00 3.--4. "         L2_RF1P_EMAW                       ,l2_rf1p_emaw" "0,1,2,3"
        bitfld.long 0x00 0.--2. "     L2_RF1P_EMA                        ,l2_rf1p_ema" "0,1,2,3,4,5,6,7"

group d:0xD8440030++0x03
    line.long 0x00 "CLUSTERx_STATUS0,Cluster x Status Register"

group d:0xD8440070++0x03
    line.long 0x00 "CLUSTERx_STATUS1,Cluster x Status Register"

group d:0xD84400E4++0x03
    line.long 0x00 "CLUSTERx_STATUS2,Cluster x Status Register"
        bitfld.long 0x00 8. " L2FLUSHDONE                        ,l2 hardware flush complete" "0,1"
        bitfld.long 0x00 4.--7. "         STANDBY_WFE                        ,cpu core standbywfe status" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 0.--3. "    SMPEN                              ,smp status  indicates whether a core is taking part in coherency.  for cluster 0:  bit [3] is used for core 3  bit [2] is used for core 2  bit [1] is used for core 1  bit [0] is used for core 0    for cluster 1:  bit [3] is used for core 7  bit [2] is used for core 6  bit [1] is used for core 5  bit [0] is used for core 4" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"

group d:0xD8440040++0x03
    line.long 0x00 "CLUSTER1_CPUx_CFG0,Cluster 1 Core x Config Register"

group d:0xD8440044++0x03
    line.long 0x00 "CLUSTER1_CPUx_CFG1,Cluster 1 Core x Config Register"

group d:0xD8440048++0x03
    line.long 0x00 "CLUSTER1_CPUx_CFG2,Cluster 1 Core x Config Register"

group d:0xD844004C++0x03
    line.long 0x00 "CLUSTER1_CPUx_CFG3,Cluster 1 Core x Config Register"
        bitfld.long 0x00 29. " CRYPTODISABLE99                    ,crypto disable  this field is used to disable the cryptography extension.  1 = disable  0 = enable" "0,1"
        bitfld.long 0x00 27. "         CFGEND101                          ,ee bit config  this field controls the state of the ee bit in the cp15 system control register.  0 = ee bit is low  1 = ee bit is high" "0,1"
        bitfld.long 0x00 25. "     CFGTE103                           ,processor out-of-reset exception handling state  0 = arm  1 = thumb" "0,1"
        bitfld.long 0x00 18. "   CP15SDISABLE105                 ,cp15 coprocessor register non-secure write disable  1 = attempts to write to cp15 secure-state registers will result in an undefined instruction exception  0 = writes to cp15 secure-state registers are allowed and will not result in an undefined instruction exception" "0,1"

group d:0xD8440080++0x03
    line.long 0x00 "CS_SRAM_CTRL,CoreSight SRAM Control Register"
        bitfld.long 0x00 30. " DCI_SRDP_EMASB114                  ,srdp_emasb" "0,1"
        bitfld.long 0x00 28.--29. "         DCI_SRDP_EMAWB115                  ,srdp_emawb" "0,1,2,3"
        bitfld.long 0x00 25.--27. "     DCI_SRDP_EMAB116                   ,srdp_emab" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 24. "   DCI_SRDP_EMASA117               ,srdp_emasa" "0,1"
        textline "                                        "
        bitfld.long 0x00 22.--23. "DCI_SRDP_EMAWA118                  ,srdp_emawa" "0,1,2,3"
        bitfld.long 0x00 19.--21. "         DCI_SRDP_EMAA119                   ,srdp_emaa" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 18. "     DCI_SR1P_EMAS120                   ,sr1p_emas" "0,1"
        bitfld.long 0x00 16.--17. "   DCI_SR1P_EMAW121                ,sr1p_emaw" "0,1,2,3"
        textline "                                        "
        bitfld.long 0x00 13.--15. "DCI_SR1P_EMA122                    ,sr1p_ema" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 12. "         DCI_RF2P_EMASA123                  ,rf2p_emasa" "0,1"
        bitfld.long 0x00 9.--11. "     DCI_RF2P_EMAB124                   ,rf2p_emab" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 6.--8. "   DCI_RF2P_EMAA125                ,rf2p_emaa" "0,1,2,3,4,5,6,7"
        textline "                                        "
        bitfld.long 0x00 5. "DCI_RF1P_EMAS126                   ,rf1p_emas" "0,1"
        bitfld.long 0x00 3.--4. "         DCI_RF1P_EMAW127                   ,rf1p_emaw" "0,1,2,3"
        bitfld.long 0x00 0.--2. "     DCI_RF1P_EMA128                    ,rf1p_ema" "0,1,2,3,4,5,6,7"

group d:0xD8440084++0x03
    line.long 0x00 "GIC_CTRL,GIC Control Register"
        bitfld.long 0x00 22. " GIC500_SW_RSTN                     ,gic500 sw reset  0=reset.  usually used for gic500 ecc fatal" "0,1"
        hexmask.long.word 0x00 12.--21. 1. "         NSEI_TO_CPU_CORE_MASK              ,gic500 ecc fatal caused nsei  to cpu core mask,  there're 10 cpu cores,  each cpu core use 1 bit   1=mask"
        bitfld.long 0x00 11. "  GIC500_ECC_FATAL_INT_STATUS        ,gic500 ecc fatal interrupt status  1=gic500 ecc fatal interrupt valid" "0,1"
        bitfld.long 0x00 10. "   GIC500_ECC_FATAL_INT_CLR        ,gic500 ecc fatal interrupt clear  1=clear the nsei  and ecc fatal status  interrupt. this bit will automatically restore to 0 after write to 1" "0,1"
        textline "                                        "
        bitfld.long 0x00 9. "GIC500_ECC_FATAL_INT_EN            ,gic500 ecc fatal interrupt enable  1=enable the interrupt. if gic500 send out ecc_fatal=1, the gic500 will be hw reset, and the cpu cores will receive nsei  interrupt" "0,1"

group d:0xD8440088++0x03
    line.long 0x00 "CKG_CTRL,Clock Gate Control Register"
        hexmask.long.word 0x00 16.--25. 1. " CCI_CLKOFF_TIMER                   ,cci dynamic clock gate timer. when dynamic lcock gate enable, cci clock will off after cci_clkoff_timer cycle."
        bitfld.long 0x00 4. "      ATCLKEN_MASK                       ,atclken_mask" "0,1"
        bitfld.long 0x00 3. "     CIU_CKG_EN                         ,dragon ciu dynamic gate enable  1=dynamic clock gate  0=clock is always on" "0,1"
        bitfld.long 0x00 2. "   CCI_CKG_EN                      ,cci clock dynamic gate enable  1=dynamic clock gate  0=clock is always on" "0,1"
        textline "                                        "
        bitfld.long 0x00 1. "MAIN_CKG_EN                        ,fabric 1x3 main clock dynamic gate enable  1=dynamic clock gate  0=clock is always on" "0,1"
        bitfld.long 0x00 0. "         ACLKM0_CKG_EN                      ,aclkm0 clock dynamic gate enable  1=dynamic clock gate  0=clock is always on" "0,1"

group d:0xD844008C++0x03
    line.long 0x00 "CPU_GIC_CTRL,CPU GIC Control Register"
        bitfld.long 0x00 5. " NFIQ_NIRQ_MASK_C2                  ,cluster2 nfiq and nirq mask  1=mask. when giccdisable_c2=0, this bit must be always 1;  when giccdisable_c2=1, this bit can be 0 or 1" "0,1"
        bitfld.long 0x00 4. "         NFIQ_NIRQ_MASK_C1                  ,cluster1 nfiq and nirq mask  1=mask. when giccdisable_c1=0, this bit must be always 1;  when giccdisable_c1=1, this bit can be 0 or 1" "0,1"
        bitfld.long 0x00 3. "     NFIQ_NIRQ_MASK_C0                  ,cluster0 nfiq and nirq mask  1=mask. when giccdisable_c0=0, this bit must be always 1;  when giccdisable_c0=1, this bit can be 0 or 1" "0,1"
        bitfld.long 0x00 2. "   GICCDISABLE_C2                  ,cluster2 disable gic cpu interface  1=disable,  this configuration only change to be valid at the time cpu cluster reset  go to de-assert" "0,1"
        textline "                                        "
        bitfld.long 0x00 1. "GICCDISABLE_C1                     ,cluster1 disable gic cpu interface  1=disable,  this configuration only change to be valid at the time cpu cluster reset  go to de-assert" "0,1"
        bitfld.long 0x00 0. "         GICCDISABLE_C0                     ,cluster0 disable gic cpu interface  1=disable,  this configuration only change to be valid at the time cpu cluster reset  go to de-assert" "0,1"

group d:0xD8440090++0x03
    line.long 0x00 "CCI_DBG_CTRL,CCI Debug Control Register"
        bitfld.long 0x00 5. " CCI_GPU_FORCE_AWQOS                ,gpu force awqos to 0 in cci550  1=force to 0" "0,1"
        bitfld.long 0x00 4. "         CCI_GPU_FORCE_ARQOS                ,gpu force arqos to 0 in cci550  1=force to 0" "0,1"
        bitfld.long 0x00 3. "     DCI_DBGEN178                       ,invasive debug enable. if high, enables the counting and export of pmu events." "0,1"
        bitfld.long 0x00 2. "   DCI_SPIDEN179                   ,secure invasive debug enable. if both spiden and dbgen are high, enables the counting of both non-secure and secure events." "0,1"
        textline "                                        "
        bitfld.long 0x00 1. "DCI_NIDEN180                       ,non-invasive debug enable. if high, the signal enables counting and export of pmu events." "0,1"
        bitfld.long 0x00 0. "         DCI_SPNIDEN181                     ,secure privileged non-invasive debug enable. if both spniden and niden are high, the signal enables counting of both nonsecure and secure events." "0,1"

group d:0xD8440094++0x03
    line.long 0x00 "PW_STR_CTRL,Pulse Latch Width Control register"
        bitfld.long 0x00 2. " PW_STR_2                           ,cluster 2 pulse latch width control" "0,1"
        bitfld.long 0x00 1. "         PW_STR_1                           ,cluster 1 pulse latch width control" "0,1"
        bitfld.long 0x00 0. "     PW_STR_0                           ,cluster 0 pulse latch width control" "0,1"

group d:0xD8440098++0x03
    line.long 0x00 "CCI_INF_QOS_CTRL,CCI Interface QoS control"
        bitfld.long 0x00 20.--23. " C2_ARQOS_CFG                       ,c2_arqos_cfg" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 16.--19. "        C2_AWQOS_CFG                       ,c2_awqos_cfg" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 12.--15. "    C1_ARQOS_CFG                       ,c1_arqos_cfg" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 8.--11. "  C1_AWQOS_CFG                    ,c1_awqos_cfg" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        textline "                                        "
        bitfld.long 0x00 4.--7. "C0_ARQOS_CFG                       ,c0_arqos_cfg" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 0.--3. "        C0_AWQOS_CFG                       ,c0_awqos_cfg" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"

group d:0xD84400C8++0x03
    line.long 0x00 "CLUSTER2_CPUx_CFG0,Cluster 2 Core x Config Register"

group d:0xD84400CC++0x03
    line.long 0x00 "CLUSTER2_CPUx_CFG1,Cluster 2 Core x Config Register"
        bitfld.long 0x00 29. " CRYPTODISABLE232                   ,crypto disable  this field is used to disable the cryptography extension.  1 = disable  0 = enable" "0,1"
        bitfld.long 0x00 27. "         CFGEND234                          ,ee bit config  this field controls the state of the ee bit in the cp15 system control register.  0 = ee bit is low  1 = ee bit is high" "0,1"
        bitfld.long 0x00 25. "     CFGTE236                           ,processor out-of-reset exception handling state  0 = arm  1 = thumb" "0,1"
        bitfld.long 0x00 18. "   CP15SDISABLE238                 ,cp15 coprocessor register non-secure write disable  1 = attempts to write to cp15 secure-state registers will result in an undefined instruction exception  0 = writes to cp15 secure-state registers are allowed and will not result in an undefined instruction exception" "0,1"

group d:0xD84400E8++0x03
    line.long 0x00 "CPU_L2_LIGHT_SLEEP_CTRL,CPU L2 LIGHT SLEEP CONTROL Register"
        bitfld.long 0x00 6. " C2_L2_REPLRAM_LIGHT_SLEEP_DIS      ,cluster2 l2 replram light sleep disable" "0,1"
        bitfld.long 0x00 5. "         C2_L2_TAGRAM_LIGHT_SLEEP_DIS       ,cluster2 l2 tagram light sleep disable" "0,1"
        bitfld.long 0x00 4. "     C2_L2_DATARAM_LIGHT_SLEEP_DIS      ,cluster2 l2 dataram light sleep disable" "0,1"
        bitfld.long 0x00 3. "   C1_L2_VICTIMRAM_LIGHT_SLEEP_DIS ,cluster1 l2 victimram light sleep disable" "0,1"
        textline "                                        "
        bitfld.long 0x00 2. "C1_L2_DATARAM_LIGHT_SLEEP_DIS      ,cluster1 l2 dataram light sleep disable" "0,1"
        bitfld.long 0x00 1. "         C0_L2_VICTIMRAM_LIGHT_SLEEP_DIS    ,cluster0 l2 victimram light sleep disable" "0,1"
        bitfld.long 0x00 0. "     C0_L2_DATARAM_LIGHT_SLEEP_DIS      ,cluster0 l2 dataram light sleep disable" "0,1"

group d:0xD84400EC++0x03
    line.long 0x00 "CPU_ACLKM0_ACLKM1_CTRL,CPU ACLKM0_ACLKM1 Control Register"
        bitfld.long 0x00 2. " DIS_SLOW_CLK_DURING_CLUSTER2_PWRUP ,disable slow clock during cluter2 cpu core power up   1=aclkm0 and aclkm1 are free runing during cluster2 cpu core power up   0=aclkm0 and aclkm1 is gated for some time, or is slow clock instead during cpu core power up" "0,1"
        bitfld.long 0x00 1. "         DIS_SLOW_CLK_DURING_CLUSTER1_PWRUP ,disable slow clock during cluter1 cpu core power up   1=aclkm0 and aclkm1 are free runing during cluster1 cpu core power up   0=aclkm0 and aclkm1 is gated for some time, or is slow clock instead during cpu core power up" "0,1"
        bitfld.long 0x00 0. "     DIS_SLOW_CLK_DURING_CLUSTER0_PWRUP ,disable slow clock during cluter0 cpu core power up   1=aclkm0 and aclkm1 are free runing during cluster0 cpu core power up   0=aclkm0 and aclkm1 is gated for some time, or is slow clock instead during cpu core power up" "0,1"

group d:0xD8440104++0x03
    line.long 0x00 "CLUSTER0_ROM_READ_ADDR_REMAP,Cluster 0 ROM READ ADDR REMAP Register"
        hexmask.long 0x00 1.--28. 1. " ROM_REMAP_ADDR                     ,rom_remap_addr"
        bitfld.long 0x00 0. "  ROM_REMAP_ENABLE                   ,rom_remap_enable  1=enable。 only used for fpga" "0,1"

tree.end

tree "dssp"

width 14.

group d:0xF0205100++0x03
    line.long 0x00 "DSSP_DSSPRR,DSSP Reset Register"
        bitfld.long 0x00 2. " HW_OP                ,hardware option id: 1434490. this field must be set to 0 for normal operation." "0,1"
        bitfld.long 0x00 1. "   RSSP                  ,dssp reset  signal that resets the dssp serial interface - the dssp section that interface to the pads.   must be set to get the dssp out of reset.  0 = reset the dssp serial machine logic  1 = the dssp serial interface is out of reset" "0,1"
        bitfld.long 0x00 0. "  RSSPA             ,dssp fifo reset  signal that resets the dssp fifo interface - the dssp section that interfaces the gpb and includes the rx/tx fifos.  must be set to get the dssp out of reset.   can be used to reset the dssp fifo logic without changing the state of the signal that interfaces the chip pads. this reset resets the dssp core control registers. it does not reset the three additional registers.  0 = reset the dssp fifo logic and bus interface logic  1 = the dssp fifo and bus interface are out of reset" "0,1"

group d:0xF0205104++0x03
    line.long 0x00 "DSSP_DSSPTIR,DSSP Tx Interface Register"
        bitfld.long 0x00 3. " TXFRM_INV            ,tx frame signal polarity  this bit may be modified.   0 = the frame-sync output signal polarity is unchanged.  1 = the frame-sync output signal is inverted before leaving the dssp.  this bit must be accessed only when the dssp is disabled." "0,1"
        bitfld.long 0x00 2. "   DMATXREQCLR           ,dmatxreqclr  when set to 1, this field disables the dma tx request signal and sets it to its idle state. the idle state remains until this bit is set to 0.  this bit can be accessed at all times." "0,1"
        bitfld.long 0x00 1. "  TXSWOEC           ,dssp txgpio software oe mux control  sets the source of the tx gpio oe signal.   0 = txgpio oe controlled by software - according to txswoe bit  1 = txgpio oe controlled by dssp  this bit must be accessed only when the dssp is disabled." "0,1"
        bitfld.long 0x00 0. "   TXSWOE                 ,dssp txgpio software oe  software tx gpio oe bit, effective when this field is 0.  0 = txgpio is in tri-state  1 = txgpio is active  this bit must be accessed only when the dssp is disabled." "0,1"

group d:0xF0205108++0x03
    line.long 0x00 "DSSP_DSSPRIR,DSSP Rx Interface Register"
        bitfld.long 0x00 7. " DMARXREQCLR          ,dmarxreqclr  when set to 1, this bit disables the dma rx request signal and sets it to its idle state. the idle state remains until this bit is set to 0.  this bit must be accessed at all times." "0,1"
        bitfld.long 0x00 5.--6. "   SCLKINSEL             ,ssp_clk input clock select (mux a in the dssp data/clock pad connectivity figure in the <var product number> datasheet)  this field selects the source for the functional clock of the dssp serial interface when the dssp is in clock-master mode (uses the mccu-generated dssp clock as the source for the functional clock).  clock source options are:  0x0 = mccu-generated dssp clock  0x1 = return clock from the clock pad (used only for rx-data clock-master mode. in this mode, the dssp uses a delayed version of the mccu-generated dssp functional clock to enable working at high frequency - 26/13 mhz)  0x2 = sclk return clock from the pad of dssp 0 (referred to also as external clock, used to synchronize any dssp to the input clock source of dssp 0) - for clock-slave mode  0x3 = 1/4-cycle clock delay (same effect as the return clock option but with fixed delay) - hardware test option for rx-data clock-master mode (requires <sclkoutsel>=1)  this bit must be accessed only when the dssp is disabled." "0,1,2,3"
        bitfld.long 0x00 4. "  SCLKOUTSEL        ,dssp sclk out clock select (mux b in the dssp data/clock pad connectivity figure in the <var product number> datasheet)  when the dssp is in clock-master mode, this bit selects the sclk output clock source to the external device.  output clock options are:  0 = dssp-generated clock (usually used with <sclkinsel> = 0x0)  1 = mccu-generated dssp clock, while the dssp gets the delayed version of the clock (requires <sclkinsel> = 0x1 or 0x3)  this bit must be accessed only when the dssp is disabled." "0,1"
        bitfld.long 0x00 3. "   RXCLKSEL               ,dssp rx internal clock select (mux c in the dssp data/clock pad connectivity figure in the <var product number> datasheet).   when the dssp is master on the clock and a full-rate clock is selected, the rx logic clock can be 1/4-cycle lead in respect to the clock driven to the output pad.  0 = regular clock selected for rx (must be set for normal operation)  1 = 1/4-cycle lead clock selected for rx (hardware test option)  this bit must be accessed only when the dssp is disabled." "0,1"
        textline "                        "
        bitfld.long 0x00 1.--2. "RXTXSWOEC            ,dssp rxtx gpio software oe mux control (mux d in the dssp data/clock pad connectivity figure in the <var product number> datasheet)  sets the source of the rxtx gpio output enable (oe) signal.   0x0 = software-controlled - according to rxtxswoe bit  0x1 = dssp-hardware controlled by dssp  0x2 = frm-controlled option 1: the frame signal is used as the output enable when the frame signal is active during the transmit. should be used for read-back mode to invert the pad direction between the tx and rx parts  0x3 = frm-controlled option 2  this bit must be accessed only when the dssp is disabled." "0,1,2,3"
        bitfld.long 0x00 0. "   RXTXSWOE              ,dssp txgpio software oe  software rxtx gpio output enable (oe) bit, effective when this field is 0.  0 = rxtxgpio is in tri-state  1 = rxtxgpio is active  this bit must be accessed only when the dssp is disabled." "0,1"

group d:0xF020510C++0x03
    line.long 0x00 "DSSP_DSSPCFG,DSSP Configuration Registers"
        bitfld.long 0x00 19. " RDBACK_32BITS_ENABLE ,read-back mode bit length (30 or 32)  0 = maximal length of read-back word is 30 bits (legacy logic)  1 = maximal length of read back word is 32 bits" "0,1"
        bitfld.long 0x00 18. "   GPIO_SSPSCLK_PATH_SEL ,selects the path for the sspsclk clock  0 = directly from the pads  1 = via the sspsclk gater" "0,1"
        hexmask.long.byte 0x00 11.--17. 1. "  FRFLT_SMP_LEN     ,defines the full length of the sample, in sclk clock cycles.  this value should be set to the desired length minus 1   range: 1 to 127 (0x1 to 0x7f)  reset value: 0"
        bitfld.long 0x00 10. "  FRFLT_NO_PASS__LEN_MSB ,msb of <frflt_no_pass_len> field." "0,1"
        textline "                        "
        hexmask.long.byte 0x00 4.--9. 1. "FRFLT_NO_PASS_LEN    ,defines the length of the sequence that is filtered out of the frame, in sclk clock cycles.  this value is a fraction of the <frflt_smp_len> field.   msb is configured in the <frflt_no_pass_len_msb> field.  range: 1 to 127 (0x1 to 0x7f)  reset value: 0"
        bitfld.long 0x00 3. "  FRFLT_CK_POL          ,frame filter clock polarity  0 = frame filter uses the same clock as dssp_0 sclk  1 = frame filter uses polarity inverted from dssp_0 sclk" "0,1"
        bitfld.long 0x00 2. "  FRFLT_FRM_OUT_POL ,frame filter output frame-sync polarity  0 = frame-sync signal to dssp_0 is active high  1 = frame-sync signal to dssp_0 is active low" "0,1"
        bitfld.long 0x00 1. "   FRFLT_FRM_IN_POL       ,frame filter input frame-sync polarity  0 = frame-sync signal is treated as active high  1 = frame-sync signal is treated as active low" "0,1"
        textline "                        "
        bitfld.long 0x00 0. "FSTRP_EN             ,0 = disable frame filter  1 = enable frame filter" "0,1"

tree.end

tree "dtc"

width 26.

group d:0xD4285000++0x03
    line.long 0x00 "DTC_DOCR_CSA0_10,DTC Chain Start Address Register 0/1"

group d:0xD4285008++0x03
    line.long 0x00 "DTC_DOCR_CSA0_11,DTC Chain Start Address Register 0/1"
        hexmask.long 0x00 0.--31. 1. " CHAIN0_START_ADDR ,bit sample  address of the first descriptor in the chain. can point to f8 or f9 descriptor – depends on f8/f9b flag.  for channel 0/1"

group d:0xD4285004++0x03
    line.long 0x00 "DTC_DOCR_CTRL0_10,DTC Control Register 0/1"

group d:0xD428500C++0x03
    line.long 0x00 "DTC_DOCR_CTRL0_11,DTC Control Register 0/1"
        bitfld.long 0x00 25.--28. " FIFO_OUT_AF_SIZE  ,fifo_out almost full threshold  defines the number of words in the output fifo above which dtc stops fetching data" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 21.--24. "        FIFO_OUT_AE_SIZE ,fifo_out almost empty threshold  defines the number of words in the output fifo below which dtc fetches more data" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 17.--20. "      FIFO_IN_AF_SIZE ,fifo_in almost full threshold  defines the number of words in the input fifo above which dtc stops fetching data" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 13.--16. "  FIFO_IN_AE_SIZE ,fifo_in almost empty threshold  defines the number of words in the input fifo below which dtc fetches more data" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        textline "                                    "
        bitfld.long 0x00 5. "CHN_START         ,start processing configuration  1 = start  0 = do not start" "0,1"
        bitfld.long 0x00 4. "         DONEINDICATION   ,done indication  1 = indicates cee has occurred  0 = indicates cee has not occurred  this bit is cleared by hardware when dtc starts to process the chain and is set to 1 when chain processing has completed." "0,1"
        bitfld.long 0x00 2.--3. "       CHN_CEE         ,chain end event  0x0 = no action – dtc continues to operate as usual  0x1 = cpu interrupt  0x2 = trigger edch tx-path  0x3 = cpu interrupt and trigger edch tx-path  regardless of the mode used above, the done bit is set by dtc once it is done." "0,1,2,3"
        bitfld.long 0x00 1. "   CHN_F8_F9       ,f8/f9 selector  0 = f9  1 = f8" "0,1"
        textline "                                    "
        bitfld.long 0x00 0. "CHN_DIR           ,direction  this field defines the direction of data (for cipher).  0 = ul  1 = dl" "0,1"

group d:0xD4285010++0x03
    line.long 0x00 "DTC_DOCR_SW_BYPASS,DTC Software Bypass Register"
        bitfld.long 0x00 12. " BNDRY_EN          ,boundary enable  control of dtc special handling of memory accesses that cross the 4k boundary.  0 = enable boundary handling  1 = disable boundary handling" "0,1"
        bitfld.long 0x00 11. "         CK_BE_LE_SEL     ,ciphering key big/little endian selection  this field selects the ck data endianity.  0 = little endian  1 = big endian" "0,1"
        bitfld.long 0x00 10. "       SW_OVR          ,software override  0 = dtc clocks according to the <hardware enable> field  1 = dtc clocks are always on" "0,1"
        bitfld.long 0x00 9. "   HW_EN           ,hardware enable  0 = disable automatic control of dtc clocks  1 = enable clocks activation automatically" "0,1"
        textline "                                    "
        bitfld.long 0x00 8. "TEST_EN           ,test mux enable" "0,1"
        bitfld.long 0x00 5.--7. "         TEST_MUX_SEL     ,test mux selection  this field is used to configure the dtc test mux." "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 4. "       EHT             ,edch hardware trigger  0 = don’t generate hardware trigger / clear existing trigger  1 = generate a hardware trigger to edch hardware  generating a trigger involves 2 writes to this bit: first write 0 to clear eht and then write 1 to generate the trigg" "0,1"
        bitfld.long 0x00 3. "   EHT_EN          ,edch hardware trigger enable  0 = eht disabled, edch hardware is triggered by dtc (depending upon the cee configuration) when processing a chain is complete  1 = eht enabled, the dtc generates a hardware trigger to the e-dch encoder when 1 is written to eht" "0,1"
        textline "                                    "
        bitfld.long 0x00 2. "SWM               ,software direct access mode  when this mode is on, software can write to the internal dtc descriptor registers and fifos. the dtc operates as usual while the dtc’s dma operation is bypassed by software read/writes.  0 = off  1 = on" "0,1"
        bitfld.long 0x00 1. "         SSC              ,single step continue  0 = don’t continue  1 = continue  after handling each descriptor, the dtc stops automatically and generates the cee. to continue processing with the next descriptor, set this bit to 1.  the dtc hardware resets this bit each time it starts to process a new descriptor." "0,1"
        bitfld.long 0x00 0. "       SSM             ,single step mode  if this mode is activated, the dtc generates the cee after handling each descriptor in the chain (used mainly for software debug mode).  0 = ssm off  1 = ssm on" "0,1"

group d:0xD4285020++0x03
    line.long 0x00 "DTC_F8_DTCCR_NDP,F8 Next Descriptor Pointer Register"
        hexmask.long 0x00 0.--31. 1. " DTCCR_NDP         ,next descriptor pointer  f8_ndp pointer to the next descriptor – assumes that the descriptors are 256-bit aligned.  default = 0, alignment = 256"

group d:0xD4285024++0x03
    line.long 0x00 "DTC_F8_DTCCR_SA,F8 Source Address Register"
        hexmask.long 0x00 0.--31. 1. " DTTCR_SA80        ,f8 source address  f8_sa pointer to the source data address  default = 0"

group d:0xD4285028++0x03
    line.long 0x00 "DTC_F8_DTCCR_DA,F8 Destination Address Register"
        hexmask.long 0x00 0.--31. 1. " DTTCR_DA          ,f8 destination address  f8_da pointer to the destination address  default = 0"

group d:0xD428502C++0x03
    line.long 0x00 "DTC_F8_DTCCR_CONTROL,F8 Control Register"
        bitfld.long 0x00 30. " F8_RCS            ,f8 retain cipher state  this flag indicates if the cipher state should be retained between configurations.  1 = retain state  0 = do not retain state  always clear this bit for the last descriptor in a chain (pointing to null).  set this bit for a descriptor in which the cipher state should be retained (the first descriptor that is not in retain state should have f8_rcs = 0).  if rcs is set, software must send the same cipher configuration parameters as in the first descriptor.  default = 0" "0,1"
        bitfld.long 0x00 29. "         F8_CB            ,f8 cipher bypass  this flag indicates if the cipher is to be bypassed or not. in bypass mode, the bits are passed from source to destination without ciphering.  1 = cipher bypass on  0 = cipher bypass off (cipher data)" "0,1"
        bitfld.long 0x00 28. "       F8_CONT         ,f8 continuous output  this flag indicates if the continuous output mode is operating. in this mode, the f8_obo and destination address fields are ignored, and the dtc continues to write the output stream from the location it stopped in previous descriptor (address and bit).  1 = continue  0 = don’t continue  default = 0" "0,1"
        bitfld.long 0x00 24.--26. "   F8_CO           ,f8 cipher offset  this field indicates the number of bits that are passed from source to destination without passing ciphering.  the following values are allowed:  0x0 = no ciphering offset  0x1 = 4-bit ciphering offset  0x2 = 8-bit ciphering offset  0x3 = 12-bit ciphering offset  0x4 = 16-bit ciphering offset  0x5 = 20-bit ciphering offset  0x6 and 0x7 = reserved  default = 0x0" "0,1,2,3,4,5,6,7"
        textline "                                    "
        hexmask.long.byte 0x00 16.--21. 1. "F8_BEARER         ,f8 radio bearer  radio bearer id parameter for f8  range [1..32]  this value minus 1 is used as bearer in the ciphering algorithm (input to kasumi algorithm is 5 bit [0..31]).   default = 0"
        hexmask.long.word 0x00 0.--15. 1. "        F8_LEN           ,f8 total bit length  including cipher offset bits, not including the header data size  range: 1 - 20000 bit  default = 0"

group d:0xD4285030++0x03
    line.long 0x00 "DTC_F8_DTCCR_HEADER_DATA,F8 Header Register"
        bitfld.long 0x00 28.--31. " F8_HDR_SIZE       ,f8 header size  this field indicates the size of the header data in bits.  0x0 = indicates not to insert any header  0x1 = 4  0x2 = 6  0x3 = 8  0x4 = 12  0x5 = 14  0x6 = 16  0x7 = 20  0x8 = 22  0x9 to 0xf = reserved  default = 0" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        hexmask.long.tbyte 0x00 0.--22. 1. "        F8_HDR_DATA      ,f8 total bit length  including cipher offset bits, not including the header data size  range: 1 - 20000 bit  default = 0"

group d:0xD4285034++0x03
    line.long 0x00 "DTC_F8_DTCCR_BIT_OFFSET,F8 Bit Offset Register"
        hexmask.long.word 0x00 16.--31. 1. " F8_IBO            ,f8 input bit offset  range 0 – 65535  default = 0"
        hexmask.long.word 0x00 0.--15. 1. "      F8_OBO           ,f8 output bit offset  range 0 – 65535  f8_obo range is limited to value of 0..7 when f8_cont = 1"

group d:0xD4285038++0x03
    line.long 0x00 "DTC_F8_DTCCR_COUNT_C,F8 Count C Register"
        hexmask.long 0x00 0.--31. 1. " F8_COUNTC         ,f8 count c  parameter for cipher.  default = 0"

group d:0xD428503C++0x03
    line.long 0x00 "DTC_F8_DTCCR_CK_ADDR,F8 CK Address Register"
        hexmask.long 0x00 0.--31. 1. " F8_CK_ADDR        ,f8 ck address  this field is used for the address of the ciphering key (ck). the dtc fetches the ck from this address if it does not have a ck from this memory already stored.  the ck must be aligned in memory to 256 bit.  default = 0"

group d:0xD4285020++0x03
    line.long 0x00 "DTC_F9_DTCCR_NDP,F9 Next Descriptor Pointer Register"

group d:0xD4285024++0x03
    line.long 0x00 "DTC_F9_DTCCR_SA,F9 Source Address Register"
        hexmask.long 0x00 0.--31. 1. " DTTCR_SA159       ,f9 source address  f9_sa pointer to the source data address  default = 0"

group d:0xD4285028++0x03
    line.long 0x00 "DTC_F9_DTCCR_DA,F9 Destination Address Register"
        hexmask.long.tbyte 0x00 0.--18. 1. " F9_LEN            ,f9 total bit length  range 0.. 524287  default = 0"

group d:0xD428502C++0x03
    line.long 0x00 "DTC_F9_DTCCR_Control,F9 Control Register"
        hexmask.long 0x00 0.--31. 1. " F9_FRESH          ,f9 fresh parameter  f9 fresh parameter for cipher  default = 0"

group d:0xD4285030++0x03
    line.long 0x00 "DTC_F9_DTCCR_HEADER_DATA,F9 Header Data Register"
        hexmask.long 0x00 0.--31. 1. " F9_COUNTI         ,f9 count-i parameter  f9_counti count-i parameter for cipher  default = 0"

group d:0xD4285034++0x03
    line.long 0x00 "DTC_F9_DTCCR_BIT_OFFSET,F9 Bit Offset Register"
        hexmask.long 0x00 0.--31. 1. " F9_IK_ADDR        ,f9 ik address  this field is used for the address of the integrity key (ik).  the dtc fetches the ik from this address if it does not have an ik of this memory already stored.  the ik must be aligned in memory to 256 bit.  default = 0"

group d:0xD4285038++0x03
    line.long 0x00 "DTC_F9_DTCCR_COUNT_C,F9 Count C Register"
        hexmask.long.word 0x00 0.--15. 1. " F9_IBO            ,f9 input bit offset  range 0 - 65535  default = 0"

group d:0xD4285050++0x03
    line.long 0x00 "DTC_CKIK_1,Ciphering Key Register 1"
        hexmask.long 0x00 0.--31. 1. " DTC_CKIK_1        ,dtc_ckik_1  bits [31:0] of ck/ik  default = 0x00000000"

group d:0xD4285054++0x03
    line.long 0x00 "DTC_CKIK_2,Ciphering Key Register 2"
        hexmask.long 0x00 0.--31. 1. " DTC_CKIK_2        ,dtc_ckik_2  bits [63:32] of ck/ik  default = 0x00000000"

group d:0xD4285058++0x03
    line.long 0x00 "DTC_CKIK_3,Ciphering Key Register 3"
        hexmask.long 0x00 0.--31. 1. " DTC_CKIK_3        ,dtc_ckik_3  bits [95:64] of ck/ik  default = 0x00000000"

group d:0xD428505C++0x03
    line.long 0x00 "DTC_CKIK_4,Ciphering Key Register 4"
        hexmask.long 0x00 0.--31. 1. " DTC_CKIK_4        ,dtc_ckik_4  bits [127:96] of ck/ik  default = 0x00000000"

group d:0xD4285060++0x03
    line.long 0x00 "DTC_DISR_REG,DTC Interrupt Status Register"
        bitfld.long 0x00 5. " FOFFIFOOUTFULL    ,fof fifo out full  to be used in software mode to indicate to software that the output fifo is full.  dtc generates an interrupt on the active channel (channel 0 or 1) once the output fifo is full and sets this bit to high, and then this bit will be set to low by dtc once the fifo is not empty.  in software mode, the software should fill the input fifo (full size) and then wait for fof interrupt to read the results. if the block size is smaller than the input fifo size, software should pad with ‘0’ to reach input fifo size.  default = 0" "0,1"
        bitfld.long 0x00 4. "         MP_ERR1          ,mp_err1  error in memory protection on channel 1  default = 0" "0,1"
        bitfld.long 0x00 3. "       MP_ERR0         ,mp_err0  error in memory protection on channel 0  default = 0" "0,1"
        bitfld.long 0x00 2. "   MERR1           ,merr1  error on dtc master bus while processing channel 1  default = 0" "0,1"
        textline "                                    "
        bitfld.long 0x00 1. "MERR0             ,merr0  error on dtc master bus while processing channel 0  default = 0" "0,1"
        bitfld.long 0x00 0. "         SERR             ,serr  error on dtc slave bus.  default = 0" "0,1"

group d:0xD4285070++0x03
    line.long 0x00 "DTC_MAC_I0_REG0,DTC_MACI_Ch0/1 Register"

group d:0xD4285074++0x03
    line.long 0x00 "DTC_MAC_I0_REG1,DTC_MACI_Ch0/1 Register"
        hexmask.long 0x00 0.--31. 1. " DTC_MAC_I0_1_REG  ,dtc_mac_i0/1_reg  32-bit result of f9 for channel 0/1"

group d:0xD4285080++0x03
    line.long 0x00 "DTC_MPR_HIGHn_ADDR0,High Address Range Registers"

group d:0xD4285088++0x03
    line.long 0x00 "DTC_MPR_HIGHn_ADDR1,High Address Range Registers"

group d:0xD4285090++0x03
    line.long 0x00 "DTC_MPR_HIGHn_ADDR2,High Address Range Registers"
        hexmask.long 0x00 0.--31. 1. " DTC_MPR0_HIGH     ,dtc_mprn_high  32-bit address indicating high address range"

group d:0xD4285084++0x03
    line.long 0x00 "DTC_MPR_LOWn_ADDR0,Low Address Range Registers"

group d:0xD428508C++0x03
    line.long 0x00 "DTC_MPR_LOWn_ADDR1,Low Address Range Registers"

group d:0xD4285094++0x03
    line.long 0x00 "DTC_MPR_LOWn_ADDR2,Low Address Range Registers"
        hexmask.long 0x00 0.--31. 1. " DTC_MPR0_LOW      ,dtc_mprn_low  32 bit address indicating low address range"

group d:0xD42850A0++0x03
    line.long 0x00 "DTC_READ,DTC Read Register"
        hexmask.long 0x00 0.--31. 1. " DRAR              ,read address  this field contains the address that the dtc attempted to read at the time the error interrupt (mpr or bus error) occurred.  0x00000000 indicates that the error was not caused by read."

group d:0xD42850A4++0x03
    line.long 0x00 "DTC_WRITE,DTC Write Register"
        hexmask.long 0x00 0.--31. 1. " DWAR              ,write address  this field contains the address that the dtc attempted to write to at the time the error interrupt (mpr or bus error) occurred.  0x00000000 indicates that the error was not caused by write."

group d:0xD42850C0++0x03
    line.long 0x00 "DTC_FIFO_READ,DTC FIFO Read Address Register"
        hexmask.long 0x00 0.--31. 1. " DTC_FIFO_READ     ,fifo read address"

group d:0xD42850C0++0x03
    line.long 0x00 "DTC_FIFO_WRITE,DTC FIFO Write Address Register"
        hexmask.long 0x00 0.--31. 1. " DTC_FIFO_WRITE    ,fifo write address"

tree.end

tree "geu"

width 28.

group d:0xD4292800++0x03
    line.long 0x00 "GEU_STATUS,GEU Status Register"

group d:0xD4292804++0x03
    line.long 0x00 "GEU_CONFIG,GEU Configuration Register"
        bitfld.long 0x00 30. " STICKY_CONTROL_BIT       ,sticky control bit  software lock bit  when this bit is set to 1, the block 0/5/6 cannot be programmed, and this bit is sticky so that during the reset cycle, software can only set it one time and cannot set it back to 0." "0,1"
        bitfld.long 0x00 28. "         FUSE_POWER_BYPASS      ,fuse power regulator bypass  0 = don't use the power from fuse power regulator  1 = use the power from fuse power regulator" "0,1"
        bitfld.long 0x00 25.--27. "     FUSE_CLOCK_DIVIDER ,clock divider value  the clock divider value is used to select the clock frequency of the fuse serial clockclk_div_val==3'h0 ? 13'h1fff :     //div by 8191 (max divider value)          clk_div_val==3'h1 ? 13'h1388 :     //div by 5000) 208m          clk_div_val==3'h2 ? 13'h1388 :     //div by 5000) 208m          clk_div_val==3'h3 ? 13'h0ea6 :     //div by 3750) 156m          clk_div_val==3'h4 ? 13'h09c4 :     //div by 2500104m          clk_div_val==3'h5 ? 13'h06fc :     //div by 1778 74m          clk_div_val==3'h6 ? 13'h06fc :     //div by 1778 74m          div_clk_cntr;  // programmable in aes_rf _28f8" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 23. "  FUSE_CLOCK_DISABLE ,fuse clock disable  0 = enable fuse block clock  1 = disable fuse block clock" "0,1"
        textline "                                      "
        bitfld.long 0x00 22. "FUSE_SOFTWARE_RESET      ,fuse software reset  0 = fuse software reset is de-asserted  1 = fuse software reset is asserted" "0,1"
        bitfld.long 0x00 18.--21. "         FUSE_BLOCK_NUMBER      ,fuse block number  select fuse block during fuse value programming. there are 16 x 256-bit fuse blocks in the <var product number>. during fuse value programming, allow software to program one fuse block at a time. the settings, fuse blocks, and their contents correspond to those described in the generic encryption fuse layout." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 17. "    HIGH_VOLT_ENABLE   ,high volt enable  1 = enable the on-chip fuse power regulator to generate 2.5v for fuse programming  it takes about 1 ms for the fuse power regulator to output stable power after this field is set." "0,1"
        bitfld.long 0x00 16. "  BURN_FUSE_ENABLE   ,burn fuse enable  1 = enable fuse programming" "0,1"
        textline "                                      "
        bitfld.long 0x00 15. "FUSE_LOCK                ,fuse lock  1 = enable fuse locking feature" "0,1"
        bitfld.long 0x00 14. "         ENABLE_SOFT_FUSE_PROG  ,enable software fuse programming  1 = enable software fuse programming interface" "0,1"
        bitfld.long 0x00 13. "     SEL_FUSE_B         ,select to burning fuse b block if this bit is set to 0x1." "0,1"

group d:0xD4292820++0x03
    line.long 0x00 "BCM_CONFIG_0,BCM Config 0 Register"
        bitfld.long 0x00 20.--22. " BROM_RTC                 ,bcm brom rtc" "0,1,2,3,4,5,6,7"

group d:0xD4292824++0x03
    line.long 0x00 "BCM_CONFIG_1,BCM Config 1 Register"
        bitfld.long 0x00 31. " ROM_SECURE_EN            ,rom secure enable  when this bit and the global secure enable are set, rom access is secure.  only the secure axi transaction can access secure rom data. otherwise, it is disabled." "0,1"
        bitfld.long 0x00 8. "         ROM_CLK_GATING_CTRL    ,rom clock gating control  1 = rom clock is enabled" "0,1"
        bitfld.long 0x00 5.--7. "     ROM_WAIT_STATE     ,rom wait state  inserted number of waiting cycles during rom access" "0,1,2,3,4,5,6,7"

group d:0xD4292838++0x03
    line.long 0x00 "GEU_FUSE_PROG_VAL1,Fuse Programming Value[127:0] in Software Fuse Programming Mode Register"
        hexmask.long 0x00 0.--31. 1. " FUSE_3_0_31_0            ,fuse programming value[127:0]"

group d:0xD4292848++0x03
    line.long 0x00 "GEU_FUSE_PROG_VAL2,Fuse Programming Value[255:128] in Software Fuse Programming Mode Register"
        hexmask.long 0x00 0.--31. 1. " FUSE_7_4_31_0            ,fuse programming value[255:128]"

group d:0xD4292904++0x03
    line.long 0x00 "GEU_FUSE_VAL_APCFG1,Fuse Value for Application Subsystem Config Register 1"
        hexmask.long.word 0x00 16.--31. 1. " OTP_APP_TOP_CONFIG_15_0  ,fuse value for application subsystem configuration [15:0]"
        hexmask.long.word 0x00 0.--15. 1. "      OTP_CP_TOP_CONFIG_15_0 ,fuse value for communication subsystem configuration [15:0]"

group d:0xD4292908++0x03
    line.long 0x00 "GEU_FUSE_VAL_APCFG2,Fuse Value for Application Subsystem Config Register 2"
        hexmask.long 0x00 0.--31. 1. " OTP_APP_TOP_CONFIG_47_16 ,fuse value for application subsystem configuration [47:16]"

group d:0xD429290C++0x03
    line.long 0x00 "GEU_FUSE_VAL_APCFG3,Fuse Value for Application Subsystem Config Register 3"
        hexmask.long 0x00 0.--31. 1. " OTP_APP_TOP_CONFIG_79_48 ,fuse value for application subsystem configuration [79:48]"

group d:0xD4292910++0x03
    line.long 0x00 "GEU_FUSE_MANU_PARA_1,Manufacturing Parameters [31:0] Register"
        hexmask.long 0x00 0.--31. 1. " MANU_PARA_31_0           ,fuse value for manufacturing parameters [31:0]"

group d:0xD4292914++0x03
    line.long 0x00 "GEU_FUSE_MANU_PARA_2,Manufacturing Parameters [63:32] Register"
        hexmask.long 0x00 0.--31. 1. " MANU_PARA_63_32          ,fuse value for manufacturing parameters [63:32]"

group d:0xD4292918++0x03
    line.long 0x00 "GEU_FUSE_MANU_PARA_3,Manufacturing Parameters [95:64] Register"
        hexmask.long 0x00 0.--31. 1. " MANU_PARA_95_64          ,fuse value for manufacturing parameters [95:64]"

group d:0xD429291C++0x03
    line.long 0x00 "GEU_FUSE_MANU_PARA_4,Manufacturing Parameters [127:96] Register"
        hexmask.long 0x00 0.--31. 1. " MANU_PARA_127_96         ,fuse value for manufacturing parameters [127:96]"

group d:0xD4292920++0x03
    line.long 0x00 "GEU_FUSE_MANU_PARA_5,Manufacturing Parameters [159:128] Register"
        hexmask.long 0x00 0.--31. 1. " MANU_PARA_159_128        ,fuse value for manufacturing parameters [159:128]"

group d:0xD4292924++0x03
    line.long 0x00 "GEU_FUSE_VAL_ROOT_KEY1,Fuse Value for Root Key Register 1"
        hexmask.long 0x00 0.--31. 1. " RKEY_31_0                ,fuse value for root key[31:0]"

group d:0xD4292928++0x03
    line.long 0x00 "GEU_FUSE_VAL_ROOT_KEY2,Fuse Value for Root Key Register 2"
        hexmask.long 0x00 0.--31. 1. " RKEY_63_32               ,fuse value for root key[63:32]"

group d:0xD429292C++0x03
    line.long 0x00 "GEU_FUSE_VAL_ROOT_KEY3,Fuse Value for Root Key Register 3"
        hexmask.long 0x00 0.--31. 1. " RKEY_95_64               ,fuse value for root key[95:64]"

group d:0xD4292930++0x03
    line.long 0x00 "GEU_FUSE_VAL_ROOT_KEY4,Fuse Value for Root Key Register 4"
        hexmask.long 0x00 0.--31. 1. " REKY_127_96              ,fuse value for root key[127:96]"

group d:0xD4292934++0x03
    line.long 0x00 "GEU_FUSE_VAL_ROOT_KEY5,Fuse Value for Root Key Register 5"
        hexmask.long 0x00 0.--31. 1. " RKEY_159_128             ,fuse value for root key[159:128]"

group d:0xD4292938++0x03
    line.long 0x00 "GEU_FUSE_VAL_ROOT_KEY6,Fuse Value for Root Key Register 6"
        hexmask.long 0x00 0.--31. 1. " RKEY_191_160             ,fuse value for root key[191:160]"

group d:0xD429293C++0x03
    line.long 0x00 "GEU_FUSE_VAL_ROOT_KEY7,Fuse Value for Root Key Register 7"
        hexmask.long 0x00 0.--31. 1. " RKEY_223_192             ,fuse value for root key[223:192]"

group d:0xD4292940++0x03
    line.long 0x00 "GEU_FUSE_VAL_ROOT_KEY8,Fuse Value for Root Key Register 8"
        hexmask.long 0x00 0.--31. 1. " RKEY_255_224             ,fuse value for root key[255:224]"

group d:0xD4292944++0x03
    line.long 0x00 "GEU_FUSE_VAL_SSK_1_8,Fuse Value for Secret Symmetric Key SSK 1- 8"
        hexmask.long 0x00 0.--31. 1. " OTP_SSK_31_0             ,fuse value for ssk [31:0]"

group d:0xD4292964++0x03
    line.long 0x00 "GEU_FUSE_VAL_OEM_BANK6_1_8,Fuse Value for BANK6 1- 8"
        hexmask.long 0x00 0.--31. 1. " FUSE_BANK6               ,fuse value for bank6[31:0]"

group d:0xD4292984++0x03
    line.long 0x00 "GEU_FUSE_STATUS,Fuse Operation Status Register"
        hexmask.long.word 0x00 14.--29. 1. " LOCK_BIT                 ,fuse lock bit  this field records the 16 fuse lock bits for 16 fuse blocks. bit [0] is for block 0, bit [1] is for block 1…bit [15] is for block 15."
        hexmask.long.word 0x00 2.--13. 1. "      LIFE_CYCLE             ,life cycle fuse bits  there are 12-bit fuse bits for life cycle."
        bitfld.long 0x00 1. "  GE_FUSE_READY205   ,fuse ready  1 = fuse value is stable and ready to be read" "0,1"
        bitfld.long 0x00 0. "  FUSE_BURN_DONE     ,fuse burn done  1 = fuse write process is done" "0,1"

group d:0xD4292988++0x03
    line.long 0x00 "DRNG_DATA,Digital Random Data Register"
        hexmask.long 0x00 0.--31. 1. " DRNG_DATA                ,digital random data from drng"

group d:0xD4292990++0x03
    line.long 0x00 "GEU_FUSE_VAL_BANK7_1_8,Fuse Value for BANK7 1- 8"
        hexmask.long 0x00 0.--31. 1. " FUSE_BANK7               ,fuse value for bank7[31:0]"

group d:0xD4292A00++0x03
    line.long 0x00 "GEU_FUSE_VAL_BANK8_1_8,Fuse Value for BANK8 1- 8"
        hexmask.long 0x00 0.--31. 1. " FUSE_BANK8               ,fuse value for bank8[31:0]"

group d:0xD4292A20++0x03
    line.long 0x00 "GEU_FUSE_VAL_BANK9_1_8,Fuse Value for BANK9 1- 8"
        hexmask.long 0x00 0.--31. 1. " FUSE_BANK9               ,fuse value for bank9[31:0]"

group d:0xD4292A40++0x03
    line.long 0x00 "GEU_FUSE_VAL_BANK10_1_8,Fuse Value for BANK10 1- 8"
        hexmask.long 0x00 0.--31. 1. " FUSE_BANK10              ,fuse value for bank10[31:0]"

group d:0xD4292A60++0x03
    line.long 0x00 "GEU_FUSE_VAL_BANK11_1_8,Fuse Value for BANK11 1- 8"
        hexmask.long 0x00 0.--31. 1. " FUSE_BANK11              ,fuse value for bank11[31:0]"

group d:0xD4292A80++0x03
    line.long 0x00 "GEU_FUSE_VAL_CDPKH_1_8,Fuse Value for BANK3 Chip Debug Public Key Hash CDPKH1- 8"
        hexmask.long 0x00 0.--31. 1. " FUSE_BANK3_CDPKH         ,fuse value for bank3 chip debug public key hash cdpkh[31:0]"

group d:0xD4292AA0++0x03
    line.long 0x00 "GEU_FUSE_VAL_ROTPKH_1_8,Fuse Value for BANK4  Root of Trust Public Key Hash ROTPKH1- 8"
        hexmask.long 0x00 0.--31. 1. " FUSE_BANK4_ROTPKH        ,fuse value for bank4  root of trust public key hash rotpkh[31:0]"

group d:0xD4292AC0++0x03
    line.long 0x00 "GEU_FUSE_VAL_ARCN_1_8,Fuse Value for BANK5 ARCN 1- 8"
        hexmask.long 0x00 0.--31. 1. " FUSE_BANK5_ARCN          ,fuse value for bank5 arcn[31:0]"

group d:0xD4292BFC++0x03
    line.long 0x00 "FUSE_SCLK_DIV_CNTR,Fuse Slow Clock Divider Counter Register"
        hexmask.long.word 0x00 0.--12. 1. " FUSE_SCLK_DIV_CNTR       ,fuse sclk divider counter  the clock divider value is used to manually define clock frequency of the fuse serial clock.  sclk = wtm clk /this value. it only takes effect when geu_config[27:25] = 0x7"

tree.end

tree "gpbaux"

width 22.

group d:0xF0240000++0x03
    line.long 0x00 "COEL_GPB_MON_MUX,Monitor Mux Register"
        bitfld.long 0x00 13.--14. " SPARE1_TP_SEL              ,spare1_tp_sel  this field controls the specific signal that is output to the coel_spare1_tp test point, according to the values below.  0x0 = m1_ds32_cli_obs_0 output to coel_spare1_tp  0x1 = m1_ds32_cli_obs_1 output to coel_spare1_tp  0x2 = m1_ds32_c" "0,1,2,3"
        bitfld.long 0x00 12. "         SW_JTAG                  ,sw vs. jtag control  0x1 = jtag controls the monitor mux and the signal sent to coel_spare1_tp  0x0 = sw_mon_mux controls the monitor mux and the signal sent to coel_spare1_tp" "0,1"
        bitfld.long 0x00 9.--11. "   SW_MON_MUX3               ,sw_mon_mux3  if software controls the monitor mux of test points [31:24], then this field determines which signals are output to the pads as follows:  0x0 = wb modem tp outputs to the pads  0x1 = gsm apb tp outputs to the pads  0x2 = gsm gpb tp output" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 6.--8. "  SW_MON_MUX2             ,sw_mon_mux2  if software controls the monitor mux of test points [23:16], then this field determines which signals are output to the pads as follows:  0x0 = wb modem tp outputs to the pads  0x1 = gsm apb tp outputs to the pads  0x2 = gsm gpb tp output" "0,1,2,3,4,5,6,7"
        textline "                                "
        bitfld.long 0x00 3.--5. "SW_MON_MUX1                ,if software controls the monitor mux of test points [15:8], then this field determines which signals are output to the pads as follows:  0x0 = wb modem tp outputs to the pads  0x1 = gsm apb tp outputs to the pads  0x2 = gsm gpb tp outputs to the pads<p" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 0.--2. "         SW_MON_MUX0              ,sw_mon_mux0  if software controls the monitor mux of test points [7:0], then this field determines which signals are output to the pads as follows:  0x0 = wb modem tp outputs to the pads  0x1 = gsm apb tp outputs to the pads  0x2 = gsm gpb tp outputs" "0,1,2,3,4,5,6,7"

group d:0xF0240004++0x03
    line.long 0x00 "C2DM,C2 DMA Muxing Register"
        hexmask.long 0x00 0.--31. 1. " C2DM                       ,dma muxing"

group d:0xF0240008++0x03
    line.long 0x00 "DMAC2_EOCINH_WR,DMAC 2 EOC Inhibit Register"
        hexmask.long 0x00 0.--31. 1. " DMAC2_EOCINH_WR            ,dmac 2 eoc inhibit"

group d:0xF024000C++0x03
    line.long 0x00 "COEL_GPB_CONTROL,GPB Control Register"
        bitfld.long 0x00 3.--7. " EXT_GPB_CYCLE              ,external gpb cycle  sets the number of cycles for an external gpb clock cycle" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"
        bitfld.long 0x00 2. "        EXT_GPB_CLK              ,external gpb clock  chicken bit for external clock" "0,1"
        bitfld.long 0x00 0.--1. "   EXT_GPB_MODE              ,external gpb mode  0x1 = monitor  0x3 = ext r/w" "0,1,2,3"

group d:0xF0240010++0x03
    line.long 0x00 "COEL_GPB_AFE_CONTROL,GPB AFE Control Register"
        bitfld.long 0x00 13. " WB_PAD_CONTROL_OUT_SEL     ,wb_pad_control_out_sel  0x0 = pad (default)  0x1 = wb" "0,1"
        bitfld.long 0x00 12. "         WB_PAD_CONTROL_IN_SEL    ,wb_pad_control_in_sel  0x0 = pad (default)  0x1 = gilint" "0,1"
        bitfld.long 0x00 11. "   WB_PAD_IQ_RX_SEL          ,wb_pad_iq_rx_sel  0x0 = pad (default)  0x1 = wb" "0,1"
        bitfld.long 0x00 10. "  WB_PAD_IQ_TX_SEL        ,wb_pad_iq_tx_sel  0x0 = wb (default)  0x1 = pad" "0,1"
        textline "                                "
        bitfld.long 0x00 0. "LEGACY_DIGRF_GILINT_SELECT ,legacy_digrf_gilint_select  this field controls the digrf module mux, primary, and diversity.  0x0 = selects legacy  0x1 = selects digrf  0x2 = selects gilint  0x3 = coel outputs 0x0000" "0,1"
        bitfld.long 0x00 0. "         AFE_CONTROL_SPARE        ,afe control spare bits" "0,1"
        bitfld.long 0x00 3. "   DIG_ANA_INT               ,digital/analog interface" "0,1"
        bitfld.long 0x00 0. "  AFE_TEST_MODE           ,afe test mode  0x0 = normal mode  0x1 = external afe  0x2 = afe test - input to afe  0x3 = afe test - output from afe" "0,1"
        textline "                                "
        bitfld.long 0x00 0. "SW_RESET_AFE               ,software reset for integrated afe" "0,1"

group d:0xF0240014++0x03
    line.long 0x00 "WB_AFE_SMP_CLK_CFG,WB AFE Sample Clock Configuration Register"
        bitfld.long 0x00 10.--11. " DIGGP_GSRAM_WTC67          ,grayback gsram wtc" "0,1,2,3"
        bitfld.long 0x00 8.--9. "         DIGGP_GSRAM_RTC68        ,grayback gsram rtc" "0,1,2,3"
        bitfld.long 0x00 3.--4. "   DIGGP_GSRAM_ROM_RTC_REF70 ,grayback l2 rom rtc ref" "0,1,2,3"
        bitfld.long 0x00 0.--2. "  DIGGP_GSRAM_ROM_RTC71   ,grayback l2 rom rtc" "0,1,2,3,4,5,6,7"

group d:0xF0240018++0x03
    line.long 0x00 "GPB_COEL_SPARE1,GPB Coel Spare1 Register"
        bitfld.long 0x00 5. " SEL_LSM_UART_TXMSG1_TRIG   ,select fb rx time signals or tx time signals to lsm_uart module  0 = rx   1 = tx" "0,1"
        bitfld.long 0x00 4. "         SEL_LSM_UART_TXMSG2_TRIG ,select fb rx time signals or tx time signals to lsm_uart module  0 = tx  1 = rx" "0,1"
        bitfld.long 0x00 3. "   MASK_FB_TX_TIME_SIG_SCC   ,mask fb_tx_time_sig_scc[12] to lsm_uart module  0 = masked  1 = not masked" "0,1"
        bitfld.long 0x00 2. "  MASK_FB_TX_TIME_SIG_PCC ,mask fb_tx_time_sig_pcc[12] to lsm_uart module  0 = masked  1 = not masked" "0,1"
        textline "                                "
        bitfld.long 0x00 1. "MASK_FB_RX_TIME_SIG_SCC    ,mask fb_rx_time_sig_scc[12] to lsm_uart module  0 = masked  1 = not masked" "0,1"
        bitfld.long 0x00 0. "         MASK_FB_RX_TIME_SIG_PCC  ,mask fb_rx_time_sig_pcc[12] to lsm_uart module  0 = masked  1 = not masked" "0,1"

group d:0xF024001C++0x03
    line.long 0x00 "GPB_COEL_SPARE2,GPB Coel Spare2 Register"
        bitfld.long 0x00 15. " FB_ENABLE_30P72M           ,clock enable of 30.72 mhz clock in fb sleep timer  1 = enable  0 = disable" "0,1"
        hexmask.long.byte 0x00 3.--9. 1. "         WTCRTC_DIGRF4            ,digrf4 memory control signals"
        bitfld.long 0x00 1. "  GSM_SW_RSTN_GPB           ,software reset of gsm gpb peripherals  0 = apply reset  1 = release reset" "0,1"
        bitfld.long 0x00 0. "  FB_SLEEP_EN             ,fb sleep enable/disable  0x1 = fb sleep enable   0x0 = fb sleep disable" "0,1"

tree.end

tree "gpbec"

width 8.

group d:0xF0202000++0x03
    line.long 0x00 "CIP_OB,E-Cipher Output Buffer Register"
        hexmask.long 0x00 0.--31. 1. " GPBEC_OUTPUT_BUFFER16 ,memory"

tree.end

tree "gpbcontrol"

width 20.

group d:0xF0204000++0x03
    line.long 0x00 "GPB_MON_CTRL,GPB Peripherals Monitor Control Register"
        bitfld.long 0x00 29.--31. " SEL                           ,select  selects 1 of 8 possible test point combinations" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 16. "   MEN                          ,global control for gpb peripheral monitor  0 = disable monitor  1 = enable monitor" "0,1"
        bitfld.long 0x00 12.--15. "   PMS3                            ,pms3  0x0 = viterbi decoder  0x1 = e-cipher  0x2 = dssp 0  0x3 = dssp 1  0x4 = dssp 2  0x5 = dssp 3  0x6 = hsl  0x7 = gssp<p>0x8 = mirq  0x9 = timers  0xa = equalizer  all other values are reserved." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 8.--11. "  PMS2                            ,pms2  0x0 = viterbi decoder  0x1 = e-cipher  0x2 = dssp 0  0x3 = dssp 1  0x4 = dssp 2  0x5 = dssp 3  0x6 = hsl  0x7 = gssp<p>0x8 = mirq  0x9 = timers  0xa = equalizer  all other values are reserved." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        textline "                              "
        bitfld.long 0x00 4.--7. "PMS1                          ,pms1  0x0 = viterbi decoder  0x1 = e-cipher  0x2 = dssp 0  0x3 = dssp 1  0x4 = dssp 2  0x5 = dssp 3  0x6 = hsl  0x7 = gssp<p>0x8 = mirq  0x9 = timers  0xa = equalizer  all other values are reserved." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 0.--3. "  PMS0                         ,pms0  0x0 = viterbi decoder  0x1 = e-cipher  0x2 = dssp 0  0x3 = dssp 1  0x4 = dssp 2  0x5 = dssp 3  0x6 = hsl  0x7 = gssp<p>0x8 = mirq  0x9 = timers  0xa = equalizer  all other values are reserved." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"

group d:0xF0204004++0x03
    line.long 0x00 "VIT_CLK_SELECT,Viterbi Clock Control Register"
        bitfld.long 0x00 4. " GPBMO_SW_RESET32              ,software reset  0 = normal operation (default)  1 = reset peripheral" "0,1"
        bitfld.long 0x00 2.--3. "   CLOCK_SELECT33               ,clock select  0x0 = 52 mhz  0x1 = 78 mhz  0x2 or 0x3 = 104 mhz" "0,1,2,3"
        bitfld.long 0x00 1. "   GPBMO_CLOCK_ENABLE34            ,clock enable  0 = off  1 = on (default)" "0,1"

group d:0xF0204008++0x03
    line.long 0x00 "EQU_CLK_SELECT,Equalizer Clock Control Register"
        bitfld.long 0x00 4. " GPBMO_SW_RESET43              ,software reset  0 = normal operation (default)  1 = reset peripheral" "0,1"
        bitfld.long 0x00 2.--3. "   CLOCK_SELECT44               ,clock select  0x0 = 52 mhz  0x1 = 78 mhz  0x2 or 0x3 = 104 mhz" "0,1,2,3"
        bitfld.long 0x00 1. "   GPBMO_CLOCK_ENABLE45            ,clock enable  0 = off  1 = on (default)" "0,1"

group d:0xF020400C++0x03
    line.long 0x00 "E_CIP_CLK_SELECT,E-Cipher Clock Control Register"
        bitfld.long 0x00 4. " GPBMO_SW_RESET54              ,software reset  0 = normal operation (default)  1 = reset peripheral" "0,1"
        bitfld.long 0x00 2.--3. "   CLOCK_SELECT55               ,clock select  0x0 = 52 mhz  0x1 = 78 mhz  0x2 or 0x3 = 104 mhz" "0,1,2,3"
        bitfld.long 0x00 1. "   GPBMO_CLOCK_ENABLE56            ,clock enable  0 = off  1 = on (default)" "0,1"
        bitfld.long 0x00 0. "   26-MHZ_CLOCK_ENABLE             ,26-mhz clock enable  0 = off  1 = on" "0,1"

group d:0xF0204010++0x03
    line.long 0x00 "DSSP0_CLK_SELECT,DSSP 0 Clock Control Register"
        bitfld.long 0x00 4. " GPBMO_SW_RESET65              ,software reset  0 = normal operation (default)  1 = reset peripheral" "0,1"
        bitfld.long 0x00 2.--3. "   CLOCK_SELECT66               ,clock select  0x0 = 26 mhz  0x1 = 13 mhz  0x2 or 0x3 = 6.5 mhz" "0,1,2,3"
        bitfld.long 0x00 1. "   FUNCTIONAL_CLOCK_ENABLE67       ,functional clock enable  0 = off  1 = on (default)" "0,1"
        bitfld.long 0x00 0. "   GPBMO_BUS_CLOCK_ENABLE68        ,bus clock enable  0 = off  1 = on" "0,1"

group d:0xF0204014++0x03
    line.long 0x00 "DSSP1_CLK_SELECT,DSSP 1 Clock Control Register"
        bitfld.long 0x00 4. " GPBMO_SW_RESET76              ,software reset  0 = normal operation (default)  1 = reset peripheral" "0,1"
        bitfld.long 0x00 2.--3. "   CLOCK_SELECT77               ,clock select  0x0 = 26 mhz  0x1 = 13 mhz  0x2 or 0x3 = 6.5 mhz" "0,1,2,3"
        bitfld.long 0x00 1. "   FUNCTIONAL_CLOCK_ENABLE78       ,functional clock enable  0 = off  1 = on (default)" "0,1"
        bitfld.long 0x00 0. "   GPBMO_BUS_CLOCK_ENABLE79        ,bus clock enable  0 = off  1 = on" "0,1"

group d:0xF0204018++0x03
    line.long 0x00 "DSSP2_CLK_SELECT,DSSP 2 Clock Control Register"
        bitfld.long 0x00 4. " GPBMO_SW_RESET87              ,software reset  0 = normal operation (default)  1 = reset peripheral" "0,1"
        bitfld.long 0x00 2.--3. "   CLOCK_SELECT88               ,clock select  0x0 = 26 mhz  0x1 = 13 mhz  0x2 or 0x3 = 6.5 mhz" "0,1,2,3"
        bitfld.long 0x00 1. "   FUNCTIONAL_CLOCK_ENABLE89       ,functional clock enable  0 = off  1 = on (default)" "0,1"
        bitfld.long 0x00 0. "   GPBMO_BUS_CLOCK_ENABLE90        ,bus clock enable  0 = off  1 = on" "0,1"

group d:0xF020401C++0x03
    line.long 0x00 "DSSP3_CLK_SELECT,DSSP 3 Clock Control Register"
        bitfld.long 0x00 4. " GPBMO_SW_RESET98              ,software reset  0 = normal operation (default)  1 = reset peripheral" "0,1"
        bitfld.long 0x00 2.--3. "   CLOCK_SELECT99               ,clock select  0x0 = 26 mhz  0x1 = 13 mhz  0x2 or 0x3 = 6.5 mhz" "0,1,2,3"
        bitfld.long 0x00 1. "   FUNCTIONAL_CLOCK_ENABLE100      ,functional clock enable  0 = off  1 = on (default)" "0,1"
        bitfld.long 0x00 0. "   GPBMO_BUS_CLOCK_ENABLE101       ,bus clock enable  0 = off  1 = on" "0,1"

group d:0xF0204020++0x03
    line.long 0x00 "GSSP_CLK_CTRL,GSSP Clock Control Register"
        bitfld.long 0x00 9. " GPBMO_GSSP2_SW_RESET109       ,gssp2 software reset  0 = normal operation (default)  1 = reset peripheral" "0,1"
        bitfld.long 0x00 7.--8. "   GSSP2_CLOCK_SELECT           ,gssp2 clock select  0x0 = i2s clock  0x1 = sys clock  0x2 = external clock  0x3 = 26 mhz" "0,1,2,3"
        bitfld.long 0x00 6. "   GSSP2_FUNCTIONAL_CLOCK_ENABLE   ,gssp2 functional clock enable  0 = off  1 = on (default)" "0,1"
        bitfld.long 0x00 5. "   GPBMO_GSSP2_BUS_CLOCK_ENABLE112 ,gssp2 bus clock enable  0 = off  1 = on" "0,1"
        textline "                              "
        bitfld.long 0x00 4. "GPBMO_GSSP1_SW_RESET113       ,gssp1 software reset  0 = normal operation (default)  1 = reset peripheral" "0,1"
        bitfld.long 0x00 2.--3. "   GSSP1_CLOCK_SELECT           ,gssp1 clock select  0x0 = i2s clock  0x1 = sys clock  0x2 = external clock  0x3 = 26 mhz" "0,1,2,3"
        bitfld.long 0x00 1. "   GSSP1_FUNCTIONAL_CLOCK_ENABLE   ,gssp1 functional clock enable  0 = off  1 = on (default)" "0,1"
        bitfld.long 0x00 0. "   GSSP1_BUS_CLOCK_ENABLE116       ,gssp1 bus clock enable  0 = off  1 = on" "0,1"

group d:0xF0204024++0x03
    line.long 0x00 "TIMERS_CLK_CTRL,GPB Timers Clock Control Register"
        bitfld.long 0x00 4. " GPBMO_SW_RESET124             ,software reset  0 = normal operation (default)  1 = reset peripheral" "0,1"
        bitfld.long 0x00 1. "   FUNCTIONAL_CLOCK_ENABLE126   ,functional clock enable  0 = off  1 = on (default)" "0,1"
        bitfld.long 0x00 0. "   GPBMO_BUS_CLOCK_ENABLE127       ,bus clock enable  0 = off  1 = on" "0,1"

group d:0xF0204028++0x03
    line.long 0x00 "MIRQ_CLK_CTRL,MIRQ Clock Control Register"
        bitfld.long 0x00 4. " GPBMO_SW_RESET135             ,software reset  0 = normal operation (default)  1 = reset peripheral" "0,1"
        bitfld.long 0x00 0. "   FUNCTIONAL_CLOCK_ENABLE137   ,functional clock enable  0 = off  1 = on" "0,1"

group d:0xF020402C++0x03
    line.long 0x00 "HSL_CLK_CTRL,HSL Clock Control Register"
        bitfld.long 0x00 4. " GPBMO_SW_RESET145             ,software reset  0 = normal operation (default)  1 = reset peripheral" "0,1"
        bitfld.long 0x00 0. "   FUNCTIONAL_CLOCK_ENABLE147   ,functional clock enable  0 = off  1 = on" "0,1"

group d:0xF0204034++0x03
    line.long 0x00 "WB_WAKE_UP_TCU_CTL,WCDMA Wakeup TCU Control Register"
        bitfld.long 0x00 1. " GWBWAKESEL155                 ,gwbwakesel  this control goes to the wb macro." "0,1"
        bitfld.long 0x00 0. "   GWBSLPEQEN156                ,gwbslpeqen  this control goes to the wb macro." "0,1"

group d:0xF0204050++0x03
    line.long 0x00 "GMCGC,GMCGC"
        bitfld.long 0x00 31. " GWBWAKESEL163                 ,gwbwakesel  this control goes to the wb macro." "0,1"
        bitfld.long 0x00 30. "   GWBSLPEQEN164                ,gwbslpeqen  this control goes to the wb macro." "0,1"
        bitfld.long 0x00 21.--22. "   VITERBI_FUNC_CLOCK_SELECT       ,viterbi func clock select  0x0 = 52 mhz  0x1 = 78 mhz  0x2 = 104 mhz" "0,1,2,3"
        bitfld.long 0x00 19.--20. "   EQUALIZER_FUNC_CLOCK_SELECT     ,equalizer func clock select  00 = 52 mhz  01 = 78 mhz  0 = 104 mhz" "0,1,2,3"
        textline "                              "
        bitfld.long 0x00 17.--18. "E-CIPHER_FUNC_CLOCK_SELECT    ,e-cipher func clock select  0x0 = 52 mhz  0x1 = 78 mhz  0x2 = 104 mhz" "0,1,2,3"
        bitfld.long 0x00 15. "   DSSP0_FUNC_CLOCK_SELECT170   ,dssp 0 func clock select  0 = 26 mhz  1 = 13 mhz" "0,1"
        bitfld.long 0x00 14. "   DSSP1_FUNC_CLOCK_SELECT171      ,dssp 1 func clock select  0 = 26 mhz  1 = 13 mhz" "0,1"
        bitfld.long 0x00 13. "   DSSP2_FUNC_CLOCK_SELECT172      ,dssp 2 func clock select  0 = 26 mhz  1 = 13 mhz" "0,1"
        textline "                              "
        bitfld.long 0x00 12. "DSSP3_FUNC_CLOCK_SELECT173    ,dssp 3 func clock select  0 = 26 mhz  1 = 13 mhz" "0,1"
        bitfld.long 0x00 10. "   E-CIPHER_26-MHZ_CLOCK_ENABLE ,e-cipher 26-mhz clock enable  clock enable  0 = off  1 = on" "0,1"
        bitfld.long 0x00 9. "   E-CIPHER_FUNC_CLOCK_ENABLE      ,e-cipher func clock enable  clock enable  0 = off  1 = on" "0,1"
        bitfld.long 0x00 8. "   VITERBI_FUNC_CLOCK_ENABLE       ,viterbi func clock enable  0 = off  1 = on" "0,1"
        textline "                              "
        bitfld.long 0x00 7. "EQUALIZER_FUNC_CLOCK_ENABLE   ,equalizer func clock enable  0 = off  1 = on" "0,1"
        bitfld.long 0x00 6. "   DSSP3_FUNC_CLOCK_ENABLE      ,dssp 3 func clock enable  0 = off  1 = on" "0,1"
        bitfld.long 0x00 5. "   DSSP2_FUNC_CLOCK_ENABLE         ,dssp 2 func clock enable  0 = off  1 = on" "0,1"
        bitfld.long 0x00 4. "   DSSP1_FUNC_CLOCK_ENABLE         ,dssp 1 func clock enable  0 = off  1 = on" "0,1"
        textline "                              "
        bitfld.long 0x00 3. "DSSP0_FUNC_CLOCK_ENABLE       ,dssp 0 func clock enable  0 = off  1 = on" "0,1"
        bitfld.long 0x00 2. "   MIRQ_FUNC_CLOCK_ENABLE       ,mirq func clock enable  0 = off  1 = on" "0,1"
        bitfld.long 0x00 1. "   TCU_FUNC_CLOCK_ENABLE           ,tcu func clock enable  0 = off  1 = on" "0,1"

group d:0xF0204054++0x03
    line.long 0x00 "GMCGC_II,GMCGC_II"
        bitfld.long 0x00 16.--17. " GSSP2_FUNC_CLOCK_SELECT       ,gssp2 func clock select  0x0 = gssp i2s clk  0x1 = gssp sys clk  0x2 = gssp ext clk  0x3 = 26 mhz" "0,1,2,3"
        bitfld.long 0x00 15. "   GSSP2_FUNC_CLOCK_ENABLE      ,gssp2 func clock enable  0 = off  1 = on" "0,1"
        bitfld.long 0x00 14. "   GPBMO_GSSP2_BUS_CLOCK_ENABLE195 ,gssp2 bus clock enable  0 = off  1 = on" "0,1"
        bitfld.long 0x00 13. "   DSSP3_BUS_CLOCK_ENABLE          ,dssp 3 bus clock enable  0 = off  1 = on" "0,1"
        textline "                              "
        bitfld.long 0x00 12. "DSSP2_BUS_CLOCK_ENABLE        ,dssp 2 bus clock enable  0 = off  1 = on" "0,1"
        bitfld.long 0x00 11. "   DSSP1_BUS_CLOCK_ENABLE       ,dssp 1 bus clock enable  0 = off  1 = on" "0,1"
        bitfld.long 0x00 10. "   DSSP0_BUS_CLOCK_ENABLE          ,dssp 0 bus clock enable  0 = off  1 = on" "0,1"
        bitfld.long 0x00 9. "   TIMERS_BUS_CLOCK_ENABLE         ,timers bus clock enable  0 = off  1 = on" "0,1"
        textline "                              "
        bitfld.long 0x00 8. "TIMERS_FUNC_CLOCK_ENABLE      ,timers func clock enable  0 = off  1 = on" "0,1"
        bitfld.long 0x00 7. "   GSSP1_BUS_CLOCK_ENABLE202    ,gssp1 bus clock enable  0 = off  1 = on" "0,1"
        bitfld.long 0x00 6. "   GSSP1_FUNC_CLOCK_ENABLE         ,gssp1 func clock enable  0 = off  1 = on" "0,1"
        bitfld.long 0x00 5. "   DSSP0_FUNC_CLOCK_SELECT204      ,dssp 0 func clock select  0 = as configured in gmcgc  1 = 6.5 mhz" "0,1"
        textline "                              "
        bitfld.long 0x00 4. "DSSP1_FUNC_CLOCK_SELECT205    ,dssp 1 func clock select  0 = as configured in gmcgc  1 = 6.5 mhz" "0,1"
        bitfld.long 0x00 3. "   DSSP2_FUNC_CLOCK_SELECT206   ,dssp 2 func clock select  0 = as configured in gmcgc  1 = 6.5 mhz" "0,1"
        bitfld.long 0x00 2. "   DSSP3_FUNC_CLOCK_SELECT207      ,dssp 3 func clock select  0 = as configured in gmcgc  1 = 6.5 mhz" "0,1"
        bitfld.long 0x00 0.--1. "   GSSP1_FUNC_CLOCK_SELECT         ,gssp1 func clock select  0x0 = gssp i2s clk  0x1 = gssp sys clk  0x2 = gssp ext clk  0x3 = 26 mhz" "0,1,2,3"

group d:0xF0204070++0x03
    line.long 0x00 "BACKWARD_COMP_MODE,GPB Peripherals Backward Compatibility Select Control Register"
        bitfld.long 0x00 0. " BACKWARD_COMPATIBILITY_SELECT ,backward compatibility select  0 = work in new mode  1 = work in backward compatibility mode (default)" "0,1"

tree.end

tree "gpbeq"

width 14.

group d:0xF0200000++0x03
    line.long 0x00 "EQU_DEST_IBU,Equalizer Input Buffer Register"
        hexmask.long.word 0x00 22.--31. 1. " Q_SYMBOL ,q symbol value"
        hexmask.long.word 0x00 6.--15. 1. "  I_SYMBOL ,i symbol value"

tree.end

tree "gpbv"

width 10.

group d:0xF0201000++0x03
    line.long 0x00 "VD_OB,Viterbi Output Buffer on GPB Register"
        hexmask.long 0x00 0.--31. 1. " OUTPUT_BUFFER_ON_GPB ,read data from the output buffer."

group d:0xF0201004++0x03
    line.long 0x00 "VD_IB_RD,Viterbi Decoder Input Buffer on GPB Register"
        hexmask.long 0x00 0.--31. 1. " INPUT_BUFFER_READ    ,read data from the input buffer."

group d:0xF0201040++0x03
    line.long 0x00 "VD_IB,Viterbi Decoder Input Buffer Write Register"
        hexmask.long 0x00 0.--31. 1. " VD_IB                ,write to the input buffer."

tree.end

tree "gpioedge"

width 12.

group d:0xD4019800++0x03
    line.long 0x00 "GPIOE_RER0,GPIO Edge Read Register 0"
        hexmask.long 0x00 0.--31. 1. " EDGE_DET16 ,gpio port [31:0] edge detect (edge_det[31:0])  0 = no edge detected   1 = edge detected on the corresponding port"

group d:0xD4019804++0x03
    line.long 0x00 "GPIOE_RER1,GPIO Edge Read Register 1"
        hexmask.long 0x00 0.--31. 1. " EDGE_DET23 ,gpio port [63:32] edge detect (edge_det[63:32])  0 = no edge detected   1 = edge detected on the corresponding port"

group d:0xD4019808++0x03
    line.long 0x00 "GPIOE_RER2,GPIO Edge Read Register 2"
        hexmask.long 0x00 0.--31. 1. " EDGE_DET30 ,gpio port [95:64] edge detect (edge_det[95:64])  0 = no edge detected   1 = edge detected on the corresponding port"

group d:0xD401980C++0x03
    line.long 0x00 "GPIOE_RER3,GPIO Edge Read Register 3"
        hexmask.long 0x00 0.--31. 1. " EDGE_DET37 ,gpio port [127:96] edge detect (edge_det[127:96])  0 = no edge detected   1 = edge detected on the corresponding port"

tree.end

tree "gssp"

width 10.

group d:0xD023B00C++0x03
    line.long 0x00 "GSSP_GBS,GSSP Bus Select Register"
        bitfld.long 0x00 1. " GSSP2_GBS ,gssp2 bus select  this field selects which bus connects to the gssp.  0 = gpb (default)  1 = apb" "0,1"
        bitfld.long 0x00 0. "  GSSP1_GBS ,gssp1 bus select  this field selects which bus connects to the gssp.  0 = gpb (default)  1 = apb" "0,1"

tree.end

tree "ic"
tree "ic_usb controller"

width 22.

group d:0xD1050000++0x03
    line.long 0x00 "USB_ID,Identification Register"
        hexmask.long.byte 0x00 16.--23. 1. " US_REVISION25    ,revision number of the core"
        hexmask.long.byte 0x00 8.--13. 1. "        NID5_0         ,ones complement version of id[5:0]"
        hexmask.long.byte 0x00 0.--5. 1. "    US_ID29       ,configuration number  this number is set to 0x05 and indicates that the peripheral is the usb-hs usb 2.0 core."

group d:0xD1050004++0x03
    line.long 0x00 "USB_HWGENERAL,General Hardware Parameters Register"
        bitfld.long 0x00 9. " US_SM37          ,sm  reserved for internal testing" "0,1"
        bitfld.long 0x00 6.--8. "         US_PHYM38      ,phym  reserved for internal testing" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 4.--5. "     US_PHYW39     ,phyw  reserved for internal testing" "0,1,2,3"
        bitfld.long 0x00 3. "   US_BWT40     ,bwt  reserved for internal testing" "0,1"
        textline "                                "
        bitfld.long 0x00 1.--2. "US_CLKC41        ,clkc  reserved for internal testing" "0,1,2,3"
        bitfld.long 0x00 0. "         US_RT42        ,rt  reserved for internal testing" "0,1"

group d:0xD1050008++0x03
    line.long 0x00 "USB_HWHOST,Host Hardware Parameters Register"
        hexmask.long.byte 0x00 24.--31. 1. " US_TTPER49       ,ttper  reserved for internal testing"
        hexmask.long.byte 0x00 16.--23. 1. "        US_TTASY50     ,ttasy  reserved for internal testing"
        bitfld.long 0x00 1.--3. "    US_NPORT52    ,nport  reserved for internal testing" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 0. "   HC53         ,hc  reserved for internal testing" "0,1"

group d:0xD105000C++0x03
    line.long 0x00 "USB_HWDEVICE,Device Hardware Parameters Register"
        bitfld.long 0x00 1.--5. " US_DEVEP61       ,devep  reserved for internal testing" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"
        bitfld.long 0x00 0. "        DC62           ,device capable  reserved for internal testing" "0,1"

group d:0xD1050010++0x03
    line.long 0x00 "USB_HWTXBUF,TX Buffer Hardware Parameters Register"
        bitfld.long 0x00 31. " US_TXLCR69       ,txlcr  reserved for internal testing" "0,1"
        hexmask.long.byte 0x00 16.--23. 1. "         US_TXCHANADD71 ,txchanadd  reserved for internal testing"
        hexmask.long.byte 0x00 8.--15. 1. "    US_TXADD72    ,txadd  reserved for internal testing"
        hexmask.long.byte 0x00 0.--7. 1. "  US_TCBURST73 ,tcburst  reserved for internal testing"

group d:0xD1050014++0x03
    line.long 0x00 "USB_HWRXBUF,RX Buffer Hardware Parameters Register"
        hexmask.long.byte 0x00 8.--15. 1. " US_RXADD81       ,rxadd  reserved for internal testing"
        hexmask.long.byte 0x00 0.--7. 1. "        US_RXBURST82   ,rxburst  reserved for internal testing"

group d:0xD1050100++0x03
    line.long 0x00 "USB_CAPLENGTH,Capability Register Length - EHCI Compliant Register"
        hexmask.long.byte 0x00 0.--7. 1. " US_CAPLENGTH93   ,caplength"

group d:0xD1050102++0x03
    line.long 0x00 "USB_HCIVERSION,Host Interface Version Number - EHCI Compliant Register"
        hexmask.long.word 0x00 0.--15. 1. " US_HCIVERSION100 ,hciversion"

group d:0xD1050104++0x03
    line.long 0x00 "USB_HCSPARAMS,Host Ctrl. Structural Parameters EHCI Compliant with"
        bitfld.long 0x00 24.--27. " US_N_TT108       ,number of transaction translators (n_tt)  this field indicates the number of embedded transaction translators associated with the usb2.0 host controller.  this in a non-ehci field to support embedded tt." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 20.--23. "        US_N_PTT109    ,number of ports per transaction translator (n_ptt)  this field indicates the number of ports assigned to each transaction translator within the usb2.0 host controller.  this in a non-ehci field to support embedded tt." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 16. "    US_PI111      ,port indicators (p indicator)  this bit indicates whether the ports support port indicator control.  1 = port status and control registers include a read/writeable field for controlling the state of the port indicator.  this field will always be 1." "0,1"
        bitfld.long 0x00 12.--15. "   US_N_CC112   ,number of companion controller (n_cc)  this field indicates the number of companion controllers associated with this usb2.0 host controller.  a zero in this field indicates there are no internal companion controllers. port ownership hand-off is not supported.  a value larger than zero in this field indicates there are companion usb1.1 host controller(s). port-ownership hand-offs are supported. high, full and low speed devices are supported on the host controller root ports.  this field will always be 0x0 in the <var product number>." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        textline "                                "
        bitfld.long 0x00 8.--11. "US_N_PCC113      ,number of ports per companion controller  this field indicates the number of ports supported per internal companion controller. it is used to indicate the port routing configuration to the system software.  for example, if n_ports has a value of 6 and n_cc has a value of 2 then n_pcc could have a value of 3. the convention is that the first n_pcc ports are assumed to be routed to companion controller 1, the next n_pcc ports to companion controller 2, etc.  in the previous example, the n_pcc could have been 4, where the first 4 are routed to companion controller 1 and the last two are routed to companion controller 2.   the number in this field must be consistent with n_ports and n_cc.  this field will always be 0x0 in the <var product number>." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 4. "        US_PPC115      ,port power control  this field indicates whether the host controller implementation includes port power control. a one indicates the ports have port power switches. a zero indicates the ports do not have port power switches. the value of this field affects the functionality of the port power field in each port status and control register.  this field will always be 0x0 for a device only implementation." "0,1"
        bitfld.long 0x00 0.--3. "     US_N_PORTS116 ,number of downstream ports  this field specifies the number of physical downstream ports implemented on this host controller." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"

group d:0xD1050108++0x03
    line.long 0x00 "USB_HCCPARAMS,Host Ctrl. Capability Parameters EHCI Compliant"
        hexmask.long.byte 0x00 8.--15. 1. " US_EECP124       ,ehci extended capabilities pointer  this optional field indicates the existence of a capabilities list.  0x0 = no extended capabilities are implemented"
        bitfld.long 0x00 4.--7. "        US_IST125      ,isochronous scheduling threshold  this field indicates, relative to the current position of the executing host controller, where software can reliably update the isochronous schedule. when bit [7] is zero, the value of the least significant 3 bits indicates the number of micro-frames a host controller can hold a set of isochronous data structures (one or more) before flushing the state. when bit [7] is a one, then host software assumes the host controller may cache an isochronous data structure for an entire frame.  this field will always be 0x0 in the <var product number>." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 2. "    ASP127        ,asynchronous schedule park capability  if this bit is set to a one, then the host controller supports the park feature for high-speed queue heads in the asynchronous schedule. the feature can be disabled or enabled and set to a specific level by using the asynchronous schedule park mode enable and asynchronous schedule park mode count fields in the usbcmd register.  this field will always be 0x1 in the <var product number>." "0,1"
        bitfld.long 0x00 1. "   US_PFL128    ,programmable frame list flag   if this bit is set to zero, then the system software must use a frame list length of 1024 elements with this host controller. the usbcmd register frame list size field is a read-only register and must be set to zero.if set to a one, then the system software can specify and use a smaller frame list and configure the host controller via the usbcmd register frame list size field. the frame list must always be aligned on a 4k-page boundary. this requirement ensures that the frame list is always physically contiguous.  this field will always be 0x1 in the <var product number>." "0,1"
        textline "                                "
        bitfld.long 0x00 0. "US_ADC129        ,64-bit addressing capability  this field will always be 0. no 64-bit addressing capability is supported." "0,1"

group d:0xD1050120++0x03
    line.long 0x00 "USB_DCIVERSION,Dev. Interface Version Number Register"
        hexmask.long.word 0x00 0.--15. 1. " US_DCIVERSION137 ,dciversion"

group d:0xD1050124++0x03
    line.long 0x00 "USB_DCCPARAMS,Device Ctrl. Capability Parameters Register"
        bitfld.long 0x00 8. " HC145            ,host capable  1 = this controller is capable of operating as an ehci compatible usb 2.0 host controller" "0,1"
        bitfld.long 0x00 7. "         DC146          ,device capable  1 = this controller is capable of operating as a usb 2.0 device" "0,1"
        bitfld.long 0x00 0.--4. "     US_DEN148     ,device endpoint number  this field indicates the number of endpoints built into the device controller. if this controller is not device capable, then this field will be 0. valid values are 0 to 16." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"

group d:0xD1050140++0x03
    line.long 0x00 "USB_CMD,USB Command Register"
        hexmask.long.byte 0x00 16.--23. 1. " US_ITC159        ,interrupt threshold control  the system software uses this field to set the maximum rate at which the host/device controller will issue interrupts. itc contains the maximum interrupt interval measured in micro-frames. valid values are provided below.  value maximum interrupt interval  0x0 = immediate (no threshold)  0x1 = 1 micro-frame  0x2 = 2 micro-frames  0x4 = 4 micro-frames  0x8 = 8 micro-frames  0x10 = 16 micro-frames  0x20 = 32 micro-frames  0x40 = 64 micro-frames"
        bitfld.long 0x00 15. "        FS2            ,frame list size2  most significant bit (msb) of fs field" "0,1"
        bitfld.long 0x00 14. "     ATDTW         ,add dtd tripwire  this field is only used during device mode operation." "0,1"
        bitfld.long 0x00 13. "   SUTW         ,setup tripwire  this field is only used during device mode operation." "0,1"
        textline "                                "
        bitfld.long 0x00 11. "ASPE             ,asynchronous schedule park mode enable  if the asynchronous park capability bit in the hccparams register is a one, then this bit defaults to 1 and is r/w. otherwise the bit must be a 0 and is ro. software uses this bit to enable or disable park mode. when this bit is one, park mode is enabled. when this bit is a 0, park mode is disabled  only used in host mode." "0,1"
        bitfld.long 0x00 8.--9. "         ASP166         ,asynchronous schedule park mode count  if the asynchronous park capability bit in the hccparams register is a one, then this field defaults to 3h and is r/w. otherwise it defaults to zero and is ro. it contains a count of the number of successive transactions the host controller is allowed to execute from a high-speed queue head on the asynchronous schedule before continuing traversal of the asynchronous schedule.  valid values are 1h to 3h. software must not write a zero to this bit when park mode enable is a one as this will result in undefined behavior  only used in host mode." "0,1,2,3"
        bitfld.long 0x00 6. "     IAA           ,interrupt on async advance doorbell  this bit is used as a doorbell by software to tell the host controller to issue an interrupt the next time it advances the asynchronous schedule. software must write a '1b' to this bit to ring the doorbell.  when the host controller has evicted all appropriate cached schedule states, it sets the interrupt on async advance status bit in the usbsts register. if the interrupt on sync advance enable bit in the usbintr register is one, then the host controller will assert an interrupt at the next interrupt threshold.  the host controller sets this bit to zero after it has set the interrupt on sync advance status bit in the usbsts register to one. software should not write a one to this bit when the asynchronous schedule is inactive. doing so will yield undefined results.  this bit is only used in host mode. writing a one to this bit when device mode is selected will have undefined results." "0,1"
        bitfld.long 0x00 5. "   ASE          ,asynchronous schedule enable  this bit controls whether the host controller skips processing the asynchronous schedule.  values meaning   0 = do not process the asynchronous schedule.  1 = use the asynclistaddr register to access the asynchronous schedule.  only used in host mode." "0,1"
        textline "                                "
        bitfld.long 0x00 4. "PSE              ,periodic schedule enable  this bit controls whether the host controller skips processing the periodic schedule.  values meaning  0 = do not process the periodic schedule  1 = use the periodiclistbase register to access the periodic schedule.  only used in host mode." "0,1"
        bitfld.long 0x00 2.--3. "         FS             ,frame list size  this field specifies the size of the frame list that controls which bits in the frame index register should be used for the frame list current index. note that this field is made up from usbcmd bits 15, 3 and 2.  values meaning  0x0 = 1024 elements (4096 bytes)  0x1 = 512 elements (2048 bytes)  0x2 = 256 elements (1024 bytes)  0x3 128 elements (512 bytes)  0x4 64 elements (256 bytes)  0x5 32 elements (128 bytes)  0x6 16 elements (64 bytes)  0x7 8 elements (32 bytes)  only used in host mode." "0,1,2,3"
        bitfld.long 0x00 1. "     US_RST172     ,controller reset (reset)  software uses this bit to reset the controller. this bit is set to zero by the controller when the reset process is complete. software cannot terminate the reset process early by writing a zero to this register.  host mode:  when software writes a one to this bit, the controller resets its internal pipelines, timers, counters, state machines, etc. to their initial value. any transaction currently in progress on usb is immediately terminated. a usb reset is not driven on downstream ports. software should not set this bit to a one when the hchalted bit in the usbsts register is a zero. attempting to reset an actively running host controller will result in undefined behavior.  device mode:  when software writes a one to this bit, the controller resets its internal pipelines, timers, counters, state machines, etc. to their initial value. writing a one to this bit when the device is in the attached state is not recommended, since the effect on an attached host is undefined. in order to ensure that the device is not in an attached state before initiating a controller reset, all primed endpoints should be flushed and the usbcmd run/stop (rs) bit should be set to '0b'." "0,1"
        bitfld.long 0x00 0. "   US_RS173     ,run/stop (rs)  host mode:  when set to a 1, the controller proceeds with the execution of the schedule. the controller continues execution as long as this bit is set to a one. when this bit is set to 0, the host controller completes the current transaction on the usb and then halts.  the hchalted bit in the usbsts register indicates when the controller has finished the transaction and has entered the stopped state. software should not write a one to this field unless the host controller is in the halted state (i.e. hchalted in the usbsts register is a one).   device mode:  writing a one to this bit will cause the controller to enable a pull-up on d+ and initiate an attach event. this control bit is not directly connected to the pull-up enable, as the pull-up will become disabled upon transitioning into high-speed mode. software should use this bit to prevent an attach event before the controller has been properly initialized.    writing a '0b' to this will cause a detach event." "0,1"

group d:0xD1050144++0x03
    line.long 0x00 "USB_STS,USB Status Register"
        bitfld.long 0x00 25. " US_TI1181        ,general purpose timer interrupt 1  this bit is set when the counter in the gptimer1ctrl register transitions to zero. writing a one to this bit will clear it." "0,1"
        bitfld.long 0x00 24. "         TI0            ,general purpose timer interrupt 0  this bit is set when the counter in the gptimer2ctrl register transitions to zero. writing a one to this bit will clear it." "0,1"
        bitfld.long 0x00 19. "     US_UPI184     ,usb host periodic interrupt  this bit is set by the host controller when the cause of an interrupt is a completion of a usb transaction where the transfer descriptor (td) has an interrupt on complete (ioc) bit set and the td was from the periodic schedule.  this bit is also set by the host controller when a short packet is detected and the packet is on the periodic schedule. a short packet is when the actual number of bytes received was less than expected.  this bit is not used by the device controller and will always be zero." "0,1"
        bitfld.long 0x00 18. "   US_UAI185    ,usb host asynchronous interrupt  this bit is set by the host controller when the cause of an interrupt is a completion of a usb transaction where the transfer descriptor (td) has an interrupt on complete (ioc) bit set and the td was from the asynchronous schedule.  this bit is also set by the host when a short packet is detected and the packet is on the asynchronous schedule. a short packet is when the actual number of bytes received was less than expected.  this bit is not used by the device controller and will always be zero." "0,1"
        textline "                                "
        bitfld.long 0x00 16. "US_NAKI187       ,nak interrupt  this bit is read-only. it is set by hardware when for a particular endpoint both the tx/rx endpoint nak bit and the corresponding tx/rx endpoint nak enable bit are set. this bit is automatically cleared by hardware when the all the enabled tx/rx endpoint nak bits are cleared" "0,1"
        bitfld.long 0x00 15. "         US_AS189       ,asynchronous schedule status  this bit reports the current real status of the asynchronous schedule. when set to zero the asynchronous schedule status is disabled and if set to one the status is enabled. the controller is not required to immediately disable or enable the asynchronous schedule when software transitions the asynchronous schedule enable bit in the usbcmd register. when this bit and the asynchronous schedule enable bit are the same value, the asynchronous schedule is either enabled (1) or disabled (0).  only used in host mode." "0,1"
        bitfld.long 0x00 14. "     US_PS190      ,periodic schedule status  this bit reports the current real status of the periodic schedule. when set to zero the periodic schedule is disabled, and if set to one the status is enabled. the controller is not required to immediately disable or enable the periodic schedule when software transitions the periodic schedule enable bit in the usbcmd register. when this bit and the periodic schedule enable bit are the same value, the periodic schedule is either enabled (1) or disabled (0).  only used in host mode." "0,1"
        bitfld.long 0x00 13. "   RCL          ,reclamation  this is a read-only status bit used to detect an empty asynchronous schedule.  only used in host mode." "0,1"
        textline "                                "
        bitfld.long 0x00 12. "HCH              ,hchaited  this bit is a zero whenever the run/stop bit is a one. the controller sets this bit to one after it has stopped executing because of the run/stop bit being set to 0, either by software or by the controller hardware (e.g. internal error).  only used in host mode." "0,1"
        bitfld.long 0x00 10. "         US_ULPII194    ,ulpi interrupt  when the ulpi viewport is present in the design, an event completion will set this interrupt.  this is used by both host and device controller. only present in designs where configuration constant vusb_hs_phy_ulpi = 1." "0,1"
        bitfld.long 0x00 8. "     US_SLI196     ,dcsuspend  when a device controller enters a suspend state from an active state, this bit will be set to 1. the device controller clears the bit upon exiting from a suspend state." "0,1"
        bitfld.long 0x00 7. "   US_SRI197    ,sof received  0 = default. when the device controller detects a start of (micro) frame, this field will be set to 1. when a sof is extremely late, the device controller will automatically set this bit to indicate that an sof was expected. therefore, this field will be set roughly every 1 ms in device fs mode and every 125 ms in hs mode and will be synchronized to the actual sof that is received.  since the device controller is initialized to fs before connect, this field will be set at an interval of 1 ms during the prelude to connect and chirp.  in host mode, this bit will be set every 125 <mu>s and can be used by the host controller driver as a time base.  software writes 1 to this bit to clear it.  this is a non-ehci status bit." "0,1"
        textline "                                "
        bitfld.long 0x00 6. "US_URI198        ,usb reset received  when the device controller detects a usb reset and enters the default state, this bit will be set to 1. software can write 1 to this field to clear the usb reset received status bit." "0,1"
        bitfld.long 0x00 5. "         AAI            ,interrupt on async advance  system software can force the host controller to issue an interrupt the next time the host controller advances the asynchronous schedule by writing 1 to the <interrupt on async advance doorbell> field in the usb command register. this status bit indicates the assertion of that interrupt source." "0,1"
        bitfld.long 0x00 4. "     US_SEI200     ,system error  in the bvci implementation of the usbhs core, this bit is not used, and will always be cleared to '0b'. in the amba implementation, this bit will be set to '1b' when an error response is seen by the master interface (hresp[1:0]=error)." "0,1"
        bitfld.long 0x00 3. "   US_FRI201    ,frame list rollover  the host controller sets this field to 1 when the frame list index rolls over from its maximum value to 0. the exact value at which the rollover occurs depends on the frame list size. for example. if the frame list size (as programmed in the <fs[1:0]> field in the usb command register) is 1024, the usb frame index register rolls over every time frindex[13] toggles. similarly, if the size is 512, the host controller sets this bit to a one every time fhindex[12] toggles." "0,1"
        textline "                                "
        bitfld.long 0x00 2. "US_PCI202        ,port change detect  the host controller sets this bit to 1 when on any port a connect status occurs, a port enable/disable change occurs, or the <force port resume> field in the port status/control register is set as the result of a j-k transition on the suspended port.  the device controller sets this bit to 1 when the port controller enters the full or high-speed operational state.  when the port controller exits the full or high-speed operation states due to reset or suspend events, the notification mechanisms are the <iaa> field in the usb command register and the <dcsuspend> bits respectively.  this bit is not ehci compatible." "0,1"
        bitfld.long 0x00 1. "         US_UEI203      ,usb error interrupt (usberrint)  when completion of a usb transaction results in an error condition, this field is set by the host/device controller. this field is set along with the <ui>, if the td on which the error interrupt occurred also had its interrupt on complete (ioc) bit set.  the device controller detects resume signaling only." "0,1"
        bitfld.long 0x00 0. "     US_UI204      ,usb interrupt (usbint)  this field is set by the host/device controller when the cause of an interrupt is a completion of a usb transaction where the transfer descriptor (td) has an interrupt on complete (ioc) bit set.  this bit is also set by the host/device controller when a short packet is detected. a short packet is when the actual number of bytes received was less than the expected number of bytes." "0,1"

group d:0xD1050148++0x03
    line.long 0x00 "USB_INTR,USB Interrupt Enable Register"
        bitfld.long 0x00 25. " US_TIE1212       ,general purpose timer interrupt enable 1  when this bit is a one, and the ti1 bit in the extsts register is a one, the controller will issue an interrupt. the interrupt is acknowledged by software clearing the ti1 bit." "0,1"
        bitfld.long 0x00 24. "         US_TIE0213     ,general purpose timer interrupt enable 0  when this bit is a one, and the ti0 bit in the extsts register is a one, the controller will issue an interrupt. the interrupt is acknowledged by software clearing the ti0 bit." "0,1"
        bitfld.long 0x00 19. "     US_UPEI215    ,usb host periodic interrupt enable  when this bit is a one, and the upi bit in the extsts register is a one, the host controller will issue an interrupt at the next interrupt threshold. the interrupt is acknowledged by software clearing the upi bit." "0,1"
        bitfld.long 0x00 18. "   US_UAEI216   ,usb host asynchronous interrupt enable  when this bit is a one, and the uai bit in the extsts register is a one, the host controller will issue an interrupt at the next interrupt threshold. the interrupt is acknowledged by software clearing the uai bit." "0,1"
        textline "                                "
        bitfld.long 0x00 16. "US_NAKE218       ,nak interrupt enable  this bit is set by software if it wants to enable the hardware interrupt for the <nak interrupt bit> field in the usb status register. if both this bit and the corresponding <nak interrupt bit> field are set, a hardware interrupt is generated." "0,1"
        bitfld.long 0x00 10. "         US_ULPIE220    ,ulpi interrupt enable  when this bit is a one, and the ulpi interrupt bit in the usbsts register transitions, the controller will issue and interrupt. the interrupt is acknowledged by software writing a one to the ulpi interrupt bit." "0,1"
        bitfld.long 0x00 8. "     US_SLE222     ,sleep enable  when this bit is 1, and the <dcsuspend> field in the usb status register transitions, the device controller will issue an interrupt. the interrupt is acknowledged by software writing 1 to the <dcsuspend> field.  only used by the device controller." "0,1"
        bitfld.long 0x00 7. "   US_SRE223    ,sof received enable  when this bit is 1, and the <sof received> field in the usb status register is 1, the device controller will issue an interrupt. the interrupt is acknowledged by software clearing the <sof received> field." "0,1"
        textline "                                "
        bitfld.long 0x00 6. "US_URE224        ,usb reset enable  when this bit is 1, and the <usb reset received> field in the usb status register is 1, the device controller will issue an interrupt. the interrupt is acknowledged by software clearing the <usb reset received> field.  only used by the device controller." "0,1"
        bitfld.long 0x00 5. "         US_AAE225      ,interrupt on async advance enable  when this bit is 1, and the <aai 0b-08h> field in the usb status register is 1, the host controller will issue an interrupt at the next interrupt threshold. the interrupt is acknowledged by software clearing the <aai 0b-08h> field.  only used by the host controller." "0,1"
        bitfld.long 0x00 4. "     US_SEE226     ,system error enable  when this bit is 1, and bit 4 in the usb status register is 1, the host/device controller will issue an interrupt. the interrupt is acknowledged by software clearing bit 4 in the usb status register." "0,1"
        bitfld.long 0x00 3. "   US_FRE227    ,frame list rollover enable  when this bit is 1, and the <frame list rollover> field in the usb status register is 1, the host controller will issue an interrupt. the interrupt is acknowledged by software clearing the <frame list rollover> field.  only used by the host controller." "0,1"
        textline "                                "
        bitfld.long 0x00 2. "US_PCE228        ,port change detect enable  when this bit is 1, and the <port change detect> field in the usb status register is 1, the host/device controller will issue an interrupt. the interrupt is acknowledged by software clearing the <port change detect> field." "0,1"
        bitfld.long 0x00 1. "         US_UEE229      ,usb error interrupt enable  when this bit is 1, and the <usb error interrupt (usberrint)> field in the usb status register is 1, the host controller will issue an interrupt at the next interrupt threshold. the interrupt is acknowledged by software clearing the <usb error interrupt (usberrint)> field." "0,1"
        bitfld.long 0x00 0. "     US_UE230      ,usb interrupt enable  when this bit is 1 and the <usb interrupt (usbint)> field in the usb status register is 1, the host/device controller will issue an interrupt at the next interrupt threshold. the interrupt is acknowledged by software clearing the <usb interrupt (usbint)> field." "0,1"

group d:0xD105014C++0x03
    line.long 0x00 "USB_FRINDEX,USB Frame Index Register"
        hexmask.long.word 0x00 0.--13. 1. " US_FRINDEX238    ,frame index  the value, in this register, increments at the end of each time frame (e.g. micro-frame). bits [n:3] are used for the frame list current index. this means that each location of the frame list is accessed 8 times (frames or micro-frames) before moving to the next index. the following illustrates values of n based on the value of the frame list size field in the usbcmd register, when used in host mode.  usbcmd frame list size n  0x0 = (1024) 12  0x01 = (512)  11  0x2 = (256)  10  0x3 = (128)  9  0x4 = (64)   8  0x5 = (32)   7  0x6 = (16)   6  0x7 = (8)    5  in device mode, the value is the current frame number of the last frame transmitted. it is not used as an index.  in either mode bits 2:0 indicate the current microframe."

group d:0xD1050154++0x03
    line.long 0x00 "USB_PERIODICLISTBASE,Host Controller Frame List Base Address Register (Host Mode)"
        hexmask.long.tbyte 0x00 12.--31. 1. " US_BASEADR245    ,base address (low)  these bits correspond to memory address signals [31:12], respectively. only used by the host controller."

group d:0xD1050158++0x03
    line.long 0x00 "USB_ASYNCLISTADDR,Host Controller Next Asynchronous List Address Register"
        hexmask.long 0x00 5.--31. 1. " US_ASYBASE253    ,link pointer low (lpl)  these bits correspond to memory address signals [31:5], respectively. this field may only reference a queue head (oh). only used by the host controller."

group d:0xD1050160++0x03
    line.long 0x00 "USB_BURSTSIZE,Programmable Burst Size Register - Host Controller"
        hexmask.long.byte 0x00 8.--15. 1. " US_TXPBURST262   ,programmable tx burst length  this register represents the maximum length of a the burst in 32-bit words while moving data from system memory to the usb bus."
        hexmask.long.byte 0x00 0.--7. 1. "        US_RXPBURST263 ,programmable rx burst length  this register represents the maximum length of a the burst in 32-bit words while moving data from the usb bus to system memory."

group d:0xD105016C++0x03
    line.long 0x00 "IC_USB,IC_USB enable and voltage negotiation"
        bitfld.long 0x00 31. " IC8              ,these bits enables the inter-chip transceiver for each port (for the mph case). to enable the interface, the bits pts must be set to '011b' in the portscx. writing a '1' to each bit selects the ic_usb interface for that port. if the controller is not a mph implementation, ic8 to ic2 will be '0' and read-only." "0,1"
        bitfld.long 0x00 28.--30. "         IC_VDD8        ,it selects which voltage is being supplied to the peripheral through each port. 000 – no voltage 001 – 1.0v 010 – 1.2v 011 – 1.5v 100 – 1.8v 101 – 3.0v 110 – reserved 111 – reserved this field is read-only and set to '000b' in case of device mode operation. ic_vdd8 to ic_vdd2 are read-only and set to '000b' in case the controller is not mph. the voltage negotiation should happen between enabling port power (pp) in portscx register and asserting the run/stop bit in usbcmd register." "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 27. "     IC7           ,check ic8" "0,1"
        bitfld.long 0x00 24.--26. "   IC_VDD7      ,check ic_vdd8" "0,1,2,3,4,5,6,7"
        textline "                                "
        bitfld.long 0x00 23. "IC6              ,check ic8" "0,1"
        bitfld.long 0x00 20.--22. "         IC_VDD6        ,check ic_vdd8" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 19. "     IC5           ,check ic8" "0,1"
        bitfld.long 0x00 16.--18. "   IC_VDD5      ,check ic_vdd8" "0,1,2,3,4,5,6,7"
        textline "                                "
        bitfld.long 0x00 15. "IC4              ,check ic8" "0,1"
        bitfld.long 0x00 12.--14. "         IC_VDD4        ,check ic_vdd8" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 11. "     IC3           ,check ic8" "0,1"
        bitfld.long 0x00 8.--10. "   IC_VDD3      ,check ic_vdd8" "0,1,2,3,4,5,6,7"
        textline "                                "
        bitfld.long 0x00 7. "IC2              ,check ic8" "0,1"
        bitfld.long 0x00 4.--6. "         IC_VDD2        ,check ic_vdd8" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 3. "     IC1           ,check ic8" "0,1"
        bitfld.long 0x00 0.--2. "   IC_VDD1      ,check ic_vdd8" "0,1,2,3,4,5,6,7"

group d:0xD1050170++0x03
    line.long 0x00 "ULPIVIEWPORT,ULPI Viewport Register"
        bitfld.long 0x00 30. " ULPIWU           ,ulpi wakeup  writing the ‘1’ to this bit will begin the wakeup operation. the bit will automatically transition to '0' after the wakeup is complete. once this bit is set, the driver can not set it back to ‘0’." "0,1"
        bitfld.long 0x00 29. "         ULPIRW         ,ulpi read/write control  0 = read  1 = write  this bit selects between running a read or write operation." "0,1"
        bitfld.long 0x00 27. "     ULPISS        ,ulpi synchronous state  1 = normal synchronous state.  0 = in another state (i.e. carkit, serial, low power).  this bit represents the state of the ulpi interface. before reading this bit, the ulpiport field should be set accordingly if used in a multi port host implementation." "0,1"
        bitfld.long 0x00 24.--26. "   ULPIPORT     ,ulpi port number  for the wakeup or read/write operation to be executed, this value selects the port number to which a ulpi phy is attached. the range is 0 to 7. this field should always be written 0x0 for non multi port host implementations." "0,1,2,3,4,5,6,7"
        textline "                                "
        hexmask.long.byte 0x00 16.--23. 1. "ULPIADDR         ,ulpi data address  when a read or write operation is commanded, the address of the operation is written to this field."
        hexmask.long.byte 0x00 8.--15. 1. "        ULPIDATRD      ,ulpi data read  after a read operation completes, the result is placed in this field."
        hexmask.long.byte 0x00 0.--7. 1. "    ULPIDATWR     ,ulpi data write  when a write operation is commanded, the data to be sent is written to this field."

group d:0xD1050178++0x03
    line.long 0x00 "USB_ENDPTNAK,Endpoint NAK Register"
        hexmask.long.word 0x00 16.--31. 1. " US_EPTN309       ,tx endpoint nak  each tx endpoint has 1 bit in this field. the bit is set when the controller sends a nak handshake on a received in token for the corresponding endpoint.  bit 15 – endpoint #15  ...  bit 1 – endpoint #1  bit 0 – endpoint #0"
        hexmask.long.word 0x00 0.--15. 1. "      US_EPRN311     ,rx endpoint nak  each rx endpoint has 1 bit in this field. the bit is set when the controller sends a nak handshake on a received out or ping token for the corresponding endpoint.  bit 15 – endpoint #15  ...  bit 1 – endpoint #1  bit 0 – endpoint #0"

group d:0xD105017C++0x03
    line.long 0x00 "USB_ENDPTNAKEN,Endpoint NAK Enable Register"
        hexmask.long.word 0x00 16.--31. 1. " US_EPTNE319      ,tx endpoint nak enable  each bit is an enable bit for the corresponding tx endpoint nak bit. if this bit is set and the corresponding tx endpoint nak bit is set, the nak interrupt bit is set.  bit 15 – endpoint #15  ...  bit 1 – endpoint #1  bit 0 – endpoint #0"
        hexmask.long.word 0x00 0.--15. 1. "      US_EPRNE321    ,rx endpoint nak enable  each bit is an enable bit for the corresponding rx endpoint nak bit. if this bit is set and the corresponding rx endpoint nak bit is set, the nak interrupt bit is set.  bit 15 – endpoint #15  ...  bit 1 – endpoint #1  bit 0 – endpoint #0"

group d:0xD1050184++0x03
    line.long 0x00 "USB_PORTSC,Port Status/Control Register"
        bitfld.long 0x00 30.--31. " US_PTS329        ,parallel transceiver select  utmi/utmi+  this bit is not defined in the ehci specification.this register bit pair is used in conjunction with the configuration constant vusb_hs_phy_type to control which parallel transceiver interface is selected. if vusb_hs_phy_type is set for 0, 1, 2, 3, 8 or 10 then this bit is read only. if vusb_hs_phy_type is 4, 5, 6, 7, 9 or 11 then this bit is read/write.  this field is reset to:  3'b0: if vusb_hs_phy_type = 0, 4 – utmi/utmi+.  3'h1:if vusb_hs_phy_type = 1, 5 – ulpi ddr.  3'h2 if vusb_hs_phy_type = 2, 6 – ulpi.  3'h3 if vusb_hs_phy_type = 3, 7, 8, 9 – serial/1.1 phy/ic_usb (fs only).  3'h4 if vusb_hs_phy_type = 10, 11 – utmi for hsic phy.  note that this field is made up from portscx bits 25, 30 and 31." "0,1,2,3"
        bitfld.long 0x00 29. "         US_STS330      ,serial transceiver select  this register bit is used in conjunction with the configuration constant vusb_hs_phy_serial to control whether the parallel or serial transceiver interface is selected for fs and ls operation. the serial interface engine can be used in combination with the utmi+ physical interface to provide fs/ls signaling instead of the parallel interface. if usb_hs_phy_serial is set for 0 or 1 then this bit is read only. if vusb_hs_phy_serial is 2 or 3 then this bit is read/write.  this bit has no effect unless parallel transceiver select is set to utmi+. the serial/1.1 and ic_usb physical interface will use the serial interface engine for fs/ls signaling regardless of this bit value." "0,1"
        bitfld.long 0x00 28. "     US_PTW331     ,parallel transceiver width  8-bit [60 mhz] utmi  this bit is not defined in the ehci specification." "0,1"
        bitfld.long 0x00 26.--27. "   US_PSPD332   ,port speed  this register field indicates the speed at which the port is operating.  0x0 = full speed.  0x1 = low speed.  0x2 = high speed.  0x3 = not connected" "0,1,2,3"
        textline "                                "
        bitfld.long 0x00 25. "US_PTS2333       ,parallel transceiver select  default = 0x0.  msb bit of pts field." "0,1"
        bitfld.long 0x00 24. "         US_PFSC334     ,port force full speed connect  writing this bit to a '1b' will force the port to only connect at full speed. it disables the chirp sequence that allows the port to identify itself as high speed. this is useful for testing fs configurations with a hs host, hub or  device.   this bit is for debugging purposes." "0,1"
        bitfld.long 0x00 23. "     US_PHCD335    ,phy low power suspend - clock disable (plpscd)  writing this bit to a '1b' will disable the phy clock. writing a '0b' enables it. reading this bit will indicate the status of the phy clock.  note: the phy clock cannot be disabled if it is being used as the system clock. in device mode, the phy can be put into low power clock disable when the device is not running (usbcmd rs=0b) or the host has signaled suspend (portscx susp=1b).  low power clock disable will be cleared automatically when the host has signaled resume. before forcing a resume from the device, the controller driver must clear this bit.  in host mode, the phy can be put into low power suspend clock disable when the downstream device has been put into suspend mode or when no downstream device is connected. low power clock disable is completely under the control of software." "0,1"
        bitfld.long 0x00 22. "   US_WKOC336   ,wake on over-current enable (wkovc_e)  writing '1' to this bit enables the port to be sensitive to over-current conditions as wakeup events.  this field is zero if port power (pp) is '0' or in device mode.  this bit is output from the controller as signal  pwrctl_wake_ovrcurr_en for use by an external power control circuit.  only used in host mode." "0,1"
        textline "                                "
        bitfld.long 0x00 21. "WKDS             ,wake on disconnect enable (wkdscnnt_e)  writing this bit to a one enables the port to be sensitive to device disconnects as wakeup events.  this field is zero if port power (pp) is '0' or in device mode.  this bit is output from the controller as signal pwrctl_wake_dscnnt_en for use by an external power control circuit.  only used in host mode." "0,1"
        bitfld.long 0x00 20. "         US_WKCN338     ,wake on connect enable (wkcnnt_e)  writing this bit to a one enables the port to be sensitive to device connects as wake-up events.  this field is zero if port power(pp) is '0' or in device mode.  this bit is output from the controller as signal pwrctl_wake_cnnt_en for use by an external power control circuit.  only used in host mode." "0,1"
        bitfld.long 0x00 16.--19. "     US_PTC339     ,port test control  any other value than zero indicates that the port is operating in test mode.   value specific test   0x0 = test_mode_disable  0x1 = j_ state  0x2 =  k_state  0x3 = se0 (host) / nak (device)  0x4 = packet  0x5 = force_enable_hs  0x6 = force_enable_fs  0x7 =  force_enable_ls  0x8 = reserved  ... reserved.  0xf = reserved.  refer to chapter 7 of the usb specification revision 2.0 for details on each test mode.  the force_enable_fs and force enable_ls are extensions to the test mode support specified in the ehci specification.  writing the ptc field to any of the force_enable_{hs/fs/ls} values will force the port into the connected and enabled state at the selected speed.  writing the ptc field back to test_mode_disable will allow the port state machines to progress normally from that point.  note: low speed operations are not supported when in device mode." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 14.--15. "  US_PIC340    ,port indicator control  writing to this field has no effect if the p_indicator bit in the hcsparams register is a zero. if p_indicator bit is a one, then the bits are:  0x0 = port indicators are off  0x1 = amber  0x2 = green  0x3 = undefined  refer to the usb specification revision 2.0 for a description on how these bits are to be used.  this field is output from the controller as signals port_ind_ctl_1 and port_ind_ctl_0 for use by an external led driving circuit." "0,1,2,3"
        textline "                                "
        bitfld.long 0x00 13. "US_PO341         ,port owner  port owner hand off is not implemented in this design, therefore this bit will always read back as 0b." "0,1"
        bitfld.long 0x00 12. "         US_PP342       ,the function of this bit depends on the value of the port power switching (ppc) field in the hcsparams register. the behavior is as follows:  ppc pp operation  0 0 read only: a controller in device mode does not have port power control switches.  1 1/0 read/write. a controller in host mode requires port power control switches.  this bit represents the current setting of the switch (0 = off, 1 = on). when power is not available on a port (i.e. pp equals to 0), the port is non-functional and will not report attaches, detaches, etc.   when an over-current condition is detected on a powered port and ppc is a one, the pp bit in each affected port may be transitioned by the controller driver from 1 to 0 (removing power from the port).  in device mode port power control is not necessary, thus ppc and pp = 0." "0,1"
        bitfld.long 0x00 10.--11. "     US_LS343      ,line status  these bits reflect the current logical levels of the d+ (bit 11) and d- (bit 10) signal lines. the encoding of the bits are:  0x0 = se0  x02 = j-state  0x1 = k-state  0x3 = undefined  in host mode, the use of linestate by the controller driver is not necessary (unlike ehci), because the port controller state machine and the port routing manage the connection of ls and fs.  in device mode, the use of linestate by the controller driver is not necessary." "0,1,2,3"
        bitfld.long 0x00 9. "   US_HSP344    ,high-speed port  0 = host/device connected to the port is not in a high-speed mode  1 = host/device connected to the port is in high-speed mode" "0,1"
        textline "                                "
        bitfld.long 0x00 8. "US_PR347         ,port reset  this field is zero if port power(pp) is '0'.  host mode:  1 = port is in reset  0 = port is not in reset  when software writes '1' to this bit the bus-reset sequence as defined in the usb specification revision 2.0 is started. this bit will automatically change to '0' after the reset sequence is complete. this behavior is different from ehci where the host controller driver is required to set this bit to a zero after the reset duration is timed in the driver.   device mode: this bit is a read only status bit. device reset from the usb bus is also indicated in the usbsts register." "0,1"
        bitfld.long 0x00 7. "         US_SUSP348     ,suspend  host mode:  1 = port in suspend state  0 = port not in suspend state  port enabled bit and suspend bit of this register define the port states as follows:  bits [port enabled, suspend] port state  0x disable  10 enable  11 suspend   when in suspend state, downstream propagation of data is blocked on this port, except for port reset. the blocking occurs at the end of the current transaction if a transaction was in progress when this bit was written to '1'. in the suspend state, the port is sensitive to resume detection. note that the bit status does not change until the port is suspended and that there may be a delay in suspending a port if there is a transaction currently in progress on the usb.  the controller when in host mode will unconditionally set this bit to zero when software sets the force port resume bit to '0'. the controller ignores a write of '0' to this bit.  if software sets this bit to a '1' when the port is not enabled (i.e. port enabled bit is a '0')  the results are undefined.  this field is '0' if port power(pp) is '0' in host mode." "0,1"
        bitfld.long 0x00 6. "     US_FPR349     ,force port resume  1= resume detected/driven on port.  0=no resume (k-state) detected/driven on port.  host mode:  software sets this bit to one to drive resume signaling. the controller sets this bit to '1' if a j-to-k transition is detected while the port is in the suspend state. when this bit transitions to a '1' because a j-to-k transition is detected, the port change detect bit in the usbsts register is also set to '1'. this bit will automatically change to '0' after the resume sequence is complete. this behavior is different from ehci where the controller driver is required to set this bit to a '0' after the resume duration is timed in the driver." "0,1"
        bitfld.long 0x00 5. "   US_OCC351    ,over-current change  this bit gets set to '1' when there is a change to over-current active. software clears this bit by writing a '1' to this bit position.   when in host mode implementations the user can provide over-current detection to the vbus_pwr_fault input for this condition." "0,1"
        textline "                                "
        bitfld.long 0x00 4. "US_OCA352        ,over-current active  0 = this port does not have an over-current condition. this field will automatically transition from 1 to 0 when the over current condition is removed.  for host mode implementations the user can provide over-current detection to the vbus_pwr_fault input for this condition." "0,1"
        bitfld.long 0x00 3. "         US_PEC353      ,port enable/disable change  if set to '1' indicates a port enabled/disabled status change.  host mode:   for the root hub, this bit gets set to a '1' only when a port is disabled due to disconnect on the port or due to the appropriate conditions existing at the eof2 point (see chapter 11 of the usb specification). software clears this by writing a '1' to it.  this field is 0 if port power(pp) is 0." "0,1"
        bitfld.long 0x00 2. "     US_PE354      ,port enabled/disabled  1 enable  0 disable  host mode:  ports can only be enabled by controller as a part of the reset and enable. software cannot enable a port by writing a '1' to this field. ports can be disabled by either a fault condition (disconnect event or other fault condition) or by the software. note that the bit status does not change until the port state actually changes. there may be a delay in disabling or enabling a port due to other controller and bus events. when the port is disabled ('0b'), downstream propagation of data is blocked except for reset.  this field is '0' if port power(pp) is '0' in host mode.  device mode: the device port is always enabled. (this bit will be always '1')." "0,1"
        bitfld.long 0x00 1. "   US_CSC355    ,connect status change  if set to '1' indicates a change in current connect status (ccs).  host mode:  indicates a change has occurred in the port’s current connect status. the controller sets this bit for all changes to the port device connect status, even if system software has not cleared an existing connect status change. for example, the insertion status changes twice before system software has cleared the changed condition, hub hardware will be ‘setting’ an already-set bit (i.e., the bit will remain set). software clears this bit by writing a '1' to it. this field is '0' if port power(pp) is '0' in host mode.  device mode: this bit is undefined in device mode." "0,1"
        textline "                                "
        bitfld.long 0x00 0. "US_CCS356        ,current connect status  host mode:  1 = device is present on port  0 = no device is present  this value reflects the current state of the port, and may not correspond directly to the event that caused the connect status change bit to be set. this field is '0' if port power(pp) is '0' in host mode.  device mode:   1 = attached  0 = not attached  a '1' indicates that the device successfully attached and is operating in either high speed or full speed as indicated by the pspd bits in this register. a '0' indicates that the device did not attach successfully or was forcibly disconnected by the software writing a '0' to the run/stop bit in the usbcmd register. it does not state the device being disconnected or suspended." "0,1"

group d:0xD10501A8++0x03
    line.long 0x00 "USB_MODE,USB Device Mode Register"
        bitfld.long 0x00 4. " US_SDIS364       ,stream disable mode  0 = inactive  1 = active  host mode:  setting to a '1' ensures that overruns/underruns of the latency fifo are eliminated for low bandwidth systems where the rx and tx buffers are sufficient to contain the entire packet. enabling stream disable also has the effect of ensuring the tx latency is filled to capacity before the packet is launched onto the usb." "0,1"
        bitfld.long 0x00 3. "         US_SLOM367     ,setup lockout mode  this bit controls behavior of the setup lock mechanism.  0 = setup lockouts on  1 = setup lockouts off (dcd requires use of setup data buffer tripwire in usbcmd).  only used in device mode." "0,1"
        bitfld.long 0x00 2. "     US_ES369      ,endian select  this bit can change the byte ordering of the transfer buffers to match the host microprocessor bus architecture. the bit fields in the microprocessor interface and the dma data structures (including the setup buffer within the device qh) are unaffected by the value of this bit, because they are based upon 32-bit words.  0 = little endian – first byte referenced in least significant byte of 32-bit word  1 = big endian – first byte referenced in most significant byte of 32-bit word" "0,1"
        bitfld.long 0x00 0.--1. "   US_CM370     ,controller mode  controller mode is defaulted to the proper mode for host only and device only implementations. for those designs that contain both host & device capability (otg), the controller will default to an idle state and will need to be initialized to the desired operating mode after reset. for combination host/device controllers, this register can only be written once after reset. if it is necessary to switch modes, software must reset the controller by writing to the rst bit in the usbcmd register before  reprogramming this register.  0x0 = idle (default for combination host/device)  0x1 = reserved  0x2 =  controller in device mode (default for device only controller)  0x3 = controller in host mode (default for host only controller)" "0,1,2,3"

tree.end

tree "ic_usb integration register"

width 18.

group d:0xD1051004++0x03
    line.long 0x00 "USBSPH_MISC,USB SPH Miscellaneous Control Register"

group d:0xD1051028++0x03
    line.long 0x00 "USBSPH_INT,USB SPH Interrupt Register"
        bitfld.long 0x00 11. " USB_RESUME_INT   ,usb resume interrupt enable  1 = assertion of bit [6] will cause an interrupt" "0,1"
        bitfld.long 0x00 10. "  HSIC_READY_INT_EN       ,hsic ready interrupt enable  when hsic function is implemented, if this bit is set to 1, bit [2] will result in an interrupt" "0,1"
        bitfld.long 0x00 9. "  HSIC_CONNECT_INT_EN ,hsic connect interrupt enable  when hsic function is implemented, if this bit is set to 1, bit [1] will result in an interrupt" "0,1"
        bitfld.long 0x00 6. "  USBSP_RESUME_INT28  ,usb resume interrupt status  write of 1 clears this bit to 0" "0,1"
        textline "                            "
        bitfld.long 0x00 2. "USBSP_31         ,hsic phy ready interrupt" "0,1"
        bitfld.long 0x00 1. "  HSIC_CONNECT_INT        ,hsic connect interrupt status  this field is used for hsic function implementation, write 1 clear to 0" "0,1"
        bitfld.long 0x00 0. "  INTERRUPT           ,interrupt from usb core" "0,1"

group d:0xD1051034++0x03
    line.long 0x00 "USBSPH_MISC_CTRL,USB SPH Misc Control Register"
        bitfld.long 0x00 31. " OTG_CLK480_READY ,480m clock from otg phy is ready 1: 480m clock is ready 0: 480m clock is not ready" "0,1"
        bitfld.long 0x00 15. "  USBSP_PLL_LOCK_BYPASS45 ,480m clock ready bypass  this field is used to bypass the function in the <480m clock ready> field.  1 =  xcvr_clk to usb_core will always be running even if the <480m clock ready> field is set to 0" "0,1"
        bitfld.long 0x00 14. "  USBSP_PLL_LOCK46    ,480m clock ready  this field is used for xcvr_clock gating to usb_core  0 = xcvr_clk sent to usb_core will be gated" "0,1"
        bitfld.long 0x00 13. "  USBSP_XCVR_UDRDIS47 ,xcvr clock disable  this field works together with the <software disable control of xcvr_clk> field to disable xcvr_clk generation  refer to application notes for the clock disable sequence. 1= xcvr_clk sent to icusb controller will be invalid" "0,1"
        textline "                            "
        bitfld.long 0x00 12. "XCVR_SWDIS       ,software disable control of xcvr_clk  1 = xcvr_clk generated from usb2 phy 480m clock will be disabled" "0,1"
        bitfld.long 0x00 9. "  SER_SEL_D2              ,ser wakeup circuit 1: dp/dm xor with dp_d2/dm_d2 generate wakeup signal 0: dp/dm xor with dp_d1/dm_d1 generate wakeup signal" "0,1"
        bitfld.long 0x00 8. "  ICUSB_SUSPENDM_EN   ,suspendm from icusb sph controller will effect otg phy suspendm or not 1: when icusb sph suspendm is not indicate phy suspend, phy will not suspend. when icusb sph suspendm want phy suspend, then if phy suspend or not depend on otg controller 0: suspendm of ogt phy will not be effected by sph suspendm" "0,1"
        bitfld.long 0x00 7. "  ICUSB_IN_USE_CP     ,1: cp side sw program icusb to work, this will make usb2 phy power up 0:cp side sw will not run icusb function" "0,1"
        textline "                            "
        bitfld.long 0x00 6. "CLKSEL           ,clock select  1 = selects clk_32k to power control block" "0,1"
        bitfld.long 0x00 5. "  PDWN_EN                 ,power down selection  0 = <power down> field will take effect" "0,1"
        bitfld.long 0x00 3.--4. "  USBSP_RTC55         ,rtc  this field is used for the rtc for both the txbuffer and rxbuffer dpram." "0,1,2,3"
        bitfld.long 0x00 1.--2. "  USBSP_WTC56         ,wtc  this field is used for the wtc for both the txbuffer and rxbuffer dpram." "0,1,2,3"
        textline "                            "
        bitfld.long 0x00 0. "USBSP_PDWN57     ,power down  this field is used for power down of both the txbuffer and rxbuffer dpram." "0,1"

tree.end

tree.end

tree "icu"

width 33.

group d:0xD4282000++0x03
    line.long 0x00 "ICU_CFG_x,Interrupt 0 to 63 Configuration Registers"
        bitfld.long 0x00 16. " CPU9_INT16                      ,<var processor: application> core9 interrupt  1 = route to core9 interrupt" "0,1"
        bitfld.long 0x00 15. "         CPU8_INT17                     ,<var processor: application> core8 interrupt  1 = route to core8 interrupt" "0,1"
        bitfld.long 0x00 14. "   CPU7_INT18                     ,<var processor: application> core7 interrupt  1 = route to core7 interrupt" "0,1"
        bitfld.long 0x00 13. "  CPU6_INT19                     ,<var processor: application> core6 interrupt  1 = route to core6 interrupt" "0,1"
        textline "                                           "
        bitfld.long 0x00 12. "CPU5_INT20                      ,<var processor: application> core5 interrupt  1 = route to core5 interrupt" "0,1"
        bitfld.long 0x00 11. "         CPU4_INT21                     ,<var processor: application> core4 interrupt  1 = route to core4 interrupt" "0,1"
        bitfld.long 0x00 9. "   CPU3_INT23                     ,<var processor: application> core3 interrupt  1 = route to core3 interrupt" "0,1"
        bitfld.long 0x00 8. "  CPU2_INT24                     ,<var processor: application> core2 interrupt  1 = route to core2 interrupt" "0,1"
        textline "                                           "
        bitfld.long 0x00 7. "CPU1_INT25                      ,<var processor: application> core1 interrupt  1 = route to core1 interrupt" "0,1"
        bitfld.long 0x00 6. "         CPU0_INT26                     ,<var processor: application> core0 interrupt  1 = route to core0 interrupt" "0,1"
        bitfld.long 0x00 4. "   IRQ_FIQ28                      ,irq/fiq  1 = route to irq  0 = route to fiq" "0,1"
        bitfld.long 0x00 0.--3. "  PRIORITY_MASKING29             ,priority/masking  0xf to 0x1 = interrupt arbitration priority  0x0 = interrupt is masked" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"

group d:0xD4282100++0x03
    line.long 0x00 "ICU_CFG_x,Interrupt 64 to 127 Configuration Registers"
        bitfld.long 0x00 16. " CPU9_INT38                      ,<var processor: application> core9 interrupt  1 = route to core9 interrupt" "0,1"
        bitfld.long 0x00 15. "         CPU8_INT39                     ,<var processor: application> core8 interrupt  1 = route to core8 interrupt" "0,1"
        bitfld.long 0x00 14. "   CPU7_INT40                     ,<var processor: application> core7 interrupt  1 = route to core7 interrupt" "0,1"
        bitfld.long 0x00 13. "  CPU6_INT41                     ,<var processor: application> core6 interrupt  1 = route to core6 interrupt" "0,1"
        textline "                                           "
        bitfld.long 0x00 12. "CPU5_INT42                      ,<var processor: application> core5 interrupt  1 = route to core5 interrupt" "0,1"
        bitfld.long 0x00 11. "         CPU4_INT43                     ,<var processor: application> core4 interrupt  1 = route to core4 interrupt" "0,1"
        bitfld.long 0x00 9. "   CPU3_INT45                     ,<var processor: application> core3 interrupt  1 = route to core3 interrupt" "0,1"
        bitfld.long 0x00 8. "  CPU2_INT46                     ,<var processor: application> core2 interrupt  1 = route to core2 interrupt" "0,1"
        textline "                                           "
        bitfld.long 0x00 7. "CPU1_INT47                      ,<var processor: application> core1 interrupt  1 = route to core1 interrupt" "0,1"
        bitfld.long 0x00 6. "         CPU0_INT48                     ,<var processor: application> core0 interrupt  1 = route to core0 interrupt" "0,1"
        bitfld.long 0x00 4. "   IRQ_FIQ50                      ,irq/fiq  1 = route to irq  0 = route to fiq" "0,1"
        bitfld.long 0x00 0.--3. "  PRIORITY_MASKING51             ,priority/masking  0xf to 0x1 = interrupt arbitration priority  0x0 = interrupt is masked" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"

group d:0xD4282200++0x03
    line.long 0x00 "ICU_INT_STATUS_0,Interrupt Status Register 0"
        hexmask.long 0x00 0.--31. 1. " INT_STATUS_0                    ,interrupt status [31:0] (after masking)  0 = interrupt is not pending   1 = interrupt is pending"

group d:0xD4282204++0x03
    line.long 0x00 "ICU_INT_STATUS_1,Interrupt Status Register 1"
        hexmask.long 0x00 0.--31. 1. " INT_STATUS_1                    ,interrupt status [63:32] (after masking)  0 = interrupt is not pending   1 = interrupt is pending"

group d:0xD4282208++0x03
    line.long 0x00 "ICU_INT_STATUS_2,Interrupt Status Register 2"
        hexmask.long 0x00 0.--31. 1. " INT_STATUS_2                    ,interrupt status [95:64] (after masking)  0 = interrupt is not pending   1 = interrupt is pending"

group d:0xD428220C++0x03
    line.long 0x00 "ICU_INT_STATUS_3,Interrupt Status Register 3"
        hexmask.long 0x00 0.--31. 1. " INT_STATUS_3                    ,interrupt status [127:96] (after masking)  0 = interrupt is not pending   1 = interrupt is pending"

group d:0xD4282220++0x03
    line.long 0x00 "ICU_APc0_FIQ_NUM,APc0 FIQ Selected Interrupt Number Register"
        bitfld.long 0x00 7. " INT_PENDING87                   ,interrupt pending  0 = no pending interrupt  1 = pending interrupt available" "0,1"
        hexmask.long.byte 0x00 0.--6. 1. "         SEL_INT_NUM88                  ,selected interrupt number"

group d:0xD4282224++0x03
    line.long 0x00 "ICU_APc0_IRQ_NUM,APc0 IRQ Selected Interrupt Number Register"
        bitfld.long 0x00 7. " INT_PENDING96                   ,interrupt pending  0 = no pending interrupt  1 = pending interrupt available" "0,1"
        hexmask.long.byte 0x00 0.--6. 1. "         SEL_INT_NUM97                  ,selected interrupt number"

group d:0xD4282228++0x03
    line.long 0x00 "ICU_APc0_GBL_INT_MSK,APc0 Global Interrupt Mask Register"
        bitfld.long 0x00 1. " IRQ_MSK105                      ,global irq masking bit, can be cleared by pmu hardware  0 = interrupt is not masked  1 = interrupt is masked" "0,1"
        bitfld.long 0x00 0. "         FIQ_MSK106                     ,global fiq masking bit, can be cleared by pmu hardware  0 = interrupt is not masked  1 = interrupt is masked" "0,1"

group d:0xD4282230++0x03
    line.long 0x00 "ICU_APc1_FIQ_NUM,APc1 FIQ Selected Interrupt Number Register"
        bitfld.long 0x00 7. " INT_PENDING114                  ,interrupt pending  0 = no pending interrupt  1 = pending interrupt available" "0,1"
        hexmask.long.byte 0x00 0.--6. 1. "         SEL_INT_NUM115                 ,selected interrupt number"

group d:0xD4282234++0x03
    line.long 0x00 "ICU_APc1_IRQ_NUM,APc1 IRQ Selected Interrupt Number Register"
        bitfld.long 0x00 7. " INT_PENDING123                  ,interrupt pending  0 = no pending interrupt  1 = pending interrupt available" "0,1"
        hexmask.long.byte 0x00 0.--6. 1. "         SEL_INT_NUM124                 ,selected interrupt number"

group d:0xD4282238++0x03
    line.long 0x00 "ICU_APc1_GBL_INT_MSK,APc1 Global Interrupt Mask Register"
        bitfld.long 0x00 1. " IRQ_MSK132                      ,global irq masking bit, can be cleared by pmu hardware  0 = interrupt is not masked  1 = interrupt is masked" "0,1"
        bitfld.long 0x00 0. "         FIQ_MSK133                     ,global fiq masking bit, can be cleared by pmu hardware  0 = interrupt is not masked  1 = interrupt is masked" "0,1"

group d:0xD4282240++0x03
    line.long 0x00 "ICU_APc2_FIQ_NUM,APc2 FIQ Selected Interrupt Number Register"
        bitfld.long 0x00 7. " INT_PENDING141                  ,interrupt pending  0 = no pending interrupt  1 = pending interrupt available" "0,1"
        hexmask.long.byte 0x00 0.--6. 1. "         SEL_INT_NUM142                 ,selected interrupt number"

group d:0xD4282244++0x03
    line.long 0x00 "ICU_APc2_IRQ_NUM,APc2 IRQ Selected Interrupt Number Register"
        bitfld.long 0x00 7. " INT_PENDING150                  ,interrupt pending  0 = no pending interrupt  1 = pending interrupt available" "0,1"
        hexmask.long.byte 0x00 0.--6. 1. "         SEL_INT_NUM151                 ,selected interrupt number"

group d:0xD4282248++0x03
    line.long 0x00 "ICU_APc2_GBL_INT_MSK,APc2 Global Interrupt Mask Register"
        bitfld.long 0x00 1. " IRQ_MSK159                      ,global irq masking bit, can be cleared by pmu hardware  0 = interrupt is not masked  1 = interrupt is masked" "0,1"
        bitfld.long 0x00 0. "         FIQ_MSK160                     ,global fiq masking bit, can be cleared by pmu hardware  0 = interrupt is not masked  1 = interrupt is masked" "0,1"

group d:0xD4282250++0x03
    line.long 0x00 "ICU_APc3_FIQ_NUM,APc3 FIQ Selected Interrupt Number Register"
        bitfld.long 0x00 7. " INT_PENDING168                  ,interrupt pending  0 = no pending interrupt  1 = pending interrupt available" "0,1"
        hexmask.long.byte 0x00 0.--6. 1. "         SEL_INT_NUM169                 ,selected interrupt number"

group d:0xD4282254++0x03
    line.long 0x00 "ICU_APc3_IRQ_NUM,APc3 IRQ Selected Interrupt Number Register"
        bitfld.long 0x00 7. " INT_PENDING177                  ,interrupt pending  0 = no pending interrupt  1 = pending interrupt available" "0,1"
        hexmask.long.byte 0x00 0.--6. 1. "         SEL_INT_NUM178                 ,selected interrupt number"

group d:0xD4282258++0x03
    line.long 0x00 "ICU_APc3_GBL_INT_MSK,APc3 Global Interrupt Mask Register"
        bitfld.long 0x00 1. " IRQ_MSK186                      ,global irq masking bit, can be cleared by pmu hardware  0 = interrupt is not masked  1 = interrupt is masked" "0,1"
        bitfld.long 0x00 0. "         FIQ_MSK187                     ,global fiq masking bit, can be cleared by pmu hardware  0 = interrupt is not masked  1 = interrupt is masked" "0,1"

group d:0xD4282270++0x03
    line.long 0x00 "ICU_APc4_FIQ_NUM,APc4 FIQ Selected Interrupt Number Register"
        bitfld.long 0x00 7. " INT_PENDING195                  ,interrupt pending  0 = no pending interrupt  1 = pending interrupt available" "0,1"
        hexmask.long.byte 0x00 0.--6. 1. "         SEL_INT_NUM196                 ,selected interrupt number"

group d:0xD4282274++0x03
    line.long 0x00 "ICU_APc4_IRQ_NUM,APc4 IRQ Selected Interrupt Number Register"
        bitfld.long 0x00 7. " INT_PENDING204                  ,interrupt pending  0 = no pending interrupt  1 = pending interrupt available" "0,1"
        hexmask.long.byte 0x00 0.--6. 1. "         SEL_INT_NUM205                 ,selected interrupt number"

group d:0xD4282278++0x03
    line.long 0x00 "ICU_APc4_GBL_INT_MSK,APc4 Global Interrupt Mask Register"
        bitfld.long 0x00 1. " IRQ_MSK213                      ,global irq masking bit, can be cleared by pmu hardware  0 = interrupt is not masked  1 = interrupt is masked" "0,1"
        bitfld.long 0x00 0. "         FIQ_MSK214                     ,global fiq masking bit, can be cleared by pmu hardware  0 = interrupt is not masked  1 = interrupt is masked" "0,1"

group d:0xD4282280++0x03
    line.long 0x00 "ICU_APc5_FIQ_NUM,APc5 FIQ Selected Interrupt Number Register"
        bitfld.long 0x00 7. " INT_PENDING222                  ,interrupt pending  0 = no pending interrupt  1 = pending interrupt available" "0,1"
        hexmask.long.byte 0x00 0.--6. 1. "         SEL_INT_NUM223                 ,selected interrupt number"

group d:0xD4282284++0x03
    line.long 0x00 "ICU_APc5_IRQ_NUM,APc5 IRQ Selected Interrupt Number Register"
        bitfld.long 0x00 7. " INT_PENDING231                  ,interrupt pending  0 = no pending interrupt  1 = pending interrupt available" "0,1"
        hexmask.long.byte 0x00 0.--6. 1. "         SEL_INT_NUM232                 ,selected interrupt number"

group d:0xD4282288++0x03
    line.long 0x00 "ICU_APc5_GBL_INT_MSK,APc5 Global Interrupt Mask Register"
        bitfld.long 0x00 1. " IRQ_MSK240                      ,global irq masking bit, can be cleared by pmu hardware  0 = interrupt is not masked  1 = interrupt is masked" "0,1"
        bitfld.long 0x00 0. "         FIQ_MSK241                     ,global fiq masking bit, can be cleared by pmu hardware  0 = interrupt is not masked  1 = interrupt is masked" "0,1"

group d:0xD4282290++0x03
    line.long 0x00 "ICU_APc6_FIQ_NUM,APc6 FIQ Selected Interrupt Number Register"
        bitfld.long 0x00 7. " INT_PENDING249                  ,interrupt pending  0 = no pending interrupt  1 = pending interrupt available" "0,1"
        hexmask.long.byte 0x00 0.--6. 1. "         SEL_INT_NUM250                 ,selected interrupt number"

group d:0xD4282294++0x03
    line.long 0x00 "ICU_APc6_IRQ_NUM,APc6 IRQ Selected Interrupt Number Register"
        bitfld.long 0x00 7. " INT_PENDING258                  ,interrupt pending  0 = no pending interrupt  1 = pending interrupt available" "0,1"
        hexmask.long.byte 0x00 0.--6. 1. "         SEL_INT_NUM259                 ,selected interrupt number"

group d:0xD4282298++0x03
    line.long 0x00 "ICU_APc6_GBL_INT_MSK,APc6 Global Interrupt Mask Register"
        bitfld.long 0x00 1. " IRQ_MSK267                      ,global irq masking bit, can be cleared by pmu hardware  0 = interrupt is not masked  1 = interrupt is masked" "0,1"
        bitfld.long 0x00 0. "         FIQ_MSK268                     ,global fiq masking bit, can be cleared by pmu hardware  0 = interrupt is not masked  1 = interrupt is masked" "0,1"

group d:0xD42822A0++0x03
    line.long 0x00 "ICU_APc7_FIQ_NUM,APc7 FIQ Selected Interrupt Number Register"
        bitfld.long 0x00 7. " INT_PENDING276                  ,interrupt pending  0 = no pending interrupt  1 = pending interrupt available" "0,1"
        hexmask.long.byte 0x00 0.--6. 1. "         SEL_INT_NUM277                 ,selected interrupt number"

group d:0xD42822A4++0x03
    line.long 0x00 "ICU_APc7_IRQ_NUM,APc7 IRQ Selected Interrupt Number Register"
        bitfld.long 0x00 7. " INT_PENDING285                  ,interrupt pending  0 = no pending interrupt  1 = pending interrupt available" "0,1"
        hexmask.long.byte 0x00 0.--6. 1. "         SEL_INT_NUM286                 ,selected interrupt number"

group d:0xD42822A8++0x03
    line.long 0x00 "ICU_APc7_GBL_INT_MSK,APc7 Global Interrupt Mask Register"
        bitfld.long 0x00 1. " IRQ_MSK294                      ,global irq masking bit, can be cleared by pmu hardware  0 = interrupt is not masked  1 = interrupt is masked" "0,1"
        bitfld.long 0x00 0. "         FIQ_MSK295                     ,global fiq masking bit, can be cleared by pmu hardware  0 = interrupt is not masked  1 = interrupt is masked" "0,1"

group d:0xD42822B0++0x03
    line.long 0x00 "ICU_APc8_FIQ_NUM,APc8 FIQ Selected Interrupt Number Register"
        bitfld.long 0x00 7. " INT_PENDING303                  ,interrupt pending  0 = no pending interrupt  1 = pending interrupt available" "0,1"
        hexmask.long.byte 0x00 0.--6. 1. "         SEL_INT_NUM304                 ,selected interrupt number"

group d:0xD42822B4++0x03
    line.long 0x00 "ICU_APc8_IRQ_NUM,APc8 IRQ Selected Interrupt Number Register"
        bitfld.long 0x00 7. " INT_PENDING312                  ,interrupt pending  0 = no pending interrupt  1 = pending interrupt available" "0,1"
        hexmask.long.byte 0x00 0.--6. 1. "         SEL_INT_NUM313                 ,selected interrupt number"

group d:0xD42822B8++0x03
    line.long 0x00 "ICU_APc8_GBL_INT_MSK,APc8 Global Interrupt Mask Register"
        bitfld.long 0x00 1. " IRQ_MSK321                      ,global irq masking bit, can be cleared by pmu hardware  0 = interrupt is not masked  1 = interrupt is masked" "0,1"
        bitfld.long 0x00 0. "         FIQ_MSK322                     ,global fiq masking bit, can be cleared by pmu hardware  0 = interrupt is not masked  1 = interrupt is masked" "0,1"

group d:0xD42822C0++0x03
    line.long 0x00 "ICU_APc9_FIQ_NUM,APc9 FIQ Selected Interrupt Number Register"
        bitfld.long 0x00 7. " INT_PENDING330                  ,interrupt pending  0 = no pending interrupt  1 = pending interrupt available" "0,1"
        hexmask.long.byte 0x00 0.--6. 1. "         SEL_INT_NUM331                 ,selected interrupt number"

group d:0xD42822C4++0x03
    line.long 0x00 "ICU_APc9_IRQ_NUM,APc9 IRQ Selected Interrupt Number Register"
        bitfld.long 0x00 7. " INT_PENDING339                  ,interrupt pending  0 = no pending interrupt  1 = pending interrupt available" "0,1"
        hexmask.long.byte 0x00 0.--6. 1. "         SEL_INT_NUM340                 ,selected interrupt number"

group d:0xD42822C8++0x03
    line.long 0x00 "ICU_APc9_GBL_INT_MSK,APc9 Global Interrupt Mask Register"
        bitfld.long 0x00 1. " IRQ_MSK348                      ,global irq masking bit, can be cleared by pmu hardware  0 = interrupt is not masked  1 = interrupt is masked" "0,1"
        bitfld.long 0x00 0. "         FIQ_MSK349                     ,global fiq masking bit, can be cleared by pmu hardware  0 = interrupt is not masked  1 = interrupt is masked" "0,1"

group d:0xD4282300++0x03
    line.long 0x00 "ICU_ARM_INT_STATUS,"
        bitfld.long 0x00 25. " AP_L2_INT_STATUS                ,ap l2 int status" "0,1"
        bitfld.long 0x00 23.--24. "         AP_C2_COMMIRQ_STATUS           ,ap cluster2  2 cores commirq status" "0,1,2,3"
        bitfld.long 0x00 22. "   AP_C2_AXIERR_STATUS            ,ap cluster2 axierr status" "0,1"
        hexmask.long.byte 0x00 14.--21. 1. "  CCI_EVNTCNTOVERFLOW_STATUS     ,cci evntcntoverflow  status"
        textline "                                           "
        bitfld.long 0x00 13. "CCI_ERRORIRQ_STATUS             ,cci errorirq status" "0,1"
        bitfld.long 0x00 9.--12. "         AP_C1_COMMIRQ_STATUS           ,ap cluster1  4 cores commirq status" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 8. "  AP_C1_AXIERR_STATUS            ,ap cluster1 axierr status" "0,1"
        bitfld.long 0x00 4.--7. "  AP_C0_COMMIRQ_STATUS           ,ap cluster0  4 cores commirq status" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        textline "                                           "
        bitfld.long 0x00 3. "AP_C0_AXIERR_STATUS             ,ap cluster0 axierr status" "0,1"
        bitfld.long 0x00 2. "         CP_L2_UECC_INT_STATUS          ,seagull l2 uecc interrupt status" "0,1"
        bitfld.long 0x00 1. "   CP_L2_ECC_INT_STATUS           ,seagull l2 ecc interrupt status" "0,1"
        bitfld.long 0x00 0. "  CP_L2_PA_ECC_INT_STATUS        ,seagull l2 pa ecc interrupt status" "0,1"

group d:0xD4282304++0x03
    line.long 0x00 "ICU_ARM_INT_MSK,ARM Interrupt Mask Register"
        bitfld.long 0x00 25. " AP_L2_INT_MASK                  ,ap l2 int mask  0 = interrupt is not masked  1 = interrupt is masked.  currently it's not used." "0,1"
        bitfld.long 0x00 23.--24. "         AP_C2_COMMIRQ_MASK             ,ap cluster2  2 cores commirq mask  0 = interrupt is not masked  1 = interrupt is masked" "0,1,2,3"
        bitfld.long 0x00 22. "   AP_C2_AXIERR_MASK              ,ap cluster2 axierr mask  0 = interrupt is not masked  1 = interrupt is masked" "0,1"
        hexmask.long.byte 0x00 14.--21. 1. "  CCI_EVNTCNTOVERFLOW_MASK       ,cci evntcntoverflow  mask  0 = interrupt is not masked  1 = interrupt is masked"
        textline "                                           "
        bitfld.long 0x00 13. "CCI_ERRORIRQ_MASK               ,cci errorirq mask  0 = interrupt is not masked  1 = interrupt is masked" "0,1"
        bitfld.long 0x00 9.--12. "         AP_C1_COMMIRQ_MASK             ,ap cluster1  4 cores commirq mask  0 = interrupt is not masked  1 = interrupt is masked" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 8. "  AP_C1_AXIERR_MASK              ,ap cluster1 axierr mask  0 = interrupt is not masked  1 = interrupt is masked" "0,1"
        bitfld.long 0x00 4.--7. "  AP_C0_COMMIRQ_MASK             ,ap cluster0  4 cores commirq mask  0 = interrupt is not masked  1 = interrupt is masked" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        textline "                                           "
        bitfld.long 0x00 3. "AP_C0_AXIERR_MASK               ,ap cluster0 axierr mask  0 = interrupt is not masked  1 = interrupt is masked" "0,1"
        bitfld.long 0x00 2. "         CP_L2_UECC_INT_MSK             ,seagull l2 uecc interrupt mask  0 = interrupt is not masked  1 = interrupt is masked" "0,1"
        bitfld.long 0x00 1. "   CP_L2_ECC_INT_MSK              ,seagull l2 ecc interrupt mask  0 = interrupt is not masked  1 = interrupt is masked" "0,1"
        bitfld.long 0x00 0. "  CP_L2_PA_ECC_INT_MSK           ,seagull l2 pa ecc interrupt mask  0 = interrupt is not masked  1 = interrupt is masked" "0,1"

group d:0xD4282308++0x03
    line.long 0x00 "CP_WDT_INT_CLR,CP WDT interrupt clear"
        bitfld.long 0x00 1. " CP_WDT_INT_AP_CLR               ,ap internal clearing of cp_wdt_irq.    1 = ap internally clear the cp_wdt (cp_wdt_irq origin is not cleared).    0 = no action" "0,1"
        bitfld.long 0x00 0. "         CP_WDT_INT_SENSE               ,cp wdt int selection.    0 = use original cp_wdt interrupt.    1 = use the ap internal cleared cp_wdt interrupt" "0,1"

group d:0xD428230C++0x03
    line.long 0x00 "ICU_INT_WAKEUP_MASK,ICU Interrupt Wakeup Mask"
        bitfld.long 0x00 11. " ICU_INT_WAKEUP_TO_AP_CORE9_MSK  ,icu int wakeup to ap core9 mask  1 = mask" "0,1"
        bitfld.long 0x00 10. "         ICU_INT_WAKEUP_TO_AP_CORE8_MSK ,icu int wakeup to ap core8 mask  1 = mask" "0,1"
        bitfld.long 0x00 9. "   ICU_INT_WAKEUP_TO_AP_CORE7_MSK ,icu int wakeup to ap core7 mask  1 = mask" "0,1"
        bitfld.long 0x00 8. "  ICU_INT_WAKEUP_TO_AP_CORE6_MSK ,icu int wakeup to ap core6 mask  1 = mask" "0,1"
        textline "                                           "
        bitfld.long 0x00 7. "ICU_INT_WAKEUP_TO_AP_CORE5_MSK  ,icu int wakeup to ap core5 mask  1 = mask" "0,1"
        bitfld.long 0x00 6. "         ICU_INT_WAKEUP_TO_AP_CORE4_MSK ,icu int wakeup to ap core4 mask  1 = mask" "0,1"
        bitfld.long 0x00 4. "   ICU_INT_WAKEUP_TO_AP_CORE3_MSK ,icu int wakeup to ap core3 mask  1 = mask" "0,1"
        bitfld.long 0x00 3. "  ICU_INT_WAKEUP_TO_AP_CORE2_MSK ,icu int wakeup to ap core2 mask  1 = mask" "0,1"
        textline "                                           "
        bitfld.long 0x00 2. "ICU_INT_WAKEUP_TO_AP_CORE1_MSK  ,icu int wakeup to ap core1 mask  1 = mask" "0,1"
        bitfld.long 0x00 1. "         ICU_INT_WAKEUP_TO_AP_CORE0_MSK ,icu int wakeup to ap core0 mask  1 = mask" "0,1"

group d:0xD4282318++0x03
    line.long 0x00 "ICU_DMA_NON_SEC_AP_CORES_INT_ST,DMA Non-secure Interrupt to AP Cores Status Register"
        hexmask.long 0x00 0.--31. 1. " DMA_NON_SEC_AP_CORES_INT_STATUS ,dma non-secure interrupt to ap cores interrupt status  this field contains one bit for each dma channel interrupt that is pending (after masking).  0 = dma interrupt is not pending   1 = dma interrupt is pending"

group d:0xD428231C++0x03
    line.long 0x00 "ICU_DMA_NON_SEC_AP_INT_MSK,DMA Non-secure Interrupt to AP Cores Mask Register"
        hexmask.long 0x00 0.--31. 1. " DMA_NON_SEC_AP_CORES_INT_MASK   ,dma non-secure interrupt mask to ap cores. this field contains one bit for each dma channel interrupt mask.  1 = interrupt is masked"

group d:0xD4282320++0x03
    line.long 0x00 "ICU_DMA_SEC_AP_CORES_INT_ST,DMA Secure Interrupt to AP Cores Status Register"
        hexmask.long 0x00 0.--31. 1. " DMA_SEC_AP_CORES_INT_STATUS     ,dma secure interrupt to ap cores interrupt status  this field contains one bit for each dma channel interrupt that is pending (after masking).  0 = dma interrupt is not pending   1 = dma interrupt is pending"

group d:0xD4282324++0x03
    line.long 0x00 "ICU_DMA_SEC_AP_INT_MSK,DMA Secure Interrupt to AP Cores Mask Register"
        hexmask.long 0x00 0.--31. 1. " DMA_SEC_AP_CORES_INT_MASK       ,dma secure interrupt mask to ap cores. this field contains one bit for each dma channel interrupt mask.  1 = interrupt is masked"

tree.end

tree "jtagsw"

width 33.

group d:0xD4013100++0x03
    line.long 0x00 "JTAGSW_EN,Enable Software JTAG Register"
        bitfld.long 0x00 0. " EN_MUX_JTG_SOFT          ,enable the software jtag functionality  1 = enabled  0 = disabled" "0,1"

group d:0xD4013104++0x03
    line.long 0x00 "JTAGSW_CTRL,Software JTAG Control Register"
        bitfld.long 0x00 3. " JTAG_SOFT_OUT_TCK        ,software jtag tck control" "0,1"
        bitfld.long 0x00 2. "  JTAG_SOFT_OUT_TMS      ,software jtag tms control" "0,1"
        bitfld.long 0x00 1. "  JTAG_SOFT_OUT_TRST ,software jtag trst control" "0,1"
        bitfld.long 0x00 0. "  JTAG_SOFT_OUT_TDI ,software jtag tdi control" "0,1"

group d:0xD4013108++0x03
    line.long 0x00 "JTAGSW_DATA,Software JTAG Serial Data Register"
        bitfld.long 0x00 0. " JTAG_SOFT_PREAD_DATA34   ,software jtag data  if the <enable the software jtag functionality> field is set to 0x1, then this field reflects the value of the input signal jtag_tdo based on the controls of the software jtag serial data register." "0,1"

group d:0xD401310C++0x03
    line.long 0x00 "JTAGSW_READ_BOOTROM_BRANCH2SRAM,Software JTAG Read Access to bootrom_branch2sram"
        bitfld.long 0x00 1. " JTAG_SOFT_PREAD_DATA_GPS ,read bootrom_branch2gps_sram through software jtag.  if the <enable the software jtag functionality> field is set to 0x1, then this field reflects the value of bootrom_branch2gps_sram, which decides whether to branch to sram. i.e. with this bit judged 1, boot can choose to branch to gps sram, to execute program preloaded through dat mode." "0,1"
        bitfld.long 0x00 0. "  JTAG_SOFT_PREAD_DATA44 ,read bootrom_branch2sram through software jtag.  if the <enable the software jtag functionality> field is set to 0x1, then this field reflects the value of bootrom_branch2sram, which decides whether to branch to sram. i.e. with this bit judged 1, boot can choose to branch to squ, to execute program preloaded through dat mode." "0,1"

tree.end

tree "kpc"

width 12.

group d:0xD4012000++0x03
    line.long 0x00 "KPC_PC,Keypad Control Register"
        bitfld.long 0x00 30. " KP_AS24                      ,automatic scan  0 = no effect  1 = a write of 0x1 to this field causes the keypad to be scanned once, then for it to reset to zero" "0,1"
        bitfld.long 0x00 29. "   ASACT                        ,automatic scan on activity  0 = no automatic scan on activity  1 = if <automatic scan> is 0x0, the keypad is scanned to detect the key pressed whenever there is any keypad activity and the key is pressed for a duration longer than the key debounce interval specified by kpkdi[interval]." "0,1"
        bitfld.long 0x00 26.--28. "   MKRN      ,matrix keypad row number  this octal value plus 1 indicates the number of rows in the matrix keypad. examples:  0x0 = number of keypad rows is 1  0x7 = number of keypad rows is 8" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 23.--25. "   MKCN        ,matrix keypad column number  this octal value plus 1 indicates the number of columns in the matrix keypad. examples:  0x0 = number of keypad columns is 1  0x7 = number of keypad columns is 8" "0,1,2,3,4,5,6,7"
        textline "                      "
        bitfld.long 0x00 22. "MI                           ,matrix keypad interrupt  when this field is automatically set to 0x1, an interrupt is sent to the interrupt controller. this field is reset when read. writes to this field are ignored." "0,1"
        bitfld.long 0x00 21. "   IMKP                         ,ignore multiple keypress (applies to matrix-keypad interface only)  0 = in case of automatic scan by keypad activity and manual scan, do not ignore multiple keypresses  1 = in case of automatic scan by keypad activity and manual scan, ignore multiple keypresses after a keypress activity has been detected and scanned" "0,1"
        bitfld.long 0x00 20. "   MS7       ,manual matrix scan line 7  asserted to scan column 7 of the matrix keypad." "0,1"
        bitfld.long 0x00 19. "   MS6         ,manual matrix scan line 6  asserted to scan column 6 of the matrix keypad." "0,1"
        textline "                      "
        bitfld.long 0x00 18. "MS5                          ,manual matrix scan line 5  asserted to scan column 5 of the matrix keypad." "0,1"
        bitfld.long 0x00 17. "   MS4                          ,manual matrix scan line 4  asserted to scan column 4 of the matrix keypad." "0,1"
        bitfld.long 0x00 16. "   MS3       ,manual matrix scan line 3  asserted to scan column 3 of the matrix keypad." "0,1"
        bitfld.long 0x00 15. "   MS2         ,manual matrix scan line 2  asserted to scan column 2 of the matrix keypad." "0,1"
        textline "                      "
        bitfld.long 0x00 14. "MS1                          ,manual matrix scan line 1  asserted to scan column 1 of the matrix keypad." "0,1"
        bitfld.long 0x00 13. "   MS0                          ,manual matrix scan line 0  asserted to scan column 0 of the matrix keypad." "0,1"
        bitfld.long 0x00 12. "   ME        ,matrix keypad enable  0 = disabled  1 = enabled" "0,1"
        bitfld.long 0x00 11. "   KP_MIE47    ,matrix interrupt enable  0 = disabled  1 = enabled" "0,1"
        textline "                      "
        bitfld.long 0x00 9. "DK_DEB_SEL                   ,direct keypad debounce select  1 = direct keypad debounce interval equal to the <direct key debounce interval> field of the keypad key debounce interval register  0 = direct keypad debounce interval equal to the <matrix key debounce interval> field of the keypad key debounce interval register" "0,1"
        bitfld.long 0x00 6.--8. "   DN                           ,direct key number  this octal value + 1 indicates the number of keys in the direct keypad plus the number of rotary-encoder sensor inputs. examples:  0x0 = number of direct keys plus rotary-encoder sensor inputs is 1  0x7 = number of direct keys plus rotary-encoder sensor inputs is 8" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 5. "   DI        ,direct keypad interrupt  when this field is automatically set to 0x1, an interrupt is sent to the interrupt controller. this field is reset when read. writes to this field are ignored." "0,1"
        bitfld.long 0x00 4. "   RE_ZERO_DEB ,rotary encoder zero debounce interval  1 = rotary encoder logic debounce interval equals zero  0 = rotary encoder logic debounce interval is equal to the direct keypad debounce interval" "0,1"
        textline "                      "
        bitfld.long 0x00 3. "REE1                         ,rotary encoder 1 enable  0 = not enabled  1 = enabled" "0,1"
        bitfld.long 0x00 2. "   REE0                         ,rotary encoder 0 enable  0 = disabled  1 = enabled" "0,1"
        bitfld.long 0x00 1. "   DE        ,direct keypad enable  0 = disabled  1 = enabled" "0,1"
        bitfld.long 0x00 0. "   DIE         ,direct keypad interrupt enable  0 = disabled  1 = enabled" "0,1"

group d:0xD4012008++0x03
    line.long 0x00 "KPC_DK,Keypad Direct Key Register"
        bitfld.long 0x00 31. " DKP                          ,direct key pressed  1 = direct key pressed since last read  0 = reset on register read" "0,1"
        bitfld.long 0x00 7. "   DK7                          ,direct key 7 input" "0,1"
        bitfld.long 0x00 6. "   DK6       ,direct key 6 input" "0,1"
        bitfld.long 0x00 5. "   DK5         ,direct key 5 input" "0,1"
        textline "                      "
        bitfld.long 0x00 4. "DK4                          ,direct key 4 input" "0,1"
        bitfld.long 0x00 3. "   RB1_DK3                      ,rotary encoder b / direct key 3 input  if rotary encoder 1 is disabled: input = direct key 3  if rotary encoder 1 is enabled: input = rotary encoder 1, sensor b" "0,1"
        bitfld.long 0x00 2. "   RA1_DK2   ,rotary encoder a / direct key 2 input  if rotary encoder 1 is disabled: input = direct key 2  if rotary encoder 1 is enabled: input = rotary encoder 1, sensor a" "0,1"
        bitfld.long 0x00 1. "   RB0_DK1     ,rotary encoder b / direct key 1 input  if rotary encoder 0 is disabled: input = direct key 1  if rotary encoder 0 is enabled: input = rotary encoder 0, sensor b" "0,1"
        textline "                      "
        bitfld.long 0x00 0. "RA0_DK0                      ,rotary encoder a / direct key 0 input  if rotary encoder 0 is disabled: input = direct key 0  if rotary encoder 0 is enabled: input = rotary encoder 0, sensor a" "0,1"

group d:0xD4012010++0x03
    line.long 0x00 "KPC_REC,Keypad Rotary Encoder Count Register"
        bitfld.long 0x00 31. " OF1                          ,overflow bit for rotary encoder 1  set to 0x1 when the count value goes above the maximum 8-bit value of 255. reset to 0x0 on read." "0,1"
        bitfld.long 0x00 30. "   UF1                          ,underflow bit for rotary encoder 1  set to 0x1 when the count value goes below zero. reset to 0x0 on read." "0,1"
        hexmask.long.byte 0x00 16.--23. 1. "   RE_COUNT1 ,count value for rotary encoder 1"
        bitfld.long 0x00 15. "  OF0         ,overflow bit for rotary encoder 0  set to 0x1 when the count value goes above the maximum 8-bit value of 255. reset to 0x0 on read." "0,1"
        textline "                      "
        bitfld.long 0x00 14. "UF0                          ,underflow bit for rotary encoder 0  set to 0x1 when the count value goes below zero. reset to 0x0 on read." "0,1"
        hexmask.long.byte 0x00 0.--7. 1. "   RE_COUNT0                    ,count value for rotary encoder 0"

group d:0xD4012018++0x03
    line.long 0x00 "KPC_MK,Keypad Matrix Key Register"
        bitfld.long 0x00 31. " MKP                          ,mkp  0 = reset on register read  1 = matrix key pressed since last read" "0,1"
        bitfld.long 0x00 7. "   MR7                          ,matrix row 7" "0,1"
        bitfld.long 0x00 6. "   MR6       ,matrix row 6" "0,1"
        bitfld.long 0x00 5. "   MR5         ,matrix row 5" "0,1"
        textline "                      "
        bitfld.long 0x00 4. "MR4                          ,matrix row 4" "0,1"
        bitfld.long 0x00 3. "   MR3                          ,matrix row 3" "0,1"
        bitfld.long 0x00 2. "   MR2       ,matrix row 2" "0,1"
        bitfld.long 0x00 1. "   MR1         ,matrix row 1" "0,1"
        textline "                      "
        bitfld.long 0x00 0. "MR0                          ,matrix row 0" "0,1"

group d:0xD4012020++0x03
    line.long 0x00 "KPC_AS,Keypad Automatic Scan Register"
        bitfld.long 0x00 31. " SO123                        ,scan on  this field is set to 1 at the beginning of the automatic scan or automatic scan on activity and is cleared to 0 when the scan completes. when set, the data in this register is invalid." "0,1"
        bitfld.long 0x00 26.--30. "   MUKP                         ,multiple keys pressed  0x00 = no key pressed  0x01 = single key pressed. read row and column information from the <row pressed> and <column pressed> fields.  > 0x01 = multiple keys pressed. read the keypress information from the keypad interface automatic scan multiple keypress registers 0 to 3" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"
        bitfld.long 0x00 4.--7. "  RP        ,row pressed  0xf = data invalid (also the reset value)  0x0 = key pressed is in row 0  ...continuing sequentially through...  0x7 = key pressed is in row 7" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 0.--3. "  CP          ,column pressed  0xf = data invalid (also the reset value)  0x0 = key pressed is in column 0  ...continuing sequentially through...  0x7 = key pressed is in column 7" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"

group d:0xD4012028++0x03
    line.long 0x00 "KPC_ASMKP0,Keypad Automatic Scan Multiple Keypress Register 0"
        bitfld.long 0x00 31. " SO152                        ,scan on  this field is set to 1 at the beginning of the automatic scan or automatic scan on activity and cleared to 0 when the scan completes. when set, the data in this register is invalid." "0,1"
        hexmask.long.byte 0x00 16.--23. 1. "   MKC1                         ,matrix keypad column 1 reading  a set bit identifies a key in the corresponding row and column 1:  bit 23 = row 7, sequentially through  bit 16 = row 0"
        hexmask.long.byte 0x00 0.--7. 1. "  MKC0      ,matrix keypad column 0 reading  a set bit identifies a key in the corresponding row and column 0:  bit 7 = row 7, sequentially through  bit 0 = row 0"

group d:0xD4012030++0x03
    line.long 0x00 "KPC_ASMKP1,Keypad Automatic Scan Multiple Keypress Register 1"
        bitfld.long 0x00 31. " SO163                        ,scan on  this field is set to 1 at the beginning of the automatic scan or automatic scan on activity and cleared to 0 when the scan completes. when set, the data in this register is invalid." "0,1"
        hexmask.long.byte 0x00 16.--23. 1. "   MKC3                         ,matrix keypad column 3 reading  a set bit identifies a key in the corresponding row and column 3:  bit 23 = row 7, sequentially through  bit 16 = row 0"
        hexmask.long.byte 0x00 0.--7. 1. "  MKC2      ,matrix keypad column 2 reading  a set bit identifies a key in the corresponding row and column 2:  bit 7 = row 7, sequentially through  bit 0 = row 0"

group d:0xD4012038++0x03
    line.long 0x00 "KPC_ASMKP2,Keypad Automatic Scan Multiple Keypress Register 2"
        bitfld.long 0x00 31. " SO174                        ,scan on  this field is set to 1 at the beginning of the automatic scan or automatic scan on activity and cleared to 0 when the scan completes. when set, the data in this register is invalid." "0,1"
        hexmask.long.byte 0x00 16.--23. 1. "   MKC5                         ,matrix keypad column 5 reading  a set bit identifies a key in the corresponding row and column 5:  bit 23 = row 7, sequentially through  bit 16 = row 0"
        hexmask.long.byte 0x00 0.--7. 1. "  MKC4      ,matrix keypad column 4 reading  a set bit identifies a key in the corresponding row and column 4:  bit 7 = row 7, sequentially through  bit 0 = row 0"

group d:0xD4012040++0x03
    line.long 0x00 "KPC_ASMKP3,Keypad Automatic Scan Multiple Keypress Register 3"
        bitfld.long 0x00 31. " SO185                        ,scan on  this field is set to 1 at the beginning of the automatic scan or automatic scan on activity and cleared to 0 when the scan completes. when set, the data in this register is invalid." "0,1"
        hexmask.long.byte 0x00 16.--23. 1. "   MKC7                         ,matrix keypad column 7 reading  a set bit identifies a key in the corresponding row and column 7:  bit 23 = row 7, sequentially through  bit 16 = row 0"
        hexmask.long.byte 0x00 0.--7. 1. "  MKC6      ,matrix keypad column 6 reading  a set bit identifies a key in the corresponding row and column 6:  bit 7 = row 7, sequentially through  bit 0 = row 0"

group d:0xD4012048++0x03
    line.long 0x00 "KPC_KDI,Keypad Key Debounce Interval Register"
        hexmask.long.byte 0x00 8.--15. 1. " DIRECT_KEY_DEBOUNCE_INTERVAL ,direct key debounce interval  this field is used for the direct key debounce interval in binary number of 2 ms."
        hexmask.long.byte 0x00 0.--7. 1. "  MATRIX_KEY_DEBOUNCE_INTERVAL ,matrix key debounce interval  this field is used for the matrix key debounce interval in binary number of 2 ms."

tree.end

tree "nfu"

width 14.

group d:0xD4283000++0x03
    line.long 0x00 "NFU_DCR,Data Flash Control Register"
        bitfld.long 0x00 31. " SPARE_EN              ,spare area enable  set this field to use the spare area of the nand flash for data storage. if this field is set and ecc is not enabled (<ecc enable> cleared), it is possible to write to and read from the entire data area and spare area. if this field is clear, the spare area is not available to users. if this field and <ecc enable> are set, the remaining spare bytes after ecc is written are available to software. refer to the tables on data area available to programmer when page_sz = 01 and data area available to programmer when page_sz = 00 (following this register) which specify the data bytes available for program/read, to the user per page for different settings in this field and the <ecc enable> field. the number specified in the dma data column in these tables is the number of bytes that the dma descriptors must be configured to transfer per page when the dfc is operating in dma mode.  the new ecc control register defines the number of bytes used by ecc in the <ecc bytes used in spare area> field in the ecc control register. for hamming ecc, the compatible definition is used. for extended ecc, additional bytes are required to achieve the needed error recovery.  0 = write/read to available spare area disabled  1 = write/read to available spare area enabled" "0,1"
        bitfld.long 0x00 30. "         ECC_EN      ,ecc enable  when this field is set, it enables the computation of ecc and error detection and correction. when this field is clear, ecc computation and error checks are not performed.  the new eccctrl register defines the type of ecc to be performed. the compatible algorithm is to use a single bit error correct, double bit detect hamming code where a syndrome is generated for each 512 bytes. for extended correction, a bch algorithm with 16-bit per 2 kb page correcting code is used.  0 = ecc is disabled for write and read data  1 = ecc is enabled for write and read data" "0,1"
        bitfld.long 0x00 29. "     NF_DMA_EN22    ,dma request enable  set this field to enable command and data dma requests. when this field is clear, no dma requests are asserted.  0 = data and command dma are disabled  1 = data and command dma are enabled" "0,1"
        bitfld.long 0x00 28. "     ND_RUN        ,nand controller run mode  when this field is set, the nand controller starts to execute the command in the command buffer. if the command buffer is empty when this field is set, the nand controller asserts the command-dma request if the dma request is enabled. this field is cleared when the nand flash controller finishes the execution of a command with the <next command> field in the data controller command buffer 0 register clear, indicating the end of the command sequence. for a bad-block detect, this field is cleared after the command buffer is emptied. clearing this field during a command execution results in an immediate termination of transactions to the flash device and clears the data and command buffers.  0 = nand controller is not in run mode  1 = nand controller is in run mode" "0,1"
        textline "                        "
        bitfld.long 0x00 27. "DWIDTH_C              ,data bus width of the nand flash controller  this field defines the data-bus width used by the nand flash controller to communicate to the flash memory device(s).  when this field = 1 and the <data bus width of the nand flash memory> field = 0, two flash devices are connected to the same chip. see the sequential row read (srr) functionality section.  0 = data bus width is 8 bits  1 = data bus width is 16 bits" "0,1"
        bitfld.long 0x00 26. "         DWIDTH_M    ,data bus width of the nand flash memory  this field defines the data bus width of the nand flash-memory devices used in the memory system. this field and the <data bus width of the nand flash controller> field determine the way nand flash devices are interfaced. table 3-9 on page 3-21 shows the valid data-width settings. the <data bus width of the nand flash controller> = 0 and this field = 1 is an invalid setting, and if used, the flash controller behavior defaults to <data bus width of the nand flash controller> = 0 and this field = 0.   when <data bus width of the nand flash controller> = 1 and this field = 0, two flash devices are connected to the same chip. see the sequential row read (srr) functionality section.  0 = data bus width is 8 bits  1 = data bus width is 16 bits" "0,1"
        bitfld.long 0x00 24.--25. "     PAGE_SZ        ,page size of the flash device  this field defines the page size of the flash memory. all memory devices used in the flash-memory system must have the same bus width, page size, command set, and timing parameters.  refer to the tables on data area available to programmer when page_sz = 01 and data area available to programmer when page_sz = 00 (following this register) which describe the data area available to the programmer when this field is set to 0x0 and 0x1.  0x0 = 512 bytes main and 16 bytes spare area, 528 bytes total  0x1 = 2048 bytes main and 64 bytes spare area, 2112 bytes total  0x2 = reserved to define 4096 byte page  0x3 = reserved to define 8192 byte page" "0,1,2,3"
        bitfld.long 0x00 23. "     SEQ_DIS       ,sequential page read disable  this field should be set if sequential page read is not wanted. when this field is clear, all multi-page reads are completed sequentially. the device is addressed only when the first page is read, and subsequent page reads are performed by toggling nd_ren when the device is ready. consult the data sheet of the flash part under 'sequential row read' or similar for details." "0,1"
        textline "                        "
        bitfld.long 0x00 22. "ND_STOP               ,nand flash controller clean stop  this field puts the controller in a quiescent state cleanly if set before going into a low power mode. the controller will finish the current operation in execution (excluding automatic status check) and clear the <nand controller run mode> field to go into idle state when this bit is set to 1.   software needs to set this bit to 1 before entering low power mode and wait for the <nand controller run mode> field to become 0 before it enters low power mode. refer to the low power mode section for the exact low power entry/exit sequence.  the usage model for this field is to interrupt the nand controller and dma when processing a long chain of commands. this field is of limited utility when the dfc is not used in dma mode as the time between setting the <nand controller run mode> field and the completion of the command does not leave much opportunity to set the bit. one way to have a synchronous stop is to set this field at the same time that one sets the <nand controller run mode> field, but this is obviously a contrived example with no practical utility.  0 = do not put the controller in idle  1 = stop the controller and put it into an idle state for low power mode entry" "0,1"
        bitfld.long 0x00 21. "         FORCE_CSX   ,force chip select false on busy  if this field is set, then the ce for the addressed flash must be de-asserted during the time where busy is expected to be asserted. in addition, during all operations, dfi arbitration must be allowed during the command and/or data transfer phases. under normal operation, ce shall stay asserted throughout the command and also throughout the data transfer phases, but if the dfi is being arbitrated away from the dfc, the command sequence or data sequence shall be interrupted at the beginning of the current cycle by first de-asserting ce and then relinquishing the dfi to the other slave. during an address phase where ale is asserted, ale is de-asserted along with ce. when the dfc re-acquires the dfi, ale and ce will assert and address cycles will continue with we strobes.  0 = assert chip select during entire command, except during command overlap  1 = de-assert chip select during busy phases" "0,1"
        bitfld.long 0x00 20. "     CLR_PG_CNT     ,clear page count  when set, this field clears the data controller page count register. after the nand interface page count register is cleared, this field is reset. when a program failure occurs, this field can be used to clear the page count values after software reads the number of pages programmed correctly.  0 = page count not cleared  1 = clear page count" "0,1"
        bitfld.long 0x00 19. "     STOP_ON_UNCOR ,stop on uncorrectable error  if an uncorrectable error is received on a read and this field is set, the <next command> field in the data controller command buffer 0 register is reset and further command dma processing is halted.  0 = do not stop on uncorrectable error  1 = stop on uncorrectable error" "0,1"
        textline "                        "
        bitfld.long 0x00 16.--18. "RD_ID_CNT             ,read id byte count  this field specifies the number of data bytes to read from the flash device when a read-id command is issued. for a read id command, the page count should be set to 1 (<page count> field in data controller command buffer 2 register should be zero).   values from 0x1 to 0x7. specifies the number of bytes of read id data to be read from the flash device." "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 15. "         RA_START    ,row address start position  this field specifies the address cycle where row address starts in the addressing sequence. when this field is clear, the <addr2> field in the data controller command buffer 1 register (address sent out in the second addressing cycle) contains the first row address. when this field is set, the <addr3> field in the data controller command buffer 1 register (address sent out in the third addressing cycle) contains the first row address.   0 = row address supplied to flash from second address cycle onwards  1 = row address supplied to flash from third address cycle onwards  the purpose of this field is to support older nand configurations that had 3 (or maybe 4) bytes of address. certain old small capacity and small block devices have the column address separated into a byte of address (<addr1>) where the most significant bit of the column was addressed if necessary by the first command byte. to access bytes 0-255, the first command byte was 0x00 and to access bytes 256-511, the first command byte is 0x01. however, most of the time, an entire page will be read anyway, so sub block addressing is not commonly used. for large page nand devices, this bit should always be set to 1." "0,1"
        bitfld.long 0x00 13.--14. "     PG_PER_BLK     ,pages per block  this field specifies the number of pages in one block of the flash device. when cleared, this field indicates 32 pages/block, and when set, it indicates 64 pages/block. this field along with the <row address start position> field is used by the dfc to increment the row address in multi-page commands.  0x0 = flash device has 32 pages per block  0x2 = flash device has 64 pages per block  0x1 = flash device has 128 pages per block  0x3 = flash device has 256 pages per block" "0,1,2,3"
        bitfld.long 0x00 12. "     ND_ARB_EN     ,data flash bus arbiter enable  this field enables the bus arbiter in the dfc, which controls the ownership of the data-flash bus. the data flash bus is shared between the smc and the dfc to transfer data to/from external memory devices. the ownership of df_sclk (the clock supplied to external memory devices on the data flash interface) is also controlled by the bus arbiter. when the dfc is granted the data flash bus, df_sclk is driven low. when this field is clear, the bus arbiter in the dfc is disabled, and the data flash bus and df_sclk are granted permanently to the smc. this field must be set when dfc operation is preferred." "0,1"
        textline "                        "
        bitfld.long 0x00 11. "RDYM                  ,flash device ready interrupt mask  this field is used to mask an interrupt request that is asserted when nd_rdy makes a transition from low to high, as indicated by the <rdy> field in the data controller status register. when this field is cleared, the interrupt is enabled, and whenever <rdy> is set, an interrupt request is made to the interrupt controller. when this field is cleared, the interrupt is masked and the state of the <rdy> status field does not generate an interrupt.  if more than one rnb signal is used, this mask bit enables/disables interrupts for both.  0 = flash device ready interrupt is enabled  1 = flash device ready interrupt is disabled" "0,1"
        bitfld.long 0x00 10. "         CS0_PAGEDM  ,nd_cs0n page done interrupt mask  this field is used to mask or enable an interrupt request that is asserted when a page transaction (read or write) to a flash device interfaced using nd_cs0n is completed, as indicated by the <nd_cs0n page done> field in the data controller status register. when this field is cleared, the interrupt is enabled and whenever <nd_cs0n page done> is set, an interrupt request is made to the interrupt controller. when this field is set, the interrupt is masked and the state of the page_dn status bit does not generate an interrupt.  0 = nd_cs0n page done interrupt is enabled  1 = nd_cs0n page done interrupt is disabled" "0,1"
        bitfld.long 0x00 9. "     CS1_PAGEDM     ,nd_cs1n page done interrupt mask  this field is used to mask or enable an interrupt request that is asserted when a page transaction (read or write) to flash device interfaced using nd_cs1n is completed as indicated by the <nd_cs1n page done> field in the data controller status register. when this field is cleared, the interrupt is enabled, and whenever <data controller status register> is set, an interrupt request is made to the interrupt controller. when this field is set, the interrupt is masked and the state of the page_dn status bit does not generate an interrupt.  0 = nd_cs1n page done interrupt is enabled  1 = nd_cs1n page done interrupt is disabled" "0,1"
        bitfld.long 0x00 8. "     CS0_CMDDM     ,nd_cs0n command done interrupt mask  this field is used to mask or enable an interrupt request that is asserted when the command for the flash device interfaced using nd_cs0n has been executed, as indicated by the <nd_cs0n command done> field in the data controller status register. when this field is cleared, the interrupt is enabled and whenever <nd_cs0n command done> is set, an interrupt request is made to the interrupt controller. when this field is set, the interrupt is masked and the state of the <nd_cs0n command done> field does not generate an interrupt.  0 = nd_cs0n command done interrupt is enabled  1 = nd_cs0n command done interrupt is disabled" "0,1"
        textline "                        "
        bitfld.long 0x00 7. "CS1_CMDDM             ,nd_cs1n command done interrupt mask  this field is used to mask or enable an interrupt request that is asserted when the command for the flash device interfaced using nd_cs1n has been executed, as indicated by the <nd_cs1n command done> field in the data controller status register. when this field is cleared, the interrupt is enabled, and whenever <nd_cs1n command done> is set, an interrupt request is made to the interrupt controller. when this field is set, the interrupt is masked and the state of the <nd_cs1n command done> status bit does not generate an interrupt.  0 = nd_cs1n command done interrupt is enabled  1 = nd_cs1n command done interrupt is disabled" "0,1"
        bitfld.long 0x00 6. "         CS0_BBDM    ,nd_cs0n bad block detect interrupt mask  this field is used to mask or enable an interrupt request that is asserted when the status check at the end of a page write or block erase to a device interfaced using nd_cs0n returns a bad-block error, as indicated by the <nd_cs0n bad block detect> field in the data controller status register. when this field = 0, the interrupt is enabled and whenever <nd_cs0n bad block detect> is set, an interrupt request is made to the interrupt controller. when this field = 1, the interrupt is masked and the state of the <nd_cs0n bad block detect> status bit does not generate an interrupt.  0 = nd_cs0n bad block detect interrupt is enabled  1 = nd_cs0n bad block detect interrupt is disabled" "0,1"
        bitfld.long 0x00 5. "     CS1_BBDM       ,nd_cs1n bad block detect interrupt mask  this field is used to mask or enable an interrupt request that is asserted when the status check at the end of a page write or block erase to a device interfaced using nd_cs1n returns a bad block error, as indicated by the <nd_cs1n bad block detect> field in the data controller status register. when this field is cleared, the interrupt is enabled, and whenever <nd_cs1n bad block detect> is set, an interrupt request is made to the interrupt controller. when this field is set, the interrupt is masked and the state of the <nd_cs1n bad block detect> status bit does not generate an interrupt." "0,1"
        bitfld.long 0x00 4. "     UNCERRM       ,ecc failure error interrupt mask  this field is used to mask or enable an interrupt request that is asserted when an uncorrectable hamming double-bit error is detected in any of the data streams as indicated by the <uncorrectable error> field in that data controller status register. when in extended ecc mode, this field indicates a failure with the bch ecc. when this field is cleared, the interrupt is enabled and whenever <uncorrectable error> is set, an interrupt request is made to the interrupt controller. when this field is set, the interrupt is masked and the state of the <uncorrectable error> status bit does not generate an interrupt. no data correction is possible for either kind of failure.  0 = ecc failure error interrupt is enabled  1 = ecc failure error interrupt is disabled" "0,1"
        textline "                        "
        bitfld.long 0x00 3. "CORERRM               ,correctable error interrupt mask  this field is used to mask or enable an interrupt request that is asserted when either a single-bit error is detected in any of the data streams when in hamming ecc mode or when the number of error exceeds the threshold defined in the ecc control register when in bch mode. this condition is indicated by the <correctable error> field in the data controller status register. when this field is cleared, the interrupt is enabled and whenever <correctable error> is set, an interrupt request is made to the interrupt controller. when this field is set, the interrupt is masked and the state of the <uncorrectable error> field in the data controller status register does not generate an interrupt. this interrupt is an indication only and can be used to determine if read disturbs require a block to be rewritten.  0 = single-bit error interrupt is enabled  1 = single-bit error interrupt is disabled" "0,1"
        bitfld.long 0x00 2. "         WRDREQM     ,write data request interrupt mask  this field is used to mask or enable an interrupt request that is asserted when a write command is loaded into command buffer and data buffer is empty, as indicated by the <write data request> field in the data controller status register. when this field is cleared, the interrupt is enabled and whenever <write data request> is set, an interrupt request is made to the interrupt controller. when this field is set, the interrupt is masked and the state of the <write data request> status bit does not generate an interrupt.  0 = write data request interrupt is enabled  1 = write data request interrupt is disabled" "0,1"
        bitfld.long 0x00 1. "     RDDREQM        ,read data request interrupt mask  this field is used to mask or enable an interrupt request that is asserted when the data buffer has been loaded with a page of read data, as indicated by the <read data request> field in the data controller status register. when this field is cleared, the interrupt is enabled, and whenever <read data request> is set, an interrupt request is made to the interrupt controller. when this field is set, the interrupt is masked and the state of the <read data request> status bit does not generate an interrupt.  0 = read data request interrupt is enabled  1 = read data request interrupt is disabled" "0,1"
        bitfld.long 0x00 0. "     WRCMDREQM     ,write command request interrupt mask  this field is used to mask or enable an interrupt request that is asserted when a write to the command buffer is requested, as indicated by the <write command request> field in the data controller status register. when this field is cleared, the interrupt is enabled, and whenever <write command request> is set, an interrupt request is made to the interrupt controller. when this field is set, the interrupt is masked and the state of the <read data request> field in the data controller status register does not generate an interrupt.  0 = write command request interrupt is enabled  1 = write command request interrupt is disabled" "0,1"

group d:0xD4283004++0x03
    line.long 0x00 "NFU_DTR0CS0,Data Controller Timing Parameter 0 Register for ND_CS0n"
        bitfld.long 0x00 27.--31. " TADL_X_ND             ,ad-l adjust" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"
        bitfld.long 0x00 26. "        SELCNTR     ,select read counter  this field determines the source of the read strobe.  0 = strobe is measured by phase values in the read enable return delay register  1 = strobe is <read strobe count delay> + 1 dfc clocks from the rising edge of ren." "0,1"
        bitfld.long 0x00 22.--25. "     RD_CNT_DEL     ,read strobe count delay  when enabled by the <select read counter> field, this value is the number of dfc clocks after the rising edge of ren to latch read data into the dfc from the dfi." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 19.--21. "    TCH           ,enable signal hold time  enable signal hold time (tch) defines the hold time (with respect to the rising edge of nd_wen) of nd_cs0n, nd_cs1n, nd_ale, and nd_cle.  value from 0 to 7. specifies the hold time for nd_cs0n, nd_cs1n, nd_ale, and nd_cle outputs in terms of nand controller clock periods.  hold time = tch+1." "0,1,2,3,4,5,6,7"
        textline "                        "
        bitfld.long 0x00 16.--18. "TCS                   ,enable signal setup time   enable signal setup time (tcs) defines the setup time (with respect to the falling edge of nd_wen) of nd_cs0n, nd_cs1n, nd_ale, and nd_cle.   value from 0 to 7. specifies the setup time for nd_cs0n, nd_cs1n, nd_ale, and nd_cle outputs in terms of nand controller clock periods.  setup time = tcs+1." "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 11.--13. "         TWH         ,nd_wen high duration  the period for which nd_wen remains high, while address or data is being input to the nand flash device in multiple nd_wen cycles, is specified by nd_wen high duration (twh). the valid values for twh are 0 through 7. actual high duration of nd_wen is twh+1 nand controller clock cycles.  value from 0 to 7. specifies the nd_wen high duration, in terms of nand controller clock periods.  nd_wen high duration = twh+1 for a series of write pulses. for the last write pulse of a command, the duration is max(twh,tch)+1.  also note that this is the minimum duration that is guaranteed. the maximum duration for which the nd_wen is high is greater than twh nand clock cycles if the dfi bus is granted to the smc during this time." "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 8.--10. "     TWP            ,nd_wen pulse width  the period for which nd_wen is asserted low is specified in we_pulse width (twp). the valid values for twp are 0 through 7. actual high duration of nd_wen pulse would be twp+1 nand controller clock cycles. the nd_wen cycle time is twh+twp+2 nand controller clock cycles.  value from 0 to 7. specifies the nd_wen pulse width in terms of nand controller clock periods.  nd_wen pulse width = twp+1." "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 7. "     SEL_NRE_EDGE  ,if the sel_nre_egde=1 -> select -ve edge as refernece for read data else +ve edge(default)" "0,1"
        textline "                        "
        bitfld.long 0x00 6. "ETRP                  ,extended trp  this bit is the msb for the trp value." "0,1"
        bitfld.long 0x00 3.--5. "         TRH         ,nd_ren high duration  the period for which nd_ren remains high while nd_ren is being toggled to access data during a read operation is specified by nd_ren high duration (trh). the valid values for trh are 0 through 7. actual high duration of nd_ren is trh+1 nand controller-clock cycles.  value from 0 to 7. specifies the nd_ren high duration in terms of nand controller clock periods.  nd_ren high duration = trh+1.  also note that this is the minimum duration that is guaranteed. the maximum duration for which the nd_ren is high is greater than trh nand clock cycles if the dfi bus is granted to the smc during this time." "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 0.--2. "     TRP            ,nd_ren pulse width  this field in conjunction with the <extended trp> field determine the period for which nd_ren is asserted low. the valid values for trp are 0 through 16. actual high duration of the nd_ren pulse is {etrp,trp}+1 nand controller clock cycles. the nd_ren cycle time would be trh+trp+2 nand controller clock cycles.  value from 0 to 16. specifies the nd_ren pulse width in terms of nand controller clock periods.  nd_ren pulse width = {etrp, trp} +1." "0,1,2,3,4,5,6,7"

group d:0xD428300C++0x03
    line.long 0x00 "NFU_DTR1CS0,Data Controller Timing Parameter 1 Register for ND_CS0n"
        hexmask.long.word 0x00 16.--31. 1. " TR                    ,nd_wen high to nd_ren low for read  value from 1 to 65535. specifies the delay between nd_wen high and nd_ren low for read in terms of nand controller clock periods. this delay depends on the value programmed in tch (in data controller timing parameter 0 register for nd_cs0n) in addition to tr programmed value.  delay = (tch + 1) + (tr+2)"
        bitfld.long 0x00 15. "      WAIT_MODE   ,this bit determines how the information in this register is used to determine state machine transitions on read operations.   0 = the tr time value specified in this register solely determine the duration. when this count has not expired, the state machine stalls and when the count reaches tr, regardless of the state of rnb, the operation will proceed. in other words rnb is ignored.  1 = the tr time value specified in this register determine the minimum duration. when this count has not expired, the state machine stalls. when this count has expired, there may be an additional stall if rnbx is still indicating busy. the proceed condition is the and of the time out from the defined timer and rnbx i.e. to proceed, both the time value must have expired and rnbx must be signaling <q>ready</q>.  for all reads, the timer always counts after the read command has been issued and this bit only determines the actual state machine proceed condition." "0,1"
        bitfld.long 0x00 14. "     TR_PRESCALE    ,tr multiplied by 16 when it set to 1" "0,1"
        bitfld.long 0x00 8.--9. "     TRHW_X        ,    2'b00 : trhw_cnt_x = 6'h00; //wait 0 clocks     2'b01 : trhw_cnt_x = 6'h0f;// 16 clocks     2'b10 : trhw_cnt_x = 6'h20; //32 clocks     2'b11 : trhw_cnt_x = 6'h30; //48 clocks" "0,1,2,3"
        textline "                        "
        bitfld.long 0x00 4.--7. "TWHR                  ,nd_wen high to nd_ren low for a read status  for a status-read command, nd_wen high to nd_ren low delay (twhr) specifies the delay between de-assertion of nd_wen and assertion of nd_ren.  the actual delay depends on tar, twh, and tch (the latter two in the data controller timing parameter 0 register for nd_cs0n) as well.  delay = max(tar, max(0, twhr - max(twh, tch)))  also note that this is the minimum duration that is guaranteed. the maximum duration is greater than twhr nand clock cycles if the dfi bus is granted to the smc during this time." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 0.--3. "        TAR         ,nd_ale low to nd_ren low delay   for a read-id command, nd_ale low to nd_ren low delay (tar) specifies the delay between de-assertion of nd_ale and assertion of nd_ren. the valid values for tar are 0 to 15.   the actual delay depends on tar, twh, and tch (the latter two in the data controller timing parameter 0 register for nd_cs0n) as well.  delay = max(tar, max(0, twhr - max(twh, tch)))+2" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"

group d:0xD4283014++0x03
    line.long 0x00 "NFU_DSR,Data Controller Status Register"
        bitfld.long 0x00 16.--20. " ERR_CNT               ,block error count  if the <ecc enable> field in the data flash control register is true, the <bch enable> field in the ecc control register is true and a ecc check has been performed, these bits indicate the number of errors encountered. if either <ecc enable> or <bch enable> are false, this field is 0x00. the error count is the number of non-zero syndromes. writing 0x1f into this field will reset the error count." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"
        bitfld.long 0x00 15. "        TRUSTVIO    ,trust violation  this field is set when a trusted partition access violation occurs." "0,1"
        bitfld.long 0x00 12. "     RDY109         ,the nand flash-ready (rdy) status bit is set when nand_rnb (nand flash ready/busy) has made a low-to-high transition, indicating the ready state entry of flash device(s). the nand flash-ready condition can be programmed to cause an interrupt by clearing the flash-device-ready interrupt mask (rdym). this status field is updated continuously each time nand_rnb input makes a low-to-high transition, regardless of the type of command sent to the flash device.  in a ganged configuration (two 8-bit parts connected as a logical 16-bit part, where the rnb signals of each part are wire anded), the rdy reflects the worst case time from the two ganged parts.  0 = the nd_rdy input has not transitioned from low to high  1 = the nd_rdy input has transitioned from low to high" "0,1"
        bitfld.long 0x00 11. "     RDY111        ,nand flash ready  the nand flash-ready (rdy) status bit is set when nand_rnb (nand flash ready/busy) has made a low-to-high transition, indicating the ready state entry of flash device(s). the nand flash-ready condition can be programmed to cause an interrupt by clearing the flash-device-ready interrupt mask (rdym). this status bit is updated continuously each time nand_rnb input makes a low-to-high transition, regardless of the type of command sent to the flash device.  in a ganged configuration (two 8-bit parts connected as a logical 16-bit part, where the rnb signals of each part are wire anded) the rdy reflects the worst case time from the two ganged parts.  0 = the ready/busy_ input has not transitioned from low to high  1 = the ready/busy_ input has transitioned from low to high" "0,1"
        textline "                        "
        bitfld.long 0x00 10. "CS0_PAGED             ,nd_cs0n page done  this status field is set when the read or write transaction to flash device(s) interfaced using nd_cs0n has completed a page of access including any user-defined spare-area access and ecc. this field is not set if an auto-status check after a program command results in a failure. this field is not set for read id, read status, and erase commands. page-done condition can be programmed to cause an interrupt by clearing the <nd_cs0n page done interrupt mask> field.   0 = the current read/write transaction on nd_cs0n has not reached a page boundary  1 = the current read/write transaction on nd_cs0n has reached a page boundary" "0,1"
        bitfld.long 0x00 9. "         CS1_PAGED   ,nd_cs1n page done  this status field is set when the read or write transaction to flash device(s) interfaced using nd_cs1n has completed a page of access including any user-defined spare-area access and ecc. this field is not set if an auto-status check after a program command results in a failure. this field is not set for read id, read status, and erase commands. page-done condition can be programmed to cause an interrupt by clearing the <nd_cs1 page done interrupt mask> field." "0,1"
        bitfld.long 0x00 8. "     CS0_CMDD       ,nd_cs0n command done  this field is set when the execution of the command sent to the flash device(s) on nd_cs0n completes successfully. this field is not set if an auto-status check after a program/erase command returns a failure. a command-done condition can be programmed to cause an interrupt by clearing the <nd_cs0n command done interrupt mask> field in the data flash control register. command done is set when the command has finished being sequenced to the dfi, but whether or not a particular command is finished depends on the specific command. a read type command is done when it has been sequenced, but it is still required that the data buffer be emptied, so setting this field does not signify that the dfc is ready for the next operation.  0 = the command execution on nd_cs0n has not successfully completed  1 = the command execution on nd_cs0n has successfully completed" "0,1"
        bitfld.long 0x00 7. "     CS1_CMDD      ,nd_cs1n command done  this field is set when the execution of the command sent to the flash device(s) on nd_cs0n is completed successfully. this field is not set if an auto-status check after a program/erase command returns a failure. command-done condition can be programmed to cause an interrupt by clearing the nd_cs0n command-done mask (cs1_cmddm). command done is set when the command has finished being sequenced to the dfi, but whether or not a particular command is finished depends on the specific command. a read type command is done when it has been sequenced, but it is still required that the data buffer be emptied, so setting cs0_cmdd does not signify that the dfc is ready for the next operation.  0 = the command execution on nd_cs1n has not successfully completed  1 = the command execution on nd_cs1n has successfully completed" "0,1"
        textline "                        "
        bitfld.long 0x00 6. "CS0_BBD               ,nd_cs0n bad block detect  this status field is set when the status read after a program/erase operation to flash device(s) interfaced using nd_cs0n returns a program/erase failure. a bad-block detect condition can be programmed to cause an interrupt by clearing the <nd_cs0n bad block detect interrupt mask> field in the data flash control register. when two 8-bit nand flash devices are interfaced to the 16-bit nand flash controller data bus (<data bus width of the nand flash controller> field in the data flash control register = 1 and <data bus width of the nand flash memory> field in the data flash control register = 0) using nd_cs0n, a program/erase failure in any one of the two devices results in this field getting set. because both flash devices are addressed at the same time, software must mark the corresponding blocks as non-valid.   0 = no bad block is encountered while a write/erase on nd_cs0n  1 = bad block is encountered while a write/erase on nd_cs0n" "0,1"
        bitfld.long 0x00 5. "         CS1_BBD     ,nd_cs1n bad block detect  this status field is set when the status read after a program/erase operation to flash device(s) interfaced using nd_cs1n returns a program/erase failure. a bad-block detect condition can be programmed to cause an interrupt by clearing the <nd_cs1n bad block detect interrupt mask> field in the data flash control register. when two 8-bit nand flash devices are interfaced to the 16-bit nand flash controller data bus (<data bus width of the nand flash controller> field in the data flash control register = 1 and <data bus width of the nand flash memory> field in the data flash control register = 0) using nd_cs1n, a program/erase failure in any one of the two devices results in this field getting set. because both flash devices are addressed at the same time, software can mark the corresponding blocks as non-valid.   0 = no bad block is encountered while a write/erase on nd_cs1n  1 = bad block is encountered while a write/erase on nd_cs1n" "0,1"
        bitfld.long 0x00 4. "     UNCERR         ,uncorrectable error  this status bit is set when an uncorrectable error is detected in any of the read data streams. uncorrectable error condition can be programmed to cause an interrupt by clearing the <ecc failure error interrupt mask> field in the data flash control register.  for <bch enable> in the ecc control register == 0 && <ecc enable> field in the data flash control register == 1 (hamming ecc is enabled) an uncorrectable error is the detection of two errors in a syndrome range. hamming codes are guaranteed to detect all possible 2 bit errors over their syndrome range. for <bch enable> == 1&& <ecc enable> == 1 (bch ecc is enabled) an uncorrectable error is the detection of more errors than be corrected. bch codes are not guaranteed to detect all possible error cases in excess of their correction ability, and it is possible (although highly unlikely) for the bch engine to report a false correction success.   when an uncorrectable error is detected, the bad-block detect bits (cs0_bbd, cs1_bbd) are not set and nand control bad block registers (ndbbrx) are not updated. software must take corrective action in this scenario. software could read ndcbx registers to get the block address that returned erroneous data and mark this block as invalid.  0 = no uncorrectable error is encountered in any of the page read data streams  1 = uncorrectable error is encountered in one of the page read data streams" "0,1"
        bitfld.long 0x00 3. "     CORERR        ,correctable error  the corerr status bit is set when a correctable error is detected in any of the read data streams. a correctable error condition can be programmed to cause an interrupt by clearing the correctable error mask (corerrm).  0 = no correctable error is encountered in any of the page read data streams.  1 = correctable error is encountered in one of the page read data streams.  for ndeccctrl.bch_en == 0 && ndcr.ecc_en == 1 (i.e. hamming ecc is enabled) a correctable error is the detection of one error in a syndrome range. for ndeccctrl.bch_en == 1&& ndcr.ecc_en == 1 (i.e. bch ecc is enabled) a correctable error is the detection of less than or equal to the maximum number of errors the bch can detect." "0,1"
        textline "                        "
        bitfld.long 0x00 2. "WRDREQ                ,write data request  the write-data-request (wrdreq) status bit is set when a write command is loaded into the nand flash controller command buffer and data buffer is empty. the write data request status bit can be programmed to cause an interrupt by clearing the write-data-request mask (wrdreqm).   0 = no write to the data buffer is required.  1 = current command is a page write and data buffer has not been loaded." "0,1"
        bitfld.long 0x00 1. "         RDDREQ      ,read data request  the read-data-request (rddreq) status bit is set when the data buffer is loaded with a complete page (including spare data if spare_en is set) of read data for a read operation. for read id and read-status operations, rddreq is set when the data buffer is loaded with the requested number of read data bytes as specified in the command.  when ecc is enabled for hamming, rddreq is set once per entire data buffer transfer. when bch ecc is enabled, rddreq is set once per 32 bytes of read data transfer. if not in dma mode, the processor must check that this bit is set after each 32 byte read from nddb.  0 = no read from the data buffer is required.  1 = data buffer has read data available." "0,1"
        bitfld.long 0x00 0. "     WRCMDREQ       ,write command request  the write-command-request (wrcmdreq) status bit is set when one of the following conditions is met, indicating a request to write a command to the nand flash controller command buffer." "0,1"

group d:0xD4283018++0x03
    line.long 0x00 "NFU_DPCR,Data Controller Page Count Register"
        hexmask.long.byte 0x00 16.--23. 1. " PG_CNT_1              ,page count for device interfaced using nd_cs1n  the page count for a flash device on nd_cs1n (pg_cnt_1) indicates the number of pages completed (programmed or read) for a given nand flash-controller command. ndcb0[auto_rs] (see ndcb0) must be set for a multi-page program or multi-page read command. the page count gets reset when a command execution is finished. pg_cnt_1 is incremented after each page of data is programmed or read. however, if the status check after programming a page indicates a failure, pg_cnt_1 is not incremented and software can read this value to find out the last page programmed correctly and then set ndcr[clr_pg_cnt] to clear the page count values (see spare area used for ecc table)."
        hexmask.long.byte 0x00 0.--7. 1. "        PG_CNT_0    ,page count for device interfaced using nd_cs0n  page count for flash device on nd_cs0n (pg_cnt_0) indicates the number of pages completed (programmed or read) for a given nand flash controller command. ndcb0[auto_rs] (see ndcb0 must be set for a multi-page program or multi-page read command. the page count gets reset when a command execution is finished. pg_cnt_0 is incremented after each page of data is programmed or read. however, if the status check after programming a page indicates a failure, pg_cnt_0 is not incremented and software can read this value to find out the last page programmed correctly and then set ndcr[clr_pg_cnt] to clear the page count values (see ndcr)."

group d:0xD428301C++0x03
    line.long 0x00 "NFU_DBBRx,Data Controller Bad Block Registers 0 and 1"
        hexmask.long 0x00 0.--31. 1. " BAD_BLOCK_INFORMATION ,for a program command bbad block information contained in these registers consists of addr5, addr4, addr3, and addr2 for the command that resulted in a bad block detection. addr5 occupies the most significant byte and addr2 the least significant byte in ndbdrx. for an erase command bad block information contained in these registers consists of addr4, addr3, addr2, and addr1 for the command that resulted in a bad block detection. addr4 occupies the most significant byte and addr1 the least significant byte in ndbdrx.  when a bad block is detected (the cs0_bbd or cs1_bbd bits in ndsr gets set), software reads the corresponding ndbdrx registers, uses the relevant portions of the bad-block information to get the bad-block address, and mark these blocks addresses as non-valid. writes to the ndbbrx registers are ignored."

group d:0xD4283024++0x03
    line.long 0x00 "NFU_DREDEL,Read Enable Return Delay Register"
        bitfld.long 0x00 25. " ND_DIN_SEL            ,1 = use din clocked by delayed re  0 = use din delayed by delay element" "0,1"
        bitfld.long 0x00 8.--9. "         ND_DATA_DLY ,din dly to controller" "0,1,2,3"
        bitfld.long 0x00 4.--7. "     ND_RECLK_DLY   ,re dly when used as reclk" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 0.--3. "    ND_RE_DLY     ,re dly to controller" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"

group d:0xD4283028++0x03
    line.long 0x00 "NFU_DECCCTRL,ECC Control Register"
        hexmask.long.byte 0x00 7.--14. 1. " ECC_SPARE             ,ecc bytes used in spare area  this read-only value determines the number of bytes in the spare area that are dedicated to ecc storage. the number of bytes is determined by the <ecc enable> field in the data flash control register and bch_en."
        hexmask.long.byte 0x00 1.--6. 1. "        ECC_THRESH  ,ecc warning threshold  ecc threshold. when <bch enable> is true and the <ecc enable> field in the data flash control register is true, and the number of corrected errors exceeds this value, the corerr status is set. currently, with a maximum of 16 errors correctable, values greater than 16 have the effect of disabling corerr status."
        bitfld.long 0x00 0. "    BCH_EN         ,bch enable  when <ecc enable> in the data flash control register is true, reads from a page will perform ecc to the following degrees of correctability:  0 = 2 bits per 512 byte page and 8 bits per 2048 byte page, distributed as one error in every other bit per 512 byte sector  1 = 16 bits per 2048 byte page (plus spare area, if enabled)" "0,1"

group d:0xD428302C++0x03
    line.long 0x00 "NFU_DBZCNT,Timer for ND_RnB0 and ND_RnB1"
        hexmask.long 0x00 6.--31. 1. " ND_RNBCNT1            ,rnb busy count 1  this field is cleared to zero on the 1 -> 0 transition of rnb[1] and while rnb[1] is low, the field counts basic dfc controller clocks. when rnb[1] has a 0 -> 1 transition, the count freezes."
        hexmask.long.word 0x00 0.--15. 1. "  ND_RNBCNT0  ,rnb busy count 0  this field is cleared to zero on the 1 -> 0 transition of rnb[1] and while rnb[0] is low, the field counts basic dfc controller clocks. when rnb[0] has a 0 -> 1 transition, the count freezes."

group d:0xD4283030++0x03
    line.long 0x00 "NFU_DMUTEX,NAND Controller MUTEX Lock Register"
        bitfld.long 0x00 0. " MUTEX                 ,mutex lock  this field implements a test-and-set operation on the flash controller mutex lock.  when the controller is idle (both ndrnb bits indicate ready and nd_run is false) and this register is read, the current value of mutex is returned and is set immediately after. if the mutex was already set, it remains set.  when the controller is not idle (if either ndrnb bits indicate busy or nd_run is true) mutex will return true, and the register bit will not be changed.  consecutive back-to-back reads of this register will never both return false. the mutex can never be set when the controller is not idle (i.e. either ndrnb bits indicate busy or <nand controller run mode> in the data flash control register is true), but it can be cleared.  the intent of this register is to support a mutually exclusive ownership lock for the nand controller which is guaranteed to be in the same power state as the nand controller itself. this will support multiple asymmetric core implementations where the two cores may wish to declare ownership of the nand controller resource and/or these two cores may be in different power states.  writing a 1 to this field will clear it if it was set. the processor that read a false from this register is the only processor permitted to write the 1 to clear, however there is no hardware protection to enforce this." "0,1"

group d:0xD4283034++0x03
    line.long 0x00 "NFU_DCMDMAT,Partition Command Match Registers"
        bitfld.long 0x00 30.--31. " VALIDCNT              ,valid count  if this field is zero, the register may be written. if this register is not zero, it defines the number of fields (from lsb to msb) that contain valid values. if this field is 0x1, only the right most field is defined and so on." "0,1,2,3"
        bitfld.long 0x00 29. "         NAKEDDIS217 ,naked disallow  if this field is 1, the associated cmd field cannot be issued as either a reset semantic or as a naked command semantic. this prevents a malicious entity from creating command sequences where the address is not present with the command byte." "0,1"
        bitfld.long 0x00 28. "     ROWADD218      ,row address  if this field is 1, the address to be matched to the partition register starts at add1 (i.e. like an erase semantic). if the bit is 0, the address to be matched is a function of the <row address start position> field in the data flash control register. if <row address start position> is 0, the address match starts at add2, and if <row address start position> is 1, the address match starts at add3.  in addition, the value of the <pages per block> field in the data flash control register determines which bits of the block address are ignored to obtain the 'true' block address. partition matches are not on a page boundary but on a block boundary as the true protection is per nand block." "0,1"
        hexmask.long.byte 0x00 20.--27. 1. "     NF_CMD219     ,command match  this is the bit pattern to match to cmd1."
        textline "                        "
        bitfld.long 0x00 19. "NAKEDDIS220           ,naked disallow  if this bit is 1, the associated cmd field cannot be issued as either a reset semantic or as a naked command semantic. this prevents a malicious entity from creating command sequences where the address is not present with the command byte." "0,1"
        bitfld.long 0x00 18. "         ROWADD221   ,row address  if this field is 1, the address to be matched to the partition register starts at add1 (i.e. like an erase semantic). if the field is 0, the address to be matched is a function of the <row address start position> field in the data flash control register. if <row address start position> is 0, the address match starts at add2, and if <row address start position> is 1, the address match starts at add3.  in addition, the value of the <pages per block> field in the data flash control register determines which bits of the block address are ignored to obtain the 'true' block address. partition matches are not on a page boundary but on a block boundary as the true protection is per nand block." "0,1"
        hexmask.long.byte 0x00 10.--17. 1. "     NF_CMD222      ,command match  this is the bit pattern to match to cmd1."
        bitfld.long 0x00 9. "    NAKEDDIS223   ,naked disallow  if this field is 1, the associated cmd field cannot be issued as either a reset semantic or as a naked command semantic. this prevents a malicious entity from creating command sequences where the address is not present with the command byte." "0,1"
        textline "                        "
        bitfld.long 0x00 8. "ROWADD224             ,row address  if this field is 1, the address to be matched to the partition register starts at add1 (i.e. like an erase semantic). if the bit is a zero, the address to be matched is a function of the <row address start position> field in the data flash control register. if <row address start position> is 0, the address match starts at add2, and if <row address start position> is 1, the address match starts at add3.  in addition, the value of the <pages per block> field in the data flash control register determines which bits of the block address are ignored to obtain the 'true' block address. partition matches are not on a page boundary but on a block boundary as the true protection is per nand block." "0,1"
        hexmask.long.byte 0x00 0.--7. 1. "         NF_CMD225   ,command match  this is the bit pattern to match to cmd1."

group d:0xD4283040++0x03
    line.long 0x00 "NFU_DDB,Data Controller Data Buffer Register"
        hexmask.long 0x00 0.--31. 1. " NAND_FLASH_DATA       ,nand flash data  this field holds the write/read data."

group d:0xD4283048++0x03
    line.long 0x00 "NFU_DCB0,Data Controller Command Buffer 0"
        bitfld.long 0x00 29.--31. " CMD_XTYPE             ,command extended type  this field extends the command type semantic field and is defined only for read and write semantics.  the read semantic is divided into three sections, command dispatch, data transfer (after ready is high), and dma transfer. if the third section is disabled, the operation being performed is referred to as 'read sniffing'. here the purpose is to read a page and compute the number of ecc correction bits to make sure that the total correction is within the safe range of the nand management algorithm.  the write semantic is divided into three sections, initial command dispatch, data transfer, and command issue.  the reason for this extended field is to enable larger block support. all blocks larger than 2 kb will composed of 2 kb chunks, and to simplify the controller logic, these chunks are moved to and from the nand as a separate command semantic.  read semantics:  0x0 = monolithic read  0x1 = last naked read  0x2 = illegal  0x3 = illegal  0x4 = read sniff  0x5 = naked read sniff  0x6 = command dispatch  0x7 = illegal    write semantics:  0x0 = monolithic write  0x1 = naked write with final command  0x2 = illegal  0x3 = final command  0x4 = command dispatch with write  0x5 = naked write  0x6 = command dispatch  0x7 = illegal" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 28. "         LEN_OVRD    ,length override  0 = use the lengths defined by the <page size of the flash device> field in the data flash control register for the operation. a command block consists of three writes and the ndlencnt value in ndcb3 may not be written.  1 = use the length defined in <ndlencnt> in data controller command buffer 3 for the operation, regardless of the programming of the <page size of the flash device> field. a command block consists of four writes and the data controller command buffer 3 register must be written." "0,1"
        bitfld.long 0x00 27. "     RDY_BYP        ,ready bypass  0 = the current command will wait for the timeout as specified in ndtr1cs0 for the indicated csel to be true before proceeding  1 = the current command will continue to the next command (if there is one as defined by the nc bit)  the purpose for this function is to enable a real-time schedule of operations to the two chip selects where operations on one nand can continue while operations on the other nand are in progress. this is useful to enable striping where multiple identical operations are scheduled to the two chip selects.  this field is in addition to the capability mentioned in the command sequence and parallel execution section in the <var product number> datasheet and allows virtually any operation pair to be overlapped." "0,1"
        bitfld.long 0x00 26. "     ST_ROW_EN     ,status row address enable  for onfi nand parts, the status command may be performed on a per logical unit basis. the logical unit is addressed by the row address defined in the read, program or erase command.  if this field is set, both the automatic status cycle at the end of each read or write or any 'manual' status read will supply the row address where the row address is defined by the <number of address cycles> field and by the <row address start position> field in the data flash control register.  for read and program commands the <number of address cycles> field defines the total number of address cycles and the <row address start position> field defines which address bytes form the row address.  for the erase command, the <number of address cycles> itself defines the number of row address cycles and the <row address start position> field is ignored." "0,1"
        textline "                        "
        bitfld.long 0x00 25. "AUTO_RS               ,auto read status  when set, this field enables the automatic checking of the program/erase status by issuing a read status command. the bit pattern to be used for the status command is defined in the data controller command buffer 2. when this field is clear, no automatic status check is performed. when automatic status check is performed, status-read data is not written into the data buffer. the status-read data is checked by the dfc for the success of program/erase operation, and in case of failure, the appropriate bad-block-detected bits are updated in ndsr (ndsr), the address of the bad block is saved in the ndbbrlx registers (ndbbrx) and further dma mode processing is halted.  set this field for program and erase commands only. setting this field for commands other than program or erase may result in incorrect operation by the dfc.  this field must be set for multipage program and read commands (when <page count> in the data controller command buffer 2 is non-zero) to ensure that a read-status command is issued after every page program and page read to verify the success of the program operation.  0 = no automatic read status command execution after program/erase  1 = automatic read status command execution after program/erase" "0,1"
        bitfld.long 0x00 24. "         CSEL        ,cs select  this field selects the chip-select signal (nd_cs[0]n or nd_cs[1]n) to be activated for the command execution.   0 = nd_cs[0]n is asserted for the access.  1 = nd_cs[1]n is asserted for the access." "0,1"
        bitfld.long 0x00 21.--23. "     NF_CMD_TYPE255 ,command type  this field defines the type of nand flash command represented by cmd1 (and cmd2 if for a double byte command)." "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 20. "     NC            ,next command  this field (if set) indicates the presence of another valid command following the current command. the nand flash controller makes the next command dma request if this field bit is set. the last command of a command sequence must have this field clear.  0 = no valid command following the current command  1 = valid command following the current command" "0,1"
        textline "                        "
        bitfld.long 0x00 19. "DBC                   ,double byte command  this field (if set) indicates that the current command involves the transfer of two commands to the nand flash. this field must be clear for a single-byte command.  0 = current command is a single-byte command  1 = current command is a double-byte command" "0,1"
        bitfld.long 0x00 16.--18. "         ADDR_CYC    ,number of address cycles  this field specifies the number of address cycles in which the nand flash is to be addressed. valid values for address cycles are 1 to 5 for nand commands program, read, erase and read-id. for example, if this field is programmed as 4, addr1, addr2, addr3, and addr4 (see nand controller command buffer 1 section) are sent to the flash device in successive address cycles, while addr5 is ignored (see nand controller command buffer 2 section).    valid values for address cycles for reset and read-status commands is 0. if software programs a non-zero value for these commands, the nand controller will simply ignore it." "0,1,2,3,4,5,6,7"
        hexmask.long.byte 0x00 8.--15. 1. "     CMD2           ,second command  this field contains the second byte of command sent to nand flash after cmd1 and address in a double-byte command."
        hexmask.long.byte 0x00 0.--7. 1. "    CMD1          ,first command  this field contains the first byte command sent to the nand flash when the command execution begins."

group d:0xD428304C++0x03
    line.long 0x00 "NDCB1,Data Controller Command Buffer 1"
        hexmask.long.byte 0x00 24.--31. 1. " ADDR4                 ,addr4  address sent out to the flash device on the fourth addressing cycle"
        hexmask.long.byte 0x00 16.--23. 1. "        ADDR3       ,addr3  address sent out to the flash device on the third addressing cycle"
        hexmask.long.byte 0x00 8.--15. 1. "    ADDR2          ,addr2  address sent out to the flash device on the second addressing cycle"
        hexmask.long.byte 0x00 0.--7. 1. "    ADDR1         ,addr1  address sent out to the flash device on the first addressing cycle"

group d:0xD4283050++0x03
    line.long 0x00 "NDCB2,Data Controller Command Buffer 2"
        hexmask.long.byte 0x00 24.--31. 1. " ST_MASK               ,status mask  this is the mask applied to the status field to determine failure. this value is anded with the status word and the resulting byte is ored over the [7:0] field, and if any result is true, the status is indicating failure.  a status mask of 0x00 is singular in that it defines a mask of 0x01 instead. if software issues 0x00 to this field, the value actually loaded will be 0x01. this singularity is to achieve compatibility with current dma descriptors and other software which should have reserved fields set to 0."
        hexmask.long.byte 0x00 16.--23. 1. "        ST_CMD      ,status command  the default status command is 0x70, but onfi allows logical unit status checks. this field allows the non-standard status command to be defined for both status commands as well as auto status reads.  a status command of 0x00 is singular in that it defines a status command of 0x70 instead. if software issues 0x00 to this field, the value actually loaded will be 0x70. this singularity is to achieve compatibility with current dma descriptors and other software which should have reserved fields programmed to zeros."
        hexmask.long.byte 0x00 8.--15. 1. "    PAGE_COUNT     ,page count  page_count specifies the number of pages of data to be transferred for a program or read command. set this field to 0 for all commands except multipage program/read commands (commands where more than one page is programmed or read), in which case page_count + 1 specifies the number of pages serviced.   value from 0 to 63. specifies the number of pages of data to be transferred for the current command.  number of pages to be transferred = page_count +1"
        hexmask.long.byte 0x00 0.--7. 1. "    ADDR5         ,addr5  address sent out to the flash device on the fifth addressing cycle."

group d:0xD4283054++0x03
    line.long 0x00 "NDCB3,Data Controller Command Buffer 3"
        hexmask.long.byte 0x00 24.--31. 1. " ADDR7                 ,addr7  address sent out to the flash device on the seventh addressing cycle."
        hexmask.long.byte 0x00 16.--23. 1. "        ADDR6       ,addr6  address sent out to the flash device on the sixth addressing cycle."
        hexmask.long.word 0x00 0.--15. 1. "    NDLENCNT       ,ndlencnt  when the arbitrary length count is selected, this value is used to count the data cycles for any and all selected operations. as a practical matter, this value should not exceed the 2176 byte buffer size.   when ecc is enabled and bch is selected, this value must be a multiple of 32 bytes."

group d:0xD4283058++0x03
    line.long 0x00 "NSACR,SRAM Attributes Control Register"
        bitfld.long 0x00 4. " PWDN                  ,nfu sram power down" "0,1"
        bitfld.long 0x00 2.--3. "         NF_WTC309   ,nfu sram wtc" "0,1,2,3"
        bitfld.long 0x00 0.--1. "     NF_RTC310      ,nfu sram rtc" "0,1,2,3"

group d:0xD428305C++0x03
    line.long 0x00 "NDARBCR,NAND DFI Arbitration Control Register"
        hexmask.long.word 0x00 0.--15. 1. " ARB_CNT               ,arbitration count  the dfc will maintain the dfi for a minimum of clock cycles as defined by this field. the values programmed into the timing registers determine the number of actual nand cycles this represents."

group d:0xD4283060++0x03
    line.long 0x00 "NDPTXCSX,Partition Region Control Registers for CS0 and CS1"
        bitfld.long 0x00 31. " VALID                 ,valid entry  when set, this block address boundary is valid and partition matches are performed. valid entries must be allocated consecutively for each chip enable group." "0,1"
        bitfld.long 0x00 30. "         LOCK        ,lock entry  when set, this block address boundary cannot be rewritten except with a hardware reset. in general, it is expected that this field will always be set during normal usage of these registers.  if it is desired to allow access to the entire nand device but to prevent update of the partition registers as part of a denial-of-service, all partition registers could be locked without being either valid or trusted." "0,1"
        bitfld.long 0x00 29. "     TRUSTED        ,trusted region  when set, this block address boundary below this entry can only be accessed when in trusted zone. any access by a non-trusted access to the trust region causes the operation which matches a value in the ndcmdmat registers, to never be issued, the status to set trustvio, and further command processing stops.  it is possible to lock the entire nand device.  a trusted region will match all cmd1 values against the ndcmdmat registers and if there is any match, the address is compared. if the address matches, the operation is prevented.  in general, it is expected that a trusted region would desire to disallow program and erase type commands, and these commands would appear in the ndcmdmat registers." "0,1"
        hexmask.long.tbyte 0x00 0.--23. 1. "     BLOCKADD      ,block address  this entry defines the boundary of the block address (as defined by the command) for this partition. blockadd for the last partition register for each chip select must be set to the address of the last block in the nand device. this value is anded with the addx values to prevent address spoofing.  if not all four partitions make sense, allocate partitions as desired and replicate the last partition value on unneeded partitions. block addresses must be assigned in strictly monotonically increasing order."

tree.end

tree "onewire"

width 13.

group d:0xD4011800++0x03
    line.long 0x00 "ONEW_W1CMDR,One-Wire Command Register"
        bitfld.long 0x00 3. " DQI        ,one_wire input  this bit reflects the present state of the one-wire bus. use it together with the <one_wire output> field when controlling the bus directly. the state of this bit does not affect any other functions of the one-wire bus master interface controller. operation of this bit is unaffected by the state of the <one_wire output enable> field in the one-wire interrupt enable register." "0,1"
        bitfld.long 0x00 2. "   DQO28 ,one_wire output  this bit is used to bypass one-wire bus master interface controller operations and drive the bus directly if needed.  0 = this bit is cleared on power-up or master reset. clearing this bit drives the bus high. one-wire bus master interface controller operations only function while the one-wire bus is held high.  1 = setting this bit drives the bus low until it is cleared or the one-wire bus master interface controller reset. while the one-wire bus is held low, no other one-wire bus master interface controller operations function. by controlling the length of time this bit is set and the point when the line is sampled (see <one_wire input> field), any one-wire communication can be generated by the host controller. to prevent accidental writes to the bus, set the <one_wire output enable> field in the one-wire interrupt enable register before the functions in this field." "0,1"
        bitfld.long 0x00 2. "  DQO29      ,one_wire output  this bit is used to bypass one-wire bus master interface controller operations and drive the bus directly if needed.  0 = this bit is cleared on power-up or reset. clearing this bit drives the bus high. one-wire bus master interface controller operations only function while the one-wire bus is held high.  1 = setting this bit drives the bus low until it is cleared or the one-wire bus master interface controller reset. while the one-wire bus is held low, no other one-wire bus master interface controller operations function. by controlling the length of time this bit is set and the point when the line is sampled (see <one_wire input> field), any one-wire communication can be generated by the host controller. to prevent accidental writes to the bus, <one_wire output enable> field in the one-wire interrupt enable register before the functions in this field." "0,1"
        bitfld.long 0x00 1. "  SRA  ,search rom accelerator  0 = sra turned off  1 = one-wire bus master interface controller switches to sra mode  refer to the book of ibutton standards for more information on this feature." "0,1"
        textline "                       "
        bitfld.long 0x00 0. "1WR31      ,one-wire reset  this field generates a reset on the one-wire bus.  0 = bus is not in reset mode.  1 = setting this bit automatically clears the <search rom accelerator> field. this field is cleared automatically as soon as the one-wire reset completes. the one-wire bus master interface controller sets the <presence detect> interrupt flag in the one-wire interrupt register when the reset is complete and sufficient time for a presence detect to occur has passed. the result of the presence detect is placed in the <presence detect result> field in the one-wire interrupt register. if a presence detect pulse was received, the <presence detect result> field is cleared, otherwise it is set." "0,1"
        bitfld.long 0x00 0. "   1WR32 ,one-wire reset  this bit generates a reset on the one-wire bus.  0 = bus is not in reset mode.   1 = setting this bit automatically clears the sra bit. the 1wr bit is cleared automatically as soon as the one-wire reset completes. the one-wire bus master interface controller sets the <presence detect> interrupt flag in the one-wire interrupt register when the reset is complete and sufficient time for a presence detect to occur has passed. the result of the presence detect is placed in the <presence detect result> field in the one-wire interrupt register." "0,1"

group d:0xD4011804++0x03
    line.long 0x00 "ONEW_W1TRR,One-Wire Transmit/Receive Buffer"
        hexmask.long.byte 0x00 0.--7. 1. " ONE_DATA42 ,transmitted/received data"

group d:0xD4011808++0x03
    line.long 0x00 "ONEW_W1INTR,One-Wire Interrupt Register"
        bitfld.long 0x00 5. " RSRF       ,receive shift register full  0=this flag is cleared when the byte is read from the receive shift register.   1=this flag is set when there’s a byte written to shift register." "0,1"
        bitfld.long 0x00 4. "   RBF   ,receive buffer full  0 = this flag is cleared when the byte is read from the receive buffer register.   1 = this flag is set when there is a byte waiting to be read in the receive buffer." "0,1"
        bitfld.long 0x00 3. "  ONE_TEMT55 ,tx shift register empty  0 = this flag is cleared when data is shifted into the trx shift register from the transmit buffer.  1 = this flag is set after the last bit has been transmitted on the one-wire bus.  temt status bit is valid upon completion of the first data transfer." "0,1"
        bitfld.long 0x00 2. "  TBE  ,transmit buffer empty  0 = this flag is cleared when data is written to the transmit buffer.   1 = this flag is set when the last bit is transferred to the tx shift register.  tbe status bit is valid after the first data transfer." "0,1"
        textline "                       "
        bitfld.long 0x00 1. "PDR        ,presence detect result  when a presence detect interrupt occurs, this field reflects the result of the presence detect read.  0 = a slave device was found.  1 = no slave device was found." "0,1"
        bitfld.long 0x00 0. "   PD    ,presence detect  0 = the required time after a one-wire reset has not elapsed or this register has been read since the last one-wire reset.  1 = after a one-wire reset has been issued, this flag is set after the appropriate amount of time for a presence detect pulse to have occurred.  this bit is cleared when the interrupt register is read." "0,1"

group d:0xD401180C++0x03
    line.long 0x00 "ONEW_W1IER,One-Wire Interrupt Enable Register"
        bitfld.long 0x00 7. " DQOE       ,one_wire output enable  this bit acts as a control select for the one_wire bus. when set to 0, the bus is controlled by the one-wire bus master interface controller as normal.   0 = this bit defaults to 0 on power-up or reset and should be left 0 unless users want to control the bus manually through the <one_wire output> field in the one-wire command register.  1 = the <one_wire output> field controls the state of the bus directly." "0,1"
        bitfld.long 0x00 5. "   ERSF  ,enable receive shift register full interrupt  0 = enable receive shift register full interrupt disabled  1 = if the receive shift register full flag is set, then an interrupt is generated" "0,1"
        bitfld.long 0x00 4. "  ERBF       ,enable receive buffer full interrupt  0 = enable receive buffer full interrupt disabled  1 = if the receive buffer full flag is set, then an interrupt is generated" "0,1"
        bitfld.long 0x00 3. "  ETMT ,enable tx shift register empty interrupt  0 = enable tx shift register empty interrupt disabled.  1 = if the tx shift register empty flag is set, then an interrupt is generated." "0,1"
        textline "                       "
        bitfld.long 0x00 2. "ETBE       ,enable transmit buffer empty interrupt  0 = enable transmit buffer empty interrupt disabled.  1 = if the transmit buffer empty flag is set, then an interrupt is generated." "0,1"
        bitfld.long 0x00 1. "   IAS   ,intr active state  this field determines the active state for the internal intr signal.  0 = reserved  1 = the internal intr signal is active high." "0,1"
        bitfld.long 0x00 0. "  EPD        ,enable presence detect interrupt  0 = enable presence detect interrupt disabled.  1 = if the enable presence detect flag is set, an interrupt is generated whenever a one-wire reset is sent and the required amount of time has passed for a presence detect pulse to have occurred. refer to the <var product number> datasheet for timing information." "0,1"

group d:0xD4011810++0x03
    line.long 0x00 "ONEW_W1CDR,One-Wire Clock Divisor Register"
        bitfld.long 0x00 2.--4. " DIV        ,divider  the one-wire bus master interface controller uses the output of the prescaler and divides by the div value to produce the one-wire clocks. this clock must be approximately 1 mhz for correct operation. for the <var product number>, this value must be set to 0x2." "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 0.--1. "   PRE   ,prescaler value  the one-wire bus master interface controller uses the input 26-mhz clock and initially divides by this value before outputting to the divider section. for the <var product number>, this value must be set to 0x3, selecting a prescale of 7." "0,1,2,3"

tree.end

tree "sc2"
tree "sc2_csi"

width 19.

group d:0xD420A000++0x03
    line.long 0x00 "CCIC_Y0_BASE_ADDR,CCIC Register"
        hexmask.long 0x00 0.--31. 1. " RW13     ,"

group d:0xD420A00C++0x03
    line.long 0x00 "CCIC_Y0_BASE_ADDR,CCIC Register"
        hexmask.long 0x00 0.--31. 1. " RW18     ,"

group d:0xD420A018++0x03
    line.long 0x00 "Offset:0x0c,CCIC_U0_BASE_ADDR"
        hexmask.long 0x00 0.--31. 1. " RW23     ,"

group d:0xD420A024++0x03
    line.long 0x00 "Offset:0x018,CCIC_V0_BASE_ADDR"
        bitfld.long 0x00 30.--31. " RW28     ," "0,1,2,3"
        hexmask.long.word 0x00 16.--29. 1. "         RW29     ,"
        hexmask.long.word 0x00 0.--13. 1. "    RW30     ,"

group d:0xD420A028++0x03
    line.long 0x00 "Offset:0x024,CCIC_IMG_PITCH"
        bitfld.long 0x00 31. " RO35     ," "0,1"
        bitfld.long 0x00 30. "         RO36     ," "0,1"
        bitfld.long 0x00 29. "       RO37     ," "0,1"
        bitfld.long 0x00 28. "     RO38     ," "0,1"
        textline "                             "
        bitfld.long 0x00 27. "RO39     ," "0,1"
        bitfld.long 0x00 26. "         RO40     ," "0,1"
        bitfld.long 0x00 25. "       RO41     ," "0,1"
        bitfld.long 0x00 24. "     RO42     ," "0,1"
        textline "                             "
        bitfld.long 0x00 23. "RO43     ," "0,1"
        bitfld.long 0x00 22. "         RO44     ," "0,1"
        bitfld.long 0x00 21. "       RO45     ," "0,1"
        bitfld.long 0x00 20. "     RO46     ," "0,1"
        textline "                             "
        bitfld.long 0x00 19. "RO47     ," "0,1"
        bitfld.long 0x00 18. "         RO48     ," "0,1"
        bitfld.long 0x00 17. "       RO49     ," "0,1"
        bitfld.long 0x00 16. "     RO50     ," "0,1"
        textline "                             "
        bitfld.long 0x00 15. "RO51     ," "0,1"
        bitfld.long 0x00 14. "         RO52     ," "0,1"
        bitfld.long 0x00 13. "       RO53     ," "0,1"
        bitfld.long 0x00 12. "     RO54     ," "0,1"
        textline "                             "
        bitfld.long 0x00 11. "RO55     ," "0,1"
        bitfld.long 0x00 10. "         RO56     ," "0,1"
        bitfld.long 0x00 9. "       RO57     ," "0,1"
        bitfld.long 0x00 8. "     RO58     ," "0,1"
        textline "                             "
        bitfld.long 0x00 7. "RO59     ," "0,1"
        bitfld.long 0x00 6. "         RO60     ," "0,1"
        bitfld.long 0x00 5. "       RO61     ," "0,1"
        bitfld.long 0x00 4. "     RO62     ," "0,1"
        textline "                             "
        bitfld.long 0x00 3. "RO63     ," "0,1"
        bitfld.long 0x00 2. "         RO64     ," "0,1"
        bitfld.long 0x00 1. "       RO65     ," "0,1"
        bitfld.long 0x00 0. "     RO66     ," "0,1"

group d:0xD420A02C++0x03
    line.long 0x00 "Offset:0x028,CCIC_IRQ_RAW_STATUS"
        bitfld.long 0x00 31. " RW71     ," "0,1"
        bitfld.long 0x00 30. "         RW72     ," "0,1"
        bitfld.long 0x00 29. "       RW73     ," "0,1"
        bitfld.long 0x00 28. "     RW74     ," "0,1"
        textline "                             "
        bitfld.long 0x00 27. "RW75     ," "0,1"
        bitfld.long 0x00 26. "         RW76     ," "0,1"
        bitfld.long 0x00 25. "       RW77     ," "0,1"
        bitfld.long 0x00 24. "     RW78     ," "0,1"
        textline "                             "
        bitfld.long 0x00 23. "RW79     ," "0,1"
        bitfld.long 0x00 22. "         RW80     ," "0,1"
        bitfld.long 0x00 21. "       RW81     ," "0,1"
        bitfld.long 0x00 20. "     RW82     ," "0,1"
        textline "                             "
        bitfld.long 0x00 19. "RW83     ," "0,1"
        bitfld.long 0x00 18. "         RW84     ," "0,1"
        bitfld.long 0x00 17. "       RW85     ," "0,1"
        bitfld.long 0x00 16. "     RW86     ," "0,1"
        textline "                             "
        bitfld.long 0x00 15. "RW87     ," "0,1"
        bitfld.long 0x00 14. "         RW88     ," "0,1"
        bitfld.long 0x00 13. "       RW89     ," "0,1"
        bitfld.long 0x00 12. "     RW90     ," "0,1"
        textline "                             "
        bitfld.long 0x00 11. "RW91     ," "0,1"
        bitfld.long 0x00 10. "         RW92     ," "0,1"
        bitfld.long 0x00 9. "       RW93     ," "0,1"
        bitfld.long 0x00 8. "     RW94     ," "0,1"
        textline "                             "
        bitfld.long 0x00 7. "RW95     ," "0,1"
        bitfld.long 0x00 6. "         RW96     ," "0,1"
        bitfld.long 0x00 5. "       RW97     ," "0,1"
        bitfld.long 0x00 4. "     RW98     ," "0,1"
        textline "                             "
        bitfld.long 0x00 3. "RW99     ," "0,1"
        bitfld.long 0x00 2. "         RW100    ," "0,1"
        bitfld.long 0x00 1. "       RW101    ," "0,1"
        bitfld.long 0x00 0. "     RW102    ," "0,1"

group d:0xD420A030++0x03
    line.long 0x00 "Offset:0x02C,CCIC_IRQ_MASK"
        bitfld.long 0x00 31. " RW107    ," "0,1"
        bitfld.long 0x00 30. "         RW108    ," "0,1"
        bitfld.long 0x00 29. "       RW109    ," "0,1"
        bitfld.long 0x00 28. "     RW110    ," "0,1"
        textline "                             "
        bitfld.long 0x00 27. "RW111    ," "0,1"
        bitfld.long 0x00 26. "         RW112    ," "0,1"
        bitfld.long 0x00 25. "       RW113    ," "0,1"
        bitfld.long 0x00 24. "     RW114    ," "0,1"
        textline "                             "
        bitfld.long 0x00 23. "RW115    ," "0,1"
        bitfld.long 0x00 22. "         RO116    ," "0,1"
        bitfld.long 0x00 21. "       RO117    ," "0,1"
        bitfld.long 0x00 20. "     RW118    ," "0,1"
        textline "                             "
        bitfld.long 0x00 19. "RW119    ," "0,1"
        bitfld.long 0x00 18. "         RW120    ," "0,1"
        bitfld.long 0x00 17. "       RW121    ," "0,1"
        bitfld.long 0x00 16. "     RW122    ," "0,1"
        textline "                             "
        bitfld.long 0x00 15. "RW123    ," "0,1"
        bitfld.long 0x00 14. "         RW124    ," "0,1"
        bitfld.long 0x00 13. "       RW125    ," "0,1"
        bitfld.long 0x00 12. "     RW126    ," "0,1"
        textline "                             "
        bitfld.long 0x00 11. "RW127    ," "0,1"
        bitfld.long 0x00 10. "         RW128    ," "0,1"
        bitfld.long 0x00 9. "       RW129    ," "0,1"
        bitfld.long 0x00 8. "     RO130    ," "0,1"
        textline "                             "
        bitfld.long 0x00 7. "RW131    ," "0,1"
        bitfld.long 0x00 6. "         RW132    ," "0,1"
        bitfld.long 0x00 5. "       RW133    ," "0,1"
        bitfld.long 0x00 4. "     RW134    ," "0,1"
        textline "                             "
        bitfld.long 0x00 3. "RW135    ," "0,1"
        bitfld.long 0x00 2. "         RO136    ," "0,1"
        bitfld.long 0x00 1. "       RO137    ," "0,1"
        bitfld.long 0x00 0. "     RW138    ," "0,1"

group d:0xD420A034++0x03
    line.long 0x00 "Offset:0x030,CCIC_IRQ_STATUS"
        bitfld.long 0x00 29.--31. " CCIC_143 ," "0,1,2,3,4,5,6,7"
        hexmask.long.word 0x00 16.--28. 1. "         RW144    ,"
        bitfld.long 0x00 14.--15. "    CCIC_145 ," "0,1,2,3"
        hexmask.long.word 0x00 0.--13. 1. "     RW146    ,"

group d:0xD420A038++0x03
    line.long 0x00 "Offset:0x34,CCIC_IMG_SIZE"
        bitfld.long 0x00 29.--31. " CCIC_151 ," "0,1,2,3,4,5,6,7"
        hexmask.long.word 0x00 16.--28. 1. "         RW152    ,"
        bitfld.long 0x00 14.--15. "    CCIC_153 ," "0,1,2,3"
        hexmask.long.word 0x00 0.--13. 1. "     RW154    ,"

group d:0xD420A03C++0x03
    line.long 0x00 "Offset:0x38,CCIC_IMG_SIZE"
        bitfld.long 0x00 30.--31. " RW159    ," "0,1,2,3"
        bitfld.long 0x00 28.--29. "         CCIC_160 ," "0,1,2,3"
        bitfld.long 0x00 27. "       RW161    ," "0,1"
        bitfld.long 0x00 26. "     RW162    ," "0,1"
        textline "                             "
        bitfld.long 0x00 25. "RW163    ," "0,1"
        bitfld.long 0x00 24. "         RW164    ," "0,1"
        bitfld.long 0x00 23. "       RW165    ," "0,1"
        bitfld.long 0x00 22. "     RW166    ," "0,1"
        textline "                             "
        bitfld.long 0x00 21. "RW167    ," "0,1"
        bitfld.long 0x00 20. "         CCIC_168 ," "0,1"
        bitfld.long 0x00 18.--19. "       CCIC_169 ," "0,1,2,3"
        bitfld.long 0x00 16.--17. "     RW170    ," "0,1,2,3"
        textline "                             "
        bitfld.long 0x00 13.--15. "RW171    ," "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 12. "         RW172    ," "0,1"
        bitfld.long 0x00 9.--11. "       RW173    ," "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 7.--8. "     RW174    ," "0,1,2,3"
        textline "                             "
        bitfld.long 0x00 5.--6. "RW175    ," "0,1,2,3"
        bitfld.long 0x00 4. "         RW176    ," "0,1"
        bitfld.long 0x00 2.--3. "       RW177    ," "0,1,2,3"
        bitfld.long 0x00 1. "     RW178    ," "0,1"
        textline "                             "
        bitfld.long 0x00 0. "RW179    ," "0,1"

group d:0xD420A040++0x03
    line.long 0x00 "Offset:0x3C,CCIC_CTRL_0"
        bitfld.long 0x00 31. " RW184    ," "0,1"
        bitfld.long 0x00 30. "         RW185    ," "0,1"
        bitfld.long 0x00 29. "       RW186    ," "0,1"
        bitfld.long 0x00 28. "     RW187    ," "0,1"
        textline "                             "
        bitfld.long 0x00 27. "RW188    ," "0,1"
        bitfld.long 0x00 25.--26. "         RW189    ," "0,1,2,3"
        bitfld.long 0x00 24. "       RW190    ," "0,1"
        bitfld.long 0x00 20.--23. "     RW191    ," "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        textline "                             "
        bitfld.long 0x00 18.--19. "CCIC_192 ," "0,1,2,3"
        bitfld.long 0x00 17. "         RW193    ," "0,1"
        hexmask.long.word 0x00 1.--16. 1. "       CCIC_194 ,"
        bitfld.long 0x00 0. "  RW195    ," "0,1"

group d:0xD420A044++0x03
    line.long 0x00 "Offset:0x40,CCIC_CTRL_1"
        bitfld.long 0x00 31. " RW200    ," "0,1"
        bitfld.long 0x00 30. "         RW201    ," "0,1"
        bitfld.long 0x00 29. "       RW202    ," "0,1"
        hexmask.long.word 0x00 13.--28. 1. "     CCIC_203 ,"
        textline "                             "
        hexmask.long.word 0x00 0.--12. 1. "RW204    ,"

group d:0xD420A048++0x03
    line.long 0x00 "Offset:0x44,CCIC_CTRL_2"
        hexmask.long.tbyte 0x00 11.--31. 1. " CCIC_209 ,"
        bitfld.long 0x00 10. "    RW210    ," "0,1"
        bitfld.long 0x00 9. "       RW211    ," "0,1"
        bitfld.long 0x00 8. "     RW212    ," "0,1"
        textline "                             "
        bitfld.long 0x00 7. "RW213    ," "0,1"
        bitfld.long 0x00 6. "         RW214    ," "0,1"
        bitfld.long 0x00 5. "       RW215    ," "0,1"
        bitfld.long 0x00 4. "     RW216    ," "0,1"
        textline "                             "
        bitfld.long 0x00 3. "RW217    ," "0,1"
        bitfld.long 0x00 2. "         RW218    ," "0,1"
        bitfld.long 0x00 1. "       RW219    ," "0,1"
        bitfld.long 0x00 0. "     RW220    ," "0,1"

group d:0xD420A060++0x03
    line.long 0x00 "Offset:0x48,CCIC_CTRL_3"
        hexmask.long.tbyte 0x00 13.--31. 1. " CCIC_225 ,"
        hexmask.long.word 0x00 0.--12. 1. "    RO226    ,"

group d:0xD420A100++0x03
    line.long 0x00 "Offset:0x60,CCIC_LNNUM"
        hexmask.long.tbyte 0x00 14.--31. 1. " CCIC_231 ,"
        bitfld.long 0x00 13. "    RW232    ," "0,1"
        bitfld.long 0x00 12. "       RW233    ," "0,1"
        bitfld.long 0x00 11. "     RW234    ," "0,1"
        textline "                             "
        bitfld.long 0x00 10. "RW235    ," "0,1"
        bitfld.long 0x00 9. "         RW236    ," "0,1"
        bitfld.long 0x00 8. "       RW237    ," "0,1"
        bitfld.long 0x00 4.--7. "     RW238    ," "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        textline "                             "
        bitfld.long 0x00 3. "RW239    ," "0,1"
        bitfld.long 0x00 1.--2. "         RW240    ," "0,1,2,3"
        bitfld.long 0x00 0. "       RW241    ," "0,1"

group d:0xD420A108++0x03
    line.long 0x00 "Offset:0x100,CCIC_CSI2_CTRL_0"
        bitfld.long 0x00 28.--31. " CCIC_246 ," "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 24.--27. "        R247     ," "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 20.--23. "      CCIC_248 ," "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 16.--19. "    R249     ," "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        textline "                             "
        bitfld.long 0x00 12.--15. "R250     ," "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 8.--11. "        R251     ," "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 4.--7. "      R252     ," "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 0.--3. "    R253     ," "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"

group d:0xD420A110++0x03
    line.long 0x00 "Offset:0x108,CCIC_CSI2_IRQ_RAW_STATUS"
        hexmask.long.byte 0x00 24.--31. 1. " CCIC_258 ,"
        hexmask.long.tbyte 0x00 0.--23. 1. "        R259     ,"

group d:0xD420A114++0x03
    line.long 0x00 "Offset:0x110,CCIC_CSI2_GSPFF"
        hexmask.long.byte 0x00 25.--31. 1. " CCIC_264 ,"
        bitfld.long 0x00 24. "        RW265    ," "0,1"
        bitfld.long 0x00 22.--23. "       RW266    ," "0,1,2,3"
        hexmask.long.byte 0x00 16.--21. 1. "     RW267    ,"
        textline "                             "
        bitfld.long 0x00 14.--15. "RW268    ," "0,1,2,3"
        hexmask.long.word 0x00 2.--13. 1. "         CCIC_269 ,"
        bitfld.long 0x00 0.--1. "    RW270    ," "0,1,2,3"

group d:0xD420A11C++0x03
    line.long 0x00 "Offset:0x114,CCIC_CSI2_VCCTRL"
        bitfld.long 0x00 31. " CCIC_275 ," "0,1"
        bitfld.long 0x00 30. "         RW276    ," "0,1"
        hexmask.long.byte 0x00 24.--29. 1. "       RW277    ,"
        bitfld.long 0x00 23. "    CCIC_278 ," "0,1"
        textline "                             "
        bitfld.long 0x00 22. "RW279    ," "0,1"
        hexmask.long.byte 0x00 16.--21. 1. "         RW280    ,"
        bitfld.long 0x00 15. "      CCIC_281 ," "0,1"
        bitfld.long 0x00 14. "     RW282    ," "0,1"
        textline "                             "
        hexmask.long.byte 0x00 8.--13. 1. "RW283    ,"
        bitfld.long 0x00 7. "        CCIC_284 ," "0,1"
        bitfld.long 0x00 6. "       RW285    ," "0,1"
        hexmask.long.byte 0x00 0.--5. 1. "     RW286    ,"

group d:0xD420A124++0x03
    line.long 0x00 "CCIC_CSI2_DPHY1,"
        hexmask.long 0x00 1.--31. 1. " CCIC_292 ,"
        bitfld.long 0x00 0. "  RW293    ," "0,1"

group d:0xD420A128++0x03
    line.long 0x00 "CCIC_CSI2_DPHY2,"
        bitfld.long 0x00 30.--31. " RW299    ," "0,1,2,3"
        bitfld.long 0x00 27.--29. "         RW300    ," "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 24.--26. "       RW301    ," "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 23. "     RW302    ," "0,1"
        textline "                             "
        bitfld.long 0x00 20.--22. "RW303    ," "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 19. "         RW304    ," "0,1"
        bitfld.long 0x00 16.--18. "       RW305    ," "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 15. "     RW306    ," "0,1"
        textline "                             "
        bitfld.long 0x00 12.--14. "RW307    ," "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 11. "         RW308    ," "0,1"
        bitfld.long 0x00 8.--10. "       RW309    ," "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 7. "     RW310    ," "0,1"
        textline "                             "
        bitfld.long 0x00 4.--6. "RW311    ," "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 3. "         RW312    ," "0,1"
        bitfld.long 0x00 0.--2. "       RW313    ," "0,1,2,3,4,5,6,7"

group d:0xD420A12C++0x03
    line.long 0x00 "Offset:0x128,CCIC_CSI2_DPHY2"
        hexmask.long.byte 0x00 24.--31. 1. " CCIC_318 ,"
        hexmask.long.byte 0x00 16.--23. 1. "        RW319    ,"
        hexmask.long.byte 0x00 8.--15. 1. "      RW320    ,"
        hexmask.long.byte 0x00 0.--7. 1. "    RW321    ,"

group d:0xD420A130++0x03
    line.long 0x00 "Offset:0x12c,CCIC_CSI2_DPHY3"
        hexmask.long.tbyte 0x00 9.--31. 1. " CCIC_326 ,"
        bitfld.long 0x00 8. "    CCIC_327 ," "0,1"
        bitfld.long 0x00 7. "       CCIC_328 ," "0,1"
        bitfld.long 0x00 6. "     RW329    ," "0,1"
        textline "                             "
        bitfld.long 0x00 5. "RW330    ," "0,1"
        bitfld.long 0x00 4. "         RW331    ," "0,1"
        bitfld.long 0x00 2.--3. "       RW332    ," "0,1,2,3"
        bitfld.long 0x00 0.--1. "     RW333    ," "0,1,2,3"

group d:0xD420A134++0x03
    line.long 0x00 "CCIC_CSI2_DPHY5,"
        hexmask.long.word 0x00 18.--31. 1. " CCIC_339 ,"
        bitfld.long 0x00 17. "      R340     ," "0,1"
        hexmask.long.word 0x00 8.--16. 1. "       CCIC_341 ,"
        bitfld.long 0x00 4.--7. "  RW342    ," "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        textline "                             "
        bitfld.long 0x00 0.--3. "RW343    ," "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"

group d:0xD420A138++0x03
    line.long 0x00 "Offset:0x134,CCIC_CSI2_DPHY5"
        hexmask.long.word 0x00 16.--31. 1. " CCIC_348 ,"
        hexmask.long.byte 0x00 8.--15. 1. "      RW349    ,"
        hexmask.long.byte 0x00 0.--7. 1. "      RW350    ,"

group d:0xD420A13C++0x03
    line.long 0x00 "Offset:0x138,CCIC_CSI2_DPHY6"
        hexmask.long.tbyte 0x00 8.--31. 1. " CCIC_355 ,"
        bitfld.long 0x00 3.--7. "    CCIC_356 ," "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"
        bitfld.long 0x00 2. "      RW357    ," "0,1"
        bitfld.long 0x00 1. "     RW358    ," "0,1"
        textline "                             "
        bitfld.long 0x00 0. "RW359    ," "0,1"

group d:0xD420A140++0x03
    line.long 0x00 "Offset:0x13c,CCIC_CSI2_VENDCNT"
        bitfld.long 0x00 27.--31. " CCIC_364 ," "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"
        bitfld.long 0x00 25.--26. "        RW365    ," "0,1,2,3"
        bitfld.long 0x00 24. "       RW366    ," "0,1"
        bitfld.long 0x00 22.--23. "     CCIC_367 ," "0,1,2,3"
        textline "                             "
        bitfld.long 0x00 21. "RW368    ," "0,1"
        bitfld.long 0x00 20. "         RW369    ," "0,1"
        bitfld.long 0x00 17.--19. "       CCIC_370 ," "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 16. "     RW371    ," "0,1"
        textline "                             "
        hexmask.long.byte 0x00 8.--15. 1. "RW372    ,"
        bitfld.long 0x00 7. "        RW373    ," "0,1"
        hexmask.long.byte 0x00 1.--6. 1. "       RW374    ,"
        bitfld.long 0x00 0. "    RW375    ," "0,1"

group d:0xD420A144++0x03
    line.long 0x00 "Offset:0x140,CCIC_CSI2_CTRL_2"
        hexmask.long 0x00 7.--31. 1. " CCIC_380 ,"
        bitfld.long 0x00 6. "  RW381    ," "0,1"
        bitfld.long 0x00 0. "       RW382    ," "0,1"

group d:0xD420A23C++0x03
    line.long 0x00 "Offset:0x144,CCIC_CSI2_CTRL_3"
        hexmask.long 0x00 0.--31. 1. " RW387    ,"

group d:0xD420A300++0x03
    line.long 0x00 "Offset:0x23c,CCIC_FRAME_BYTE_CNT"
        hexmask.long 0x00 0.--31. 1. " RW392    ,"

group d:0xD420A304++0x03
    line.long 0x00 "Offset:0x300,CCIC_ISP_DATA0"
        hexmask.long 0x00 0.--31. 1. " RW397    ,"

group d:0xD420A308++0x03
    line.long 0x00 "Offset:0x304,CCIC_ISP_DATA1"
        hexmask.long.byte 0x00 25.--31. 1. " CCIC_402 ,"
        bitfld.long 0x00 24. "        RW403    ," "0,1"
        bitfld.long 0x00 19.--23. "       CCIC_404 ," "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"
        bitfld.long 0x00 18. "    RW405    ," "0,1"
        textline "                             "
        bitfld.long 0x00 17. "RW406    ," "0,1"
        bitfld.long 0x00 16. "         RW407    ," "0,1"
        hexmask.long.word 0x00 6.--15. 1. "       CCIC_408 ,"
        hexmask.long.byte 0x00 0.--5. 1. "  RW409    ,"

group d:0xD420A310++0x03
    line.long 0x00 "Offset:0x308,CCIC_ISP_CTRL"
        hexmask.long.tbyte 0x00 9.--31. 1. " CCIC_414 ,"
        bitfld.long 0x00 7.--8. "    RW415    ," "0,1,2,3"
        bitfld.long 0x00 4.--6. "       RW416    ," "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 3. "     CCIC_417 ," "0,1"
        textline "                             "
        bitfld.long 0x00 1.--2. "RW418    ," "0,1,2,3"
        bitfld.long 0x00 0. "         RW419    ," "0,1"

group d:0xD420A314++0x03
    line.long 0x00 "Offset:0x310,CCIC_IDI_CTRL"
        bitfld.long 0x00 29.--31. " CCIC_424 ," "0,1,2,3,4,5,6,7"
        hexmask.long.word 0x00 16.--28. 1. "         CCIC_425 ,"
        bitfld.long 0x00 15. "    CCIC_426 ," "0,1"
        hexmask.long.word 0x00 0.--14. 1. "     CCIC_427 ,"

group d:0xD420A318++0x03
    line.long 0x00 "Offset:0x314,CCIC_YUV420_WIDTH"
        hexmask.long 0x00 1.--31. 1. " CCIC_432 ,"
        bitfld.long 0x00 0. "  RW433    ," "0,1"

group d:0xD420A31C++0x03
    line.long 0x00 "Offset:0x318,CCIC_YUV420_PITCH_FIX"
        hexmask.long.tbyte 0x00 13.--31. 1. " CCIC_438 ,"
        hexmask.long.word 0x00 0.--12. 1. "    RW439    ,"

group d:0xD420A320++0x03
    line.long 0x00 "Offset:0x31c,CCIC_PAR2CSI_CRTL"
        bitfld.long 0x00 28.--31. " R444     ," "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 24.--27. "        R445     ," "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 20.--23. "      R446     ," "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 16.--19. "    R447     ," "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        textline "                             "
        bitfld.long 0x00 12.--15. "R448     ," "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 8.--11. "        R449     ," "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 4.--7. "      R450     ," "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 0.--3. "    R451     ," "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"

tree.end

tree "sc2_mmu"

width 23.

group d:0xD420F000++0x03
    line.long 0x00 "SC2DESC_CH_DSA,SC2_DESCRIPTOR_CH Register"
        hexmask.long 0x00 0.--31. 1. " SC2_D_RW25  ,"

group d:0xD420F004++0x03
    line.long 0x00 "SC2DESC_CH_DSZ,SC2_DESCRIPTOR_CH Register"
        hexmask.long 0x00 0.--31. 1. " SC2_D_RW31  ,"

group d:0xD420F008++0x03
    line.long 0x00 "SC2DESC_CH_SVA,SC2_DESCRIPTOR_CH Register"
        hexmask.long 0x00 0.--31. 1. " SC2_D_RW38  ,"

group d:0xD420F00C++0x03
    line.long 0x00 "SC2DESC_CH_CTRL,SC2_DESCRIPTOR_CH Register"
        hexmask.long.word 0x00 19.--31. 1. " SC2_D_44    ,"
        bitfld.long 0x00 16.--18. "      SC2_D_RW45  ," "0,1,2,3,4,5,6,7"
        hexmask.long.byte 0x00 10.--15. 1. "     SC2_D_RW46  ,"
        hexmask.long.word 0x00 0.--9. 1. "    SC2_D_47    ,"

group d:0xD420F010++0x03
    line.long 0x00 "SC2DESC_CH_IRQ_SRC,SC2_DESCRIPTOR_CH Register"
        hexmask.long 0x00 5.--31. 1. " SC2_D_54    ,"
        bitfld.long 0x00 0.--4. "  SC2_D_R55   ," "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"

group d:0xD420F014++0x03
    line.long 0x00 "SC2DESC_CH_IRQ_ENA,SC2_DESCRIPTOR_CH Register"
        hexmask.long 0x00 5.--31. 1. " SC2_D_61    ,"
        bitfld.long 0x00 0.--4. "  SC2_D_RW62  ," "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"

group d:0xD420F018++0x03
    line.long 0x00 "SC2DESC_CH_IRQ_ENA,SC2_DESCRIPTOR_CH Register"
        hexmask.long 0x00 5.--31. 1. " SC2_D_68    ,"
        bitfld.long 0x00 4. "  SC2_D_RW69  ," "0,1"
        bitfld.long 0x00 3. "     SC2_D_RW70  ," "0,1"
        bitfld.long 0x00 2. "     SC2_D_RW71  ," "0,1"
        textline "                                 "
        bitfld.long 0x00 1. "SC2_D_RW72  ," "0,1"
        bitfld.long 0x00 0. "         SC2_D_RW73  ," "0,1"

group d:0xD420F000++0x03
    line.long 0x00 "SC2DESC_CTRL,SC2_DESCRIPTOR_GENERAL Register"
        hexmask.long.word 0x00 16.--31. 1. " SC2_D_80    ,"
        hexmask.long.word 0x00 0.--15. 1. "      SC2_D_RW81  ,"

group d:0xD420F010++0x03
    line.long 0x00 "SC2DESC_CTRL,SC2_DESCRIPTOR_GENERAL Register"
        hexmask.long.word 0x00 17.--31. 1. " SC2_D_86    ,"
        bitfld.long 0x00 16. "      SC2_D_R87   ," "0,1"
        hexmask.long.word 0x00 0.--15. 1. "     SC2_D_88    ,"

group d:0xD420F014++0x03
    line.long 0x00 "Offset:0x10,SC2DESC_CTRL_SRC"
        bitfld.long 0x00 31. " SC2_D_RW93  ," "0,1"
        hexmask.long.word 0x00 17.--30. 1. "         SC2_D_94    ,"
        bitfld.long 0x00 16. "  SC2_D_RW95  ," "0,1"
        hexmask.long.word 0x00 0.--15. 1. "     SC2_D_96    ,"

group d:0xD420F018++0x03
    line.long 0x00 "Offset:0x14,SC2DESC_IRQ_ENA"
        hexmask.long.word 0x00 17.--31. 1. " SC2_D_101   ,"
        bitfld.long 0x00 16. "      SC2_D_102   ," "0,1"
        bitfld.long 0x00 16. "     RW1CLR      ," "0,1"
        hexmask.long.word 0x00 0.--15. 1. "     SC2_D_R104  ,"

group d:0xD420F01C++0x03
    line.long 0x00 "Offset:0x18,SC2DESC_IRQ_STAT"
        hexmask.long 0x00 3.--31. 1. " SC2_D_109   ,"
        bitfld.long 0x00 2. "  SC2_D_RW110 ," "0,1"
        bitfld.long 0x00 1. "     SC2_D_RW111 ," "0,1"
        bitfld.long 0x00 0. "     SC2_D_RW112 ," "0,1"

group d:0xD420F020++0x03
    line.long 0x00 "Offset:0x1c,SC2DESC_MISC_CTRL"
        hexmask.long.word 0x00 16.--30. 1. " SC2_D_117   ,"
        hexmask.long.word 0x00 0.--15. 1. "      SC2_D_RW118 ,"

group d:0xD420F024++0x03
    line.long 0x00 "Offset:0x20,SC2DESC_CHDIS_DONE"
        hexmask.long.word 0x00 16.--31. 1. " SC2_D_123   ,"
        bitfld.long 0x00 12.--15. "      SC2_D_RW124 ," "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 8.--11. "    SC2_D_RW125 ," "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 4.--7. "    SC2_D_RW126 ," "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        textline "                                 "
        bitfld.long 0x00 0.--3. "SC2_D_RW127 ," "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"

group d:0xD420F02C++0x03
    line.long 0x00 "ISP2_QOS_MAP_CTRL,"
        bitfld.long 0x00 28.--31. " SC2_D_RW133 ," "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 24.--27. "        SC2_D_RW134 ," "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 20.--23. "    SC2_D_RW135 ," "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 16.--19. "    SC2_D_RW136 ," "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        textline "                                 "
        bitfld.long 0x00 12.--15. "SC2_D_RW137 ," "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 8.--11. "        SC2_D_RW138 ," "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 4.--7. "    SC2_D_RW139 ," "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 0.--3. "    SC2_D_RW140 ," "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"

group d:0xD420F030++0x03
    line.long 0x00 "SC2DESC_ISP_HURRY,"
        hexmask.long.tbyte 0x00 8.--30. 1. " SC2_D_146   ,"
        bitfld.long 0x00 6.--7. "    SC2_D_RW147 ," "0,1,2,3"
        bitfld.long 0x00 4.--5. "     SC2_D_RW148 ," "0,1,2,3"
        bitfld.long 0x00 2.--3. "     SC2_D_RW149 ," "0,1,2,3"
        textline "                                 "
        bitfld.long 0x00 0.--1. "SC2_D_RW150 ," "0,1,2,3"

group d:0xD420F034++0x03
    line.long 0x00 "Offset:0x30,SC2DESC_ISP_HURRY"
        hexmask.long.word 0x00 16.--30. 1. " SC2_D_RW155 ,"
        hexmask.long.word 0x00 0.--15. 1. "      SC2_D_RW156 ,"

group d:0xD420F038++0x03
    line.long 0x00 "Offset:0x34,SC2DESC_DCCH_DIS_RST"
        hexmask.long.word 0x00 16.--30. 1. " SC2_D_161   ,"
        hexmask.long.word 0x00 0.--15. 1. "      SC2_D_R162  ,"

group d:0xD420F03C++0x03
    line.long 0x00 "Offset:0x38,SC2DESC_DCCH_IDLE"
        hexmask.long.tbyte 0x00 8.--31. 1. " SC2_D_167   ,"
        bitfld.long 0x00 6.--7. "    SC2_D_RW168 ," "0,1,2,3"
        bitfld.long 0x00 4.--5. "     SC2_D_RW169 ," "0,1,2,3"
        bitfld.long 0x00 2.--3. "     SC2_D_RW170 ," "0,1,2,3"
        textline "                                 "
        bitfld.long 0x00 0.--1. "SC2_D_RW171 ," "0,1,2,3"

group d:0xD420F050++0x03
    line.long 0x00 "Offset:0x3c,SC2DESC_AXICLK_CG"
        bitfld.long 0x00 28.--31. " SC2_D_RW176 ," "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 24.--27. "        SC2_D_RW177 ," "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 20.--23. "    SC2_D_RW178 ," "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 16.--19. "    SC2_D_RW179 ," "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        textline "                                 "
        bitfld.long 0x00 12.--15. "SC2_D_RW180 ," "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 8.--11. "        SC2_D_RW181 ," "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 4.--7. "    SC2_D_RW182 ," "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 0.--3. "    SC2_D_RW183 ," "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"

group d:0xD420F054++0x03
    line.long 0x00 "ISP_MEM_EMA_CFG,"
        bitfld.long 0x00 30. " SC2_D_RW190 ," "0,1"
        bitfld.long 0x00 28.--29. "         SC2_D_RW191 ," "0,1,2,3"
        bitfld.long 0x00 25.--27. "     SC2_D_RW192 ," "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 24. "     SC2_D_RW193 ," "0,1"
        textline "                                 "
        bitfld.long 0x00 22.--23. "SC2_D_RW194 ," "0,1,2,3"
        bitfld.long 0x00 19.--21. "         SC2_D_RW195 ," "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 18. "     SC2_D_RW196 ," "0,1"
        bitfld.long 0x00 16.--17. "     SC2_D_RW197 ," "0,1,2,3"
        textline "                                 "
        bitfld.long 0x00 13.--15. "SC2_D_RW198 ," "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 12. "         SC2_D_RW199 ," "0,1"
        bitfld.long 0x00 9.--11. "     SC2_D_RW200 ," "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 6.--8. "     SC2_D_RW201 ," "0,1,2,3,4,5,6,7"
        textline "                                 "
        bitfld.long 0x00 5. "SC2_D_RW202 ," "0,1"
        bitfld.long 0x00 3.--4. "         SC2_D_RW203 ," "0,1,2,3"
        bitfld.long 0x00 0.--2. "     SC2_D_RW204 ," "0,1,2,3,4,5,6,7"

group d:0xD420F05C++0x03
    line.long 0x00 "Offset:0x54,ISP_MEM_EMA_CFG"
        bitfld.long 0x00 30.--31. " SC2_D_RW209 ," "0,1,2,3"
        bitfld.long 0x00 28.--29. "         SC2_D_RW210 ," "0,1,2,3"
        bitfld.long 0x00 26.--27. "     SC2_D_RW211 ," "0,1,2,3"
        bitfld.long 0x00 24.--25. "     SC2_D_RW212 ," "0,1,2,3"
        textline "                                 "
        bitfld.long 0x00 22.--23. "SC2_D_213   ," "0,1,2,3"
        bitfld.long 0x00 21. "         SC2_D_RW214 ," "0,1"
        bitfld.long 0x00 16.--20. "     SC2_D_215   ," "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"
        bitfld.long 0x00 15. "    SC2_D_RW216 ," "0,1"
        textline "                                 "
        bitfld.long 0x00 14. "SC2_D_RW217 ," "0,1"
        bitfld.long 0x00 13. "         SC2_D_RW218 ," "0,1"
        bitfld.long 0x00 8.--12. "     SC2_D_219   ," "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"
        bitfld.long 0x00 5.--7. "    SC2_D_RW220 ," "0,1,2,3,4,5,6,7"
        textline "                                 "
        bitfld.long 0x00 4. "SC2_D_221   ," "0,1"
        bitfld.long 0x00 3. "         SC2_D_RW222 ," "0,1"
        bitfld.long 0x00 2. "     SC2_D_RW223 ," "0,1"
        bitfld.long 0x00 1. "     SC2_D_224   ," "0,1"
        textline "                                 "
        bitfld.long 0x00 0. "SC2_D_225   ," "0,1"

group d:0xD420F060++0x03
    line.long 0x00 "Offset:0x5c,SC2DESC_HARDMUX_CTRL"
        hexmask.long.byte 0x00 24.--31. 1. " SC2_D_230   ,"
        bitfld.long 0x00 20.--23. "        SC2_D_RW231 ," "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 16.--19. "    SC2_D_RW232 ," "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 12.--15. "    SC2_D_RW233 ," "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        textline "                                 "
        bitfld.long 0x00 8.--11. "SC2_D_RW234 ," "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 4.--7. "        SC2_D_RW235 ," "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 0.--3. "    SC2_D_RW236 ," "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"

group d:0xD420F0E0++0x03
    line.long 0x00 "Offset:0x60,AFBC_JPEG_QOS_CTRL"
        bitfld.long 0x00 31. " SC2_D_241   ," "0,1"
        hexmask.long.word 0x00 16.--30. 1. "         SC2_D_RW242 ,"
        bitfld.long 0x00 15. "  SC2_D_243   ," "0,1"
        hexmask.long.word 0x00 0.--14. 1. "     SC2_D_RW244 ,"

group d:0xD420F0E4++0x03
    line.long 0x00 "EOF_DLY_COUNTER_CTRL1,"
        bitfld.long 0x00 31. " SC2_D_250   ," "0,1"
        hexmask.long.word 0x00 16.--30. 1. "         SC2_D_RW251 ,"
        bitfld.long 0x00 15. "  SC2_D_252   ," "0,1"
        hexmask.long.word 0x00 0.--14. 1. "     SC2_D_RW253 ,"

group d:0xD420F0E8++0x03
    line.long 0x00 "Offset:0xe4,EOF_DLY_COUNTER_CTRL1"
        bitfld.long 0x00 31. " SC2_D_258   ," "0,1"
        hexmask.long.word 0x00 16.--30. 1. "         SC2_D_RW259 ,"
        bitfld.long 0x00 15. "  SC2_D_260   ," "0,1"
        hexmask.long.word 0x00 0.--14. 1. "     SC2_D_RW261 ,"

group d:0xD420F0EC++0x03
    line.long 0x00 "EOF_DLY_COUNTER_CTRL3,"
        bitfld.long 0x00 31. " SC2_D_267   ," "0,1"
        hexmask.long.word 0x00 16.--30. 1. "         SC2_D_RW268 ,"
        bitfld.long 0x00 15. "  SC2_D_269   ," "0,1"
        hexmask.long.word 0x00 0.--14. 1. "     SC2_D_RW270 ,"

group d:0xD420F0F0++0x03
    line.long 0x00 "EOF_DLY_COUNTER_CTRL4,"
        bitfld.long 0x00 31. " SC2_D_276   ," "0,1"
        hexmask.long.word 0x00 16.--30. 1. "         SC2_D_RW277 ,"
        bitfld.long 0x00 15. "  SC2_D_278   ," "0,1"
        hexmask.long.word 0x00 0.--14. 1. "     SC2_D_RW279 ,"

group d:0xD420F0F4++0x03
    line.long 0x00 "EOF_DLY_COUNTER_CTRL5,"
        bitfld.long 0x00 31. " SC2_D_285   ," "0,1"
        hexmask.long.word 0x00 16.--30. 1. "         SC2_D_RW286 ,"
        bitfld.long 0x00 15. "  SC2_D_287   ," "0,1"
        hexmask.long.word 0x00 0.--14. 1. "     SC2_D_RW288 ,"

group d:0xD420F0F8++0x03
    line.long 0x00 "Offset:0xf4,EOF_DLY_COUNTER_CTRL5"
        bitfld.long 0x00 31. " SC2_D_293   ," "0,1"
        hexmask.long.word 0x00 16.--30. 1. "         SC2_D_RW294 ,"
        bitfld.long 0x00 15. "  SC2_D_295   ," "0,1"
        hexmask.long.word 0x00 0.--14. 1. "     SC2_D_RW296 ,"

group d:0xD420F0FC++0x03
    line.long 0x00 "EOF_DLY_COUNTER_CTRL7,"
        bitfld.long 0x00 31. " SC2_D_302   ," "0,1"
        hexmask.long.word 0x00 16.--30. 1. "         SC2_D_RW303 ,"
        bitfld.long 0x00 15. "  SC2_D_304   ," "0,1"
        hexmask.long.word 0x00 0.--14. 1. "     SC2_D_RW305 ,"

tree.end

tree.end

tree "sdhc"

width 33.

group d:0xD4280000++0x03
    line.long 0x00 "SD_SYS_ADDR_LOW,System Address Low Register"
        hexmask.long.word 0x00 0.--15. 1. " DMA_ADDR_L                 ,dma address low   (1) 16 lsb of dma system buffer starting byte address.   (2)this register is used with the auto cmd 23 to set a 32-bit block count value to the argument of cmd23. this register would hold the lower 16bits of the cmd23 argument."

group d:0xD4280002++0x03
    line.long 0x00 "SD_SYS_ADDR_HIGH,System Address High Register"
        hexmask.long.word 0x00 0.--15. 1. " DMA_ADDR_H                 ,dma address high  16 msb of dma system buffer starting byte address.   (2)this register is used with the auto cmd 23 to set a 32-bit block count value to the argument of cmd23. this register would hold the upper 16bits of the cmd23 argument."

group d:0xD4280004++0x03
    line.long 0x00 "SD_BLOCK_SIZE,Block Size Register"
        bitfld.long 0x00 12.--14. " HOST_DMA_BDRY              ,host dma buffer boundary  this field specifies the host memory buffer boundary. if this boundary is crossed, an interrupt (dma_int) is generated. this interrupt is reflected in <tx ready> field in the normal interrupt status register.  0x0 = 4 kb  0x1 = 8 kb  0x2 = 16 kb  0x3 = 32 kb  0x4 = 64 kb  0x5 = 128 kb  0x6 = 256 kb  0x7 = 512 kb" "0,1,2,3,4,5,6,7"
        hexmask.long.word 0x00 0.--11. 1. "         SD1S_BLOCK_SIZE36      ,block size"

group d:0xD4280006++0x03
    line.long 0x00 "SD_BLOCK_COUNT,Block Count Register"
        hexmask.long.word 0x00 0.--15. 1. " BLOCK_COUNT                ,block count  the host controller decrements the block count after each block transfer.  0x1 = 1 block  ...  0xffff = 65535 blocks  the current value of block count is reflected in the current block count register."

group d:0xD4280008++0x03
    line.long 0x00 "SD_ARG_LOW,Argument Low Register"
        hexmask.long.word 0x00 0.--15. 1. " ARG_L                      ,argument low  16 lsb of command argument  this value is inserted into 48 bits command token bits[23:8]."

group d:0xD428000A++0x03
    line.long 0x00 "SD_ARG_HIGH,Argument High Register"
        hexmask.long.word 0x00 0.--15. 1. " ARG_H                      ,argument high  16 msb of command argument  this value is inserted into 48 bits command token bits[39:24]."

group d:0xD428000C++0x03
    line.long 0x00 "SD_TRANSFER_MODE,Transfer Mode Register"
        bitfld.long 0x00 5. " MULTI_BLK_SEL              ,multiple block select  this bit should be set to 1 only when multiple blocks are to be transferred." "0,1"
        bitfld.long 0x00 4. "         TO_HOST_DIR            ,data transfer direction select  this bit defines the direction of the mmc1_dat[3:0] line data transfer. this bit is set to 1 by the host driver to transfer data from the sd card to the sd host controller, and it is set to 0 for all other commands." "0,1"
        bitfld.long 0x00 2.--3. "     AUTO_CMD_EN             ,auto cmd enable  this field determines use of auto command functions.  0x0 = auto command disabled  0x1 = auto cmd12 enable  0x2 = auto cmd23 enable  0x3 = reserved" "0,1,2,3"
        bitfld.long 0x00 1. "       BLK_CNT_EN            ,block count enable  this bit validates the value in the block count register." "0,1"
        textline "                                           "
        bitfld.long 0x00 0. "SD1S_DMA_EN69              ,dma enable  if programmed input/output (pio) mode is required, this bit should be reset to 0." "0,1"

group d:0xD428000E++0x03
    line.long 0x00 "SD_CMD,Command Register"
        hexmask.long.byte 0x00 8.--13. 1. " CMD_INDEX                  ,command index  these bits will be inserted into command token bits[45:40]"
        bitfld.long 0x00 6.--7. "        SD1S_CMD_TYPE78        ,command type  0x0 = normal command  0x1 = suspend command  0x2 = resume command  0x3 = abort command" "0,1,2,3"
        bitfld.long 0x00 5. "     DATA_PRESENT            ,data present  1 = indicates that data is present and will be transferred using the mmc1_dat[3:0] line.  0 = commands using only mmc1_cmd lines or commands with no data transfer but using busy signal on mmc1_dat[0] line (for example, cmd 38)" "0,1"
        bitfld.long 0x00 4. "       CMD_INDEX_CHK_EN      ,command index check enable  1 = host controller checks the index field in the response to see if it has the same value as the command index. if it is not, it is reported as a command index error." "0,1"
        textline "                                           "
        bitfld.long 0x00 3. "CMD_CRC_CHK_EN             ,command crc check enable  1 = host controller checks the crc field in the response. if an error is detected, it is reported as a command crc error. the number of bits checked by the crc field value changes according to the length of response." "0,1"
        bitfld.long 0x00 0.--1. "         RESP_TYPE              ,response type select for sd/sd in spi modes  for sd mode:  0x0 = no response  0x1 = response length is 136 bits  0x2 = response length is 48 bits  0x3 = response length is 48 bits and check busy after response  crc field for r3 and r4 is expected to be all 1 bits. crc check should be disabled for these response types.    for sd in spi mode:  0x0 = response length is 8 bits  0x1 = response length is 16 bits  0x2 = response length is 40 bits  0x3 = reserved" "0,1,2,3"

group d:0xD4280010++0x03
    line.long 0x00 "SD_RESP_0,Response Register 0"
        hexmask.long.word 0x00 0.--15. 1. " RESP0                      ,response 0  this register contains bits[23:8] of the response token."

group d:0xD4280012++0x03
    line.long 0x00 "SD_RESP_1,Response Register 1"
        hexmask.long.word 0x00 0.--15. 1. " RESP1                      ,response 1  this register contains bits[39:24] of the response token."

group d:0xD4280014++0x03
    line.long 0x00 "SD_RESP_2,Response Register 2"
        hexmask.long.word 0x00 0.--15. 1. " RESP2                      ,response 2  for 48-bits response token, this register is don't care.  for 136-bits response token, this register contains bits[55:40] of the response token."

group d:0xD4280016++0x03
    line.long 0x00 "SD_RESP_3,Response Register 3"
        hexmask.long.word 0x00 0.--15. 1. " RESP3                      ,response 3  for 48-bits response token, this register is don't care.  for 136-bits response token, this register contains bits[71:56] of the response token."

group d:0xD4280018++0x03
    line.long 0x00 "SD_RESP_4,Response Register 4"
        hexmask.long.word 0x00 0.--15. 1. " RESP4                      ,response 4  for 48-bits response token, this register is don't care.  for 136-bits response token, this register contains bits[87:72] of response token."

group d:0xD428001A++0x03
    line.long 0x00 "SD_RESP_5,Response Register 5"
        hexmask.long.word 0x00 0.--15. 1. " RESP5                      ,response 5  for 48 bits response token, this register is don't care.  for 136 bits response token, this register contains bits[103:88] of response token."

group d:0xD428001C++0x03
    line.long 0x00 "SD_RESP_6,Response Register 6"
        hexmask.long.word 0x00 0.--15. 1. " RESP6                      ,response 6  for 48-bits response token, this register is don't care.  for 136-bits response token, this register contains bits[119:104] of the response token.  for auto cmd12 response, this register contains bits[23:8] of the response token."

group d:0xD428001E++0x03
    line.long 0x00 "SD_RESP_7,Response Register 7"
        hexmask.long.word 0x00 0.--15. 1. " RESP7                      ,response 7  for 48-bits response token, this register is don't care.  for 136-bits response token, this register contains bits[127:120] of the response token.  for auto cmd12 response, this register contains bits[39:24] of the response token."

group d:0xD4280020++0x03
    line.long 0x00 "SD_BUFFER_DATA_PORT_0,Buffer Data Port 0 Register"
        hexmask.long.word 0x00 0.--15. 1. " CPU_DATA0                  ,processor data 0  16 lsb of the buffer"

group d:0xD4280022++0x03
    line.long 0x00 "SD_BUFFER_DATA_PORT_1,Buffer Data Port 1 Register"
        hexmask.long.word 0x00 0.--15. 1. " CPU_DATA1                  ,processor data 1  16 msb of the buffer"

group d:0xD4280024++0x03
    line.long 0x00 "SD_PRESENT_STATE_1,Present State Register 1"
        bitfld.long 0x00 11. " BUFFER_RD_EN               ,buffer read enable  this field changes from 0x0 to 0x1 when block data is ready in the buffer and from 0x1 to 0x0 when all the block data is read from the buffer." "0,1"
        bitfld.long 0x00 10. "         BUFFER_WR_EN           ,buffer write enable  this field changes from 0x0 to 0x1 when block data can be written to the buffer. so if this bit is set to 0x1, the entire block can be written to the buffer.  this field changes from 0x1 to 0x0 when all the block data is written to the buffer." "0,1"
        bitfld.long 0x00 9. "     RX_ACTIVE               ,rx active  this field indicates read transfer is active.  1 = set:" "0,1"
        bitfld.long 0x00 8. "       TX_ACTIVE             ,tx active  indicates write transfer is active.  0 = no valid write data exists in the host controller  1 = set:" "0,1"
        textline "                                           "
        bitfld.long 0x00 3. "RETUNING_REQ               ,re-tuning request  this field provides the status of the sampling clock.  0x0 = fixed or well tuned sampling clock  1 = sampling clock needs re-tuning" "0,1"
        bitfld.long 0x00 2. "         _DAT_ACTIVE            ,data line active  this field provides the status of the data line.  0 = data line is free  1 = data line is in use" "0,1"
        bitfld.long 0x00 1. "     CMD_INHIBIT_DAT         ,command inhibit data  this field provides the host driver status for issuing data commands.  0 = data command can be issued  1 = data command cannot be issued" "0,1"
        bitfld.long 0x00 0. "       CMD_INHIBIT_CMD       ,command inhibit command  if this bit is 0, it indicates the mmc1_cmd line is not in use, and the host controller can issue a command using mmc1_cmd line. this bit is set after the command register is written. this bit is cleared when the command response is received. even if the <command inhibit data> field is set to 1, commands using only the mmc1_cmd line can be issued if this bit is 0. changing from 1 to 0 generates a command complete interrupt in the normal interrupt status register. if the host controller cannot issue the command because of a command conflict error, this bit remains 1, and the command complete is not set." "0,1"

group d:0xD4280026++0x03
    line.long 0x00 "SD_PRESENT_STATE_2,Present State Register 2"
        bitfld.long 0x00 8. " CMD_LEVEL                  ,mmc1_cmd line signal level  this status is used to check the mmc1_cmd line level to recover from errors and for debugging." "0,1"
        bitfld.long 0x00 4.--7. "         DAT_LEVEL190           ,mmc1_dat[3:0] line signal level  this status is used to check the mmc1_dat[3:0] line level to recover from errors and for debugging. this is especially useful in detecting the busy signal level from mmc1_dat[0]." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 3. "    WRITE_PROT              ,write protect  this field reflects the position of the write_protect latch on the sd card. this field should be ignored if there is no such feature being provided by the card in use." "0,1"
        bitfld.long 0x00 2. "       CARD_DET              ,card detect  this field reflects the value of the mmc1_cd pin. this field is only used for testing.  0 = card not detected  1 = card detected" "0,1"
        textline "                                           "
        bitfld.long 0x00 1. "CARD_STABLE                ,card stable  this field is only used for testing. it indicates the debounced value of the card present condition.  0 = card unstable  1 = card stable" "0,1"
        bitfld.long 0x00 0. "         CARD_INSERTED          ,card inserted  this field indicates the presence of an sd card.  0 = card not inserted  1 = card inserted" "0,1"

group d:0xD4280028++0x03
    line.long 0x00 "SD_HOST_CTRL,Host Control Register"
        bitfld.long 0x00 9.--11. " SD_BUS_VLT                 ,sd bus voltage  this field reflects the voltage at operating conditions.  0x7 = 3.3v  0x6 = 3.0v  0x5 = 1.8v  0x0 to 0x4 = reserved" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 8. "         SD_BUS_POWER           ,sd bus power  this field controls the power going out to the sd card. it will be cleared if one of the following occurs: the sd_bus_vlt and the voltage support in the capabilities register 1 do not match or if a card removal state was detected." "0,1"
        bitfld.long 0x00 7. "     CARD_DET_S              ,card detect signal selection  this field selects the source for card detection.  0 = card detect input pin  1 = card detect test level (for debugging purposes only)  when the source for card detection is switched, the interrupt should be disabled during the switching period by clearing the normal interrupt status enable register in order to mask unexpected interrupts being caused by the glitch.  this signal should be disabled via the normal interrupt status enable register during debounce period." "0,1"
        bitfld.long 0x00 6. "       CARD_DET_L            ,card detect test level  1 = card inserted  0 = no card inserted" "0,1"
        textline "                                           "
        bitfld.long 0x00 5. "EX_DATA_WIDTH              ,this bit controls the 8-bit mode.  0x0 = data width for bus mode is determined by <data_width>.  0x1 = 8-bit data width." "0,1"
        bitfld.long 0x00 3.--4. "         DMA_SEL                ,dma select  one of supported dma modes as selected. the host driver checks support of dma modes using the capabilities register 1. use of the selected dma is determined by the <dma enable> field in the transfer mode register.  0x0 = sdma  0x1 = adma 1  0x2 = 32-bit address adma2  0x3 = reserved" "0,1,2,3"
        bitfld.long 0x00 2. "     HI_SPEED_EN             ,extend data output enable  0 = normal  1 = mmc1_cmd and mmc1_dat[3:0] are driven from rising edge of clock" "0,1"
        bitfld.long 0x00 1. "       DATA_WIDTH            ,data width  1 = 4-bit data mode  0 = 1-bit data mode, using only mmc1_dat[0]  refer to the ce-ata register 2 for 8-bit mode support." "0,1"
        textline "                                           "
        bitfld.long 0x00 0. "LED_CTRL                   ,led control  1 = led on  0 = led off" "0,1"

group d:0xD428002A++0x03
    line.long 0x00 "SD_BLOCK_GAP_CTRL,Block Gap Control Register"
        bitfld.long 0x00 10. " W_REMOVAL                  ,wakeup on card removal  1 = enable wakeup event on card removal detection  0 = no wakeup event" "0,1"
        bitfld.long 0x00 9. "         W_INSERTION            ,wakeup on card insertion  1 = enable wakeup event on card insertion detection  0 = no wakeup event" "0,1"
        bitfld.long 0x00 8. "     W_CARD_INT              ,wakeup on card interrupt  1 = enable wakeup event on card interrupt detection  0 = no wakeup event" "0,1"
        bitfld.long 0x00 3. "       INT_BLK_GAP           ,block gap interrupt  this field is only valid for 4-bit mode.  1 = enables interrupt detection at block gap for multiple block transfers" "0,1"
        textline "                                           "
        bitfld.long 0x00 2. "RD_WAIT_CTL                ,read wait control  if the card supports read wait, set this bit to enable use of the read wait protocol to stop read data using the mmc1_dat[2] line by host hardware. otherwise, host controller has to stop sd clock to hold read data. when the host driver detects a card insertion, it will set this bit according to the cccr of the sdio card." "0,1"
        bitfld.long 0x00 1. "         CONT_REQ               ,continue request  this field is used to restart a transaction which was stopped using the <stop at block gap request>. to cancel stop at the block gap, set the <stop at block gap request> field to 0 and set this field to 1 to restart the transfer. host controller automatically clears this field in either of the following cases:" "0,1"
        bitfld.long 0x00 0. "     STOP_AT_BLOCK_GAP_REQ   ,stop at block gap request  this field is used to stop executing a transaction at the next block gap for both dma and non-dma transfers. until the transfer complete is set to 1, indicating a transfer completion, the host driver will leave this bit set to 1. clearing both this field and the <continue request> field will not cause the transaction to restart. read wait is used to stop the read transaction at the block gap. the host controller will stop the clock at block gap request for write transfer, but for read transfer, it will stop the clock if <read wait control> is 0. otherwise, the host controller issues a read wait command to stop read data." "0,1"

group d:0xD428002C++0x03
    line.long 0x00 "SD_CLOCK_CTRL,Clock Control Register"
        hexmask.long.byte 0x00 8.--15. 1. " SD_FREQ_SEL_LO             ,sdclk frequency select lower bits  this along with <sd_freq_sel_hi> define the clock divider value to be used by the host controller. so the final sd_freq_sel = {sd_freq_sel_hi[1:0],sd_freq_sel_lo[7:0]}. the selected value is multiplied by 2 to get the actual divide value. for. e.g   sd_freq_sel = 0x00 = base clock   sd_freq_sel = 0x01 = divide by 2 of base clock  sd_freq_sel = 0x02 = divide by 4 of base clock   sd_freq_sel = 0x3 = divide by 6 of base clock.  ...  sd_freq_sel = 0x3ff = divide by 2046 of base clock."
        bitfld.long 0x00 6.--7. "        SD_FREQ_SEL_HI         ,sdclk frequency select upper bits  this along with <sd_freq_sel_lo> define the clock divider value to be used by the host controller. so the final sd_freq_sel = {sd_freq_sel_hi[1:0],sd_freq_sel_lo[7:0]}. the selected value is multiplied by 2 to get the actual divide value. for. e.g   sd_freq_sel = 0x00 = base clock   sd_freq_sel = 0x01 = divide by 2 of base clock  sd_freq_sel = 0x02 = divide by 4 of base clock   sd_freq_sel = 0x3 = divide by 6 of base clock.  ...  sd_freq_sel = 0x3ff = divide by 2046 of base clock." "0,1,2,3"
        bitfld.long 0x00 5. "     CLK_GEN_SEL             ,clock generator select  this field is used to select the clock generator mode.  0x1 = programmable clock mode  0x0 = divided clock mode" "0,1"
        bitfld.long 0x00 2. "       SD_CLK_EN             ,sdclk clock enable  this bit controls the sdclk to the card. before using the card, this bit should be set during the initialization phase." "0,1"
        textline "                                           "
        bitfld.long 0x00 1. "INT_CLK_STABLE             ,internal clock stable  this field is set to 1 once the controller detects that the internal clock is stable after setting of the <internal clock enable> field." "0,1"
        bitfld.long 0x00 0. "         INT_CLK_EN             ,internal clock enable  this field controls the sdclk to the internal logic.  1 = enable clock  0 = disable" "0,1"

group d:0xD428002E++0x03
    line.long 0x00 "SD_TIMEOUT_CTRL_SW_RESET,Timeout Control/Software Reset Register"
        bitfld.long 0x00 10. " SW_RST_DAT                 ,soft reset for data port of logic" "0,1"
        bitfld.long 0x00 9. "         SW_RST_CMD             ,soft reset for command part of logic" "0,1"
        bitfld.long 0x00 8. "     SW_RST_ALL              ,software reset for all  this reset affects the status, state machine, and fifos synchronously.   this field also resets all private registers." "0,1"
        bitfld.long 0x00 0.--3. "       TIMEOUT_VALUE         ,timeout value  determines the interval by which mmc1_dat[3:0] line timeouts are detected. this timeout is initiated in the following cases:" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"

group d:0xD4280030++0x03
    line.long 0x00 "SD_NORMAL_INT_STATUS,Normal Interrupt Status Register"
        bitfld.long 0x00 15. " ERR_INT                    ,error interrupt  if any of bits in the error interrupt status register are set, then this bit is set." "0,1"
        bitfld.long 0x00 14. "         CQ_INT                 ,command queuing interrupt    this interrupt is asserted when at least one of the bits in cqis register is set. this interrupt is cleared only clearing the source interrupt in cqis register" "0,1"
        bitfld.long 0x00 12. "     RETUNING_INT            ,re-tuning event interrupt  this status is set if re-tuning request in the <present state register> changes from 0x0 to 0x1.   host controller requests host driver to perform re-tuning fro next data transfer. current data transfer can be completed without re-tuning." "0,1"
        bitfld.long 0x00 11. "       INT_C                 ,this status is set if int_c is enabled and int_c# pin is in low level. writing this bit to 0x1 does not clear this bit. it is cleared by resetting the int_c interrupt factor. refer to shared bus control register." "0,1"
        textline "                                           "
        bitfld.long 0x00 10. "INT_B                      ,this status is set if int_b is enabled and int_b# pin is in low level. writing this bit to 0x1 does not clear this bit. it is cleared by resetting the int_b interrupt factor. refer to shared bus control register." "0,1"
        bitfld.long 0x00 9. "         INT_A                  ,this status is set if int_a is enabled and int_a# pin is in low level. writing this bit to 0x1 does not clear this bit. it is cleared by resetting the int_a interrupt factor. refer to shared bus control register." "0,1"
        bitfld.long 0x00 8. "     CARD_INT                ,card interrupt  1 = host controller detects an interrupt from the card" "0,1"
        bitfld.long 0x00 7. "       CARD_REM_INT          ,card removal interrupt  1 = card removal event detected" "0,1"
        textline "                                           "
        bitfld.long 0x00 6. "CARD_INS_INT               ,card insertion interrupt  1 = card insertion event detected" "0,1"
        bitfld.long 0x00 5. "         RX_RDY                 ,rx ready  this status is set if the <buffer read enable> field in the present state register 1 changes from 0x0 to 0x1." "0,1"
        bitfld.long 0x00 4. "     TX_RDY                  ,tx ready  this status is set if the <buffer write enable> field in the present state register 1 changes from 0x0 to 0x1." "0,1"
        bitfld.long 0x00 3. "       DMA_INT               ,dma interrupt  this status is set if the host controller detects dma crossing over the <host dma buffer boundary> field in the block size register." "0,1"
        textline "                                           "
        bitfld.long 0x00 2. "BLOCK_GAP_EVT              ,block gap event  if the <stop at block gap request> field in the block gap control register is set, this field is set when both a read/write transaction is stopped at a block gap. if the <stop at block gap request> field is not set to 1, this bit is not set to 1." "0,1"
        bitfld.long 0x00 1. "         XFER_COMPLETE          ,transfer complete  this bit is set when a read/write transaction is completed  for read transaction, this bit is set at the falling edge of read transfer active status. there are two cases in which this occurs:" "0,1"
        bitfld.long 0x00 0. "     CMD_COMPLETE            ,command complete  this bit is set when the end bit of the command response (except auto cmd12) is received. note that command timeout error has higher priority than command complete." "0,1"

group d:0xD4280032++0x03
    line.long 0x00 "SD_ERROR_INT_STATUS,Error Interrupt Status Register"
        bitfld.long 0x00 15. " CRC_STATUS_ERR             ,crc status error  1 = crc status start bit or crc status end bit or boot ack status, returned from the card in write transaction has errors" "0,1"
        bitfld.long 0x00 14. "         CPL_TIMEOUT_ERR        ,command completion signal timeout error  this field is applicable for ce-ata mode only.  1 = a command completion signal timeout occurred" "0,1"
        bitfld.long 0x00 13. "     AXI_RESP_ERR            ,axi bus response error  1 = a response other than <q>okay</q> was received on the axi bus." "0,1"
        bitfld.long 0x00 12. "       SPI_ERR               ,spi mode error  1 = error occurred in spi mode for which cause can be determined by reading the <spi error token> field in the spi mode register  0 = no error has occurred" "0,1"
        textline "                                           "
        bitfld.long 0x00 9. "ADMA_ERR                   ,adma (advanced direct memory access) error  this bit is set when the host controller detects any errors during an adma-based data transfer. the adma state at the time an error occurs is saved in the adma error status register.  the host controller also generates this interrupt when it detects any invalid descriptor data. the <adma error state> field in the adma error status register indicates the state in which an error occurred. the host driver may find that a valid bit is not set at the error descriptor.  1 = error  0 = no error" "0,1"
        bitfld.long 0x00 8. "         AUTO_CMD12_ERR         ,auto cmd12 error  occurs when detecting that one of the bits in auto cmd12 error status register has changed from 0 to 1." "0,1"
        bitfld.long 0x00 7. "     CUR_LIMIT_ERR           ,current limit error  this feature is not supported and this bit will always be read as 0." "0,1"
        bitfld.long 0x00 6. "       RD_DATA_END_BIT_ERR   ,readdata end bit error  1 = 0 detected at the end bit position of read data which uses the mmc1_dat[3:0] line or at the end bit position of the crc status" "0,1"
        textline "                                           "
        bitfld.long 0x00 5. "RD_DATA_CRC_ERR            ,read data crc error  1 = read data which uses the mmc1_dat[3:0] line transferred or write crc status having a value other than 010 detected" "0,1"
        bitfld.long 0x00 4. "         DATA_TIMEOUT_ERR       ,data timeout error  1 = set when one of the following is detected:" "0,1"
        bitfld.long 0x00 3. "     CMD_INDEX_ERR           ,command index error  0 = no command index error has occurred in the command response  1 = command index error has occurred in the command response" "0,1"
        bitfld.long 0x00 2. "       CMD_END_BIT_ERR       ,command end bit error  0 = detection of end bit of a command response in 1  1 = detection of end bit of a command response is 0" "0,1"
        textline "                                           "
        bitfld.long 0x00 1. "CMD_CRC_ERR                ,command crc error  1 = set in two cases:" "0,1"
        bitfld.long 0x00 0. "         CMD_TIMEOUT_ERR        ,command timeout error  1 = no response is returned within 64 sdclk cycles from the end bit of the command" "0,1"

group d:0xD4280034++0x03
    line.long 0x00 "SD_NORMAL_INT_STATUS_EN,Normal Interrupt Status Enable Register"
        bitfld.long 0x00 14. " CQ_STATUS_EN               ,command queuing status enable" "0,1"
        bitfld.long 0x00 12. "         RETUNE_INT_EN          ,re_tuning interrupt enable  0 = disabled  1 = enabled" "0,1"
        bitfld.long 0x00 11. "     INT_C_INT_EN            ,int_c enable  0 = disabled  1 = enabled" "0,1"
        bitfld.long 0x00 10. "       INT_B_INT_EN          ,int_b enable  0 = disabled  1 = enabled" "0,1"
        textline "                                           "
        bitfld.long 0x00 9. "INT_A_INT_EN               ,int_a enable  0 = disabled  1 = enabled" "0,1"
        bitfld.long 0x00 8. "         CARD_INT_EN            ,card interrupt enable  0 = disabled  1 = enabled" "0,1"
        bitfld.long 0x00 7. "     CARD_REM_EN             ,card removal status enable  0 = disabled  1 = enabled" "0,1"
        bitfld.long 0x00 6. "       CARD_INS_EN           ,card insertion status enable  0 = disabled  1 = enabled" "0,1"
        textline "                                           "
        bitfld.long 0x00 5. "RD_RDY_EN                  ,buffer read ready enable  0 = disabled  1 = enabled" "0,1"
        bitfld.long 0x00 4. "         TX_RDY_EN              ,buffer write ready enable  0 = disabled  1 = enabled" "0,1"
        bitfld.long 0x00 3. "     DMA_INT_EN              ,dma interrupt enable  0 = disabled  1 = enabled" "0,1"
        bitfld.long 0x00 2. "       BLOCK_GAP_EVT_EN      ,block gap event enable  0 = disabled  1 = enabled" "0,1"
        textline "                                           "
        bitfld.long 0x00 1. "XFER_COMPLETE_EN           ,transfer complete enable  0 = disabled  1 = enabled" "0,1"
        bitfld.long 0x00 0. "         CMD_COMPLETE_EN        ,command complete enable  0 = disabled  1 = enabled" "0,1"

group d:0xD4280036++0x03
    line.long 0x00 "SD_ERROR_INT_STATUS_EN,Error Interrupt Status Enable Register"
        bitfld.long 0x00 15. " CRC_STATUS_ERR_EN          ,crc status error enable  0 = disabled  1 = enabled" "0,1"
        bitfld.long 0x00 14. "         CPL_TIMEOUT_ERR_EN     ,cpl timeout error enable  0 = disabled  1 = enabled" "0,1"
        bitfld.long 0x00 13. "     AXI_RESP_ERR_EN         ,axi response error enable  0 = disabled  1 = enabled" "0,1"
        bitfld.long 0x00 12. "       SPI_ERR_EN            ,spi error enable  0 = disabled  1 = enabled" "0,1"
        textline "                                           "
        bitfld.long 0x00 10. "TUNING_ERR_EN              ,tuning error enable  0 = disabled  1 = enabled" "0,1"
        bitfld.long 0x00 9. "         ADMA_ERR_EN            ,adma error enable  0 = disabled  1 = enabled" "0,1"
        bitfld.long 0x00 8. "     AUTO_CMD12_ERR_EN       ,auto cmd12 error enable  0 = disabled  1 = enabled" "0,1"
        bitfld.long 0x00 7. "       CUR_LIM_ERR_EN        ,current limit error enable  0 = disabled  1 = enabled" "0,1"
        textline "                                           "
        bitfld.long 0x00 6. "RD_DATA_END_BIT_ERR_EN     ,data end bit error enable  0 = disabled  1 = enabled" "0,1"
        bitfld.long 0x00 5. "         RD_DATA_CRC_ERR_EN     ,data crc error enable  0 = disabled  1 = enabled" "0,1"
        bitfld.long 0x00 4. "     DATA_TIMEOUT_ERR_EN     ,data timeout error enable  0 = disabled  1 = enabled" "0,1"
        bitfld.long 0x00 3. "       CMD_INDEX_ERR_EN      ,command index error enable  0 = disabled  1 = enabled" "0,1"
        textline "                                           "
        bitfld.long 0x00 2. "CMD_END_BIT_ERR_EN         ,command end bit error enable  0 = disabled  1 = enabled" "0,1"
        bitfld.long 0x00 1. "         CMD_CRC_ERR_EN         ,command crc error enable  0 = disabled  1 = enabled" "0,1"
        bitfld.long 0x00 0. "     CMD_TIMEOUT_ERR_EN      ,command timeout error enable  0 = disabled  1 = enabled" "0,1"

group d:0xD4280038++0x03
    line.long 0x00 "SD_NORMAL_INT_STATUS_INT_EN,Normal Interrupt Status Interrupt Enable Register"
        bitfld.long 0x00 14. " CQ_SIGNAL_ENABLE           ,command queuing signal enable" "0,1"
        bitfld.long 0x00 12. "         RETUNE_INT_INT_EN      ,re-tuning interrupt interrupt enable  0 = disabled  1 = enabled" "0,1"
        bitfld.long 0x00 11. "     INT_C_INT_INT_EN        ,int_c interrupt interrupt enable  0 = disabled  1 = enabled" "0,1"
        bitfld.long 0x00 10. "       INT_B_INT_INT_EN      ,int_b interrupt interrupt enable  0 = disabled  1 = enabled" "0,1"
        textline "                                           "
        bitfld.long 0x00 9. "INT_A_INT_INT_EN           ,int_a interrupt interrupt enable  0 = disabled  1 = enabled" "0,1"
        bitfld.long 0x00 8. "         CARD_INT_INT_EN        ,card interrupt interrupt enable  0 = disabled  1 = enabled" "0,1"
        bitfld.long 0x00 7. "     CARD_REM_INT_EN         ,card removal interrupt enable  0 = disabled  1 = enabled" "0,1"
        bitfld.long 0x00 6. "       CARD_INS_INT_EN       ,card insertion interrupt enable  0 = disabled  1 = enabled" "0,1"
        textline "                                           "
        bitfld.long 0x00 5. "RX_RDY_INT_EN              ,buffer read ready interrupt enable  0 = disabled  1 = enabled" "0,1"
        bitfld.long 0x00 4. "         TX_RDY_INT_EN          ,buffer write ready interrupt enable  0 = disabled  1 = enabled" "0,1"
        bitfld.long 0x00 3. "     DMA_INT_INT_EN          ,dma interrupt interrupt enable  0 = disabled  1 = enabled" "0,1"
        bitfld.long 0x00 2. "       BLOCK_GAP_EVT_INT_EN  ,block gap event interrupt enable  0 = disabled  1 = enabled" "0,1"
        textline "                                           "
        bitfld.long 0x00 1. "XFER_COMPLETE_INT_EN       ,transfer complete interrupt enable  0 = disabled  1 = enabled" "0,1"
        bitfld.long 0x00 0. "         CMD_COMPLETE_INT_EN    ,command complete interrupt enable  0 = disabled  1 = enabled" "0,1"

group d:0xD428003A++0x03
    line.long 0x00 "SD_ERROR_INT_STATUS_INT_EN,Error Interrupt Status Interrupt Enable Register"
        bitfld.long 0x00 15. " CRC_STATUS_ERR_INT_EN      ,crc status error interrupt enable  0 = disabled  1 = enabled" "0,1"
        bitfld.long 0x00 14. "         CPL_TIMEOUT_ERR_INT_EN ,cpl timeout error interrupt enable  0 = disabled  1 = enabled" "0,1"
        bitfld.long 0x00 13. "     AXI_RESP_ERR_INT_EN     ,axi response error interrupt enable  0 = disabled  1 = enabled" "0,1"
        bitfld.long 0x00 12. "       SPI_ERR_INT_EN        ,spi error interrupt enable  0 = disabled  1 = enabled" "0,1"
        textline "                                           "
        bitfld.long 0x00 10. "TUNE_ERR_INT_EN            ,tuning error interrupt enable  0 = disabled  1 = enabled" "0,1"
        bitfld.long 0x00 9. "         ADMA_ERR_INT_EN        ,adma error interrupt enable  0 = disabled  1 = enabled" "0,1"
        bitfld.long 0x00 8. "     AUTO_CMD12_ERR_INT_EN   ,auto cmd12 error interrupt enable  0 = disabled  1 = enabled" "0,1"
        bitfld.long 0x00 7. "       CUR_LIM_ERR_INT_EN    ,current limit error interrupt enable  0 = disabled  1 = enabled" "0,1"
        textline "                                           "
        bitfld.long 0x00 6. "RD_DATA_END_BIT_ERR_INT_EN ,data end bit error interrupt enable  0 = disabled  1 = enabled" "0,1"
        bitfld.long 0x00 5. "         RD_DATA_CRC_ERR_INT_EN ,data crc error interrupt enable  0 = disabled  1 = enabled" "0,1"
        bitfld.long 0x00 4. "     DATA_TIMEOUT_ERR_INT_EN ,data timeout error interrupt enable  0 = disabled  1 = enabled" "0,1"
        bitfld.long 0x00 3. "       CMD_INDEX_ERR_INT_EN  ,command index error interrupt enable  0 = disabled  1 = enabled" "0,1"
        textline "                                           "
        bitfld.long 0x00 2. "CMD_END_BIT_ERR_INT_EN     ,command end bit interrupt error enable  0 = disabled  1 = enabled" "0,1"
        bitfld.long 0x00 1. "         CMD_CRC_ERR_INT_EN     ,command crc error interrupt enable  0 = disabled  1 = enabled" "0,1"
        bitfld.long 0x00 0. "     CMD_TIMEOUT_ERR_INT_EN  ,command timeout error interrupt enable  0 = disabled  1 = enabled" "0,1"

group d:0xD428003C++0x03
    line.long 0x00 "SD_AUTO_CMD12_ERROR_STATUS,Auto CMD12 Error Status Register"
        bitfld.long 0x00 7. " CMD_NOT_ISSUED             ,command not issued due to auto_cmd12 error" "0,1"
        bitfld.long 0x00 4. "         AUTO_CMD_INDEX_ERR     ,auto cmd12 or auto cmd23 error  this error occurs if the command index error occurs in response to a command  0 = disabled  1 = enabled" "0,1"
        bitfld.long 0x00 3. "     AUTO_CMD_END_BIT_ERR    ,auto cmd12 or auto cmd23end bit error  this error occurs when detecting that the end bit of command response is 0.  0 = disabled  1 = enabled" "0,1"
        bitfld.long 0x00 2. "       AUTO_CMD_CRC_ERR      ,auto cmd12 or auto cmd23 crc error  this error occurs when detecting crc error in the command response.  0 = disabled  1 = enabled" "0,1"
        textline "                                           "
        bitfld.long 0x00 1. "AUTO_CMD_TIMEOUT_ERR       ,auto cmd12 or auto cmd23 timeout error  this error occurs if no response is returned within 64 sdclk cycles from the end bit of command.  0 = disabled  1 = enabled" "0,1"
        bitfld.long 0x00 0. "         AUTO_CMD12_NOT_EXE     ,auto cmd12 not executed  this error occurs when host controller cannot issue auto cmd12 to stop multiple block data transfer due to some errors.  0 = disabled  1 = enabled" "0,1"

group d:0xD428003E++0x03
    line.long 0x00 "HOST_CTRL_2,Host Control 2 Register"
        bitfld.long 0x00 15. " PRE_VAL_EN                 ,preset value enable  0x1 = automatic selection by preset value are enabled  0x0 = sdclk and driver strength are controlled by host driver" "0,1"
        bitfld.long 0x00 14. "         ASYNC_INT_EN           ,asynchronous interrupt enable   this bit can be set to 0x1 if a card supports asynchronous interrupts and <async_int_support> is set to 0x1 in the capabilities register. asynchronous interrupt is effective when dat[1] interrupt is used in 4-bit sd mode (and zero is set to <int_pin_sel> in shared bus control register). if this bit is set to 0x1, the host driver can stop the sdclk during asynchronous interrupt period to save power. during this period, the host controller continues to deliver the card interrupt to the host when it is asserted by the card.   0x1 = enabled  0x0 = disabled" "0,1"
        bitfld.long 0x00 7. "     SAMPLING_CLK_SEL        ,sampling clock select  host controller uses this bit to select sampling clock to receive cmd and dat. this bit is set by tuning procedure and valid after the completion of tuning (when <exe_tuning> is cleared). setting 0x1 means that tuning is completed successfully and setting 0x0 means that tuning is failed. writing 0x1 to this bit is meaningless and ignored. a tuning circuit is reset by writing 0x0. this bit can be cleared by setting <exe_tuning>. once the tuning circuit is reset, it will take time to complete tuning sequence. therefore, host driver should keep this bit to 0x1 to perform re-tuning sequence in a short time. change of this bit is not allowed while the host controller is receiving response or a read data block.   0x1 = tuned clock is used to sample data  0x0 = fixed clock is used to sample data." "0,1"
        bitfld.long 0x00 6. "       EXE_TUNING            ,execute tuning.  this bit is set to 0x1 to start tuning procedure and automatically cleared when tuning procedure is completed. the result of the tuning is indicated to <sampling_clk_sel>. tuning procedure is aborted by writing 0x0.   0x1 = execute tuning.  0x0 = not tuned or tuning completed." "0,1"
        textline "                                           "
        bitfld.long 0x00 4.--5. "DRV_STRENGTH_SEL           ,driver strength select.  host controller output driver in 1.8v signaling is selected by this field. in 3.3v signaling this field is not effective. this field can be set depending on driver type a, c and d support bits in the capabilities register.   this bit depends on setting of <pre_val_en>. if <pre_val_en> = 0x0, this field is set by the host driver. if <pre_val_en> = 0x1, this field is automatically set by a value specified in one of the preset value registers.  0x0 = driver type b  0x1 = driver type a  0x2 = driver type c  0x3 = driver type d" "0,1,2,3"
        bitfld.long 0x00 3. "         SDH_V18_EN             ,1.8v signaling enable  0x1 = 1.8v signaling enable  0x0 = 3.3v signaling enable" "0,1"
        bitfld.long 0x00 0.--2. "     UHS_MODE_SEL            ,uhs mode select. this field is used to select one of uhs-i modes and effective when <sdh_v18_en> = 0x1.  if <pre_val_en> in the host control2 register is set to 0x1, host controller set sdclk frequency select, clock generator select in the clock control register and driver strength select according to the preset value registers. in this case, one of the preset value registers is selected by this field. host driver should reset <sd_clk_en> before changing this field to avoid generating clock glitch  0x0 = sdr12  0x1 = sdr25  0x2 = sdr50  0x3 = sdr104  0x4 = ddr50  all other values are reserved for mmc mode, added two backdoor defined modes:   5(101) hs200 mode   5(110) hs400 mode normally sw only need set rx114 hs200/hs400 modes" "0,1,2,3,4,5,6,7"

group d:0xD4280040++0x03
    line.long 0x00 "SD_CAPABILITIES_1,Capabilities Register 1"
        hexmask.long.byte 0x00 8.--15. 1. " BASE_FREQ                  ,base frequency  the base clock frequency for sdclk  0xc8 = 200 mhz (actually 198.24 mhz).  0x0 means get info via other method."
        bitfld.long 0x00 7. "        TIMEOUT_UNIT           ,timeout unit  the unit of base clock used to detect timeouts.  1 = mhz  0 = khz" "0,1"
        hexmask.long.byte 0x00 0.--5. 1. "     TIMEOUT_FREQ            ,timeout frequency  this value indicates the base clock frequency used to detect timeouts.  0x32 = 50 mhz (actually 49.56 mhz).  0x0 means get info via other method."

group d:0xD4280042++0x03
    line.long 0x00 "SD_CAPABILITIES_2,Capabilities Register 2"
        bitfld.long 0x00 14.--15. " CFG_SLOT_TYPE              ,slot type  this field indicates what type of slot the host controller is connected to.  0x0 = removable card slot  0x1 = embedded slot for one device  0x2 = shared bus slot  0x3 = reserved" "0,1,2,3"
        bitfld.long 0x00 13. "         ASYNC_INT_SUPPORT      ,asynchronous interrupt support.  0x1 = asynchronous interrupt supported  0x0 = asynchronous interrupt not supported" "0,1"
        bitfld.long 0x00 12. "     SYS_BUS_64_SUPPORT      ,64-bit system bus support  this bit indicates whether the host controller is capable of 64-bit system bus.  0x1 = 64-bit system bus supported, 0x0 = 64-bit system bus not supported." "0,1"
        bitfld.long 0x00 10. "       VLG_18_SUPPORT        ,voltage support 1.8v  this bit indicates whether the host controller is capable of 1.8v.  0x1 = 1.8v supported, 0x0 = 1.8v not supported." "0,1"
        textline "                                           "
        bitfld.long 0x00 9. "VLG_30_SUPPORT             ,voltage support 3.0v  this bit indicates whether the host controller is capable of 3.0v.  0x1 = 3.0v supported, 0x0 = 3.0v not supported." "0,1"
        bitfld.long 0x00 8. "         VLG_33_SUPPORT         ,voltage support 3.3v  this bit indicates whether the host controller is capable of 3.3v.  0x1 = 3.3v supported, 0x0 = 3.3v not supported." "0,1"
        bitfld.long 0x00 7. "     SUS_RES_SUPPORT         ,suspend resume support  this bit indicates whether the host controller is capable of suspend resume commands.  0x1 = suspend/resume supported, 0x0 = suspend/resume not supported." "0,1"
        bitfld.long 0x00 6. "       SDMA_SUPPORT          ,sdma support  this bit indicates whether the host controller is capable of sdma.  0x1 = sdma supported, 0x0 = sdma not supported." "0,1"
        textline "                                           "
        bitfld.long 0x00 5. "HI_SPEED_SUPPORT           ,high speed support  this bit indicates whether the host controller is capable of high speed mode (25 - 50mhz).  0x1 = high speed mode supported, 0x0 = high speed mode not supported." "0,1"
        bitfld.long 0x00 4. "         ADMA1_SUPPORT          ,adma1 support  this bit indicates whether the host controller is capable of adma1.  0x1 = adma1 supported, 0x0 = adma1 not supported." "0,1"
        bitfld.long 0x00 3. "     ADMA2_SUPPORT           ,adma2 support  this bit indicates whether the host controller is capable of adma2.  0x1 = adma2 supported, 0x0 = adma2 not supported." "0,1"
        bitfld.long 0x00 2. "       EX_DATA_WIDTH_SUPPORT ,8-bit support  this bit indicates whether the host controller is capable of 8-bit bus operation.  0x1 = 8-bit supported  0x0 = 8-bit not supported" "0,1"
        textline "                                           "
        bitfld.long 0x00 0.--1. "MAX_BLK_LEN                ,maximum block length   the maximum block length in bytes.   0x0 = 512 bytes" "0,1,2,3"

group d:0xD4280044++0x03
    line.long 0x00 "SD_CAPABILITIES_3,Capabilities Register 3"
        bitfld.long 0x00 14.--15. " RETUNE_MODES               ,re_tuning modes.  this field selects the re-tuning method and limits the maximum data length.  0x0 = mode1 = timer  0x1 = mode2 = timer and re-tuning request  0x2 = mode3 = auto re-tuning (for transfer) timer and re-tuning request  0x3 = reserved." "0,1,2,3"
        bitfld.long 0x00 13. "         SDR50_TUNE             ,use tuning for sdr50 mode.   0x1 = sdr50 requires tuning  0x0 = sdr50 does not require tuning" "0,1"
        bitfld.long 0x00 8.--11. "     TMR_RETUNE              ,timer count for re-tuning.  this field indicates an initial value of the re-tuning timer for mode 1 to 3.  0xf = get information from other source." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 6. "      DRV_TYPE_D            ,driver type d support  0x1 = driver type d is supported  0x0 = driver type d is not supported" "0,1"
        textline "                                           "
        bitfld.long 0x00 5. "DRV_TYPE_C                 ,driver type c support.  0x1 = driver type c is supported.  0x0 = driver type c is not supported." "0,1"
        bitfld.long 0x00 4. "         DRV_TYPE_A             ,driver type a support  0x1 = driver type a is supported  0x0 = driver type a is not supported." "0,1"
        bitfld.long 0x00 2. "     DDR50_SUPPORT           ,ddr50 support  0x1 =ddr50 is supported  0x0 =ddr50 is not supported." "0,1"
        bitfld.long 0x00 1. "       SDR104_SUPPORT        ,sdr104 support  0x1 = sdr104 is supported  0x0 = sdr104 is not supported." "0,1"
        textline "                                           "
        bitfld.long 0x00 0. "SDR50_SUPPORT              ,sdr50 support  0x1 = sdr50 is supported  0x0 = sdr50 is not supported." "0,1"

group d:0xD4280046++0x03
    line.long 0x00 "SD_CAPABILITIES_4,Capabilities Register 4"
        hexmask.long.byte 0x00 0.--7. 1. " <CLK_MULTIPLIER>           ,clock multiplier  this field indicates clock multiplier value of programmable clock generator. 0x0 means that host controller does not support programmable clock generator."

group d:0xD4280048++0x03
    line.long 0x00 "SD_MAX_CURRENT_1,Maximum Current Register 1"
        hexmask.long.byte 0x00 8.--15. 1. " MAX_CUR_30                 ,maximum current for 3.0v  0x0 = get information via another method  0x1 = 4 ma  0x2 = 8 ma  ...  0xf = 1020 ma"
        hexmask.long.byte 0x00 0.--7. 1. "        MAX_CUR_33             ,maximum current for 3.3v  0x0 = get information via another method  0x1 = 4 ma  0x2 = 8 ma  ...  0xf = 1020 ma"

group d:0xD428004A++0x03
    line.long 0x00 "SD_MAX_CURRENT_2,Maximum Current Register 2"
        hexmask.long.byte 0x00 0.--7. 1. " MAX_CUR_18                 ,maximum current for 1.8v  0x0 = get information via another method  0x1 = 4 ma  0x2 = 8 ma  ...  0xff = 1020 ma"

group d:0xD428004C++0x03
    line.long 0x00 "SD_MAX_CURRENT_3,Maximum Current Register 3"

group d:0xD428004E++0x03
    line.long 0x00 "SD_MAX_CURRENT_4,Maximum Current Register 4"

group d:0xD4280050++0x03
    line.long 0x00 "SD_FORCE_EVENT_AUTO_CMD12_ERROR,Force Event Auto cmd12 Error Register"
        bitfld.long 0x00 7. " F_ACMD12_ISSUE_ERR         ,force event for command not issued by auto cmd12 error  when 1 is written at this location, it sets the <command not issued due to auto_cmd12 error> field in the auto cmd12 error status register." "0,1"
        bitfld.long 0x00 4. "         F_ACMD_INDEX_ERR       ,force event for auto cmd index error  when 1 is written at this location, it sets the <auto cmd error> field in the auto cmd error status register." "0,1"
        bitfld.long 0x00 3. "     F__ACMD_EBIT_ERR        ,force event for auto cmd end bit error  when 1 is written at this location, it sets the <auto cmd end bit error> field in the auto cmd error status register." "0,1"
        bitfld.long 0x00 2. "       F_ACMD_CRC_ERR        ,force event for auto cmd crc error  when 1 is written at this location, it sets the <auto cmd crc error> field in the auto cmd error status register." "0,1"
        textline "                                           "
        bitfld.long 0x00 1. "F_ACMD_TO_ERR              ,force event for auto cmd timeout error  when 1 is written at this location, it sets the <auto cmd timeout error> field in the auto cmd error status register." "0,1"
        bitfld.long 0x00 0. "         F_ACMD12_NEXE_ERR      ,force event for auto cmd12 not executed error  when 1 is written at this location, it sets the <auto cmd12 not executed> field in the auto cmd12 error status register." "0,1"

group d:0xD4280052++0x03
    line.long 0x00 "SD_FORCE_EVENT_FOR_ERROR_STATUS,Force Event for Error Status Register"
        bitfld.long 0x00 15. " F_CRC_STATUS_ERR           ,force event for crc status error  when 1 is written at this location, it sets the <crc status error> field in the error interrupt status register." "0,1"
        bitfld.long 0x00 14. "         F_CPL_TIMEOUT_ERR      ,force event for cpl timeout error  when 1 is written at this location, it sets the <command completion signal timeout error> field in the error interrupt status register." "0,1"
        bitfld.long 0x00 13. "     F_AXI_RESP_ERR          ,force event for axi response bit error  when 1 is written at this location, it sets the <axi bus response error> field in the error interrupt status register." "0,1"
        bitfld.long 0x00 12. "       F_SPI_ERR             ,force event for spi error  when 1 is written at this location, it sets the <spi mode error> field in the error interrupt status register." "0,1"
        textline "                                           "
        bitfld.long 0x00 9. "F_ADMA_ERR                 ,force event for adma error  when 1 is written at this location, it sets the <adma error> field in the error interrupt status register." "0,1"
        bitfld.long 0x00 8. "         F_ACMD12_ERR           ,force event for auto cmd12 error  when 1 is written at this location, it sets the <auto cmd12 error> field in the error interrupt status register." "0,1"
        bitfld.long 0x00 7. "     F_CURRENT_ERR           ,force event for current limit error  when 1 is written at this location, it sets the <current limit error> field in the error interrupt status register." "0,1"
        bitfld.long 0x00 6. "       F_DAT_END_BIT_ERR     ,force event for data end bit error  when 1 is written at this location, it sets the <readdataend bit error> field in the error interrupt status register." "0,1"
        textline "                                           "
        bitfld.long 0x00 5. "F_DAT_CRC_ERR              ,force event for data crc error  when 1 is written at this location, it sets the <read data crc error> field in the error interrupt status register." "0,1"
        bitfld.long 0x00 4. "         F_DAT_TO_ERR           ,force event for data timeout error  when 1 is written at this location, it sets the <read data crc error> field in the error interrupt status register." "0,1"
        bitfld.long 0x00 3. "     F_CMD_INDEX_ERR         ,force event for command index error  when 1 is written at this location, it sets the <data timeout error> field in the error interrupt status register." "0,1"
        bitfld.long 0x00 2. "       F_CMD_END_BIT_ERR     ,force event for command end bit error  when 1 is written at this location, it sets the <command index error> field in the error interrupt status register." "0,1"
        textline "                                           "
        bitfld.long 0x00 1. "F_CMD_CRC_ERR              ,force event for command crc error  when 1 is written at this location, it sets the <command crc error> field in the error interrupt status register." "0,1"
        bitfld.long 0x00 0. "         F_CMD_TO_ERR           ,force event for command timeout error  when 1 is written at this location, it sets the <command timeout error> field in the error interrupt status register." "0,1"

group d:0xD4280054++0x03
    line.long 0x00 "SD_ADMA_ERROR_STATUS,ADMA Error Status Register"
        bitfld.long 0x00 2. " ADMA_LEN_ERR               ,adma length mismatch error  this error occurs in the following two cases:" "0,1"
        bitfld.long 0x00 0.--1. "         ADMA_STATE             ,adma error state  this field indicates the state of adma when error occurred during adma transfer. this field never indicates 0x2 because adma never stops in this state." "0,1,2,3"

group d:0xD4280058++0x03
    line.long 0x00 "SD_ADMA_SYS_ADDR_1,ADMA System Address Register 1"
        hexmask.long.word 0x00 0.--15. 1. " ADMA_SYS_ADDR568           ,adma system address  this register holds byte address of executing command of the descriptor table. at the start of adma, this register should be programmed to point to the start address of the descriptor table. this register is incremented whenever fetching a descriptor line. when an adma error interrupt is generated, this register will hold a valid descriptor address depending on the adma state."

group d:0xD428005A++0x03
    line.long 0x00 "SD_ADMA_SYS_ADDR_2,ADMA System Address Register 2"
        hexmask.long.word 0x00 0.--15. 1. " ADMA_SYS_ADDR575           ,adma system address  this register holds byte address of executing command of the descriptor table. at the start of adma, this register should be programmed to point to the start address of the descriptor table. this register is incremented whenever fetching a descriptor line. when an adma error interrupt is generated, this register will hold a valid descriptor address depending on the adma state."

group d:0xD428005C++0x03
    line.long 0x00 "SD_ADMA_SYS_ADDR_3,ADMA System Address Register 3"
        hexmask.long.word 0x00 0.--15. 1. " ADMA_SYS_ADDR581           ,adma system address  this register holds byte address of executing command of the descriptor table. at the start of adma, this register should be programmed to point to the start address of the descriptor table. this register is incremented whenever fetching a descriptor line. when an adma error interrupt is generated, this register will hold a valid descriptor address depending on the adam state."

group d:0xD428005E++0x03
    line.long 0x00 "SD_ADMA_SYS_ADDR_4,ADMA System Address Register 4"
        hexmask.long.word 0x00 0.--15. 1. " ADMA_SYS_ADDR588           ,adma system address  this register holds byte address of executing command of the descriptor table. at the start of adma, this register should be programmed to point to the start address of the descriptor table. this register is incremented whenever fetching a descriptor line. when an adma error interrupt is generated, this register will hold a valid descriptor address depending on the adma state."

group d:0xD4280060++0x03
    line.long 0x00 "PRESET_VALUE_FOR_INIT,Preset Value Register for Initialization"
        bitfld.long 0x00 14.--15. " DRV_STRENGTH_VAL595        ,driver strength select value  driver strength is supported by 1.8v signaling bus speed modes. this field is meaningless for 3.3v signaling.  0x0 = driver type b  0x1 = driver type a  0x2 = driver type c  0x3 = driver type d" "0,1,2,3"
        bitfld.long 0x00 10. "         CLKGEN_SEL_VAL597      ,clock generator select value.  this bit is effective when host controller supports programmable clock generator.  0x1 = programmable clock generator  0x0 = divided clock" "0,1"
        hexmask.long.word 0x00 0.--9. 1. "     SDCLK_FREQ_SEL_VAL598   ,sdclk frequency select value  10-bit preset value to set <sdclk_freq_sel> in the clock control register."

group d:0xD4280062++0x03
    line.long 0x00 "PRESET_VALUE_FOR_DS,Preset Value Register for Default Speed"
        bitfld.long 0x00 14.--15. " DRV_STRENGTH_VAL605        ,driver strength select value  driver strength is supported by 1.8v signaling bus speed modes. this field is meaningless for 3.3v signaling.  0x0 = driver type b  0x1 = driver type a  0x2 = driver type c  0x3 = driver type d" "0,1,2,3"
        bitfld.long 0x00 10. "         CLKGEN_SEL_VAL607      ,clock generator select value.  this bit is effective when host controller supports programmable clock generator.  0x1 = programmable clock generator  0x0 = divided clock" "0,1"
        hexmask.long.word 0x00 0.--9. 1. "     SDCLK_FREQ_SEL_VAL608   ,sdclk frequency select value.  10-bit preset value to set <sdclk_freq_sel> in the clock control register."

group d:0xD4280064++0x03
    line.long 0x00 "PRESET_VALUE_FOR_HS,Preset Value Register for High Speed"
        bitfld.long 0x00 14.--15. " DRV_STRENGTH_VAL615        ,driver strength select value  driver strength is supported by 1.8v signaling bus speed modes. this field is meaningless for 3.3v signaling.  0x0 = driver type b  0x1 = driver type a  0x2 = driver type c  0x3 = driver type d" "0,1,2,3"
        bitfld.long 0x00 10. "         CLKGEN_SEL_VAL617      ,clock generator select value  this bit is effective when host controller supports programmable clock generator.  0x1 = programmable clock generator  0x0 = divided clock" "0,1"
        hexmask.long.word 0x00 0.--9. 1. "     SDCLK_FREQ_SEL_VAL618   ,sdclk frequency select value.  10-bit preset value to set <sdclk_freq_sel> in the clock control register."

group d:0xD4280066++0x03
    line.long 0x00 "PRESET_VALUE_FOR_SDR12,Preset Value Register for SDR12"
        bitfld.long 0x00 14.--15. " DRV_STRENGTH_VAL625        ,driver strength select value  driver strength is supported by 1.8v signaling bus speed modes. this field is meaningless for 3.3v signaling.  0x0 = driver type b  0x1 = driver type a  0x2 = driver type c  0x3 = driver type d" "0,1,2,3"
        bitfld.long 0x00 10. "         CLKGEN_SEL_VAL627      ,clock generator select value  this bit is effective when host controller supports programmable clock generator.  0x1 = programmable clock generator  0x0 = divided clock" "0,1"
        hexmask.long.word 0x00 0.--9. 1. "     SDCLK_FREQ_SEL_VAL628   ,sdclk frequency select value  10-bit preset value to set <sdclk_freq_sel> in the clock control register."

group d:0xD4280068++0x03
    line.long 0x00 "PRESET_VALUE_FOR_SDR25,Preset Value Register for SDR25"
        bitfld.long 0x00 14.--15. " DRV_STRENGTH_VAL635        ,driver strength select value.  driver strength is supported by 1.8v signaling bus speed modes. this field is meaningless for 3.3v signaling.  0x0 = driver type b  0x1 = driver type a  0x2 = driver type c  0x3 = driver type d" "0,1,2,3"
        bitfld.long 0x00 10. "         CLKGEN_SEL_VAL637      ,clock generator select value  this bit is effective when host controller supports programmable clock generator.  0x1 = programmable clock generator  0x0 = divided clock" "0,1"
        hexmask.long.word 0x00 0.--9. 1. "     SDCLK_FREQ_SEL_VAL638   ,sdclk frequency select value  10-bit preset value to set <sdclk_freq_sel> in the clock control register."

group d:0xD428006A++0x03
    line.long 0x00 "PRESET_VALUE_FOR_SDR50,Preset Value Register for SDR50"
        bitfld.long 0x00 14.--15. " DRV_STRENGTH_VAL645        ,driver strength select value  driver strength is supported by 1.8v signaling bus speed modes. this field is meaningless for 3.3v signaling.  0x0 = driver type b  0x1 = driver type a  0x2 = driver type c  0x3 = driver type d" "0,1,2,3"
        bitfld.long 0x00 10. "         CLKGEN_SEL_VAL647      ,clock generator select value  this bit is effective when host controller supports programmable clock generator.  0x1 = programmable clock generator  0x0 = divided clock" "0,1"
        hexmask.long.word 0x00 0.--9. 1. "     SDCLK_FREQ_SEL_VAL648   ,sdclk frequency select value.  10-bit preset value to set <sdclk_freq_sel> in the clock control register."

group d:0xD428006C++0x03
    line.long 0x00 "PRESET_VALUE_FOR_SDR104,Preset Value Register for SDR104"
        bitfld.long 0x00 14.--15. " DRV_STRENGTH_VAL655        ,driver strength select value  driver strength is supported by 1.8v signaling bus speed modes. this field is meaningless for 3.3v signaling.  0x0 = driver type b  0x1 = driver type a  0x2 = driver type c  0x3 = driver type d" "0,1,2,3"
        bitfld.long 0x00 10. "         CLKGEN_SEL_VAL657      ,clock generator select value  this bit is effective when host controller supports programmable clock generator.  0x1 = programmable clock generator  0x0 = divided clock" "0,1"
        hexmask.long.word 0x00 0.--9. 1. "     SDCLK_FREQ_SEL_VAL658   ,sdclk frequency select value  10-bit preset value to set <sdclk_freq_sel> in the clock control register."

group d:0xD428006E++0x03
    line.long 0x00 "PRESET_VALUE_FOR_DDR50,Preset Value Register for DDR50"
        bitfld.long 0x00 14.--15. " DRV_STRENGTH_VAL665        ,driver strength select value  driver strength is supported by 1.8v signaling bus speed modes. this field is meaningless for 3.3v signaling.  0x0 = driver type b  0x1 = driver type a  0x2 = driver type c  0x3 = driver type d" "0,1,2,3"
        bitfld.long 0x00 10. "         CLKGEN_SEL_VAL667      ,clock generator select value  this bit is effective when host controller supports programmable clock generator.  0x1 = programmable clock generator  0x0 = divided clock" "0,1"
        hexmask.long.word 0x00 0.--9. 1. "     SDCLK_FREQ_SEL_VAL668   ,sdclk frequency select value.  10-bit preset value to set <sdclk_freq_sel> in the clock control register."

group d:0xD42800E0++0x03
    line.long 0x00 "SHARED_BUS_CTRL,Shared Bus Control Register"
        hexmask.long.byte 0x00 24.--30. 1. " BEND_PWR_CTRL              ,back-end power control  each bit of this field controls back-end power supply for an embedded device. host interface voltage is not controlled by this field. the number of devices supported is specified by <num_clk_pins> and a maximum of 7 devices can be controlled.  each bit corresponds to each device. bit[24] corresponds to device 1 and bit[30] corresponds to device 7.   the function of each bit is:   0x0 = back-end power is off  0x1 = back-end power is supplied"
        bitfld.long 0x00 20.--22. "        INT_PIN_SEL            ,interrupt pin select  interrupt pin inputs are enabled by this field. enable of unsupported interrupt pin is meaningless.  0x0 = interrupt is detected by interrupt cycle." "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 16.--18. "     CLK_PIN_SEL             ,clock pin select  one of the clock pin outputs is selected by this field.  0x0 = clock pins are disabled" "0,1,2,3,4,5,6,7"
        hexmask.long.byte 0x00 8.--14. 1. "       BUS_WIDTH_PRESET      ,bus width preset  this field defines the bus width preset for devices on a shared bus.  0x0 = bus width defined by <data_transfer_width>  0x1 = 8-bit mode"
        textline "                                           "
        bitfld.long 0x00 4.--5. "NUM_INT_PINS               ,number of interrupt input pins  this field defines the number of interrupt input pins supported on shared bus system.  0x0 = interrupt input pin is not supported" "0,1,2,3"
        bitfld.long 0x00 0.--2. "         NUM_CLK_PINS           ,number of clock pins  this field indicates support of clock pins to select one of the devices on shared bus.  0x0 = shared bus is not supported" "0,1,2,3,4,5,6,7"

group d:0xD42800FC++0x03
    line.long 0x00 "SD_SLOT_INT_STATUS,Slot Interrupt Status Register"
        bitfld.long 0x00 1. " SLOT_INT1                  ,interrupt line for slot 1" "0,1"
        bitfld.long 0x00 0. "         SLOT_INT0              ,interrupt line for slot 0" "0,1"

group d:0xD42800FE++0x03
    line.long 0x00 "SD_HOST_CTRL_VER,Host Control Version Register"
        hexmask.long.byte 0x00 0.--7. 1. " SD_VER                     ,sd host specification number  0x0 = supports version 1.0  0x1 = supports version 2.0  0x2 = supports version 3.0   all other values are reserved."

group d:0xD4280100++0x03
    line.long 0x00 "SDHC_VID_PID,SD HOST CTRL Vendor ID/Project ID/version ID Register"
        bitfld.long 0x00 28.--31. " VERSION_ID                 ,0x1 means first ip version in project 'aquila'" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        hexmask.long.byte 0x00 20.--27. 1. "        PROJECT_ID             ,0x1 means first project 'aquila' in vendor asr"
        hexmask.long.tbyte 0x00 0.--19. 1. "    VENDOR_ID               ,stands for vendor name 'asr', contains three fields, every field use one or two hexadecimal to show the english character's number in alphabet bit[19:16]: a  (a, 10th of the alphabet) bit[15:8]: 0x13 (s, 19th of the alphabet) bit[7:0]:0x12 (r, 18th of the alphabet)"

group d:0xD4280104++0x03
    line.long 0x00 "SDHC_OP_CTRL,SDHC Opeartion Control register (Clock and Burst Size Setup Register)"
        bitfld.long 0x00 15. " WR_OSTDG                   ,this field controls the outstanding write requests on axi.    0x0 = allow outstanding requests on axi.    0x1 = do not allow outstanding requests on axi." "0,1"
        bitfld.long 0x00 14. "         RD_OSTDG               ,this field controls the outstanding read requests on axi.    0x0 = allow outstanding requests on axi.    0x1 = do not allow outstanding requests on axi." "0,1"
        bitfld.long 0x00 7. "     WR_ENDIAN               ,write endian  data being written to the card is in the following format.  1 = little endian  0 = big endian" "0,1"
        bitfld.long 0x00 6. "       RD_ENDIAN             ,read endian  data being read from the card is in the following format.  1 = little endian  0 = big endian" "0,1"
        textline "                                           "
        bitfld.long 0x00 5. "AXI_NON_POST_WR            ,axi non-post write  1 = all axi master write requests are non-post write  0 = only the last request is issued as non-post write" "0,1"
        bitfld.long 0x00 4. "         PRIORITY               ,this is a static bit that is passed along as the most significant bit of the id when axi requests are made. this bit should be changed only before and after completion of a data command and not in between.  0x0 = low priority.  0x1 = high priority." "0,1"
        bitfld.long 0x00 2.--3. "     DMA_SIZE                ,fifo threshold  this field is used for the fifo threshold for the internal fsm to generate a dma request to the axi master.  0x0 = 64 bytes  0x1 = 128 bytes  0x2 = 192 bytes  0x3 = 256 bytes" "0,1,2,3"
        bitfld.long 0x00 0.--1. "       BRST_SIZE             ,dma burst size on the axi fabric  0x0 = 32 bytes burst  0x1 = 64 bytes burst  0x2 = 128 bytes    0x3 = 256 bytes" "0,1,2,3"

group d:0xD4280108++0x03
    line.long 0x00 "SDHC_OP_EXT_REG,SDHC Operation extend CTRL Register"
        bitfld.long 0x00 28.--30. " ARM_EMA                    ,arm artisan sram extra time for memory read and write 000 is fastest and 111 is the slowest" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 26.--27. "         ARM_EMAW               ,arm artisan sram delay for write operation by extendind the internal write pulse. 00 is fastest and 11is the slowest" "0,1,2,3"
        bitfld.long 0x00 25. "     ARM_EMAS                ,this field control extends the arm artisan sram pulse width of sense-amplifier enable signal. the default setting is low but when drive high, the pulse is extended." "0,1"
        bitfld.long 0x00 24. "       ARM_RET1N             ,retention mode 1 enable, active low." "0,1"
        textline "                                           "
        bitfld.long 0x00 16.--19. "PRE_GATE_CLK_CNT           ,this field controls the amount of clock cycles that are provided before clock gating is enabled on the sd_clk io pad." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 14. "        PDLVMC                 ,this field controls some power down function for the internal 64x64 memory." "0,1"
        bitfld.long 0x00 13. "     PDFVSSM                 ,this field controls some power down function for the internal 64x64 memory." "0,1"
        bitfld.long 0x00 12. "       FORCE_CLK_ON          ,force sd i/o pad clock on  setting this field to 0x1 overrides the sd clock i/o pad clock gate and forces the clock on. this field is meant to be used in conjunction with the <ovrrd_clk_oen> field. bit [11]     bit [12]     setting  0                 --                <force sd i/o pad clock on> setting is ignored (not used)  1                0                  clocks are forced off  1                1                  clocks are forced on" "0,1"
        textline "                                           "
        bitfld.long 0x00 11. "OVRRD_CLK_OEN              ,override pad clock output enable  setting this field to 0x1 overrides the sd pad clock output enable.   this field is meant to be used in conjunction with the <force_clk_on> field.  bit [11]     bit [12]     setting  0                 --                <force sd i/o pad clock on> setting is ignored (not used)  1                0                  clocks are forced off  1                1                  clocks are forced on" "0,1"
        bitfld.long 0x00 10. "         CLK_OE_USE_POS         ,  0 = use internal clock falling edge output(to eliminate clock signal tri-state issue)  1 = use internal clock rising edge output   this field controls the sd/emmc bus clk pad output enable signal use clock rising edge output or use clock falling edge output note: if sw set rx160<31> = 1 means host will run at legacy mode, just use external phy as gpio, bus clock signal wil directly output to phy io by using test mode interfaces,at this condition, recommanded sw to clear this bit." "0,1"
        bitfld.long 0x00 9. "     CLK_GATE_ON             ,clock gate on  0 = enable dynmical clock gate  1 = enable clock free running  this field affects all clock gates in the sd design if the <clock gate ctl> field is set to 1." "0,1"
        bitfld.long 0x00 8. "       CLK_GATE_CTL          ,clock gate ctl  0 = disable software clock gating override  1 = enable software clock gating override" "0,1"
        textline "                                           "
        bitfld.long 0x00 7. "USE_DAT3                   ,this field allows the card detect functionality to be detected using the dat[3] pin.    0x0 = use dedicated pin.    0x1 = use dat[3]." "0,1"
        bitfld.long 0x00 6. "         SD1S_PDWN751           ,power down  this bit controls the power down port on the internal 2 port 64x64 fifo." "0,1"
        bitfld.long 0x00 5. "     FIFO_CS                 ,fifo cs  this field should be written to 0x1 before any toggling of the pdwn bit." "0,1"
        bitfld.long 0x00 4. "       FIFO_CLK              ,fifo clock  this field should be set to 0x1 before any toggling of the pdwn bit." "0,1"
        textline "                                           "
        bitfld.long 0x00 2.--3. "SD1S_WTC754                ,wtc  this field is used for fifo speed setting." "0,1,2,3"
        bitfld.long 0x00 0.--1. "         SD1S_RTC755            ,rtc  this field is used for fifo speed setting." "0,1,2,3"

group d:0xD428010C++0x03
    line.long 0x00 "SDHC_LEGACY_CTRL_REG,SDHC LEGACY CTRL Parameters Register"
        hexmask.long.byte 0x00 24.--31. 1. " GEN_PAD_CLK_CNT            ,pad clock count  this field should be used in conjunction with <gen_pad_clk_on>  this field configures the number of clock cycles generated on the io pad. the default value of 0x4a will generate 75 clock cycles."
        bitfld.long 0x00 9.--13. "        SPI_ERR_TOKEN          ,spi error token  this is the spi error token received in command response when spi mode is enabled." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"
        bitfld.long 0x00 8. "    SPI_EN                  ,enable spi mode  this field indicates that spi mode has been enabled. this will cause the host controller to drive the signals on the interface in accordance with spi protocol.  1 = spi mode enabled  0 = spi mode disabled" "0,1"
        bitfld.long 0x00 6. "       GEN_PAD_CLK_ON        ,generate pad clock  this bit should be set in conjunction with the field <gen_pad_clk_cnt>. setting this bit to 0x1 will generate the programmed number of clock cycles on the io pad." "0,1"
        textline "                                           "
        bitfld.long 0x00 5. "SQU_FULL_CHK               ,squ full check  this bit should be set to 0x1 only if using certain piece of memory in squ in fifo mode and a 'read' transaction is going to be performed on the sd device." "0,1"
        bitfld.long 0x00 4. "         SQU_EMPTY_CHK          ,squ empty check  this bit should be set to 0x1 only if using certain piece of memory in squ in fifo mode and a 'write' transaction is going to be performed on the sd device." "0,1"
        bitfld.long 0x00 3. "     BOOT_ACK                ,boot ack  if the boot ack mode is enabled in the mmc device then this field should be written to 0x1 before issuing the alternate boot cmd0." "0,1"
        bitfld.long 0x00 2. "       INAND_SEL             ,when driver program rx0c highest byte, the host dat/cmd line related registers will be reset.  0x1 = enable soft reset when trigger command.  0x0 = disable soft reset when trigger command." "0,1"
        textline "                                           "
        bitfld.long 0x00 1. "ASYNC_IO_EN                ,asynchronous read interface enable  this bit enables the asynchronous latching of input data.  0x1 = async interface is enabled. the clock used to latch the input data and the internal logic clock are asynchronous.  0x0 = async interface is disabled." "0,1"
        bitfld.long 0x00 0. "         PIO_RDFC               ,pio mode read operation fifo check.  0x0 = check all fifo data whether has been read done by cpu, if not, bus clock will stop and state will stop at block read beginning, then wait last block fifo data all has been read by cpu done, if done, the next block data will start to transfer(although use this method, the clock stop still not in block gap)  0x1 = don't check pio mode fifo whether has been read done by cpu. recommended sw setting this bit to 1 before use pio mode. in bus very high speed mode just as hs200/sdr104, sw must set this bit." "0,1"

group d:0xD4280110++0x03
    line.long 0x00 "SDHC_LEGACY_CEATA_REG,SDHC LEGACY CTRL for CEATA Device Register"
        hexmask.long.word 0x00 16.--29. 1. " CPL_TIMEOUT                ,command completion signal timeout value"
        bitfld.long 0x00 2. "      CHK_CPL                ,check command completion signal  when this field is set to 0x1 and the <ce-ata card> field is set to 1, indication is sent to the host controller to check for command completion signal from the ce-ata card." "0,1"
        bitfld.long 0x00 1. "     SND_CPL                 ,send command completion disable signal  when this field is set to 1 and the <ce-ata card> field is set to 1, indication is sent to the host controller to send the command completion disable signal to the ce-ata card." "0,1"
        bitfld.long 0x00 0. "       CEATA_CARD            ,ce-ata card  1 = ce-ata card mode  0 = non ce-ata card mode" "0,1"

group d:0xD4280114++0x03
    line.long 0x00 "SDHC_MMC_CTRL_REG,SDHC MMC DEVICE CTRL Registers"
        hexmask.long.byte 0x00 24.--31. 1. " DAT_LEVEL793               ,mmc1_dat[7:0] line signal level  this status is used to check the mmc_dat[7:0] line level to recover from errors and for debugging. this is especially useful in detecting the busy signal level from mmc_dat[0]. lower 4bits were same as rx26<7:4>"
        bitfld.long 0x00 12. "        MMC_CARD               ,mmc card  1 = mmc card mode  0 = sd card mode" "0,1"
        bitfld.long 0x00 11. "     MMC_RESETN              ,mmc resetn   this bit controls the value of the pin mmc_resetn going to the emmc device." "0,1"
        bitfld.long 0x00 10. "       MMC_HS200             ,this bit is set when host read device_type[196] field of extended csd register in mmc card and card support hs200 mode, setting this before host clock changes to 200mhz, follow chapter6.6.4 on emmc4.5 spec.   1 = mmc hs200 mode enable.   0 = mmc hs200 mode disable, there has other backdoor registers to enable hs200 mode, please refer to rx3e registers." "0,1"
        textline "                                           "
        bitfld.long 0x00 9. "MMC_HS400                  ,this bit is set when host read device_type[196] field of extended csd register in mmc card and card support hs400 mode, setting this before host clock changes to 200mhz, follow emmc5.0 spec.   1 = mmc hs400 mode enable.   0 = mmc hs400 mode disable, there has other backdoor registers to enable hs200 mode, please refer to rx3e registers." "0,1"
        bitfld.long 0x00 8. "         ENHANCE_STROBE_EN      ,this bit control whether host/phy will use (delayed) strobe signal to sample the cmd response, this feature is for emmc5.1 spec enhance hs400 mode, sw should check the device related ext register to decide whether host/phy should support this feature." "0,1"
        bitfld.long 0x00 6. "     CPL_COMPLETE            ,cpl_complete  this bit is set to 1 when a command completion signal is detected and the <cpl_complete enable> field has been set to 1.  this field is cleared by writing 0x1.  a write of 0x0 has no effect." "0,1"
        bitfld.long 0x00 5. "       CPL_COMPLETE_EN       ,cpl_complete enable  1 = this bit when set to 0x1 will enable the cpl_complete bit to get set to 0x1 when a command completion signal is detected." "0,1"
        textline "                                           "
        bitfld.long 0x00 4. "CPL_COMPLETE_INT_EN        ,cpl_complete interrupt enable  1 = an interrupt will be generated whenever the <cpl_complete> field is set" "0,1"
        bitfld.long 0x00 2. "         MISC_INT               ,misc_int  this status bit is set to 1 when the programmed number of clocks in <gen_pad_clk_cnt> is completed and <misc_int_en> field has been set to 0x1.  this field is cleared by writing 0x1.  a write of 0x0 has no effect." "0,1"
        bitfld.long 0x00 1. "     MISC_INT_EN             ,misc_int status enable  1 = this bit when set to 0x1 will enable the misc_int bit to get set to 0x1 when the programmed number of clocks have been generated on the pad." "0,1"
        bitfld.long 0x00 0. "       MISC_INT_INT_EN       ,misc_int interrupt enable  0x1 = an interrupt will be generated whenever the <misc_int> field is set to 0x1." "0,1"

group d:0xD4280118++0x03
    line.long 0x00 "SDHC_RX_CFG_REG,SDHC RX Configuration Register"
        hexmask.long.word 0x00 18.--27. 1. " TUNING_DLY_INC             ,when hw auto-tuning is being performed the host controller takes over the control of the delay value being programmed in the delay element. this field defines a value by which the delay value is incremented for each step."
        hexmask.long.word 0x00 8.--17. 1. "      SDCLK_DELAY            ,this field controls the delay value to the delay element."
        bitfld.long 0x00 2.--3. "  SDCLK_SEL1              ,this field is used for rx data/cmd sample clock selections: this field controls the second mux selects.     0x0 = select clock from gpio pad feedback.     0x1 = select clock output from ddl, if for sw tuning, sw should set to 0x1    0x2, 0x3 = select internal clock." "0,1,2,3"
        bitfld.long 0x00 0.--1. "       SDCLK_SEL0            ,this field is used for sw tuning process. this field controls the first mux selects.    0x0 = select clock from pad.    0x1 = select inverted clock from pad.    0x2 = select internal clock.    0x3 = select inverted internal clock." "0,1,2,3"

group d:0xD428011C++0x03
    line.long 0x00 "SDHC_TX_CFG_REG,SDHC TX Configuration Register"
        bitfld.long 0x00 31. " TX_MUX_SEL                 ,tx output clock selection.    0x0 = select clock from inverter of base clock input    0x1 = select clock from ddll output clock" "0,1"
        bitfld.long 0x00 30. "         TX_INT_CLK_SEL         ,tx output clock selection.    0x0 = select clock from the original inverter of base clock or ddll output clock    0x1 = select clock from inverter of internal work clock, will gurantee the hold time at default speed mode or high speed mode." "0,1"
        bitfld.long 0x00 29. "     TX_DLINE_SRC_SEL        ,tx delayline clock source selection.    0x0 = select base clock as tx delayline input source clock     0x1 = select internal work clock as tx delayline input source clock, normally this bit only worked at hs200 mode, but if ddr mode need to do tx tuning, this tx delayline input clock source bit should be force to 0" "0,1"
        hexmask.long.word 0x00 16.--25. 1. "       TX_HOLD_DELAY1        ,this field controls the delay value to the tx delay element for sdr104 mode."
        textline "                                           "
        hexmask.long.word 0x00 0.--9. 1. "TX_HOLD_DELAY0             ,this field controls the delay value to the tx delay element for all modes other than the sdr104 mode."

group d:0xD4280120++0x03
    line.long 0x00 "SDHC_HWTUNE_CFG_REG,SDHC HW TUNING Configuration Register"
        hexmask.long.word 0x00 20.--29. 1. " TUNING_CLK_DLY             ,this ro field indicates the final ddll delay counter value after tuning complete set, during tuning process this field will increase step by step, so normally no meaning to read it during hw tuning process."
        hexmask.long.word 0x00 10.--19. 1. "      TUNING_WD_CNT          ,this field controls the tuning success window width. if tuning success times >= tuning_wd_cnt, tuning is successful, then  hw will choose middle of the window as the final tuning ddll delay counter value. default is 10 times as spec requirment, driver can adjust the total tuning count according to real condition."
        hexmask.long.word 0x00 0.--9. 1. "  TUNING_TT_CNT           ,this field controls the total tuning times, default is 40 times as spec requirment, driver can adjust the total tuning count according to real condition. total tuning count equals tuning_tt_cnt + 1"

group d:0xD4280124++0x03
    line.long 0x00 "SDHC_HWTUNE_CFG2_REG,SDHC HW TUNING Configuration2 Register"
        hexmask.long.word 0x00 16.--25. 1. " TUNING_HW_START_CNT        ,this field will let sw have the flexibility to config the hw auto-tuning start dll counter value."
        hexmask.long.word 0x00 6.--15. 1. "      TUNING_SUCCESS_CNT     ,this ro field indicates if hw auto-tuning failed, the cmd19 tuning success times. sw can read for references to decide whether adjust tuning step (tuning_dly_inc) or change the tuning window count (tuning_wd_cnt), this field only valid after tuning complete with fail. during tuning process, read this field is meaningless."
        bitfld.long 0x00 2.--3. "  TUNING_HW_SDCLK_SEL1    ,this field is used for hw auto tuning, the meaning is like rx118<3:2> sw tuning definition." "0,1,2,3"
        bitfld.long 0x00 0.--1. "       TUNING_HW_SDCLK_SEL0  ,this field will let sw have the flexibility to config the hw auto-tuning dll source clock selection." "0,1,2,3"

group d:0xD4280128++0x03
    line.long 0x00 "SDHC_ROUNDTRIP_TIMING_REG,SDHC ROUND TRIP(TRANSIMIT TO RECEIVE) TIMING PARAM Regsiter"
        bitfld.long 0x00 24.--27. " DATA0BUSY_WAIT_CYCLES      ,this field controls host check data0 busy signal after how many cycles of the end bit of crc status in write operation, normally only hs200/sdr104/hs400 should use this field." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 16.--19. "        WRDATA0_WAIT_CYCLES    ,this field only valid when this register bit[2] or bit[1] or bit[0] be set at corresponding speed mode, if bit[1] or bit[0] be set, this field indicate the host controller internal logic data fsm should wait how many cycles between the bus driving direction turn around from data0 end bit to start bit of crc stauts when performance bus write operation" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 8.--11. "    CMD2RESP_WAIT_CYCLES    ,this field only valid when this register bit[2] or bit[1] or bit[0] be set at corresponding speed mode, if bit[1] or bit[0] be set, this field indicate the host controller internal logic cmd fsm should wait how many clock cycles between the bus driving direction turn around from cmd end bit to  response start bit." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 2. "      TRS2RCV_PARAM_EN2     ,this field control whether at hs400 mode to enable sw to control the wait cycles should insert between cmd/data transmit to receive direction turn around period, in theory, hs400 mode need enable for phy output and input dll latency." "0,1"
        textline "                                           "
        bitfld.long 0x00 1. "TRS2RCV_PARAM_EN1          ,this field control whether at ddr50/sdr50 mode to enable sw to control the wait cycles should insert between cmd/data transmit to receive direction turn around period" "0,1"
        bitfld.long 0x00 0. "         TRS2RCV_PARAM_EN0      ,this field control whether at hs200/sdr104 mode to enable sw to control the wait cycles should insert between cmd/data transmit to receive direction turn around period" "0,1"

group d:0xD428012C++0x03
    line.long 0x00 "SDHC_GPIO_CFG_REG,SDHC GPIO CFG Register"
        hexmask.long.word 0x00 16.--31. 1. " SDHC_GPO                   ,value needed to be driven to gpo pins; sw program these 16bits field, and the value will showed on gpo output ports on sdhc top module."
        hexmask.long.word 0x00 0.--15. 1. "      SDHC_GPI               ,value on gpi input ports; these 16bit fields were read-only attribute."

group d:0xD4280130++0x03
    line.long 0x00 "SDHC_DLINE_CTRL_REG,SDHC DELAYLINE Control Register"
        hexmask.long.byte 0x00 24.--31. 1. " TX_DLINE_CODE              ,delayline dtc delay control signals, sw will program this field for tuning process, detailed delayline delay equation please check delayline documents."
        hexmask.long.byte 0x00 16.--23. 1. "        RX_DLINE_CODE          ,delayline dtc delay control signals, sw will program this field for tuning process, detailed delayline delay equation please check delayline documents."
        bitfld.long 0x00 0. "    DLINE_PU                ,power-up signal:   0 =power down   1 = power up the time period from power up signal be set to the internal regulator output voltage be stable is about 100ns." "0,1"

group d:0xD4280134++0x03
    line.long 0x00 "SDHC_DLINE_CFG_REG,SDHC DELAYLINE CFG Register"
        bitfld.long 0x00 24. " TX_DLINE_GAIN              ,tx delayline gain 2x set, this bit only worked at tx_dline_reg<6> be set 1 = extended delayline delay range and decreased resolution, normally for 100mhz frequency which still need use dll delayline. 0 = default(for 200mhz case)" "0,1"
        hexmask.long.byte 0x00 16.--23. 1. "         TX_DLINE_REG           ,tx delayline delay cfg register control signals, sw will program this field for tuning process, detailed delayline delay equation please check delayline documents."
        bitfld.long 0x00 8. "    RX_DLINE_GAIN           ,rx delayline gain 2x set, this bit only worked at rx_dline_reg<6> be set 1 = extended delayline delay range and decreased resolution, normally for 100mhz frequency which still need use dll delayline. 0 = default(for 200mhz case)" "0,1"
        hexmask.long.byte 0x00 0.--7. 1. "       RX_DLINE_REG          ,rx delayline delay cfg register control signals, sw will program this field for tuning process, detailed delayline delay equation please check delayline documents."

group d:0xD4280160++0x03
    line.long 0x00 "SDHC_PHY_CTRL_REG,SDHC PHY Control Register"
        bitfld.long 0x00 31. " HOST_LEGACY_MODE           ,this field is backdoor register for sw to use old legacy topology host mode. by default, due to emmc5 phy/host topology changes, clock generation logic will moved into phy inside, phy will output working clock to host. if sw set this bit, below factors will be true: 1 host will use internal clock divider to generate clock 2 affect sw/hw rx tuning, host will use rx118/rx130 setting for dll slave delayline control, otherwise will keep use new added rx168 setting for dll slave delayline control. 3 host will treat phy just as gpio, only use phy test mode interface signals tdi/tdo/tdoe to output/input data/cmd/clk. 4 if sw set host _legacy_mode, recommended don't support hs400 mode, base clock frequency should better set <=200mhz and only up to hs200 mode 5 tbd, whether add backdoor delayline in rx/tx tuning path for clock tuning not used phy internal delayline    0x0 = host legacy mode disable, default use new external emmc5.0/sd phy topology     0x1 = host legacy mode enable." "0,1"
        hexmask.long.byte 0x00 16.--23. 1. "         PHY_DCHNL_STATUS       ,current phy 8 data channel enable status. on reset, hw logic will enable 1 bit mode data channle by default."
        hexmask.long.byte 0x00 8.--15. 1. "    PHY_DCHNL_SW            ,sw programmed 8 data channels enable signals, every bit stands for 1 data channel, every bit value description is as below:   0x1 = this data channel is enable.   0x0 = this data channel is disable. note: cmd channel is always enable inside phy"
        bitfld.long 0x00 2. "      PHY_DCHNL_SEL         ,phy 8 data channle sw enable selection. if sw want to control phy data channel function enable, should firstly set this bit and then set corresponding bits at bit[15:8].   0x1 = phy data channel function enable will be controlled by sw programmed register bits at bit[15:8], if set this bit, sw should set bit[15:8] before use phy for data transfer.   0x0 = phy data channel function enable will be automatically controlled by host hardware logic, at this mode, sw can read bit[23:16] for current hw data channel control status, normally, for emmc protocol host hw will automatically set 8 data channel function enable at initialization phase;for sd protocol, hw will set 4 data channel function enable at initialization phase." "0,1"
        textline "                                           "
        bitfld.long 0x00 1. "PHY_PLL_LOCK               ,when sw follow phy program sequence, after sw enable  phy input source clock from apmu offset 0xe0, sw should also program this bit to 1, in order to let phy know the internal input 400mhz clock source is stable.   0x1 = phy 400mhz clock source input stable signal   0x0 = phy 400mhz clock source input instable" "0,1"
        bitfld.long 0x00 0. "         PHY_FUNC_EN            ,phy function enable signal, phy will use this enable signal for internal circuit reset, if host core logic enter lower power mode, power gating(udr_latch) should keep phy_en = 0, for normal function, sw should set this bit before using phy and do other phy related setting before set this bit.   0x1 = phy function enable/phy power up   0x0 = phy function disable/phy enter lower power mode" "0,1"

group d:0xD4280164++0x03
    line.long 0x00 "SDHC_PHY_FUNC_REG,SDHC PHY Function Configuration Register"
        bitfld.long 0x00 18. " RX_USE_STROBE              ,from host, in fact is hs400 ddr mode rx_use_strobe = (uhs_mode[2:0] == 110b) | hs400_mode | enhance_strobe_en;" "0,1"
        bitfld.long 0x00 17. "         RX_USE_DLYLINE         ,from host, in fact was hs200 or sdr104, host will also have a backdoor register(bit3) for setting this bit also in sdr50/ddr50(52) modes" "0,1"
        bitfld.long 0x00 16. "     TX_USE_INVERT           ,this field be set when one of below two conditions meet: 1 rx3e<2:0> be set to all sdr mode. 2 rx118<30> = 0 be set, but rx118<30> set to 1 only affect phy test mode output put paths(tdo/tdoe) signals, all function output data/cmd and output enable signals will be controlled by phy logic." "0,1"
        bitfld.long 0x00 15. "       HS200_USE_RFIFO       ,this bit control whether sw enable rfifo when running at hs200 mode:   0x0= disable rfifo in hs200(default hs200 mode use delayline output clock sample data and directly sampled again by host internal core clock)   0x1 = enable rfifo in hs200(if enable rfifo, delayline output clock sampled data will go to async fifo, then pop of fifo and go to host)" "0,1"
        textline "                                           "
        bitfld.long 0x00 14. "RX_DIS_CKSTOP              ,due to phy addition, input data latency will be increased, host add this back door register to disable stopping clock behavior at middle of the data block when occurred fifo overflow conditions, only permitted stop clock at block gap. this field is actually a backdoor register for only sdr25/hs50/ddr50 or lower mode, since for hs200/hs400 higher mode spec claimed could not stop bus clock at middle of the data block." "0,1"
        bitfld.long 0x00 13. "         PHY_TDI_SEL            ,this field control phy test mode input signal tdi source selection:   0x0= tdi will sampled by phy internal clock signal clock, normally this signal is same as host working clock (cclk_in) from phy.   0x1 = tdi directly from phy internal io pad di port." "0,1"
        bitfld.long 0x00 12. "     TX_CKOUT_REVERSE        ,this field is backdoor register to control whether host controller reverse the output data phase:   0x0 = keep original design clock odd/even output phase, odd phase always 0, even phase = card_clk_en   0x1 = reverse odd phase data to even output port, reverse even phase data to odd output port" "0,1"
        bitfld.long 0x00 11. "       TX_DDR_REVERSE        ,this field is backdoor register to control whether host controller reverse the output data phase:   0x0 = keep original design data odd/even output phase   0x1 = reverse odd phase data to even output port, reverse even phase data to odd output port" "0,1"
        textline "                                           "
        bitfld.long 0x00 10. "RX_DDR_BKEN                ,back door register to control ddr mode rx direction whenever ddr50 mode, just force phy to use delayline output clock's both edge sample bus data in phy, and then output dqin_o[7:0] and dqin_e[7:0] to host, delayline's input clock is cki.   0x1 = back door mode is enable.   0x0 = back door mode is disable." "0,1"
        bitfld.long 0x00 9. "         RFIFO_BYPASS           ,if set, host will bypass phy interface read fifo on hs400 mode, otherwise host will use the ck_rx_cmd directly sampled cmd in certain mode, normally need use rfifo in hs400 mode, since internal clock was async with phy output data/cmd rx clock. please be noticed that this bit only worked at hs400 mode, for tuning mode use free running clock case, data/cmd async read path can choose data async fifo put in host rx interface(use async_io_en, rx10c<1>)" "0,1"
        bitfld.long 0x00 8. "     CMD_USE_EVEN            ,this bit indicate when on enhanced hs400 mode whether cmd use 3/4t ds sampled signal as controller input, default use 1/4t ds sampled signal." "0,1"
        bitfld.long 0x00 7. "       PHY_TEST_EN           ,phy test mode enable signal, control pad output and output enable signals' source: if phy_test_en=1, test mode enable (phy bypass mode) - pad output is controlled directly by tdo (output data) and tdoe (output enable) from host normal function. this field has different meaning with rx160<31> host_legacy_mode, host_legacy_mode had strong effects, but this field only affect data/cmd/clk input/output paths. if sw set this bit, only item3 of rx160<31>=1 was taken effect, that means: <p>0x1= host will treat phy just as gpio, only use phy test mode interface signals tdi/tdo/tdoe to output/input data/cmd/clk. <p>0x0 = host will use emmc normal function data/cmd/clk paths. note: recommended sw to set this bit in bootrom for safety purpose. apmu also have backdoor register which can config phy enter bypass mode, but apmu regsiter be set will let tdo/tdoe from other mfpi function not emmc controller.and if sw want to use this mode, it assumed phy internal clock generation logic was ok and this bit be set not suit for ddr mode backup method, otherwise please use rx160<31> for using whole pure backup method(just only use phy's io pad)" "0,1"
        textline "                                           "
        bitfld.long 0x00 4.--6. "PHY_MODE_STATUS            ,these 3bits reflect current phy working mode selection in host design, if phy_mode_swen = 1, this field value equal phy_mode_sw[2:0]; if phy_mode_swen = 0, this field value equal hw internal logic controlled signal phy_mode_hw[2:0]." "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 1.--3. "         PHY_MODE_SW            ,these 3bits only worked when sw set phy_mode_swen=1, sw can program these 3 bits to force host controller use 'phy_mode_sw' field and ignore host internal hw generated mode selection signal 'phy_mode_hw':   0x000 = mmc default speed mode(<=26mhz), sd ds/sdr12/sdr25(<=50mhz).   0x001 = mmc hs mode(<=50mhz,sdr protocol), sd mode sdr50 (<=100mhz)   0x010 = ddr50(or ddr52)   0x011 = hs200(or sdr104)   0x100 = hs400   0x101 = hs400 cmd enhanced mode   all other values are reserved" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 0. "     PHY_MODE_SWEN           ,this bit give sw ability to control phy working mode selection, if set this bit, sw should synchronized set bit" "0,1"

group d:0xD4280168++0x03
    line.long 0x00 "SDHC_PHY_DLLCFG_REG,SDHC PHY DLL Configuration Register"
        bitfld.long 0x00 31. " DLL_ENABLE                 ,enable dll.    0 = dll function disable(power down)    1 = dll function enable(power up)" "0,1"
        bitfld.long 0x00 30. "         DLL_DELAY_SRC          ,phy internal dedicated delayline input clock source selection. 0: delayline input clock default selected pclk(bus clock feedback) as source 1: give phy another option for change the delayline input clock source to phy internal cki(cclk_in), this option normally only worked at hs200 mode for host manually tuning method." "0,1"
        bitfld.long 0x00 29. "     DLL_REFRESH_SW          ,   1 = sw ask to manually update dll_refresh signal    0 = sw just keep manually update signal dll_refresh as invalid." "0,1"
        bitfld.long 0x00 28. "       DLL_REFRESH_SWEN      ,   1 = sw control dll_refresh manually update signal enable    0 = host hw control dll_refresh manually update signal" "0,1"
        textline "                                           "
        bitfld.long 0x00 27. "DLL_REFRESH_ENABLE         ,   1 = our host controller would generate dll_refresh signal manually adjust the delay of strobe signal;    0 = dll_rerresh signal will be always 0" "0,1"
        hexmask.long.byte 0x00 16.--23. 1. "         DLL_STEP_CTRL          ,when hw auto-tuning is being performed the host controller takes over the control of the delay value being programmed in the delay element. this field defines a value by which the delay value is incremented for each step.  note: due to new emmc5.x topology, dll slave delayline will be put into phy inside, so if use new phy topology, recommanded sw promgrammed this field, if worked at host_legacy_mode (rx160<31>=1), sw can just use old rx114 register to control hw/sw tuning process."
        hexmask.long.byte 0x00 8.--15. 1. "    DLL_DELAY_CTRL          ,phy dll slave delayline tuning delay value control for hs400 mode if phy does not use internal dll master conunter value to update dll slave.this field only be worked at with dll_reg1<1>(rx168<1>) = 1. note: due to new emmc5.x topology, dll slave delayline will be put into phy inside, so if use old topology which worked at host_legacy_mode (rx160<31>=1) or for hs200/ddr50 tuninng, need use rx114/rx130/rx134 registers to control hw/sw tuning process."
        bitfld.long 0x00 6.--7. "      DLL_VREG_CTRL         ,dll regulator output voltage control" "0,1,2,3"
        textline "                                           "
        bitfld.long 0x00 4.--5. "DLL_FULLDLY_RANGE          ,dll delayline full delay range" "0,1,2,3"
        bitfld.long 0x00 2.--3. "         DLL_PREDLY_NUM         ,dll delayline pre-delay numbers" "0,1,2,3"
        bitfld.long 0x00 1. "     DLL_BYPASS_ENABLE       ,dll master bypass enable for hs400   1 = dll master is bypassed, and dll_delay_ctrl directly controls the slave dll.   0 = dll on. use delay value from master dll." "0,1"
        bitfld.long 0x00 0. "       DLL_REFRESH_METHOD    ,dll master code refresh method:   1 = always refreshed by ck_refresh synchronized to filter clock.   0 = before locked: refreshed by ck_refresh. after locked: refreshed by host generated dll_refresh rising edge." "0,1"

group d:0xD428016C++0x03
    line.long 0x00 "SDHC_PHY_DLLCFG1_REG,SDHC PHY DLL Configuration1 Register"
        hexmask.long.byte 0x00 8.--15. 1. " DLL_REG3_CTRL              ,dll delay code offset"
        hexmask.long.byte 0x00 0.--7. 1. "        DLL_REG2_CTRL          ,dll loop parameter register. <7>: dll force lock <6>: sel_vote_tf (to be verified) <5>: bypass decimate filter <4>: reserved <3:2>: dll loop filter gain in locking process. <1:0>: dll loop filter gain in locked process default: 8’h0c"

group d:0xD4280170++0x03
    line.long 0x00 "SDHC_PHY_DLLSTS_REG,SDHC PHY DLL Status & reserved configuration Register"
        hexmask.long.byte 0x00 8.--15. 1. " PHY_WORK_MODE              ,this field indicates current phy working mode flag, from phy output signal rdo_reg2<7:0>: <7>:sdr26 <6>: sdr52 <5>: ddr52 <4>: hs200 <3>: hs400 <2>: hs400_extd <1>: start_dll <0>: dll_error"
        bitfld.long 0x00 1. "        DLL_REFRESH_STATE      ,this bit indicates dll manully refresh mode refresh signal state, this bit only valid when dll_refresh_en be set.    0: no refresh    1: manully refresh state, is from dll_refresh_hw(host hw control logic)" "0,1"
        bitfld.long 0x00 0. "     DLL_LOCK_STATE          ,this bit indicates whether master dll is at lock state or not.    0: unlock state    1: lock state" "0,1"

group d:0xD4280174++0x03
    line.long 0x00 "SDHC_PHY_DLLSTS1_REG,SDHC PHY DLL Status1 Register"
        hexmask.long.word 0x00 16.--24. 1. " DLL_MASTER_DELAY           ,the newest delay value for the delay line in master dll.     unit: 1 delay unit;    note: this field always reflects the up-to-date value no matter whether dll is locked or not"
        hexmask.long.byte 0x00 0.--7. 1. "      DLL_SLAVE_DELAY        ,this field relects the delay value currently used for strobe signal or used for sw/hw tuning process final delay value."

group d:0xD4280178++0x03
    line.long 0x00 "SDHC_PHY_PADCFG_REG,SDHC PHY Pad Configration Register"
        bitfld.long 0x00 20.--21. " CLK_PU                     ,clk pullup 2 bits resistor selection:   00 = high-z   01 = 50k ohms   10 = 40k ohms   11 =33k ohms" "0,1,2,3"
        bitfld.long 0x00 18.--19. "         DS_PU                  ,ds pullup 2 bits resistor selection:   00 = high-z   01 = 50k ohms   10 = 40k ohms   11 =33k ohms" "0,1,2,3"
        bitfld.long 0x00 16.--17. "     CMD_PU                  ,cmd pullup 2 bits resistor selection:   00 = high-z   01 = 50k ohms   10 = 40k ohms   11 =33k ohms" "0,1,2,3"
        bitfld.long 0x00 12.--13. "       CLK_PD                ,clk pulldown 2 bits resistor selection:   00 = high-z   01 = 50k ohms   10 = 40k ohms   11 =33k ohms" "0,1,2,3"
        textline "                                           "
        bitfld.long 0x00 10.--11. "DS_PD                      ,ds pulldown 2 bits resistor selection:   00 = high-z   01 = 50k ohms   10 = 40k ohms   11 =33k ohms" "0,1,2,3"
        bitfld.long 0x00 8.--9. "         CMD_PD                 ,cmd pulldown 2 bits resistor selection:   00 = high-z   01 = 50k ohms   10 = 40k ohms   11 =33k ohms" "0,1,2,3"
        bitfld.long 0x00 3.--4. "     SLEW_RATE               ,pad slew rate control:    00 = low    01 = medium    10 = high    11 = very high" "0,1,2,3"
        bitfld.long 0x00 0.--2. "       DRIVE_SEL             ,for drive nominal impedance selection:    000 = high-z    001 = 200    010 = 100    011 = 66    100 = 50    101 = 40    110 = 33    111 = 33" "0,1,2,3,4,5,6,7"

group d:0xD428017C++0x03
    line.long 0x00 "SDHC_PHY_PADCFG1_REG,SDHC PHY Pad Configration1 Register"
        hexmask.long.word 0x00 16.--31. 1. " DQX_PU                     ,dq pullup  resistor value selection, every two bits stands for one io selection: x stand for 7~0   00 = high-z   01 = 50k ohms   10 = 40k ohms   11 =33k ohms"
        hexmask.long.word 0x00 0.--15. 1. "      DQX_PD                 ,dq pulldown resistor value selection, every two bits stands for one io selection: x stand for 7~0   00 = high-z   01 = 50k ohms   10 = 40k ohms   11 =33k ohms"

group d:0xD4280180++0x03
    line.long 0x00 "SDHC_PHY_LBCTRL_REG,SDHC PHY LoopBack Control Register"
        bitfld.long 0x00 31. " CLEAR_LB_ERR_STATUS        ,write 1 to clear sdhc_phy_lbsts_reg register" "0,1"
        bitfld.long 0x00 2. "         START_STUCK0_DET_CLK   ,after operation is finished, check emmc_lb_err_status register." "0,1"
        bitfld.long 0x00 1. "     START_STUCK1_DET_CLK    ,after operation is finished, check emmc_lb_err_status register." "0,1"
        bitfld.long 0x00 0. "       LB_TEST_TRIGGER       ,carry on loopback testing immediately. before seting this bit, host driver should program sdhc_phy_lbcnt_reg register (offset: 0x188).  when sdhc_phy_lbcnt_reg register reaches 0, loopback testing will stop and this bit will be cleared automatically.    only take effect when loopback mode enable is set." "0,1"

group d:0xD4280184++0x03
    line.long 0x00 "SDHC_PHY_LBFUNC_REG,SDHC PHY LoopBack Function Configuration Register"
        bitfld.long 0x00 24.--27. " LB_DS_CNT                  ,this field stands for total latency from tx to rx through phy loopback path, sw should program this field to sync with phy's characters, recommended sw set this field to 5 in hs400 or hs200 with rfifo mode, other modes set to 4. note this field should be > 1." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 20.--23. "        LB_FILTER_CNT          ,don't compare the first lb_filter_cnt data bits and the last lb_filter_cnt data bits when performing loopback testing" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 16. "    LB_CMD_MASK             ,if set, the corresponding path will not perform lookback test." "0,1"
        hexmask.long.byte 0x00 8.--15. 1. "       LB_DQ_MASK            ,if set, the corresponding path will not perform lookback test."
        textline "                                           "
        bitfld.long 0x00 3. "LB_INVERT_CLK              ,normally, when loopback test is triggered and data pattern starts to be driven, ckout_e will become 1 and ckout_o stays at 0. if this bit is set, ckout_e will become 1 and ckout_o stays at 0. only valid when bit[28] is set." "0,1"
        bitfld.long 0x00 2. "         CLK_PASSTH_DS          ,loopback mode need host send clock control signal wr_ck_o/wr_ck_e/wr_ck_oe to phy    0: no need output clock control signals to phy, for hs400 mode use ds test, since ds in loopback comes from phy internal free running clock cki, so no need clock control signals.    1: for other working modes in loopback enable, should set this bit. wr_ck_oe in loopback mode will be 1t earlier than wr_ck_o/wr_ck_e" "0,1"
        bitfld.long 0x00 1. "     LB_PATTERN_SEL          ,   0: use programmable 32-bit pattern;    1: prbs7" "0,1"
        bitfld.long 0x00 0. "       LB_MODE_EN            ,enter loopback mode. normally, host driver shall only change this bit when no other operation is ongoing." "0,1"

group d:0xD4280188++0x03
    line.long 0x00 "SDHC_PHY_LBCNT_REG,SDHC PHY LoopBack Comparison Count Register"
        hexmask.long 0x00 0.--31. 1. " LB_COMP_CNT                ,this field records how many bits to be compared for current loopback testing. after loopback testing starts, host controller decrements this register until it reaches 0. please be noticed that after sw write this field, host will dynamically control this counter value, during loopback test process, this counter may changed cycle by cycle."

group d:0xD428018C++0x03
    line.long 0x00 "SDHC_PHY_LBSTS_REG,SDHC PHY LoopBack Error Status Register"
        bitfld.long 0x00 21. " LB_CLK_STUCK0_ERR          ,clk path is stuck at 0" "0,1"
        bitfld.long 0x00 20. "         LB_CLK_STUCK1_ERR      ,clk path is stuck at 1" "0,1"
        bitfld.long 0x00 17. "     LB_CMD_EVEN_ERR         ,if set, the cmd line path doesn't pass loopback testing" "0,1"
        bitfld.long 0x00 16. "       LB_CMD_ODD_ERR        ,if set, the cmd line path doesn't pass loopback testing" "0,1"
        textline "                                           "
        hexmask.long.byte 0x00 8.--15. 1. "LB_DQ_EVEN_ERR             ,if set, the corresponding data path doesn't pass loopback testing"
        hexmask.long.byte 0x00 0.--7. 1. "        LB_DQ_ODD_ERR          ,if set, the corresponding data path doesn't pass loopback testing"

group d:0xD4280190++0x03
    line.long 0x00 "SDHC_PHY_LBDATA_REG,SDHC PHY LoopBack DATA Pattern Configuration Register"
        bitfld.long 0x00 31. " LB_PATTERN_RST             ,reset data pattern fifo;" "0,1"
        bitfld.long 0x00 30. "         LB_PATTERN_WRITE       ,push a new data pattern into fifo;" "0,1"
        bitfld.long 0x00 16.--17. "     LB_CMD_PATTERN          ,  bit[17:16]:even/odd for cmd line;" "0,1,2,3"
        hexmask.long.word 0x00 0.--15. 1. "       LB_DATA_PATTERN       ,  bit [7:0]: odd data pattern for data line   bit[15:8]: even data pattern for data line"

group d:0xD4280194++0x03
    line.long 0x00 "SDHC_PHY_LBDATA_REG,SDHC PHY LoopBack DATA Pattern Configuration Register"
        bitfld.long 0x00 31. " CQE_FSM_RST                ,a back door register which can let sw force cqe state machine goes to a stable idle state if hw meets some problems. write 1 means force cqe fsm into idle state. write 0 has no meaning." "0,1"
        bitfld.long 0x00 0.--3. "         CQE_DEBUG_SEL          ,these 4bits field indicate which internal 32bits debug bus signals will show on 0x1f4 register:   [0000]: slot index & fsm informations   [0001]: slot index informations   [0010]: internal task slot fetch signals   [0011]: internal task ready signals this field is for hw designer debug purpose." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"

group d:0xD42801F4++0x03
    line.long 0x00 "CQE_CQBDCTRL_REG,SDHC Command Queue Debug Information Content Registers"
        hexmask.long 0x00 0.--31. 1. " CQE_DEBUG_INFO             ,32bits debug signals information output to sw. please be noticed that these register value may changed cycle by cycle due to cqe hw internal design logic may still running during sw read this value. and see 0x1f0<3:0> to check which 32bits debug bus information will be selected output to this field."

tree.end

tree "sfo"

width 19.

group d:0xD401EC00++0x03
    line.long 0x00 "SFO_FUSE_OVR_REG0,Fuse Override Register 0"
        hexmask.long.word 0x00 0.--15. 1. " APP_FUSE_OVR0 ,app fuse override value 0  override app_top_config[15:0]"

group d:0xD401EC04++0x03
    line.long 0x00 "SFO_FUSE_OVR_REG1,Fuse Override Register 1"
        hexmask.long.word 0x00 0.--15. 1. " APP_FUSE_OVR1 ,app fuse override value 1  override app_top_config[31:16]"

group d:0xD401EC08++0x03
    line.long 0x00 "SFO_FUSE_OVR_REG2,Fuse Override Register 2"
        hexmask.long.word 0x00 0.--15. 1. " APP_FUSE_OVR2 ,app fuse override value 2  override app_top_config[47:32]"

group d:0xD401EC0C++0x03
    line.long 0x00 "SFO_FUSE_OVR_REG3,Fuse Override Register 3"
        hexmask.long.word 0x00 0.--15. 1. " APP_FUSE_OVR3 ,app fuse override value 3  override app_top_config[63:48]"

group d:0xD401EC10++0x03
    line.long 0x00 "SFO_FUSE_OVR_REG4,Fuse Override Register 4"
        bitfld.long 0x00 15. " AIB_FUSE_OVR  ,aib fuse override  1 = override fuse (and strap) configuration bits on next system reset" "0,1"
        hexmask.long.word 0x00 0.--14. 1. "     APP_FUSE_OVR4 ,app fuse override value 4  override app_top_config[78:64]"

group d:0xD401EC14++0x03
    line.long 0x00 "SFO_FUSE_OVR_REG5,Fuse Override Register 5"
        hexmask.long.word 0x00 0.--15. 1. " TOP_FUSE_OVR  ,top fuse override value  override top_config[15:0]"

tree.end

tree "sleeptimer"

width 6.

group d:0xFFA60000++0x03
    line.long 0x00 "SCTR,Sleep Timer Slow Clock count_to Register"
        hexmask.long.tbyte 0x00 0.--20. 1. " SL_SLOW_COUNT_TO  ,total number of slow clock cycles to sleep  this value must be at least 3."

group d:0xFFA60004++0x03
    line.long 0x00 "FCTR,Sleep Timer Fast Clock count_to Register"
        hexmask.long.tbyte 0x00 0.--20. 1. " SL_FAST_COUNT_TO  ,total number of fast clock cycles to sleep  this value must be equivalent to at least 3 slow clock cycles."

group d:0xFFA60008++0x03
    line.long 0x00 "VSTR,VCXO Stable Time Register"
        hexmask.long.byte 0x00 0.--7. 1. " SL_VCXO_ST_TIME38 ,vcxo stable time  this field is the vctcxo stablization time (given in slow clock cycles). this value should be at least 1 and not more than 255 (decimal)."

group d:0xFFA6000C++0x03
    line.long 0x00 "PSTR,PLL Stable Time Register"
        hexmask.long.byte 0x00 0.--7. 1. " SL_VCXO_ST_TIME46 ,pll stable time  this field is the pll stablization time (given in slow clock cycles). this value should be at least 2 and not more than 254 (decimal)."

group d:0xFFA60010++0x03
    line.long 0x00 "ESLR,Endless Sleep Mode Register "
        bitfld.long 0x00 0. " ENDLESS_SLEEP     ,endless sleep mode  this field indicates the sleep mode type.  0 = scheduled  1 = endless" "0,1"

group d:0xFFA60014++0x03
    line.long 0x00 "VSCR,VCTCXO Sleep Control Register"
        bitfld.long 0x00 1. " DROWSY_EN         ,drowsy entry enable  0 = possible to enter drowsy during sleep  1 = cannot enter drowsy during sleep" "0,1"
        bitfld.long 0x00 0. "       RTU_SLP_EN ,rtu enable during sleep  0 = rtu is disabled during sleep  1 = rtu is not disabled during sleep" "0,1"

group d:0xFFA60018++0x03
    line.long 0x00 "SLCR,Slow Counter Value Register"
        hexmask.long.tbyte 0x00 0.--20. 1. " SL_SLOW_COUNTER   ,slow counter value at wake  when not in endless sleep mode, this field is read only."

tree.end

tree "slowclock"

width 16.

group d:0xD0260000++0x03
    line.long 0x00 "STAT_CTRL,Status Control Register"
        bitfld.long 0x00 4. " D2_STAT        ,d2 state status  when this bit is high, d2 state is activated." "0,1"
        bitfld.long 0x00 3. "         EARLY_WAKEUP  ,early wakeup  the slow clock examines this bit during sleep. when software writes to this bit, the slow clock outputs a wakeup event to the c, even if the sleep period is not over. recurrent writes to this register require a gap of 2 slow clock cycles." "0,1"
        bitfld.long 0x00 2. "  ABSOLUTE_RELATIVE_SELECT ,absolute/relative select  this bit chooses which value was initialized for the d2 period.  1 = absolute value how many slow clock cycles to stay in d2   0 = relative value at which slow counter cycle to wake the system." "0,1"
        bitfld.long 0x00 1. "  D2_EN ,d2 state enable  1 = enable the tcu to start d2 entry sequence  0 = slow clock cannot enter d2 state" "0,1"
        textline "                          "
        bitfld.long 0x00 0. "SCK_SW_RST     ,slow-clock software reset  1 by software explicit write = slow-clock unit is placed in reset state. in this state, the bit returns a value of 0 upon software read.  0 by software explicit write = slow-clock unit is out of reset. in this state, the bit returns a value of 1 upon software read.  at startup, this bit is set to a value of 1, placing the slow-clock unit in active - out of reset state. in this case, the bit returns value of 1 upon software read." "0,1"

group d:0xD0260004++0x03
    line.long 0x00 "WAKEUP_REL,Wakeup Event Relative Register"
        hexmask.long 0x00 0.--31. 1. " WAKEUP_REL     ,wakeup event relative  slow count value upon which a wakeup event is output to the c"

group d:0xD0260008++0x03
    line.long 0x00 "WAKEUP_ABS,Wakeup Event Absolute Register"
        hexmask.long 0x00 0.--31. 1. " WAKEUP_ABS     ,wakeup event absolute  number of slow clock cycles after which a wakeup event is output to the c"

group d:0xD026000C++0x03
    line.long 0x00 "TCU_WAKEUP_REL,Timing Control Unit Wakeup Event Relative Register"
        hexmask.long 0x00 0.--31. 1. " TCU_WAKEUP_REL ,timing control unit wakeup event  slow count value upon which the clock enable signal is asserted to the tcu. recurrent writes to this register require a gap of two slow clock cycles."

group d:0xD0260010++0x03
    line.long 0x00 "TCU_WAKEUP_ABS,Timing Control Unit Wakeup Event Absolute Register"
        hexmask.long 0x00 0.--31. 1. " TCU_WAKEUP_ABS ,timing control unit wakeup  number of slow clock cycles after which the clock enable signal is asserted to the tcu.  when this value is written for scheduled wakeup, it is counted from the last snapshot command slow count register value. when it is written for unscheduled wakeup, it is counted from the last <scnt_int>.  recurrent writes to this register require a gap of 2 slow clock cycles."

group d:0xD0260014++0x03
    line.long 0x00 "SCNT,Slow Clock Count Register"
        hexmask.long 0x00 0.--31. 1. " SCNT           ,slow clock count  test register to allow the slow clock count to be read."

group d:0xD0260018++0x03
    line.long 0x00 "SSNAP,Snapshot Command Slow Count Register"
        hexmask.long 0x00 0.--31. 1. " SSNAP          ,snapshot command slow count  slow count value associated with the most recently executed snapshot command."

group d:0xD026001C++0x03
    line.long 0x00 "FSNAP,Snapshot Command Offset Register"
        hexmask.long 0x00 0.--31. 1. " FSNAP          ,snapshot command offset to next slow clock edge  defined in terms of the high-speed clock edge count  the msb of this register indicates an overflow, which means there was a problem with the 32-khz clock, and no rising edge was found."

group d:0xD0260020++0x03
    line.long 0x00 "SCNT_INT,Slow Clock Interrupt Register"
        hexmask.long 0x00 0.--31. 1. " SCNT_INT       ,slow clock interrupt  slow count value upon which an interrupt has occurred during the sleep period."

group d:0xD0260024++0x03
    line.long 0x00 "SCNT_LOAD,Slow Clock Load Register"
        hexmask.long 0x00 0.--31. 1. " SCNT_LOAD      ,slow clock load  test register to allow the slow counter to be loaded with test data. when loading the slow clock count register with a new value, write to this register on a positive edge of the 32-khz clock. recurrent writes to this register require a gap of two slow clock cycles."

group d:0xD0260028++0x03
    line.long 0x00 "D2_LEFT,D2 Time Remaining Register"
        hexmask.long 0x00 0.--31. 1. " D2_LEFT        ,d2 time remaining  this register allows software to know how much time is left until the scheduled wakeup, and is only relevant when an early wakeup occurs. its calculation is based on the <scnt_int> field value in the slow clock interrupt register."

group d:0xD026002C++0x03
    line.long 0x00 "M_GSM_MVT_CTL,M_GSM_MVT_CTL Register"
        bitfld.long 0x00 2. " SLOWC_SELECT98 ,select  this field selects the output signal from the slow clock.  0 = through sticky bit  1 = module output - not through the sticky bit" "0,1"
        bitfld.long 0x00 1. "         SLOWC_RESET99 ,sticky bit reset  0 = not reset  1 = reset" "0,1"
        bitfld.long 0x00 0. "  SLOWC_100                ," "0,1"

tree.end

tree "smc"

width 17.

group d:0xD4283820++0x03
    line.long 0x00 "SMC_MSCx,Static Memory Control Registers"
        bitfld.long 0x00 30.--31. " WE_GEN      ,we_genx is a programmable number of external clock cycles that varies for each interface setup and memory type. consult the <var product number> datasheet for specific usage based on memory type." "0,1,2,3"
        bitfld.long 0x00 25.--27. "         WE_D_HO      ,we_d_hox is a programmable number of external clock cycles that indicates data hold cycles after df_wen latching the data. consult the <var product number> datasheet for detailed usage." "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 22.--24. "   WE_D_SU          ,we_d_sux is a programmable number of external clock cycles that indicates df_wen data setup before df_wen latches the data. consult the <var product number> datasheet for specific usage." "0,1,2,3,4,5,6,7"
        hexmask.long.byte 0x00 16.--21. 1. "   WE_LEN       ,we_lenx is a programmable number of external clock cycles that indicates the length of the df_wen latch. consult the <var product number> datasheet for detailed usage."
        textline "                           "
        bitfld.long 0x00 14.--15. "OE_GEN      ,oe_genx is a programmable number of external clock cycles that varies for each memory type and interface. consult the <var product number> datasheet for specific usage based on memory type." "0,1,2,3"
        bitfld.long 0x00 12.--13. "         OE_HO        ,oe_hox is a programmable number of external clock cycles that indicates df_oen signal hold. consult the <var product number> datasheet for detailed usage." "0,1,2,3"
        bitfld.long 0x00 9.--11. "   OE_SU            ,oe_sux is a programmable number of external clock cycles that indicates df_oen signal setup. consult the <var product number> datasheet for detailed usage." "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 6.--8. "   OE_D_HO      ,oed_hox is a programmable number of external clock cycles that indicates data hold during read. consult the <var product number> datasheet for detailed usage." "0,1,2,3,4,5,6,7"
        textline "                           "
        hexmask.long.byte 0x00 0.--5. 1. "OE_D_SU     ,oel_d_sux is a programmable number of external clock cycles that indicates data hold during read. consult the <var product number> datasheet for detailed usage."

group d:0xD4283830++0x03
    line.long 0x00 "SMC_SXCNFGx,Synchronous Static Memory Control Registers"
        hexmask.long.byte 0x00 8.--13. 1. " SXWA        ,frequency code for csxn  access time for synchronous write only  the number of external sclk cycles between latching of the address and latching of the data.  0x0 to 0x2 = reserved  0x3 = 3 clocks   0x4 = 4 clocks   0x5 = 5 clocks   0x6 = 6 clocks  0x7 = 7 clocks  0x8 = 8 clocks  0x9 = 9 clocks  0xa = 10 clocks   0xb to 0xf = reserved"
        hexmask.long.byte 0x00 0.--5. 1. "        SXRA         ,frequency code for csxn  access time for synchronous reads only  the number of external sclk cycles between latching of the address and latching of the data.  0x0 to 0x2 = reserved  0x3 = 3 clocks (frequency code configuration = 2)  0x4 = 4 clocks (frequency code configuration = 3)  0x5 = 5 clocks (frequency code configuration = 4)  0x6 = 6 clocks (frequency code configuration = 5)  0x7 = 7 clocks (frequency code configuration = 6)  0x8 = 8 clocks (frequency code configuration = 7)  0x9 = 9 clocks (frequency code configuration = 8)  0xa = 10 clocks (frequency code configuration = 9)  0xb to 0xf = reserved"

group d:0xD4283868++0x03
    line.long 0x00 "SMC_MEMCLKCFG,Clock Configuration Control Register"
        bitfld.long 0x00 0.--1. " CKEN        ,clock output enable enables the output clock df_sclk output  0 = df_sclk output is not enabled  1 = df_sclk output is enabled" "0,1,2,3"

group d:0xD4283890++0x03
    line.long 0x00 "SMC_CSDFICFGx,DFI Configuration Control Register for Chip Selects"
        bitfld.long 0x00 30.--31. " ALTS        ,address latch timing setup  used to set the setup timing for an address to be valid on the data bus for the luan/df_advn and llan signals, timings are identical for both signals.  0x0 = no setup is provided. the address is sent out at the same time as the luan/df_advn signal is asserted.  0x1 = one df_sclk cycles of setup is provided (such that the address is maintained for one df_sclk before the assertion of the luan/df_advn signal).  0x2 = two df_sclk cycles of setup are provided  0x3 = reserved" "0,1,2,3"
        bitfld.long 0x00 28.--29. "         ALTH         ,address latch timing hold  used to set the timing for an address to be valid on the data bus for the luan/df_advn and llan signals, timings are identical for both signals.  0x0 = no hold is provided. the address is removed at the same time as the lxan/df_advn signal is de-asserted.  0x1 = one df_sclk of hold is provided (such that the address is maintained for one df_sclk beyond the de-assertion of the lxan/df_advn signal).  0x2 = two df_sclk cycles of hold are provided.  0x3 = reserved  for asynchronous nor flash, hold time is in general required on the address so 0x1 or 0x2 are normally required.  for synchronous reads and writes, an extra cycle(s) of hold will not affect the latency to the read or write. the latency is the address valid signal latched to valid data on the bus." "0,1,2,3"
        bitfld.long 0x00 24.--26. "   ALW              ,address latch width  used to set the width of the luan/df_advn and llan signals on the dfi, timings are identical for both signals.  the encoding here is the number of cycles of external df_sclks that the luan/df_advn signal is asserted.  0x0 = no latch signals will be generated for address cycle, regardless of the values for <address latch timing setup> and <address latch timing hold>, address will be sent on the address lines as the cs is issued, as an example, this could be used in the lower address selection for a small size memory that does not need the higher address values, or in non muxed mode of operation with an sram.  0x1 = one df_sclk cycle width of luan/df_advn and llan  0x2 = two df_sclk cycles width of luan/df_advn and llan  0x3 = three df_sclk cycles width of luan/df_advn and llan  0x4 = four df_sclk cycles width of luan/df_advn and llan  0x5 = five df_sclk cycles width of luan/df_advn and llan  0x6 = six df_sclk cycles width of luan/df_advn and llan  0x7 = seven df_sclk cycles width of luan/df_advn and llan" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 23. "   RDY_SPEC4    ,rdy_spec[4] - active polarity  0 = active low  1 = active high" "0,1"
        textline "                           "
        bitfld.long 0x00 22. "RDY_SPEC3   ,rdy_spec[3] - cycle assertion (consider frequency and delay when set)  0 = set same cycle  1 = set previous cycle" "0,1"
        bitfld.long 0x00 20. "         RDY_SPEC2_1  ,rdy_spec[2:1] - usage  0x0 = rdy not used  0x1 = rdy used for read only  0x2 = rdy used for write only  0x3 = rdy used for read and write" "0,1"
        bitfld.long 0x00 19. "   RDY_SPEC0        ,rdy_spec[0] - signal synchronization  0 = rdy signal is synchronized to local logic  1 = rdy asynchronous, internal synchronizer used (2-stage)" "0,1"
        bitfld.long 0x00 16.--17. "   ADDRBASE     ,address base  for relevant chip select, the least significant address to be sent out as part of the low-order address. setting this field to 0x1 is the guideline to follow:  0x0 = byte address bit [0]  0x1 = byte address bit [1] (thus half word address)  0x2 to 0x3 = reserved" "0,1,2,3"
        textline "                           "
        bitfld.long 0x00 12.--14. "WRSYNC      ,control use of synchronized interface during the write cycle  0x0 = asynchronous write   0x1 = synchronous write   0x2 = asynchronous write cycle df_wen toggles each beat of burst   0x3 to 0x7 = reserved" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 8.--10. "         RDSYNC       ,control use of synchronized interface during the read cycle  0x0 = asynchronous read cycle df_oen does not toggle within burst  0x1 = synchronous read cycle df_oen does toggle   0x2 = asynchronous read cycle df_oen toggles each beat of burst (vlio)  0x3 to 0x7 = reserved" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 4.--6. "   LOWADD           ,low address setup  controls low order special operations on the address bus.  0x0 = low order addressing operation not enabled, non-muxed mode  0x1 = 4-bit low-order addressing in operation for both a/d and aa/d  0x2 = 6-bit low-order addressing in operation for both a/d and aa/d  0x3 = 8-bit low-order addressing in operation for both a/d and aa/d  0x4 = 10-bit low-order addressing in operation for both a/d and aa/d  0x5 = 12-bit low-order addressing in operation for a/d only   0x5 = 11-bit low-order addressing in operation for aa/d only  0x6 to 0x7 = reserved  refer to supported memory types section for more information." "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 3. "   RBW          ,memory bus width  0 = 8 bits  1 = 16 bits" "0,1"
        textline "                           "
        bitfld.long 0x00 0.--2. "ADDMODE     ,addressing type cs[3:0]n are used only on the dfi.  0x0 = a/d address data muxing mode  0x1 = aa/d address data muxing mode (default)  0x2 = non-muxed address data interface  0x3 to 0x7 = reserved" "0,1,2,3,4,5,6,7"

group d:0xD42838B0++0x03
    line.long 0x00 "SMC_CLK_RET_DEL,Synchronous NOR Flash Clock Return Delay Register"
        bitfld.long 0x00 25. " FLOP_SEL    ,flop select  1 = use flop_clk (delayed dfi_clock) clocked df_io[15:0] input, llan, df_advn, rdy  0 = use delayed df_io[15:0] input, llan, df_advn, rdy" "0,1"
        bitfld.long 0x00 20.--23. "         RDY_DLY_VAL  ,rdy delay value  this field is used for the number of (delay element) rdy delay to controller." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 16.--19. "  DIN_DLY_VAL      ,din delay value  this field is used for the number of (delay element) din delay to controller." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 12.--15. "  LLA_DLY_VAL  ,lla delay value  this field is used for the number of (delay element) lla delay to device." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        textline "                           "
        bitfld.long 0x00 8.--11. "ADV_DLY_VAL ,adv delay value  this field is used for the number of (delay element) adv delay to device." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 4.--7. "        SCLK_DLY_VAL ,dfi_clk out delay value  this field is used for the number of (delay element) dfi_clk out delay to device." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 0.--3. "  FLOP_CLK_DLY_VAL ,dfi_clk delay value  this field is used for the number of (delay element) dfi_clk delay when used as flop clock." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 3.--5. "  SCLK_DELAY_1 ,df_sclk delay 1  this is the second delay on the df_sclk signal for returning the df_sclk to flop the control and data." "0,1,2,3,4,5,6,7"

group d:0xD42838B4++0x03
    line.long 0x00 "SMC_ADV_RET_DEL,Synchronous NOR Flash ADVn Return Delay Register"
        bitfld.long 0x00 6.--7. " ADVN_SEL    ,determines which delayed advn to send back to the smc.  0x0 = use advn with no delay  0x1 = use advn out of one delay element  0x2 = use advn out of two delay elements  0x3 = reserved" "0,1,2,3"
        bitfld.long 0x00 3.--5. "         ADVN_DEL_1   ,this is the second delay on the df_nadv_r signal returning from the pads." "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 0.--2. "   ADVN_DEL_0       ,each delay element used has a 3-bit input to select the amount of delay the output will see. two of these delay elements are used in series. this is to delay the returned flopped control signal back to the smc. this is the first delay on the df_nadv_r signal returning from the pads." "0,1,2,3,4,5,6,7"

group d:0xD42838C0++0x03
    line.long 0x00 "SMC_CSADRMAPx,Address Mapping Control Registers"
        bitfld.long 0x00 28. " MEMUSED     ,used to indicate a memory device is occupying the space as defined by the <start address bits> and <memory size> space  0 = no memory is present at space specified by <start address bits> and <memory size>  1 = memory is present at space specified by <start address bits> and <memory size>" "0,1"
        hexmask.long.byte 0x00 16.--21. 1. "         STADD        ,start address bits  this field is used to set the start address of the csxn. default values are:  cs[0]n stadd0 = 0x00 = default for cs[0]n start address is 0x8000_0000  cs[1]n stadd1 = 0x10 = default for cs[1]n start address is 0x9000_0000  cs[2]n stadd2 = 0x20 = default for cs[2]n start address is 0xa000_0000  cs[3]n stadd3 = 0x30 = default for cs[3]n start address is 0xb000_0000"
        bitfld.long 0x00 8.--11. "  MEMSIZE          ,memory size  0x0 = 16 mb  0x1 = 32 mb  0x2 = 48 mb  0x3 = 64 mb  0x4 = 80 mb  0x5 = 96 mb  0x6 = 112 mb  0x7 = 128 mb  0x8 = 144 mb  0x9 = 160 mb  0xa = 176 mb  0xb = 192 mb  0xc = 208 mb  0xd = 224 mb  0xe = 240 mb  0xf = 256 mb (default value)" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 1. "  WR_START     ,write start address within the axi bus width  0 = start address aligned to received value (aligned to memory data width)  1 = start address aligned to axi width" "0,1"
        textline "                           "
        bitfld.long 0x00 0. "RD_START    ,read start address within the axi bus width  0 = start address aligned to received value (aligned to memory data width)  1 = start address aligned to axi width" "0,1"

group d:0xD42838D0++0x03
    line.long 0x00 "SMC_TCVCFGREG,Transceiver Configuration Control Register 0"
        bitfld.long 0x00 3. " TCVCS3EN    ,transceiver enable for chip select 3  used to enable or disable the use of the transceiver on device set on chip select 3  0 = transceiver not enabled on cs[3]n  1 = transceiver enabled on cs[3]n" "0,1"
        bitfld.long 0x00 2. "         TCVCS2EN     ,transceiver enable for chip select 2  used to enable or disable the use of the transceiver on device set on chip select 2  0 = transceiver not enabled on cs[2]n  1 = transceiver enabled on cs[2]n" "0,1"
        bitfld.long 0x00 1. "   TCVCS1EN         ,transceiver enable for chip select 1  used to enable or disable the use of the transceiver on device set on chip select 1  0 = transceiver not enabled on cs[1]n  1 = transceiver enabled on cs[1]n" "0,1"
        bitfld.long 0x00 0. "   TCVCS0EN     ,transceiver enable for chip select 0  used to enable or disable the use of the transceiver on device set on chip select 0  0 = transceiver not enabled on cs[0]n  1 = transceiver enabled on cs[0]n" "0,1"

group d:0xD42838E0++0x03
    line.long 0x00 "SMC_WE_Apx,DF_WEn Address Phase Control Registers"
        hexmask.long.word 0x00 0.--11. 1. " WE_AP_VAL   ,we_ap_val[11] - value of df_wen during high address setup for write  we_ap_val[10] - value of df_wen during high address setup for read  we_ap_val[9] - value of df_wen during high address width for write  we_ap_val[8] - value of df_wen during high address width for read  we_ap_val[7] - value of df_wen during high address hold for write  we_ap_val[6] - value of df_wen during high address hold for read  we_ap_val[5] - value of df_wen during low address setup for write  we_ap_val[4] - value of df_wen during low address setup for read  we_ap_val[3] - value of df_wen during low address width for write  we_ap_val[2] - value of df_wen during low address width for read  we_ap_val[1] - value of df_wen during low address hold for write  we_ap_val[0] - value of df_wen during low address hold for read"

group d:0xD42838F0++0x03
    line.long 0x00 "SMC_OE_Apx,DF_OEn Address Phase Control Registers"
        hexmask.long.word 0x00 0.--11. 1. " OE_AP_VAL   ,oe_ap_val[11] - value of df_oen during high address setup for write  oe_ap_val[10] - value of df_oen during high address setup for read  oe_ap_val[9] - value of df_oen during high address width for write  oe_ap_val[8] - value of df_oen during high address width for read  oe_ap_val[7] - value of df_oen during high address hold for write  oe_ap_val[6] - value of df_oen during high address hold for read  oe_ap_val[5] - value of df_oen during low address setup for write  oe_ap_val[4] - value of df_oen during low address setup for read  oe_ap_val[3] - value of df_oen during low address width for write  oe_ap_val[2] - value of df_oen during low address width for read  oe_ap_val[1] - value of df_oen during low address hold for write  oe_ap_val[0] - value of df_oen during low address hold for read"

group d:0xD4283900++0x03
    line.long 0x00 "SMC_ADV_Apx,DF_ADVn Address Phase Control Registers"
        hexmask.long.word 0x00 0.--11. 1. " ADV_AP_VAL  ,adv_ap_val[11] - value of df_oen during high address setup for write  adv_ap_val[10] - value of df_oen during high address setup for read  adv_ap_val[9] - value of df_oen during high address width for write  adv_ap_val[8] - value of df_oen during high address width for read  adv_ap_val[7] - value of df_oen during high address hold for write  adv_ap_val[6] - value of df_oen during high address hold for read  adv_ap_val[5] - value of df_oen during low address setup for write  adv_ap_val[4] - value of df_oen during low address setup for read  adv_ap_val[3] - value of df_oen during low address width for write  adv_ap_val[2] - value of df_oen during low address width for read  adv_ap_val[1] - value of df_oen during low address hold for write  adv_ap_val[0] - value of df_oen during low address hold for read"

group d:0xD4283910++0x03
    line.long 0x00 "SMC_WE_DPx,DF_WEn Data Phase Value Control Registers"
        hexmask.long.tbyte 0x00 4.--27. 1. " WE_DP_VAL   ,we_dp_val[23] reserved  we_dp_val[22] reserved  we_dp_val[21] reserved  we_dp_val[20] reserved  we_dp_val[19] reserved  we_dp_val[18] value of df_wen in wr_sync_g state  we_dp_val[17] value of df_wen in wr_sync_wait state  we_dp_val[16] value of df_wen in wr_sync_wr_data state  we_dp_val[15] value of df_wen in wr_sync_access_time state  we_dp_val[14] value of df_wen in rd_sync_g state  we_dp_val[13] value of df_wen in rd_sync_wait state  we_dp_val[12] value of df_wen in rd_sync_rd_data state  we_dp_val[11] value of df_wen in rd_sync_access_time state  we_dp_val[10] value of df_wen in rd_sync_oe_s state  we_dp_val[9] value of df_wen in wr_asnc_g state  we_dp_val[8] value of df_wen in wr_asnc_d_h state  we_dp_val[7] value of df_wen in wr_asnc_we state  we_dp_val[6] value of df_wen in wr_asnc_d state  we_dp_val[5] value of df_wen in rd_asnc_g state  we_dp_val[4] value of df_wen in rd_asnc_oe_h state  we_dp_val[3] value of df_wen in rd_asnc_d_h state  we_dp_val[2] value of df_wen in rd_asnc_d_s state  we_dp_val[1] value of df_wen in rd_asnc_oe_s state  we_dp_val[0] value of df_wen for all other state states"
        bitfld.long 0x00 0. "    EN_WE_CON    ,0 = use we default values for data phase  1 = use we values defined in we_dp_val for data phase" "0,1"

group d:0xD4283920++0x03
    line.long 0x00 "SMC_OE_Apx,DF_OEn Data Phase Value Control Registers"
        hexmask.long.tbyte 0x00 4.--27. 1. " OE_DP_VAL   ,oe_dp_val[23] reserved   oe_dp_val[22] reserved  oe_dp_val[21] reserved   oe_dp_val[20] reserved   oe_dp_val[19] reserved   oe_dp_val[18] value of df_oen in wr_sync_g state  oe_dp_val[17] value of df_oen in wr_sync_wait state  oe_dp_val[16] value of df_oen in wr_sync_wr_data state  oe_dp_val[15] value of df_oen in wr_sync_access_time state  oe_dp_val[14] value of df_oen in rd_sync_g state  oe_dp_val[13] value of df_oen in rd_sync_wait state  oe_dp_val[12] value of df_oen in rd_sync_rd_data state  oe_dp_val[11] value of df_oen in rd_sync_access_time state  oe_dp_val[10] value of df_oen in rd_sync_oe_s state  oe_dp_val[9] value of df_oen in wr_asnc_g state  oe_dp_val[8] value of df_oen in wr_asnc_d_h state  oe_dp_val[7] value of df_oen in wr_asnc_we state  oe_dp_val[6] value of df_oen in wr_asnc_d state  oe_dp_val[5] value of df_oen in rd_asnc_g state  oe_dp_val[4] value of df_oen in rd_asnc_oe_h state  oe_dp_val[3] value of df_oen in rd_asnc_d_h state  oe_dp_val[2] value of df_oen in rd_asnc_d_s state  oe_dp_val[1] value of df_oen in rd_asnc_oe_s state  oe_dp_val[0] value of df_oen for all other state states"
        bitfld.long 0x00 0. "    EN_OE_CON    ,1b0 = use oe default values for data phase  1 = use oe values defined in oe_dp_val for data phase" "0,1"

group d:0xD4283930++0x03
    line.long 0x00 "SMC_TCVENx,Transceiver Enable Value Registers"
        hexmask.long 0x00 4.--29. 1. " TCVEN_VAL   ,we_dp_val[25] reserved   we_dp_val[24] value of xcvrenn in high address state setup  we_dp_val[23] value of xcvrenn in high address state width  we_dp_val[22] value of xcvrenn in high address state hold  we_dp_val[21] value of xcvrenn in low address state setup  we_dp_val[20] value of xcvrenn in low address state width  tcven_val[19] value of xcvrenn in low address state hold   tcven_val[18] value of xcvrenn in wr_sync_g state  tcven_val[17] value of xcvrenn in wr_sync_wait state  tcven_val[16] value of xcvrenn in wr_sync_wr_data state  tcven_val[15] value of xcvrenn in wr_sync_access_time state  tcven_val[14] value of xcvrenn in rd_sync_g state  tcven_val[13] value of xcvrenn in rd_sync_wait state  tcven_val[12] value of xcvrenn in rd_sync_rd_data state  tcven_val[11] value of xcvrenn in rd_sync_access_time state  tcven_val[10] value of xcvrenn in rd_sync_oe_s state  tcven_val[9] value of xcvrenn in wr_asnc_g state  tcven_val[8] value of xcvrenn in wr_asnc_d_h state  tcven_val[7] value of xcvrenn in wr_asnc_we state  tcven_val[6] value of xcvrenn in wr_asnc_d state  tcven_val[5] value of xcvrenn in rd_asnc_g state  tcven_val[4] value of xcvrenn in rd_asnc_oe_h state  tcven_val[3] value of xcvrenn in rd_asnc_d_h state  tcven_val[2] value of xcvrenn in rd_asnc_d_s state  tcven_val[1] value of xcvrenn in rd_asnc_oe_s state  tcven_val[0] value of xcvrenn for all other state states"
        bitfld.long 0x00 0. "  EN_TCVEN_CON ,1b0 = use oe default values for data phase  1 = use oe values defined in tcven_val for all states" "0,1"

group d:0xD4283840++0x03
    line.long 0x00 "SMC_TCVENx,Address Valid (ADV) Value Registers"
        hexmask.long 0x00 4.--29. 1. " ADV_VAL     ,we_dp_val[25] reserved   we_dp_val[24] value of df_advn in high address state setup  we_dp_val[23] value of df_advn in high address state width  we_dp_val[22] value of df_advn in high address state hold  we_dp_val[21] value of df_advn in low address state setup  we_dp_val[20] value of df_advn in low address state width  tcven_val[19] value of df_advn in low address state hold   tcven_val[18] value of df_advn in wr_sync_g state  tcven_val[17] value of df_advn in wr_sync_wait state  tcven_val[16] value of df_advn in wr_sync_wr_data state  tcven_val[15] value of df_advn in wr_sync_access_time state  tcven_val[14] value of df_advn in rd_sync_g state  tcven_val[13] value of df_advn in rd_sync_wait state  tcven_val[12] value of df_advn in rd_sync_rd_data state  tcven_val[11] value of df_advn in rd_sync_access_time state  tcven_val[10] value of df_advn in rd_sync_oe_s state  tcven_val[9] value of df_advn in wr_asnc_g state  tcven_val[8] value of df_advn in wr_asnc_d_h state  tcven_val[7] value of df_advn in wr_asnc_we state  tcven_val[6] value of df_advn in wr_asnc_d state  tcven_val[5] value of df_advn in rd_asnc_g state  tcven_val[4] value of df_advn in rd_asnc_oe_h state  tcven_val[3] value of df_advn in rd_asnc_d_h state  tcven_val[2] value of df_advn in rd_asnc_d_s state  tcven_val[1] value of df_advn in rd_asnc_oe_s state  tcven_val[0] value of df_advn for all other state states"
        bitfld.long 0x00 0. "  EN_ADV_CON   ,0 = use oe default values for data phase  1 = use oe values defined in adv_val for all states" "0,1"

tree.end

tree "squ"

width 26.

group d:0xD42A0000++0x03
    line.long 0x00 "SQU_CTRL_0,SQU Control 0 Register"
        bitfld.long 0x00 30.--31. " RTC_BK0                  ,rtc bk 0" "0,1,2,3"
        bitfld.long 0x00 28.--29. "         WTC_BK0                ,wtc bk 0" "0,1,2,3"
        bitfld.long 0x00 27. "     PDWN_BK0                ,power down bk 0" "0,1"
        bitfld.long 0x00 26. "   CLKEN_BK0               ,clock enable bk 0, doesn't used in cp920" "0,1"
        textline "                                    "
        bitfld.long 0x00 24. "CAMENABLE                ,camera enable" "0,1"
        bitfld.long 0x00 23. "         FIXPRIORITY            ,fix priority" "0,1"
        bitfld.long 0x00 16. "     CAMOVE                  ,bk0 enable come from sw_camenable when it set, else come from fuse." "0,1"
        bitfld.long 0x00 14.--15. "   RTC_BROM                ,rtc brom" "0,1,2,3"
        textline "                                    "
        bitfld.long 0x00 12.--13. "RTC_REF_BROM             ,rtc ref brom" "0,1,2,3"
        bitfld.long 0x00 11. "         PDWN_BROM              ,power down brom" "0,1"
        bitfld.long 0x00 2.--4. "     APB_CLK_DIV             ,apb_clk_div" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 0.--1. "   ROM_WAIT_CYCLE          ,rom wait cycle  0x0 = 3 wait cycles  0x1 = 2 wait cycles  0x2 = 1 wait cycle  0x3 = no wait cycle" "0,1,2,3"

group d:0xD42A0008++0x03
    line.long 0x00 "SQU_CTRL_1,SQU Control 1 Register"
        bitfld.long 0x00 30.--31. " RTC_BK2                  ,rtc bk 2" "0,1,2,3"
        bitfld.long 0x00 28.--29. "         WTC_BK2                ,wtc bk 2" "0,1,2,3"
        bitfld.long 0x00 27. "     PDWN_BK2                ,power down bk 2" "0,1"
        bitfld.long 0x00 26. "   CLKEN_BK2               ,clock enable bk 2, doesn't used in 920" "0,1"
        textline "                                    "
        bitfld.long 0x00 25. "FASTACCESS               ,fast access" "0,1"
        bitfld.long 0x00 24. "         CAMENABLE148           ,camera enable" "0,1"
        bitfld.long 0x00 23. "     FIXPRIORITY149          ,fix priority 1" "0,1"
        bitfld.long 0x00 16. "   EN_BK2                  ,en bk 2" "0,1"
        textline "                                    "
        bitfld.long 0x00 14.--15. "RTC_BK1                  ,rtc bk 1" "0,1,2,3"
        bitfld.long 0x00 12.--13. "         WTC_BK1                ,wtc bk 1" "0,1,2,3"
        bitfld.long 0x00 11. "     PDWN_BK1                ,power down bk 1" "0,1"
        bitfld.long 0x00 10. "   CLKEN_BK1               ,clock enable bk 1, doesn't used in 920" "0,1"
        textline "                                    "
        bitfld.long 0x00 9. "FASTACCESSBK1            ,sw configuration" "0,1"
        bitfld.long 0x00 8. "         CAMENABLE257           ,camera enable 2" "0,1"
        bitfld.long 0x00 7. "     FIXPRIORITY258          ,fix priority 2" "0,1"

group d:0xD42A0010++0x03
    line.long 0x00 "SQU_FMBIST_CTRL_0,SQU FMBIST Control 0 Register"
        bitfld.long 0x00 31. " SQU_FMBIST_SW_CAM_ACC_EN ,squ fmbist software cam access enable" "0,1"
        bitfld.long 0x00 28.--29. "         OTP_SQU_MUX_SEL        ,otp_squ_mux_sel  this field selects which fuse block to read." "0,1,2,3"
        bitfld.long 0x00 27. "     FUSEW_CLEAR             ,fusew clear" "0,1"
        bitfld.long 0x00 24.--26. "   CLK_DIV_VAL             ,clock divider value" "0,1,2,3,4,5,6,7"
        textline "                                    "
        bitfld.long 0x00 21. "READ_FUSE5               ,read fuse 5" "0,1"
        bitfld.long 0x00 20. "         READ_FUSE4             ,read fuse 4" "0,1"
        bitfld.long 0x00 19. "     READ_FUSE3              ,read fuse 3" "0,1"
        bitfld.long 0x00 18. "   READ_FUSE2              ,read fuse 2" "0,1"
        textline "                                    "
        bitfld.long 0x00 17. "READ_FUSE1               ,read fuse 1" "0,1"
        bitfld.long 0x00 16. "         READ_FUSE0             ,read fuse 0" "0,1"
        hexmask.long.byte 0x00 8.--13. 1. "     CAM_MBIST_EN_REG        ,cam mbist enable register"
        hexmask.long.byte 0x00 0.--5. 1. "  SW_CAM_BANK_REG         ,software cam bank register"

group d:0xD42A0018++0x03
    line.long 0x00 "SQU_FMBIST_CTRL_1,SQU FMBIST Control 1 Register"
        bitfld.long 0x00 31. " SQU_FMBIST_SW_CONTROL    ,squ fmbist software control" "0,1"
        bitfld.long 0x00 30. "         FUSEW_START            ,fusew start" "0,1"
        bitfld.long 0x00 29. "     ATE_SQU_MODE            ,ate squ mode" "0,1"
        bitfld.long 0x00 28. "   PIPE_MODE               ,pipe mode" "0,1"
        textline "                                    "
        bitfld.long 0x00 27. "ACK_HI_PWR               ,ack high power" "0,1"
        bitfld.long 0x00 26. "         ACK_LO_PWR             ,ack low power" "0,1"
        bitfld.long 0x00 22. "     SQU_FMBIST_REG__EN      ,squ fmbist register  enable" "0,1"
        bitfld.long 0x00 21. "   SQU_FMBIST_RETENTION    ,squ fmbist retention" "0,1"
        textline "                                    "
        bitfld.long 0x00 20. "SQU_FMBIST_14N           ,squ fmbist 14n" "0,1"
        bitfld.long 0x00 19. "         SQU_FMBIST_FORCE_ERROR ,squ fmbist force error" "0,1"
        bitfld.long 0x00 18. "     SQU_FMBIST_CLEAR_LOGGER ,squ fmbist clear logger" "0,1"
        bitfld.long 0x00 17. "   SQU_FMBIST_CLEAR        ,squ fmbist clear" "0,1"
        textline "                                    "
        bitfld.long 0x00 16. "SQU_FMBIST_START         ,squ fmbist start" "0,1"
        bitfld.long 0x00 12.--13. "         MEMTOP_M1_IN_BITS      ,memtop m1 in bits" "0,1,2,3"
        bitfld.long 0x00 8.--10. "     COL_SIZE_IN             ,col size in" "0,1,2,3,4,5,6,7"
        hexmask.long.byte 0x00 0.--5. 1. "   SQU_FMBIST_BLOCK_EN     ,squ fmbist block enable"

group d:0xD42A0020++0x03
    line.long 0x00 "SQU_FMBIST_STATUS_0,SQU FMBIST Status 0 Register"
        bitfld.long 0x00 28. " SQ_FUSE_READY115         ,fuse ready" "0,1"
        bitfld.long 0x00 27. "         SQU_FMBIST_REG_HI_PWR  ,squ fmbist register high power" "0,1"
        bitfld.long 0x00 26. "     SQU_FMBIST_REG_LO_PWR   ,squ fmbist register low power" "0,1"
        bitfld.long 0x00 25. "   FUSEW_DONE              ,fusew done" "0,1"
        textline "                                    "
        bitfld.long 0x00 24. "BURN_ERROR               ,burn error" "0,1"
        bitfld.long 0x00 19. "         CAM_MBIST_FAIL5        ,cam mbist fail[5]" "0,1"
        bitfld.long 0x00 18. "     CAM_MBIST_DONE5         ,cam mbist done[5]" "0,1"
        bitfld.long 0x00 17. "   CAM_MBIST_FAIL4         ,cam mbist fail[4]" "0,1"
        textline "                                    "
        bitfld.long 0x00 16. "CAM_MBIST_DONE4          ,cam mbist done[4]" "0,1"
        bitfld.long 0x00 15. "         CAM_MBIST_FAIL3        ,cam mbist fail[3]" "0,1"
        bitfld.long 0x00 14. "     CAM_MBIST_DONE3         ,cam mbist done[3]" "0,1"
        bitfld.long 0x00 13. "   CAM_MBIST_FAIL2         ,cam mbist fail[2]" "0,1"
        textline "                                    "
        bitfld.long 0x00 12. "CAM_MBIST_DONE2          ,cam mbist done[2]" "0,1"
        bitfld.long 0x00 11. "         CAM_MBIST_FAIL1        ,cam mbist fail[1]" "0,1"
        bitfld.long 0x00 10. "     CAM_MBIST_DONE1         ,cam mbist done[1]" "0,1"
        bitfld.long 0x00 9. "   CAM_MBIST_FAIL0         ,cam mbist fail[0]" "0,1"
        textline "                                    "
        bitfld.long 0x00 8. "CAM_MBIST_DONE0          ,cam mbist done[0]" "0,1"
        bitfld.long 0x00 4.--7. "         SQU_FMBIST_PTR         ,squ fmbist pointer" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 2. "    SQU_FMBIST_READY        ,swu fmbist ready" "0,1"
        bitfld.long 0x00 1. "   SQU_FMBIST_LOGGER_ERROR ,squ fmbist logger error" "0,1"
        textline "                                    "
        bitfld.long 0x00 0. "SQU_FMBIST_LOGGER_FATAL  ,squ fmbist logger fatal" "0,1"

group d:0xD42A0028++0x03
    line.long 0x00 "SQU_RSVD,Reserved Register"

group d:0xD42A0030++0x03
    line.long 0x00 "SQU_CTRL_2,SQU Control 2 Register"
        bitfld.long 0x00 30.--31. " RTC_BK4                  ,rtc bk 4" "0,1,2,3"
        bitfld.long 0x00 28.--29. "         WTC_BK4                ,wtc bk 4" "0,1,2,3"
        bitfld.long 0x00 27. "     PDWN_BK4                ,power down bk 4" "0,1"
        bitfld.long 0x00 26. "   CLKEN_BK4               ,clock enable bk 4, doesn't used in cp920" "0,1"
        textline "                                    "
        bitfld.long 0x00 25. "FASTACCESS1              ,fast access 1" "0,1"
        bitfld.long 0x00 24. "         CAMENABLE1160          ,camera enable 1" "0,1"
        bitfld.long 0x00 23. "     FIXPRIORITY1161         ,fix priority 1" "0,1"
        bitfld.long 0x00 16. "   EN_BK4                  ,en bk 4" "0,1"
        textline "                                    "
        bitfld.long 0x00 14.--15. "RTC_BK3                  ,rtc bk 4" "0,1,2,3"
        bitfld.long 0x00 12.--13. "         WTC_BK3                ,wtc bk 3" "0,1,2,3"
        bitfld.long 0x00 11. "     PDWN_BK3                ,power down bk 3" "0,1"
        bitfld.long 0x00 10. "   CLKEN_BK3               ,clock enable bk 3, doesn't used in cp920" "0,1"
        textline "                                    "
        bitfld.long 0x00 9. "FASTACCESS2              ,fast access 2" "0,1"
        bitfld.long 0x00 8. "         CAMENABLE2169          ,camera enable 2" "0,1"
        bitfld.long 0x00 7. "     FIXPRIORITY2170         ,fix priority 2" "0,1"
        bitfld.long 0x00 0. "   EN_BK3                  ,en bk 3" "0,1"

group d:0xD42A0038++0x03
    line.long 0x00 "SQU_FMBIST_CTRL_2,SQU fmbist wport contl2 Registerr"
        bitfld.long 0x00 24.--28. " PWRDONE                  ,power down for bank4-bank0, corresponding bits are 28-24" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"
        bitfld.long 0x00 8.--10. "        DEBUG_SEL_DATABYTE     ," "0,1,2,3,4,5,6,7"
        hexmask.long.byte 0x00 0.--7. 1. "     DEBUG_SELB              ,"

group d:0xD42A0040++0x03
    line.long 0x00 "PERF_COUNT_CNTRL,Performance Counter Control Register"
        bitfld.long 0x00 10. " S8_RD_BYTE_COUNT_EN      ,read byte count s8" "0,1"
        bitfld.long 0x00 9. "         S8_WR_BYTE_COUNT_EN    ,write byte count s8" "0,1"
        bitfld.long 0x00 8. "     CLR_COUNT_S8            ,clear counter s8" "0,1"
        bitfld.long 0x00 6. "   S4_RD_BYTE_COUNT_EN     ,read byte count s4" "0,1"
        textline "                                    "
        bitfld.long 0x00 5. "S4_WR_BYTE_COUNT_EN      ,write byte count s4" "0,1"
        bitfld.long 0x00 4. "         CLR_COUNT_S4           ,clear counter s4" "0,1"
        bitfld.long 0x00 2. "     S1_RD_BYTE_COUNT_EN     ,read byte count s1" "0,1"
        bitfld.long 0x00 1. "   S1_WR_BYTE_COUNT_EN     ,write byte count s1" "0,1"
        textline "                                    "
        bitfld.long 0x00 0. "CLR_COUNT_S1             ,clear counter s1" "0,1"

group d:0xD42A0048++0x03
    line.long 0x00 "PERF_COUNT_S1,Performance Count S1 Registers"
        hexmask.long 0x00 0.--31. 1. " COUNT_VALUE207           ,count value"

group d:0xD42A0050++0x03
    line.long 0x00 "PERF_COUNT_S4,Performance Count S4 Registers"
        hexmask.long 0x00 0.--31. 1. " COUNT_VALUE214           ,count value"

group d:0xD42A0058++0x03
    line.long 0x00 "PERF_COUNT_S8,Performance Count S8 Registers"
        hexmask.long 0x00 0.--31. 1. " COUNT_VALUE221           ,count value"

group d:0xD42A0060++0x03
    line.long 0x00 "FAB_TIMEOUT_CTRL,AXI Fabric Timeout Control Register"
        bitfld.long 0x00 31. " SQ_AUTORESP_TYPE230      ,timeout auto response type  0 = auto response type is slverr  1 = auto response type is okay" "0,1"
        bitfld.long 0x00 30. "         SQ_AUTORESP_EN231      ,timeout auto response enable  0 = disable auto response when fabric timeout happens  1 = enable auto response when fabric timeout happens" "0,1"
        bitfld.long 0x00 29. "     SQ_TIMEOUT_INT_MSK233   ,timeout interrupt mask  0 = interrupt is not masked  1 = interrupt is masked" "0,1"
        bitfld.long 0x00 28. "   SQ_FAB_MON_RST236       ,fabric monitor reset  0 = reset fabric monitor  1 = release fabric monitor" "0,1"
        textline "                                    "
        bitfld.long 0x00 27. "SQ_FAB_MON_CLR237        ,clear the information saved when last time timeout occurs  0 = the relevant registers are kept   1 = the relevant registers are cleared" "0,1"
        hexmask.long.word 0x00 0.--15. 1. "         SQ_TIMEOUT_VAL239      ,axi fabric timeout value  this field indicates the timeout value for axi fabric. the unit of measure is one axi clock cycle."

group d:0xD42A0068++0x03
    line.long 0x00 "STATE_HOLD_CTRL,State Hold Ctrl Register"
        bitfld.long 0x00 0. " SQ_STATE_HOLD_CTRL249    ,controlling bit of holding the registers' contents after functional reset.   0 = the registers will not update the status in real time and the values in the registers are not valid.    1 = the registers will be updated to the read state in time. once reset is asserted, the state_hold_ctrl[0] will be cleared and the registers will hold the values just before reset." "0,1"

group d:0xD42A0070++0x03
    line.long 0x00 "FAB_TIMEOUT_ID_RT,Real Time AXI Fabric Timeout Transaction ID Register"
        bitfld.long 0x00 31. " SQ_WR_TIMEOUT_IND257     ,write timeout indicator  0 = no write request timeout  1 = write request timeout happens" "0,1"
        hexmask.long.byte 0x00 16.--21. 1. "         SQ_TIMEOUT_TX_WID259   ,the wid of write transaction which causes first timeout event. it is only valid when bit[31], wr_timeout_ind is asserted"
        bitfld.long 0x00 15. "    SQ_RD_TIMEOUT_IND260    ,read timeout indicator  0 = no read request timeout  1 = read request timeout happens" "0,1"
        hexmask.long.byte 0x00 0.--5. 1. "   SQ_TIMEOUT_TX_RID262    ,the rid of read transaction which causes first timeout event. it is only valid when bit[15], rd_timeout_ind is asserted"

group d:0xD42A0078++0x03
    line.long 0x00 "FAB_TIMEOUT_STATUS0_RT,Real Time AXI Fabric Timeout Status0 Register"
        hexmask.long 0x00 2.--31. 1. " SQ_TIMEOUT_WADDR270      ,the write address being accessing which has caused the first write timeout event."
        bitfld.long 0x00 0. "  SQ_WR_TIMEOUT_IND272   ,write timeout indicator  0 = no write request timeout  1 = write request timeout happens" "0,1"

group d:0xD42A0080++0x03
    line.long 0x00 "FAB_TIMEOUT_STATUS1_RT,Real Time AXI Fabric Timeout Status1 Register"
        hexmask.long 0x00 2.--31. 1. " SQ_TIMEOUT_RADDR280      ,the read address being accessing which has caused the first write timeout event."
        bitfld.long 0x00 0. "  SQ_RD_TIMEOUT_IND282   ,read timeout indicator  0 = no read request timeout  1 = read request timeout happens" "0,1"

group d:0xD42A0088++0x03
    line.long 0x00 "DVC_STATUS_RT,Real Time DVC Status Register"
        bitfld.long 0x00 24.--27. " SQ_CAUSE291              ,dvc cause  this field is the cause of the current ongoing dvc. it is only valid when the <voltage change status> field is 1.   0x1 = <var processor: application mp> software-triggered dvc  0x2 = <var processor: comm> software- triggered dvc   0x4 = <var processor: msa> software- triggered dvc    0x8 = hw-dfc triggered dvc    others = lpm entry/exit trigger dvc" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 16.--19. "        SQ_TVL293              ,target voltage level of vcc_main" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 8.--11. "    SQ_CVL295               ,current voltage level of vcc_main" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 0. "  SQ_DVC_STATUS297        ,voltage change status  the voltage change may be triggered in active state or entering low power mode.  0 = there is no voltage change or a voltage change has finished  1 = voltage change is in progress" "0,1"

group d:0xD42A0090++0x03
    line.long 0x00 "DFC_STATUS_RT,Real Time DCLK Hardware FC Status Register"
        bitfld.long 0x00 15.--18. " SQ_DFC_CAUSE306          ,dclk dfc cause  this field is the cause of the current ongoing dfc. it is only valid when the <dclk_dfc_status> field is 1.  0x1 = <var processor: application mp> triggered dfc  0x2 = <var processor: comm> triggered dfc in active mode  0x4 = msa trigged dfc in active mode    0x8 = gnss triggered dfc in active mode    others = low power mode entry/exit triggered dfc" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        hexmask.long.byte 0x00 8.--14. 1. "        SQ_TFL307              ,target freq level of dclk"
        hexmask.long.byte 0x00 1.--7. 1. "    SQ_CFL308               ,current freq level of dclk"
        bitfld.long 0x00 0. "  SQ_DFC_STATUS309        ,dclk dfc status  the dclk dfc may be triggered in active state or <var processor: seagull/msa> entering low power mode.  0 = there is no dfc or dfc has finished  1 = dfc is in progress" "0,1"

group d:0xD42A0098++0x03
    line.long 0x00 "FC_DONE_STATUS_RT,Real Time FC Done Status Register"
        bitfld.long 0x00 9. " SQ_AP_C2_FC_DONE318      ,ap c2 fc done indicator" "0,1"
        bitfld.long 0x00 8. "         SQ_AP_C1_FC_DONE319    ,ap c1 fc done indicator" "0,1"
        bitfld.long 0x00 7. "     SQ_CP_FC_DONE320        ,cp  fc done indicator" "0,1"
        bitfld.long 0x00 6. "   SQ_AP_C0_FC_DONE321     ,ap c0 fc done indicator" "0,1"
        textline "                                    "
        bitfld.long 0x00 5. "SQ_DCLK_FC_DONE322       ,dclk fc done indicator" "0,1"
        bitfld.long 0x00 4. "         SQ_ACLK_FC_DONE323     ,aclk fc done indicator" "0,1"
        bitfld.long 0x00 0.--3. "     SQ_DVC_STATUS324        ,apmu dvc fsm state" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"

group d:0xD42A00A0++0x03
    line.long 0x00 "SPAPDPCP_PM_STATE_REG_RT,Real Time SPAPDPCP PM State Register"
        bitfld.long 0x00 18.--22. " SQ_SP_STATE333           ,sp pmu state" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"
        bitfld.long 0x00 13.--17. "        SQ_AP_STATE334         ,ap pmu state" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"
        bitfld.long 0x00 8.--12. "    SG_STATE335             ,seagull pmu state" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"
        bitfld.long 0x00 4.--7. "  SQ_CP_STATE336          ,cp pmu state" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        textline "                                    "
        bitfld.long 0x00 0.--3. "SQ_WFSTATE337            ,main pmu state" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"

group d:0xD42A00A8++0x03
    line.long 0x00 "PLL_STATUS_REG_RT,Real Time PLL Status Register"
        bitfld.long 0x00 31. " SQ_PLL4_LOCK345          ,pll4 lock indicator" "0,1"
        bitfld.long 0x00 30. "         SQ_PLL3_LOCK346        ,pll3 lock indicator" "0,1"
        bitfld.long 0x00 29. "     SQ_PLL2_LOCK347         ,pll2 lock indicator" "0,1"
        bitfld.long 0x00 28. "   SQ_PLL1_LOCK348         ,pll1 lock indicator" "0,1"
        textline "                                    "
        hexmask.long.word 0x00 13.--27. 1. "SQ_CLK_DIV_INFO349       ,clock divider information"
        hexmask.long.word 0x00 0.--12. 1. "      SQ_PLL_SEL_INFO350     ,pll selection information"

group d:0xD42A00B0++0x03
    line.long 0x00 "APC0_PM_STATE_REG_RT,Real Time APC0 PM State Register"
        hexmask.long 0x00 0.--24. 1. " SQ_C0_PM_STATE359        ,ap cluster 0 lpm state"

group d:0xD42A00B8++0x03
    line.long 0x00 "APC1_PM_STATE_REG_RT,Real Time APC1 PM State Register"
        hexmask.long 0x00 0.--24. 1. " SQ_C0_PM_STATE368        ,ap cluster 1 lpm state"

group d:0xD42A00C0++0x03
    line.long 0x00 "FAB_TIMEOUT_ID_TO,AXI Fabric Timeout Transaction ID Register"
        bitfld.long 0x00 31. " SQ_WR_TIMEOUT_IND376     ,write timeout indicator  0 = no write request timeout  1 = write request timeout happens" "0,1"
        hexmask.long.byte 0x00 16.--21. 1. "         SQ_TIMEOUT_TX_WID378   ,the wid of write transaction which causes first timeout event. it is only valid when bit[31], wr_timeout_ind is asserted"
        bitfld.long 0x00 15. "    SQ_RD_TIMEOUT_IND379    ,read timeout indicator  0 = no read request timeout  1 = read request timeout happens" "0,1"
        hexmask.long.byte 0x00 0.--5. 1. "   SQ_TIMEOUT_TX_RID381    ,the rid of read transaction which causes first timeout event. it is only valid when bit[15], rd_timeout_ind is asserted"

group d:0xD42A00C8++0x03
    line.long 0x00 "FAB_TIMEOUT_STATUS0_TO,AXI Fabric Timeout Status0 Register"
        hexmask.long 0x00 2.--31. 1. " SQ_TIMEOUT_WADDR389      ,the write address being accessing which has caused the first write timeout event."
        bitfld.long 0x00 0. "  SQ_WR_TIMEOUT_IND391   ,write timeout indicator  0 = no write request timeout  1 = write request timeout happens" "0,1"

group d:0xD42A00D0++0x03
    line.long 0x00 "FAB_TIMEOUT_STATUS1_TO,AXI Fabric Timeout Status1 Register"
        hexmask.long 0x00 2.--31. 1. " SQ_TIMEOUT_RADDR399      ,the read address being accessing which has caused the first write timeout event."
        bitfld.long 0x00 0. "  SQ_RD_TIMEOUT_IND401   ,read timeout indicator  0 = no read request timeout  1 = read request timeout happens" "0,1"

group d:0xD42A00D8++0x03
    line.long 0x00 "DVC_STATUS_TO,DVC Status Register"
        bitfld.long 0x00 24.--27. " SQ_CAUSE410              ,dvc cause  this field is the cause of the current ongoing dvc. it is only valid when the <voltage change status> field is 1.   0x1 = <var processor: application mp> software-triggered dvc  0x2 = <var processor: comm> software- triggered dvc   0x4 = <var processor: msa> software- triggered dvc    0x8 = hw-dfc triggered dvc    others = lpm entry/exit trigger dvc" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 16.--19. "        SQ_TVL412              ,target voltage level of vcc_main" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 8.--11. "    SQ_CVL414               ,current voltage level of vcc_main" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 0. "  SQ_DVC_STATUS416        ,voltage change status  the voltage change may be triggered in active state or entering low power mode.  0 = there is no voltage change or a voltage change has finished  1 = voltage change is in progress" "0,1"

group d:0xD42A00E0++0x03
    line.long 0x00 "DFC_STATUS_TO,DCLK Hardware FC Status Register"
        bitfld.long 0x00 15.--18. " SQ_DFC_CAUSE425          ,dclk dfc cause  this field is the cause of the current ongoing dfc. it is only valid when the <dclk_dfc_status> field is 1.  0x1 = <var processor: application mp> triggered dfc  0x2 = <var processor: comm> triggered dfc in active mode  0x4 = msa trigged dfc in active mode    0x8 = gnss triggered dfc in active mode    others = low power mode entry/exit triggered dfc" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        hexmask.long.byte 0x00 8.--14. 1. "        SQ_TFL426              ,target freq level of dclk"
        hexmask.long.byte 0x00 1.--7. 1. "    SQ_CFL427               ,current freq level of dclk"
        bitfld.long 0x00 0. "  SQ_DFC_STATUS428        ,dclk dfc status  the dclk dfc may be triggered in active state or <var processor: seagull/msa> entering low power mode.  0 = there is no dfc or dfc has finished  1 = dfc is in progress" "0,1"

group d:0xD42A00E8++0x03
    line.long 0x00 "FC_DONE_STATUS_TO,FC Done Status Register"
        bitfld.long 0x00 9. " SQ_AP_C2_FC_DONE437      ,ap c2 fc done indicator" "0,1"
        bitfld.long 0x00 8. "         SQ_AP_C1_FC_DONE438    ,ap c1 fc done indicator" "0,1"
        bitfld.long 0x00 7. "     CP_FC_DONE_MSK439       ,cp  fc done indicator" "0,1"
        bitfld.long 0x00 6. "   SQ_AP_C0_FC_DONE440     ,ap c0 fc done indicator" "0,1"
        textline "                                    "
        bitfld.long 0x00 5. "SQ_DCLK_FC_DONE441       ,dclk fc done indicator" "0,1"
        bitfld.long 0x00 4. "         SQ_ACLK_FC_DONE442     ,aclk fc done indicator" "0,1"
        bitfld.long 0x00 0.--3. "     SQ_DVC_STATUS443        ,apmu dvc fsm state" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"

group d:0xD42A00F0++0x03
    line.long 0x00 "SPAPDPCP_PM_STATE_REG_TO,SPAPDPCP PM State Register"
        bitfld.long 0x00 18.--22. " SQ_SP_STATE452           ,sp pmu state" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"
        bitfld.long 0x00 13.--17. "        SQ_AP_STATE453         ,ap pmu state" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"
        bitfld.long 0x00 8.--12. "    SG_STATE454             ,seagull pmu state" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"
        bitfld.long 0x00 4.--7. "  SQ_CP_STATE455          ,cp pmu state" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        textline "                                    "
        bitfld.long 0x00 0.--3. "SQ_WFSTATE456            ,main pmu state" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"

group d:0xD42A00F8++0x03
    line.long 0x00 "PLL_STATUS_REG_TO,PLL Status Register"
        bitfld.long 0x00 31. " SQ_PLL4_LOCK464          ,pll4 lock indicator" "0,1"
        bitfld.long 0x00 30. "         SQ_PLL3_LOCK465        ,pll3 lock indicator" "0,1"
        bitfld.long 0x00 29. "     SQ_PLL2_LOCK466         ,pll2 lock indicator" "0,1"
        bitfld.long 0x00 28. "   SQ_PLL1_LOCK467         ,pll1 lock indicator" "0,1"
        textline "                                    "
        hexmask.long.word 0x00 13.--27. 1. "SQ_CLK_DIV_INFO468       ,clock divider information"
        hexmask.long.word 0x00 0.--12. 1. "      SQ_PLL_SEL_INFO469     ,pll selection information"

group d:0xD42A0100++0x03
    line.long 0x00 "APC0_PM_STATE_REG_TO,APC0 PM State Register"
        hexmask.long 0x00 0.--25. 1. " SQ_C0_PM_STATE478        ,ap cluster 0 lpm state"

group d:0xD42A0108++0x03
    line.long 0x00 "APC1_PM_STATE_REG_TO,APC1 PM State Register"
        hexmask.long 0x00 0.--25. 1. " SQ_C0_PM_STATE487        ,ap cluster 1 lpm state"

group d:0xD42A0110++0x03
    line.long 0x00 "FAB_TIMEOUT_ID_HD,Real Time AXI Fabric Timeout Transaction ID Register"
        bitfld.long 0x00 31. " SQ_WR_TIMEOUT_IND495     ,write timeout indicator  0 = no write request timeout  1 = write request timeout happens" "0,1"
        hexmask.long.byte 0x00 16.--21. 1. "         SQ_TIMEOUT_TX_WID497   ,the wid of write transaction which causes first timeout event. it is only valid when bit[31], wr_timeout_ind is asserted"
        bitfld.long 0x00 15. "    SQ_RD_TIMEOUT_IND498    ,read timeout indicator  0 = no read request timeout  1 = read request timeout happens" "0,1"
        hexmask.long.byte 0x00 0.--5. 1. "   SQ_TIMEOUT_TX_RID500    ,the rid of read transaction which causes first timeout event. it is only valid when bit[15], rd_timeout_ind is asserted"

group d:0xD42A0118++0x03
    line.long 0x00 "FAB_TIMEOUT_STATUS0_HD,Real Time AXI Fabric Timeout Status0 Register"
        hexmask.long 0x00 2.--31. 1. " SQ_TIMEOUT_WADDR508      ,the write address being accessing which has caused the first write timeout event."
        bitfld.long 0x00 0. "  SQ_WR_TIMEOUT_IND510   ,write timeout indicator  0 = no write request timeout  1 = write request timeout happens" "0,1"

group d:0xD42A0120++0x03
    line.long 0x00 "FAB_TIMEOUT_STATUS1_HD,Real Time AXI Fabric Timeout Status1 Register"
        hexmask.long 0x00 2.--31. 1. " SQ_TIMEOUT_RADDR518      ,the read address being accessing which has caused the first write timeout event."
        bitfld.long 0x00 0. "  SQ_RD_TIMEOUT_IND520   ,read timeout indicator  0 = no read request timeout  1 = read request timeout happens" "0,1"

group d:0xD42A0128++0x03
    line.long 0x00 "DVC_STATUS_HD,Real Time DVC Status Register"
        bitfld.long 0x00 24.--27. " SQ_CAUSE529              ,dvc cause  this field is the cause of the current ongoing dvc. it is only valid when the <voltage change status> field is 1.   0x1 = <var processor: application mp> software-triggered dvc  0x2 = <var processor: comm> software- triggered dvc   0x4 = <var processor: msa> software- triggered dvc    0x8 = hw-dfc triggered dvc    others = lpm entry/exit trigger dvc" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 16.--19. "        SQ_TVL531              ,target voltage level of vcc_main" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 8.--11. "    SQ_CVL533               ,current voltage level of vcc_main" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 0. "  SQ_DVC_STATUS535        ,voltage change status  the voltage change may be triggered in active state or entering low power mode.  0 = there is no voltage change or a voltage change has finished  1 = voltage change is in progress" "0,1"

group d:0xD42A0130++0x03
    line.long 0x00 "DFC_STATUS_HD,Real Time DCLK Hardware FC Status Register"
        bitfld.long 0x00 15.--18. " SQ_DFC_CAUSE544          ,dclk dfc cause  this field is the cause of the current ongoing dfc. it is only valid when the <dclk_dfc_status> field is 1.  0x1 = <var processor: application mp> triggered dfc  0x2 = <var processor: comm> triggered dfc in active mode  0x4 = msa trigged dfc in active mode    0x8 = gnss triggered dfc in active mode    others = low power mode entry/exit triggered dfc" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        hexmask.long.byte 0x00 8.--14. 1. "        SQ_TFL545              ,target freq level of dclk"
        hexmask.long.byte 0x00 1.--7. 1. "    SQ_CFL546               ,current freq level of dclk"
        bitfld.long 0x00 0. "  SQ_DFC_STATUS547        ,dclk dfc status  the dclk dfc may be triggered in active state or <var processor: seagull/msa> entering low power mode.  0 = there is no dfc or dfc has finished  1 = dfc is in progress" "0,1"

group d:0xD42A0138++0x03
    line.long 0x00 "FC_DONE_STATUS_HD,Real Time FC Done Status Register"
        bitfld.long 0x00 9. " SQ_AP_C2_FC_DONE556      ,ap c2 fc done indicator" "0,1"
        bitfld.long 0x00 8. "         SQ_AP_C1_FC_DONE557    ,ap c1 fc done indicator" "0,1"
        bitfld.long 0x00 7. "     CP_FC_DONE_MSK558       ,cp  fc done indicator" "0,1"
        bitfld.long 0x00 6. "   SQ_AP_C0_FC_DONE559     ,ap c0 fc done indicator" "0,1"
        textline "                                    "
        bitfld.long 0x00 5. "SQ_DCLK_FC_DONE560       ,dclk fc done indicator" "0,1"
        bitfld.long 0x00 4. "         SQ_ACLK_FC_DONE561     ,aclk fc done indicator" "0,1"
        bitfld.long 0x00 0.--3. "     SQ_DVC_STATUS562        ,apmu dvc fsm state" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"

group d:0xD42A0140++0x03
    line.long 0x00 "SPAPDPCP_PM_STATE_REG_HD,Real Time SPAPDPCP PM State Register"
        bitfld.long 0x00 18.--22. " SQ_SP_STATE571           ,sp pmu state" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"
        bitfld.long 0x00 13.--17. "        SQ_AP_STATE572         ,ap pmu state" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"
        bitfld.long 0x00 8.--12. "    SG_STATE573             ,seagull pmu state" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"
        bitfld.long 0x00 4.--7. "  SQ_CP_STATE574          ,cp pmu state" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        textline "                                    "
        bitfld.long 0x00 0.--3. "SQ_WFSTATE575            ,main pmu state" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"

group d:0xD42A0148++0x03
    line.long 0x00 "PLL_STATUS_REG_HD,Real Time PLL Status Register"
        bitfld.long 0x00 31. " SQ_PLL4_LOCK583          ,pll4 lock indicator" "0,1"
        bitfld.long 0x00 30. "         SQ_PLL3_LOCK584        ,pll3 lock indicator" "0,1"
        bitfld.long 0x00 29. "     SQ_PLL2_LOCK585         ,pll2 lock indicator" "0,1"
        bitfld.long 0x00 28. "   SQ_PLL1_LOCK586         ,pll1 lock indicator" "0,1"
        textline "                                    "
        hexmask.long.word 0x00 13.--27. 1. "SQ_CLK_DIV_INFO587       ,clock divider information"
        hexmask.long.word 0x00 0.--12. 1. "      SQ_PLL_SEL_INFO588     ,pll selection information"

group d:0xD42A0150++0x03
    line.long 0x00 "APC0_PM_STATE_REG_HD,Real Time APC0 PM State Register"
        hexmask.long 0x00 0.--25. 1. " SQ_C0_PM_STATE597        ,ap cluster 0 lpm state"

group d:0xD42A0158++0x03
    line.long 0x00 "APC1_PM_STATE_REG_HD,Real Time APC1 PM State Register"
        hexmask.long 0x00 0.--24. 1. " SQ_C0_PM_STATE606        ,ap cluster 1 lpm state"

group d:0xD42A0160++0x03
    line.long 0x00 "APC2_PM_STATE_REG_RT,Real Time APC2 PM State Register"
        hexmask.long 0x00 0.--24. 1. " SQ_C0_PM_STATE614        ,ap cluster 2 lpm state"

group d:0xD42A0168++0x03
    line.long 0x00 "APC2_PM_STATE_REG_TO,APC2 PM State Register"
        hexmask.long 0x00 0.--24. 1. " SQ_C0_PM_STATE622        ,ap cluster 2 lpm state"

group d:0xD42A0170++0x03
    line.long 0x00 "APC2_PM_STATE_REG_HD,Real Time APC2 PM State Register"
        hexmask.long 0x00 0.--24. 1. " SQ_C0_PM_STATE630        ,ap cluster 2 lpm state"

group d:0xD42A0178++0x03
    line.long 0x00 "PLL_STATUS2_REG_RT,Real Time PLL Status2 Register"
        bitfld.long 0x00 3.--5. " SQ_C2_CLK_DIV_INFO639    ,cpu c2 clock divider information" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 0.--2. "         C2_PLL_SEL_INFO640     ,cpu c2 pll selection information" "0,1,2,3,4,5,6,7"

group d:0xD42A0180++0x03
    line.long 0x00 "PLL_STATUS2_REG_TO,PLL Status2 Register"
        bitfld.long 0x00 3.--5. " SQ_C2_CLK_DIV_INFO649    ,cpu c2 clock divider information" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 0.--2. "         C2_PLL_SEL_INFO650     ,cpu c2 pll selection information" "0,1,2,3,4,5,6,7"

group d:0xD42A0188++0x03
    line.long 0x00 "PLL_STATUS2_REG_HD,Real Time PLL Status2 Register"
        bitfld.long 0x00 3.--5. " SQ_C2_CLK_DIV_INFO659    ,cpu c2 clock divider information" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 0.--2. "         C2_PLL_SEL_INFO660     ,cpu c2 pll selection information" "0,1,2,3,4,5,6,7"

group d:0xD42A0200++0x03
    line.long 0x00 "SQU_CAM_ENT_BANK0,CAM Entries Bank 0 Register"
        bitfld.long 0x00 15. " VAL_BIT668               ,valid bit" "0,1"
        hexmask.long.word 0x00 0.--13. 1. "         CAM_ENTRY_DATA670      ,cam entry data"

group d:0xD42A0280++0x03
    line.long 0x00 "SQU_CAM_ENT_BANK1,CAM Entries Bank 1 Register"
        bitfld.long 0x00 15. " VAL_BIT678               ,valid bit" "0,1"
        hexmask.long.word 0x00 0.--13. 1. "         CAM_ENTRY_DATA680      ,cam entry data"

group d:0xD42A0300++0x03
    line.long 0x00 "SQU_CAM_ENT_BANK2,CAM Entries Bank 2 Register"
        bitfld.long 0x00 15. " VAL_BIT688               ,valid bit" "0,1"
        hexmask.long.word 0x00 0.--13. 1. "         CAM_ENTRY_DATA690      ,cam entry data"

group d:0xD42A0380++0x03
    line.long 0x00 "SQU_CAM_ENT_BANK3,CAM Entries Bank 3 Register"
        bitfld.long 0x00 15. " VAL_BIT698               ,valid bit" "0,1"
        hexmask.long.word 0x00 0.--13. 1. "         CAM_ENTRY_DATA700      ,cam entry data"

group d:0xD42A0400++0x03
    line.long 0x00 "SQU_CAM_ENT_BANK4,CAM Entries Bank 4 Register"
        bitfld.long 0x00 15. " VAL_BIT708               ,valid bit" "0,1"
        hexmask.long.word 0x00 0.--13. 1. "         CAM_ENTRY_DATA710      ,cam entry data"

group d:0xD42A0480++0x03
    line.long 0x00 "SQU_CAM_ENT_BANK5,CAM Entries Bank 5 Register"
        bitfld.long 0x00 15. " VAL_BIT718               ,valid bit" "0,1"
        hexmask.long.word 0x00 0.--13. 1. "         CAM_ENTRY_DATA720      ,cam entry data"

group d:0xD42A0780++0x03
    line.long 0x00 "SQU_LOGGER_ENT,Logger Entries Register"
        bitfld.long 0x00 15. " VAL_BIT728               ,valid bit" "0,1"
        hexmask.long.word 0x00 0.--13. 1. "         CAM_ENTRY_DATA730      ,cam entry data"

group d:0xD42A0800++0x03
    line.long 0x00 "SQU_CHAN_0_BYTE_CNT,Channel 0 Byte Count Register"
        hexmask.long.word 0x00 0.--15. 1. " BYTECNT0                 ,channel 0 byte count  number of bytes of data that this dma channel must transfer."

group d:0xD42A0804++0x03
    line.long 0x00 "SQU_CHAN_1_BYTE_CNT,Channel 1 Byte Count Register"
        hexmask.long.word 0x00 0.--15. 1. " BYTECNT1                 ,channel 1 byte count  number of bytes of data that this dma channel must transfer."

group d:0xD42A0810++0x03
    line.long 0x00 "SQU_CHAN_0_SRC_ADDR,Channel 0 Source Address Register"
        hexmask.long 0x00 0.--31. 1. " SRCADD0                  ,channel 0 source address"

group d:0xD42A0814++0x03
    line.long 0x00 "SQU_CHAN_1_SRC_ADDR,Channel 1 Source Address Register"
        hexmask.long 0x00 0.--31. 1. " SRCADD1                  ,channel 1 source address"

group d:0xD42A0820++0x03
    line.long 0x00 "SQU_CHAN_0_DEST_ADDR,Channel 0 Destination Address Register"
        hexmask.long 0x00 0.--31. 1. " DESTADD0                 ,channel 0 destination address"

group d:0xD42A0824++0x03
    line.long 0x00 "SQU_CHAN_1_DEST_ADDR,Channel 1 Destination Address Register"
        hexmask.long 0x00 0.--31. 1. " DESTADD1                 ,channel 1 destination address"

group d:0xD42A0830++0x03
    line.long 0x00 "SQU_CHAN_0_NEXT_DESC_PTR,Channel 0 Next Descriptor Pointer Register"
        hexmask.long 0x00 0.--31. 1. " NDPTR0                   ,channel 0 next descriptor pointer address  this must be 16 byte aligned."

group d:0xD42A0834++0x03
    line.long 0x00 "SQU_CHAN_1_NEXT_DESC_PTR,Channel 1 Next Descriptor Pointer Register"
        hexmask.long 0x00 0.--31. 1. " NDPTR1                   ,channel 1 next descriptor pointer address  this must be 16 byte aligned."

group d:0xD42A0840++0x03
    line.long 0x00 "SQU_CHAN_0_CTRL,Channel 0 Control Register"
        bitfld.long 0x00 21. " SSPMOD818                ,sspmod  1 = ssp fifo access" "0,1"
        bitfld.long 0x00 20. "         ABR819                 ,channel abort  when software sets this bit to 1, the dma aborts in the middle. this field is cleared by the dma hardware." "0,1"
        bitfld.long 0x00 17. "     CDE821                  ,close descriptor enable  if enabled, the dma writes the remainder byte count into bits[31:16] of the byte count field.   0 = disable  1 = enable" "0,1"
        bitfld.long 0x00 15. "   SQ_SDA823               ,source/destination address alignment  0 = alignment is towards the source. after the dma's first read, all reads will be to 32-bit word aligned address.  1 = alignment is towards the destination. after the first write, the following writes will be with all byte enables asserted." "0,1"
        textline "                                    "
        bitfld.long 0x00 14. "CHANACT824               ,dma channel active  0 = channel is not active  1 = channel is active" "0,1"
        bitfld.long 0x00 13. "         FETCHND825             ,fetch next descriptor  1 = forces a fetch of the next descriptor  this field is automatically cleared after the fetch completes." "0,1"
        bitfld.long 0x00 12. "     CHANEN826               ,channel enable  when software sets this field to 1, it activates the channel.and this bit will automatically cleared after the dma transfer is done  setting it to 0 causes the channel to suspend.  re-setting this field to 1 allows the channel to continue dma transfer." "0,1"
        bitfld.long 0x00 11. "   TRANSMOD828             ,transmod  0 = external dma_req access mode" "0,1"
        textline "                                    "
        bitfld.long 0x00 10. "INTMODE829               ,interrupt mode  0 = interrupt asserted every time the dma byte count reaches 0  1 = interrupt asserted when the next descriptor pointer value is null and the dma byte count reaches 0" "0,1"
        bitfld.long 0x00 9. "         CHAINMOD830            ,chain mode  0 = chain mode  1 = non-chain mode" "0,1"
        bitfld.long 0x00 6.--8. "     BURSTLIMIT831           ,burst limit in each dma access  0x5 = 1 byte  0x6 = 2 bytes  0x0 = 4 bytes  0x1 = 8 bytes  0x3 = 16 bytes  0x7 = 32 bytes" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 4.--5. "   DESTDIR832              ,destination direction  0x0 = increment destination address  0x1 = decrement destination address  0x2 = hold in the same value  0x3 = reserved" "0,1,2,3"
        textline "                                    "
        bitfld.long 0x00 2.--3. "SRCDIR833                ,source direction  0x0 = increment source address  0x1 = decrement source address  0x2 = hold in the same value  0x3 = reserved" "0,1,2,3"

group d:0xD42A0844++0x03
    line.long 0x00 "SQU_CHAN_1_CTRL,Channel 1 Control Register"
        bitfld.long 0x00 21. " SSPMOD842                ,sspmod  1 = ssp fifo access" "0,1"
        bitfld.long 0x00 20. "         ABR843                 ,channel abort  when software sets this bit to 1, the dma aborts in the middle. this field is cleared by the dma hardware." "0,1"
        bitfld.long 0x00 17. "     CDE845                  ,close descriptor enable  if enabled, the dma writes the remainder byte count into bits[31:16] of the byte count field.   0 = disable  1 = enable" "0,1"
        bitfld.long 0x00 14. "   CHANACT847              ,dma channel active  0 = channel is not active  1 = channel is active" "0,1"
        textline "                                    "
        bitfld.long 0x00 13. "FETCHND848               ,fetch next descriptor  1 = forces a fetch of the next descriptor  this field is automatically cleared after the fetch completes." "0,1"
        bitfld.long 0x00 12. "         CHANEN849              ,channel enable  when software sets this field to 1, it activates the channel.and this bit will automatically cleared after the dma transfer is done  setting it to 0 causes the channel to suspend.  re-setting this field to 1 allows the channel to continue dma transfer." "0,1"
        bitfld.long 0x00 11. "     TRANSMOD851             ,transmod  0 = external dma_req access mode" "0,1"
        bitfld.long 0x00 10. "   INTMODE852              ,interrupt mode  0 = interrupt asserted every time the dma byte count reaches 0  1 = interrupt asserted when the next descriptor pointer value is null and the dma byte count reaches 0" "0,1"
        textline "                                    "
        bitfld.long 0x00 9. "CHAINMOD853              ,chain mode  0 = chain mode  1 = non-chain mode" "0,1"
        bitfld.long 0x00 6.--8. "         BURSTLIMIT854          ,burst limit in each dma access  0x5 = 1 byte  0x6 = 2 bytes  0x0 = 4 bytes  0x1 = 8 bytes  0x3 = 16 bytes  0x7 = 32 bytes" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 4.--5. "     DESTDIR855              ,destination direction  0x0 = increment destination address  0x1 = decrement destination address  0x2 = hold in the same value  0x3 = reserved" "0,1,2,3"
        bitfld.long 0x00 2.--3. "   SRCDIR856               ,source direction  0x0 = increment source address  0x1 = decrement source address  0x2 = hold in the same value  0x3 = reserved" "0,1,2,3"

group d:0xD42A0860++0x03
    line.long 0x00 "SQU_CHAN_PRI,Channel Priority Register"
        bitfld.long 0x00 31. " REVERSE_MEMORY_COPY      ,reverse memory copy   0x1= when <srcdir>/<destdir> is 2'b01 and the current size left in channel  is equal to or less than burst limit in each dma access, the current dma source/destination address = (channel source/destination addr - current left size)     0x0= current dma source/destination address use normal source/destination address" "0,1"
        bitfld.long 0x00 0.--1. "         PRIOCHAN10             ,channels 0 and 1 priority  0x0 = round robin  0x1 = priority to channel 1 over channel 0  0x2 = priority to channel 0 over channel 1  0x3 = reserved" "0,1,2,3"

group d:0xD42A0864++0x03
    line.long 0x00 "Channel_ID_FILTER,Channel ID FILTER"
        hexmask.long.byte 0x00 0.--7. 1. " EN_ACCESS                ,enable access"

group d:0xD42A0870++0x03
    line.long 0x00 "CHAN_0_CURR_DESC_PTR,Channel 0 Current Descriptor Pointer Register"
        hexmask.long 0x00 0.--31. 1. " CDPTR0                   ,channel 0 current descriptor pointer address"

group d:0xD42A0874++0x03
    line.long 0x00 "CHAN_1_CURR_DESC_PTR,Channel 1 Current Descriptor Pointer Register"
        hexmask.long 0x00 0.--31. 1. " CDPTR1                   ,channel 1 current descriptor pointer address"

group d:0xD42A0890++0x03
    line.long 0x00 "CHAN_0_RSR,Channel 0 Reset Select Register"
        bitfld.long 0x00 0.--1. " RSR0                     ,channel 0 reset select address  the bits in this register correspond to the bits in the chan_0_int_status register. setting a bit to 1 will enable its corresponding chan_0_int_status bit read clear function." "0,1,2,3"

group d:0xD42A0894++0x03
    line.long 0x00 "SQU_CHAN_1_RSR,Channel 1 Reset Select Register"
        bitfld.long 0x00 0.--1. " RSR1                     ,channel 1 reset select address  the bits in this register correspond to the bits in the chan_1_int_status register. setting a bit to 1 enables its corresponding chan_1_int_status bit read clear function." "0,1,2,3"

group d:0xD42A0880++0x03
    line.long 0x00 "SQU_CHAN_0_INT_MASK,Channel 0 Interrupt Mask Register"
        bitfld.long 0x00 1. " DMA_ABORT_INT927         ,channel 0 dma aborted interrupt mask  1 = channel 0 dma aborted interrupt is enabled" "0,1"
        bitfld.long 0x00 0. "         COMP928                ,channel 0 interrupt mask  1 = channel 0 comp interrupt is enabled" "0,1"

group d:0xD42A0884++0x03
    line.long 0x00 "SQU_CHAN_1_INT_MASK,Channel 1 Interrupt Mask Register"
        bitfld.long 0x00 1. " DMA_ABORT_INT936         ,channel 1 dma aborted interrupt mask  1 = channel 1 dma aborted interrupt is enabled" "0,1"
        bitfld.long 0x00 0. "         COMP937                ,channel 1 interrupt mask  1 = channel 1 comp interrupt is enabled" "0,1"

group d:0xD42A08A0++0x03
    line.long 0x00 "SQU_CHAN_0_INT_STATUS,Channel 0 Interrupt Status Register"
        bitfld.long 0x00 1. " DMA_ABORT945             ,dma abort interrupt status and clear channel 0  read clear in this field is enabled through the corresponding rsr bit setting in the chan_0_rsr register." "0,1"
        bitfld.long 0x00 0. "         INT_DONE946            ,interrupt done channel 0  read clear in this field is enabled through the corresponding rsr bit setting in the chan_0_rsr register." "0,1"

group d:0xD42A08A4++0x03
    line.long 0x00 "SQU_CHAN_1_INT_STATUS,Channel 1 Interrupt Status Register"
        bitfld.long 0x00 1. " DMA_ABORT954             ,dma abort interrupt status and clear channel 0  read clear in this field is enabled through the corresponding rsr bit setting in the chan_1_rsr register." "0,1"
        bitfld.long 0x00 0. "         INT_DONE955            ,interrupt done channel 0  read clear in this field is enabled through the corresponding rsr bit setting in the chan_1_rsr register." "0,1"

tree.end

tree "ssp"

width 21.

group d:0xD401B000++0x03
    line.long 0x00 "SSP_TOP_CTRL,SSP Top Control Register"
        bitfld.long 0x00 18. " TTELP                 ,txd three-state enable on last phase  0 = txdx is three-stated 1/2 clock cycle after the beginning of the lsb  1 = txdx output signal is three-stated on the clock edge that ends the lsb" "0,1"
        bitfld.long 0x00 17. "         TTE              ,txd three-state enable  0 = txdx output signal is not three-stated  1 = txd is three-stated when not transmitting data" "0,1"
        bitfld.long 0x00 16. "   SCFR                  ,slave clock free running  0 = clock input to sspsclkx is continuously running  1 = clock input to sspsclkx is only active during data transfers." "0,1"
        bitfld.long 0x00 15. "   IFS           ,invert frame signal  0 = sspsfrmx polarity is determined by the psp polarity bits  1 = sspsfrmx will be inverted from normal-sspsfrmx (as defined by the psp polarity bits). (works in all frame formats: spi, ssp, and psp)" "0,1"
        textline "                               "
        bitfld.long 0x00 14. "HOLD_FRAME_LOW        ,hold frame low control  1=after this field is set to 1 and the ssp is operating in master mode, the output frame clock ssp_sfrm_gpio will hold low. used for spi and nmw format rx fifo auto full control, which makes the frame clock is still low during there's no bit clock, or the data transfers before the stop clock will be discarded." "0,1"
        bitfld.long 0x00 13. "         SSP0_TRAIL25     ,trailing byte  0 = trailing bytes are handled by the <var product number>  1 = trailing bytes are handled by dma bursts" "0,1"
        bitfld.long 0x00 12. "   LBM                   ,loopback mode (test mode bit)  0 = normal serial port operation is enabled  1 = output of tx serial shifter is internally connected to input of rx serial shifter" "0,1"
        bitfld.long 0x00 11. "   SPH           ,motorola spi sspsclk phase setting  0 = sspsclkx is inactive until one cycle after the start of a frame and active until 1/2 cycle before the end of a frame  1 = sspsclkx is inactive until 1/2 cycle after the start of a frame and active until one cycle before the end of a frame" "0,1"
        textline "                               "
        bitfld.long 0x00 10. "SPO                   ,motorola spi sspsclk polarity setting  0 = the inactive or idle state of sspsclkx is low  1 = the inactive or idle state of sspsclkx is high" "0,1"
        bitfld.long 0x00 5.--9. "         DSS              ,ssp work data size,  register bits value 0~31 indicated data size 1~32 bits,  usually use data size 8bits, 16bits, 24bits, 32bits" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"
        bitfld.long 0x00 4. "  SFRMDIR               ,ssp frame (sspsfrmx) direction  0 = master mode, sspx port drives sspsfrmx  1 = slave mode, sspx port receives sspsfrmx" "0,1"
        bitfld.long 0x00 3. "   SCLKDIR       ,ssp serial bit rate clock (sspsclkx) direction  0 = master mode, sspx port drives sspsclkx  1 = slave mode, sspx port receives sspsclkx" "0,1"
        textline "                               "
        bitfld.long 0x00 1.--2. "FRF                   ,frame format  0x0 = motorola* serial peripheral interface (spi)   0x1 = texas instruments* synchronous serial protocol (ssp)  0x2 = national semiconductor microwire*  0x3 = programmable serial protocol (psp)" "0,1,2,3"
        bitfld.long 0x00 0. "         SSE              ,synchronous serial port enable  0 = sspx port is disabled   1 = sspx port is enabled" "0,1"

group d:0xD401B004++0x03
    line.long 0x00 "SSP_FIFO_CTRL,SSP FIFO Control Register"
        bitfld.long 0x00 19. " STRF                  ,select fifo for efwr (test mode bit)  only when the <enable fifo write/read> field = 1  0 = txfifo is selected for both writes and reads through the ssp data register  1 = rxfifo is selected for both writes and reads through the ssp data register" "0,1"
        bitfld.long 0x00 18. "         EFWR             ,enable fifo write/read (test mode bit)  0 = fifo write/read special function is disabled (normal sspx operational mode)  1 = fifo write/read special function is enabled" "0,1"
        bitfld.long 0x00 17. "   RXFIFO_AUTO_FULL_CTRL ,rx fifo auto full control  =1after this field is set to 1 and the ssp is operating in master mode, the ssp fsm returns to idle state and stops the ssp_sclk_gpio. when rx fifo is full, the ssp fsm continues transferring data after the rx fifo is not full. this field is used to avoid an rx fifo overrun issue.  1= enable rx fifo auto full control" "0,1"
        bitfld.long 0x00 16. "   FPCKE         ,fifo packing enable  0 = fifo packing mode disabled  1 = fifo packing mode enabled" "0,1"
        textline "                               "
        bitfld.long 0x00 14.--15. "TXFIFO_WR_ENDIAN      ,apb_pwdata write to tx fifo endian  0x0 = txfifo_wdata[31:0] = apb_pwdata[31:0]  0x1 = fifo_wdata[31:0] = {apb_pwdata[15:0], apb_pwdata[31:16]}  0x2 = txfifo_wdata[31:0] = {apb_pwdata[7:0], apb_pwdata[15:8], apb_pwdata[23:16], apb_pwdata[31:24]}  0x3 = txfifo_wdata[31:0] = {apb_pwdata[23:16], apb_pwdata[31:24], apb_pwdata[7:0], apb_pwdata[15:8]}" "0,1,2,3"
        bitfld.long 0x00 12.--13. "         RXFIFO_RD_ENDIAN ,apb_prdata read from rx fifo endian  0x0 = apb_prdata[31:0] = rxfifo_wdata[31:0]  0x1 = apb_prdata[31:0] = {rxfifo_wdata[15:0], rxfifo_wdata[31:16]}  0x2 = apb_prdata[31:0]= {rxfifo_wdata[7:0], rxfifo_wdata[15:8], rxfifo_wdata[23:16], rxfifo_wdata[31:24]}  0x3 = apb_prdata[31:0]= {rxfifo_wdata[23:16], rxfifo_wdata[31:24], rxfifo_wdata[7:0], rxfifo_wdata[15:8]}" "0,1,2,3"
        bitfld.long 0x00 11. "   RSRE                  ,receive service request enable  0 = dma service request is disabled  1 = dma service request is enabled" "0,1"
        bitfld.long 0x00 10. "   TSRE          ,transmit service request enable  0 = dma service request is disabled  1 = dma service request is enabled" "0,1"
        textline "                               "
        bitfld.long 0x00 5.--9. "RFT                   ,rxfifo trigger threshold  this field sets the threshold level at which rxfifo asserts interrupt. the level should be set to the preferred threshold value minus 1." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"
        bitfld.long 0x00 0.--4. "        TFT              ,txfifo trigger threshold  this field sets the threshold level at which txfifo asserts interrupt. the level should be set to the preferred threshold value minus 1." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"

group d:0xD401B008++0x03
    line.long 0x00 "SSP_INT_EN,SSP Interrupt Enable Register"
        bitfld.long 0x00 6. " EBCEI                 ,enable bit count error interrupt  0 = interrupt due to a bit count error is disabled  1 = interrupt due to a bit count error is enabled" "0,1"
        bitfld.long 0x00 5. "         TIM              ,transmit fifo underrun interrupt mask  0 = tur events generate an ssp interrupt  1 = tur events do not generate an ssp interrupt" "0,1"
        bitfld.long 0x00 4. "   RIM                   ,receive fifo overrun interrupt mask  0 = ror events generate an ssp interrupt  1 = ror events do not generate an ssp interrupt" "0,1"
        bitfld.long 0x00 3. "   SSP0_TIE61    ,transmit fifo interrupt enable  0 = txfifo threshold-level-reached interrupt is disabled  1 = txfifo threshold-level-reached interrupt is enabled" "0,1"
        textline "                               "
        bitfld.long 0x00 2. "RIE                   ,receive fifo interrupt enable  0 = rxfifo threshold-level-reached interrupt is disabled  1 = rxfifo threshold-level-reached interrupt is enabled" "0,1"
        bitfld.long 0x00 1. "         TINTE            ,receiver time-out interrupt enable  0 = receiver time-out interrupt is disabled  1 = receiver time-out interrupt is enabled" "0,1"
        bitfld.long 0x00 0. "   PINTE                 ,peripheral trailing byte interrupt enable  0 = peripheral trailing byte interrupt is disabled  1 = peripheral trailing byte interrupt is enabled" "0,1"

group d:0xD401B00C++0x03
    line.long 0x00 "SSP_TO,SSP Time Out Register"
        hexmask.long.tbyte 0x00 0.--23. 1. " TIMEOUT               ,timeout value  timeout value is the value (0 to 2<super 24>-1) that defines the time-out interval. the time-out interval is given by the equation shown in the timeout interval equation."

group d:0xD401B010++0x03
    line.long 0x00 "SSP_DATAR,SSP Data Register"
        hexmask.long 0x00 0.--31. 1. " SSP0_DATA88           ,data  this field is used for data to be written to the txfifo read from the rxfifo."

group d:0xD401B014++0x03
    line.long 0x00 "SSP_STATUS,SSP Status Register"
        bitfld.long 0x00 23. " OSS                   ,odd sample status  0 = rxfifo entry has two samples  1 = rxfifo entry has one sample    note that this bit needs to be looked at only when fifo packing is enabled (<fifo packing enable> field in ssp fifo control register is set). otherwise, this bit is zero.  when sspx port is in packed mode and the cpu is used instead of dma to read the rxfifo, the cpu should make sure that <receive fifo not empty> = 1 and this field = 0 before it attempts to read the rxfifo." "0,1"
        bitfld.long 0x00 22. "         TX_OSS           ,tx fifo odd sample status  when sspx port is in packed mode, the number of samples in the tx fifo is:   (<transmit fifo level>*2 + this field), when <transmit fifo not full> = 1  32, when <transmit fifo not full> = 0.  the tx fifo cannot accept new data when <transmit fifo not full> = 1 and <transmit fifo level> = 15 and this field = 1. (the tx fifo has 31 samples).    0 = txfifo entry has an even number of samples  1 = txfifo entry has an odd number of samples  note that this bit needs to be read only when fifo packing is enabled (<fifo packing enable> in the ssp fifo control register is set). otherwise, this bit is zero." "0,1"
        bitfld.long 0x00 21. "   BCE                   ,bit count error  0 = the sspx port has not experienced a bit count error  1 = the sspsfrmx signal was asserted when the bit counter was not zero" "0,1"
        bitfld.long 0x00 20. "   ROR           ,receive fifo overrun  0 = rxfifo has not experienced an overrun  1 = attempted data write to full rxfifo, causes an interrupt request" "0,1"
        textline "                               "
        bitfld.long 0x00 15.--19. "RFL                   ,receive fifo level  this field is the number of entries minus one in rxfifo. when the value 0x1f is read, the rxfifo is either empty or full, and software should read the <receive fifo not empty> field." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"
        bitfld.long 0x00 14. "        RNE              ,receive fifo not empty  0 = rxfifo is empty  1 = rxfifo is not empty" "0,1"
        bitfld.long 0x00 13. "   RFS                   ,receive fifo service request  0 = rxfifo level is at or below rft threshold (rft) or sspx port is disabled  1 = rxfifo level exceeds rft threshold (rft), causes an interrupt request" "0,1"
        bitfld.long 0x00 12. "   TUR           ,transmit fifo underrun  0 = the txfifo has not experienced an underrun  1 = a read from the txfifo was attempted when the txfifo was empty, causes an interrupt if it is enabled (<transmit fifo underrun interrupt mask> in the ssp int en register  is 0)" "0,1"
        textline "                               "
        bitfld.long 0x00 7.--11. "SSP0_TFL106           ,transmit fifo level  this field is the number of entries in txfifo.when the value 0x0 is read, the txfifo is either empty or full, and software should read the <transmit fifo not full> field." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"
        bitfld.long 0x00 6. "        TNF              ,transmit fifo not full  0 = txfifo is full  1 = txfifo is not full" "0,1"
        bitfld.long 0x00 5. "   TFS                   ,transmit fifo service request  0 = tx fifo level exceeds the tft threshold (tft + 1) or sspx port disabled  1 = txfifo level is at or below tft threshold (tft + 1), causes an interrupt request" "0,1"
        bitfld.long 0x00 4. "   SSP0_EOC109   ,end of chain  0 = dma has not signaled an end of chain condition  1 = dma has signaled an end of chain condition" "0,1"
        textline "                               "
        bitfld.long 0x00 3. "TINT                  ,receiver time-out interrupt  0 = no receiver time-out is pending  1 = receiver time-out pending, causes an interrupt request" "0,1"
        bitfld.long 0x00 2. "         PINT             ,peripheral trailing byte interrupt  0 = no peripheral trailing byte interrupt is pending  1 = peripheral trailing byte interrupt is pending" "0,1"
        bitfld.long 0x00 1. "   CSS                   ,clock synchronization status  0 = the sspx port is ready for slave clock operations  1 = the sspx port is currently busy synchronizing slave mode signals" "0,1"
        bitfld.long 0x00 0. "   BSY           ,ssp busy  0 = sspx port is idle or disabled  1 = sspx port is currently transmitting or receiving framed data" "0,1"

group d:0xD401B018++0x03
    line.long 0x00 "SSP_PSP_CTRL,SSP Programmable Serial Protocol Control Register"
        bitfld.long 0x00 27.--29. " EDMYSTOP              ,extended dummy stop  most-significant bits of the dummy stop delay.do not use in psp network mode." "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 25.--26. "         DMYSTOP          ,dummy stop  least-significant bits of the dummy stop delay  programmed value of <extended dummy stop> + this field specifies the number (0-31) of active clocks (sspsclkx) that follow the end of the transmitted data.do not use in psp network mode." "0,1,2,3"
        bitfld.long 0x00 23.--24. "   EDMYSTRT              ,extended dummy start  most-significant bits of the dummy start delay.do not use in psp network mode." "0,1,2,3"
        bitfld.long 0x00 21.--22. "   DMYSTRT       ,dummy start  least-significant bits of the dummy start delay  programmed value of this field specifies the number (0-15) of active clocks (sspsclks) between the end of start delay and when the most-significant bit of transmit/receive data is driven. do not use in psp network mode." "0,1,2,3"
        textline "                               "
        bitfld.long 0x00 18.--20. "STRTDLY               ,start delay  programmed value specifies the number (0-7) of non-active clocks (sspsclkx) that define the duration of idle time. do not use in psp network mode." "0,1,2,3,4,5,6,7"
        hexmask.long.byte 0x00 12.--17. 1. "         SFRMWDTH         ,serial frame width  least-significant bits of the serial frame width  programmed value of this field specifies the frame width from 0x00 (one sspsclkx cycle) to 0x3f (63 sspsclkx cycles)."
        hexmask.long.byte 0x00 5.--11. 1. "  SFRMDLY               ,serial frame delay  programmed value specifies the number (0 -127) of active one-half clocks (sspsclkx) asserted from the most-significant bit of txdx (output) or rxd (input) being driven to sspsfrmx.do not use in psp network mode."
        bitfld.long 0x00 4. "  SFRMP         ,serial frame polarity  0 = sspsfrmx is active low (0x0)  1 = sspsfrmx is active high (0x1)" "0,1"
        textline "                               "
        bitfld.long 0x00 3. "FSRT                  ,frame sync relative timing bit  0 = next frame is asserted after the end of the dmtstop timing  1 = next frame is asserted with the lsb of the previous frame" "0,1"
        bitfld.long 0x00 2. "         ETDS             ,end of transfer data state  0 = low  1 = last value <bit 0>" "0,1"
        bitfld.long 0x00 0.--1. "   SCMODE                ,serial bit-rate clock mode  0x0 = data driven (falling), data sampled (rising), idle state (low)  0x1 = data driven (rising), data sampled (falling), idle state (low)  10 = data driven (rising), data sampled (falling), idle state (high)  0x3 = data driven (falling), data sampled (rising), idle state (high)" "0,1,2,3"

group d:0xD401B01C++0x03
    line.long 0x00 "SSP_NET_WORK_CTRL,SSP Net Work Control Register"
        hexmask.long.byte 0x00 12.--19. 1. " RTSA                  ,rx time slot active, only used in network mode   0 = sspx port does not receive data in this time slot  1 = sspx port receives data in this time slot."
        hexmask.long.byte 0x00 4.--11. 1. "        TTSA             ,tx time slot active, only used in network mode  0 = sspx port does not transmit data in this time slot  1 = sspx port does transmit data in this time slot"
        bitfld.long 0x00 1.--3. "  FRDC                  ,frame rate divider control  value of 0x0-0x7 specifies the number of time slots per frame when in network mode (the actual number of time slots is this field +1, so 1 to 8 time slots can be specified)." "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 0. "   NET_WORK_MOD  ,mode  0 = normal ssp mode  1 = network mode. when set this bit to 1, must make sure at same time ssp_top_ctrl[frf]=0x3" "0,1"

group d:0xD401B020++0x03
    line.long 0x00 "SSP_NET_WORK_STATUS,SSP Net Work Status Register"
        bitfld.long 0x00 3. " NMBSY                 ,network mode busy  0 = sspx port is in network mode and no frame is currently active  1 = sspx port is in network mode and a frame is currently active" "0,1"
        bitfld.long 0x00 0.--2. "         TSS              ,time slot status  value indicates which time slot is currently active. because of synchronization between the sspx port's sspsclkx domain and an internal bus clock domain, the value in this field becomes stable between the beginning and end of the currently active time slot." "0,1,2,3,4,5,6,7"

group d:0xD401B024++0x03
    line.long 0x00 "SSP_RWOT_CTRL,SSP RWOT Control Register"
        bitfld.long 0x00 4. " MASK_RWOT_LAST_SAMPLE ,mask last_sample_flag in rwot mode  1= mask  0 = unmask" "0,1"
        bitfld.long 0x00 3. "         CLR_RWOT_CYCLE   ,clear ssp internal rwot_counter  this field clears the rwot_counter to 0. this field is self cleared by ssp after sse = 1.  1 = clear rwot_counter" "0,1"
        bitfld.long 0x00 2. "   SET_RWOT_CYCLE        ,set rwot cycle  this field is used to set the value of the ssp_rwot_ccm register to the ssp internal rwot_counter. this field is self-cleared by ssp after sse = 1.  1 = set rwot_counter" "0,1"
        bitfld.long 0x00 1. "   CYCLE_RWOT_EN ,enable ssp rwot cycle counter mode  1 = enable" "0,1"
        textline "                               "
        bitfld.long 0x00 0. "RWOT                  ,receive without transmit  0 = transmit/receive mode  1 = receive without transmit mode" "0,1"

group d:0xD401B028++0x03
    line.long 0x00 "SSP_RWOT_CCM,SSP RWOT Counter Cycles Match Register"
        hexmask.long 0x00 0.--31. 1. " SSPRWOTCCM            ,it's just total ssp_sclk_gpio cycles  the value of this register defines the total number of ssp_sclk_gpio cycles when ssp works in master and rwot mode. when the rwot_counter matches this value, ssp returns to idle state and does not output ssp_sclk_gpio anymore."

group d:0xD401B02C++0x03
    line.long 0x00 "SSP_RWOT_CVWRn,SSP RWOT Counter Value Write for Read Request Register"
        hexmask.long 0x00 0.--31. 1. " SSPRWOTCVWR           ,ssprwotcvwr  this register prevents the risk of instability on rwot_counter value reading, it's only valid after ssp has been enabled  write 0 = no effect  write 1 = capture value of rwot_counter  read: returns the captured value of rwot_counter"

tree.end

tree "tcu"

width 24.

group d:0xD0230000++0x03
    line.long 0x00 "TCU_FIFO_INSTR,TCU FIFO Register"
        hexmask.long.word 0x00 0.--15. 1. " FIFO              ,write tcu instructions to tcu fifo"

group d:0xD0230004++0x03
    line.long 0x00 "TCU_NUM_INST,TCU Number Of Instructions Register"
        hexmask.long.byte 0x00 0.--7. 1. " NUM_OF_INSTR      ,number of instructions in fifo"

group d:0xD0230008++0x03
    line.long 0x00 "TCU_STATUS,TCU Status Register"
        bitfld.long 0x00 6. " SHORTWAIT_FAIL    ,shortwait fail  indicates shortwait of n cycles requested when tcu is already more than n cycles into the time tick" "0,1"
        bitfld.long 0x00 5. "         CONCURRENCY_LIMIT ,concurrency limit  indicates too many concurrent instructions" "0,1"
        bitfld.long 0x00 4. "  UNDERFLOW  ,underflow  in the underflow warn state, any instruction that is presented must have a delta time of less than the current value of the delta timer. if not, underflow is set." "0,1"
        bitfld.long 0x00 3. "  UNDERFLOW_WARN ,underflow warn (fifo empty)  delta timer starts counting up and, if the next instruction written has a wait time of less than the timer count at the time it is written, then the system can recover. otherwise, an underflow error occurs." "0,1"
        textline "                                  "
        bitfld.long 0x00 2. "OVERFLOW          ,overflow  indicates that an attempt to write fifo failed because fifo is full" "0,1"
        bitfld.long 0x00 1. "         NEARLY_EMPTY      ,nearly empty  indicates when numinst falls below nearlyempty" "0,1"
        bitfld.long 0x00 0. "  NEARLYFULL ,nearlyfull  indicates when numinst is incremented above nearlyfull" "0,1"

group d:0xD023000C++0x03
    line.long 0x00 "TCU_EXCEPTION_ENABLE,TCU Exception Enable Register"
        hexmask.long.byte 0x00 0.--6. 1. " EXCEPTIONENABLE   ,exceptionenable  this field enables reported exceptions in tcu_status."

group d:0xD0230010++0x03
    line.long 0x00 "TCU_CONTROL,TCU Control Register"
        bitfld.long 0x00 3. " LOGENABLE         ,logenable  allows logging via hslcode port or eventlog register" "0,1"
        bitfld.long 0x00 2. "         FASTSTEP          ,faststep  tcu halts when halt input port is high. in this condition, a write to faststep causes the next tcu instruction to be processed. the wait time is ignored." "0,1"
        bitfld.long 0x00 1. "  FLUSH      ,flush all unexecuted instructions" "0,1"
        bitfld.long 0x00 0. "  APBTC_RESET65  ,software reset to tcu" "0,1"

group d:0xD0230014++0x03
    line.long 0x00 "TCU_NEARLY_FULL_LEVEL,TCU Nearly Full Level Register"
        hexmask.long.byte 0x00 0.--7. 1. " NEARLYFULL_LEVEL  ,nearlyfull level  sets the level for the nearlyfull exception"

group d:0xD0230018++0x03
    line.long 0x00 "TCU_NEARLY_EMPTY_LEVEL,TCU Nearly Empty Level Register"
        hexmask.long.byte 0x00 0.--7. 1. " NEARLYEMPTY_LEVEL ,nearlyempty level  sets the level for the nearlyempty exception"

group d:0xD023001C++0x03
    line.long 0x00 "TCU_WRITE_IDX,TCU Write ID Register"
        hexmask.long.byte 0x00 0.--7. 1. " WRITEIDX          ,writeidx  tcu ram location in which the next event is written by layer 1 by the pbus write cycle"

group d:0xD0230020++0x03
    line.long 0x00 "TCU_READ_IDX,TCU Read ID Register"
        hexmask.long.byte 0x00 0.--7. 1. " READIDX           ,readidx  tcu ram location in which the next event is read by the tcu in preparation for execution"

group d:0xD0230024++0x03
    line.long 0x00 "TCU_PRESCALE,TCU PreScale Register"
        hexmask.long.byte 0x00 0.--7. 1. " APBTC_PRESCALE110 ,prescaler end count  set to n-1 for divide by n.  reset: 0xb or 0x23"

group d:0xD0230028++0x03
    line.long 0x00 "TCU_DELTA_TIMER,TCU DeltaTimer Register"
        hexmask.long 0x00 0.--31. 1. " DELTATIMER        ,deltatimer  this field is used for debug purposes, particularly in the event of an underflow"

group d:0xD0230030++0x03
    line.long 0x00 "TCU_EVENT_LOG,TCU EventLog Register"
        hexmask.long 0x00 0.--31. 1. " EVENTLOG          ,eventlog  when logging is enabled, this register returns the tcu events in 16-bit form."

group d:0xD0230040++0x03
    line.long 0x00 "TCU_CLEAR_GPOA,TCU GPOAClr Register"
        hexmask.long 0x00 0.--31. 1. " GPOACLR           ,gpoaclr  write:  1 = clears gpoa(n) where n is the bit position  read: returns state of gpoa"

group d:0xD0230044++0x03
    line.long 0x00 "TCU_SET_GPOA,TCU GPOASet Register"
        hexmask.long.word 0x00 0.--15. 1. " GPOASET           ,gpoaset  write:  1 = sets gpoa(n) where n is the bit position  read: returns state of gpoa"

group d:0xD0230048++0x03
    line.long 0x00 "TCU_CLEAR_GPOA,TCU GPOBClr Register"
        hexmask.long.word 0x00 0.--15. 1. " GPOBCLR           ,gpobclr  write:  1 = clears gpob(n) where n is the bit position  read: returns state of  gpob"

group d:0xD023004C++0x03
    line.long 0x00 "TCU_SET_GPOB,TCU GPOBSet Register"
        hexmask.long.word 0x00 0.--15. 1. " GPOBSET           ,gpobset  write:  1 = sets gpob(n) where n is the bit position  read: returns state of gpob"

group d:0xD0230400++0x03
    line.long 0x00 "INSTRUCTIONRAM,TCU Instruction RAM Register"
        hexmask.long 0x00 0.--31. 1. " INSTRUCTION_RAM   ,instruction ram  full access provided for debug purposes"

tree.end

tree "timers_apb"

width 12.

group d:0xD4014000++0x03
    line.long 0x00 "TMR_CER,Timers Count Enable Register"
        bitfld.long 0x00 2. " APB_T_T2EN18      ,timer #2 count enable  0 = count is disabled  1 = count is enabled  due to the chain of synchronizers that transform this signal from domain to domain, the timers enable and disable operation does not occur immediately." "0,1"
        bitfld.long 0x00 1. "         APB_T_T1EN19   ,timer #1 count enable  0 = count is disabled  1 = count is enabled  due to the chain of synchronizers that transform this signal from domain to domain, the timers enable and disable operation does not occur immediately." "0,1"
        bitfld.long 0x00 0. "  APB_T_T0EN20   ,timer #0 count enable  0 = count is disabled  1 = count is enabled  due to the chain of synchronizers that transform this signal from domain to domain, the timers enable and disable operation does not occur immediately." "0,1"

group d:0xD4014004++0x03
    line.long 0x00 "TMR_CMR,Timers Count Mode Register"
        bitfld.long 0x00 2. " APB_T_T2MODE29    ,timer #2 count mode  0 = periodic timer mode, timer will re-load if a match hannpen and plcr != 0   1 = free-run mode, wraps around to 0 when it hits 0xffffffff." "0,1"
        bitfld.long 0x00 1. "         APB_T_T1MODE30 ,timer #1 count mode  0 = periodic timer mode, timer will re-load if a match hannpen and plcr != 0  1 = free-run mode, wraps around to 0 when it hits 0xffffffff" "0,1"
        bitfld.long 0x00 0. "  APB_T_T0MODE31 ,timer #0 count mode  0 = periodic timer mode, timer will re-load if a match hannpen and plcr != 0   1 = free-run mode, wraps around to 0 when it hits 0xffffffff" "0,1"

group d:0xD4014008++0x03
    line.long 0x00 "TMR_CRSR,Timer Count Restart register"
        bitfld.long 0x00 2. " T2RS              ,timer #2 count restart  0 = no effect   1 = count is restarted  before write this bit to 1, the other registers should be configed." "0,1"
        bitfld.long 0x00 1. "         T1RS           ,timer #1 count restart  0 = no effect  1 = count is restarted  before write this bit to 1, the other registers should be configed." "0,1"
        bitfld.long 0x00 0. "  T0RS           ,timer #0 count restart  0 = no effect   1 = count is restarted  before write this bit to 1, the other registers should be configed." "0,1"

group d:0xD401400C++0x03
    line.long 0x00 "TMR_CCR,Timer Clock Control Register"
        bitfld.long 0x00 5.--6. " APB_T_CS_252      ,clock source for timer #2  0x0 = fast clock (clock depending on apbc_timers2_clk_rst[6:4])   0x1 = 1 khz  0x2 = 32.768 khz  0x3 = fast clock (clock depending on apbc_timers2_clk_rst[6:4])" "0,1,2,3"
        bitfld.long 0x00 2.--3. "         APB_T_CS_154   ,clock source for timer #1  0x0 = fast clock (clock depending on apbc_timers2_clk_rst[6:4])   0x1 = 32.768 khz  0x2 = 1 khz  0x3 reserved" "0,1,2,3"
        bitfld.long 0x00 0.--1. "  APB_T_CS_055   ,clock source for timer #0  0x0 = fast clock (clock depending on apbc_timers2_clk_rst[6:4])   0x1 = 32.768 khz  0x2 reserved   0x3 = fast clock (clock depending on apbc_timers2_clk_rst[6:4])" "0,1,2,3"

group d:0xD4014010++0x03
    line.long 0x00 "TMR_Tn_Mm0,Timer Match Registers"

group d:0xD4014020++0x03
    line.long 0x00 "TMR_Tn_Mm1,Timer Match Registers"

group d:0xD4014030++0x03
    line.long 0x00 "TMR_Tn_Mm2,Timer Match Registers"
        hexmask.long 0x00 0.--31. 1. " APB_T_TMR_TN_MM62 ,timer n match register m value"

group d:0xD4014040++0x03
    line.long 0x00 "TMR_PLVRn,Timer Preload Value Registers"
        hexmask.long 0x00 0.--31. 1. " APB_T_TPLVRN78    ,timer n preload value that is loaded into tcrn when a match occurs between tmr_tn_tm and tcrn. the corresponding tplcrn register selects the match comparator."

group d:0xD4014050++0x03
    line.long 0x00 "TMR_PLCRn,Timer Preload Control Registers"
        bitfld.long 0x00 2. " CRPD              ,disable preload when counter restart   0x0 = preload the plcr to counter when restart bit is set    = 0x1 disable preload the plcr to counter when restart bit is set" "0,1"
        bitfld.long 0x00 0.--1. "         APB_T_MCS88    ,match comparator select  0x0 = free running mode (up to max value)  0x1 = enable preload with match comparator 0  0x2 = enable preload with match comparator 1  0x3 = enable preload with match comparator 2" "0,1,2,3"

group d:0xD4014060++0x03
    line.long 0x00 "TMR_IERn,Timer Interrupt Enable Registers"
        bitfld.long 0x00 2. " APB_T_IE298       ,interrupt enable for match comparator 2  0 = do not allow a match between match register 2 to its os timer to assert interrupt bit m2 in the corresponding tsrn or assert timer#_irq output  1 = allow a match between match register 2 to its os timer to assert interrupt bit m2 in the corresponding tsrn or assert timer#_irq output" "0,1"
        bitfld.long 0x00 1. "         APB_T_IE199    ,interrupt enable for match comparator 1  0 = do not allow a match between match register 1 to its os timer to assert interrupt bit m1 in the corresponding tsrn or assert timer#_irq output  1 = allow a match between match register 1 to its os timer to assert interrupt bit m1 in the corresponding tsrn or assert timer#_irq output" "0,1"
        bitfld.long 0x00 0. "  APB_T_IE0100   ,interrupt enable for match comparator 0  0 = do not allow a match between match register 0 to its os timer to assert interrupt bit m0 in the corresponding tsrn or assert timer#_irq output  1 = allow a match between match register 0 to its os timer to assert interrupt bit m0 in the corresponding tsrn or assert timer#_irq output" "0,1"

group d:0xD4014070++0x03
    line.long 0x00 "TMR_ICRn,Timer Interrupt Clear Registers"
        bitfld.long 0x00 2. " APB_T_TCLR2110    ,interrupt clear for match comparator 2  write:  0 = no affect  1 = clear level interrupt and corresponding status bit" "0,1"
        bitfld.long 0x00 1. "         APB_T_TCLR1111 ,interrupt clear for match comparator 1  write:  0 = no affect  1 = clear level interrupt and corresponding status bit" "0,1"
        bitfld.long 0x00 0. "  APB_T_TCLR0112 ,interrupt clear for match comparator 0  write:  0 = no affect  1 = clear level interrupt and corresponding status bit" "0,1"

group d:0xD4014080++0x03
    line.long 0x00 "TMR_SRn,Timer Status Registers"
        bitfld.long 0x00 2. " APB_T_M2122       ,match status of tmr_tn_m2  0 = timer match register tmr_tn_m2 has not matched the counter since the last interrupt clear  1 = timer match register tmr_tn_m2 has matched the counter since the last interrupt clear" "0,1"
        bitfld.long 0x00 1. "         APB_T_M1123    ,match status of tmr_tn_m1  0 = timer match register tmr_tn_m1 has not matched the counter since the last interrupt clear  1 = timer match register tmr_tn_m1 has matched the counter since the last interrupt clear" "0,1"
        bitfld.long 0x00 0. "  APB_T_M0124    ,match status of tmr_tn_m0  0 = timer match register tmr_tn_m0 has not matched the counter since the last interrupt clear  1 = timer match register tmr_tn_m0 has matched the counter since the last interrupt clear" "0,1"

group d:0xD4014090++0x03
    line.long 0x00 "TMR_CRn,Timer Count Registers"
        hexmask.long 0x00 0.--31. 1. " APB_T_TCRN137     ,timer n count register  the counter is incremented at the rising edge of the selected clock. these registers have been synchronized to apb clock domain."

group d:0xD40140B0++0x03
    line.long 0x00 "TMR_WFAR,Timers Watchdog First Access Register"
        hexmask.long.word 0x00 0.--15. 1. " KEY151            ,watchdog access key  writing the value of 0xbaba to this register matches the key"

group d:0xD40140B4++0x03
    line.long 0x00 "TMR_WSAR,Timers Watchdog Second Access Register"
        hexmask.long.word 0x00 0.--15. 1. " KEY159            ,watchdog access key  writing the value of 0xeb10 to this register matches the key"

group d:0xD40140B8++0x03
    line.long 0x00 "TMR_WMER,Timers Watchdog Match Enable Register"
        bitfld.long 0x00 1. " APB_T_WRIE167     ,watchdog reset/interrupt enable  0 = watchdog timer expiration generates a watchdog interrupt, a watchdog timer reset is not generated  1 = watchdog timer expiration generates a watchdog timer reset, a watchdog interrupt is not generated" "0,1"
        bitfld.long 0x00 0. "         APB_T_WE168    ,wdt count enable  0 = disable wdt count, reset wdt's value to zero  1 = enable counting, the wdt always starts from zero  due to the chain of synchronizers that transform this signal from domain to domain, the wdt timer enable and disable operation do not occur immediately" "0,1"

group d:0xD40140BC++0x03
    line.long 0x00 "TMR_WMR,Timers Watchdog Match Register"
        hexmask.long.word 0x00 0.--15. 1. " APB_T_WTM177      ,16-bit watchdog timer match"

group d:0xD40140C0++0x03
    line.long 0x00 "TMR_WSR,Timers Watchdog Status Register"
        bitfld.long 0x00 0. " APB_T_WTS186      ,watchdog timer reset indication  indicates that reset was caused by the wdt.  read:  0 = watchdog timer did not cause reset because this bit was cleared  1 = watchdog timer caused reset    write:  0 = clear the wdt reset status  1 = no affect" "0,1"

group d:0xD40140C4++0x03
    line.long 0x00 "TMR_WICR,Timers Watchdog Interrupt Clear Register"
        bitfld.long 0x00 0. " APB_T_WICLR195    ,wdt interrupt clear  write:  0 = no affect  1 = clear interrupt" "0,1"

group d:0xD40140C8++0x03
    line.long 0x00 "TMR_WCR,Timers Watchdog Counter Reset Register"
        bitfld.long 0x00 0. " APB_T_WCR204      ,watchdog timer counter value reset  write:  0 = no effect  1 = clears the value of wdt counter" "0,1"

group d:0xD40140CC++0x03
    line.long 0x00 "TMR_WVR,Timers Watchdog Value Register"
        hexmask.long.word 0x00 0.--15. 1. " APB_T_WTV213      ,watchdog timer value    read the current value of wdt. the value may be read while the register is in transition, so the reading must be completed in a double read procedure and a comparison of the two read values."

tree.end

tree "xirq"

width 17.

group d:0xD0231000++0x03
    line.long 0x00 "SWIENABLE,Software Interrupt xIRQ Enable Set Register"
        hexmask.long.word 0x00 0.--15. 1. " SWI_ENB_SET               ,software interrupt enable  each bit defines the mask status of the corresponding swi xirq number.  0 = no effect  1 = corresponding swi is enabled  reading from this register reflects the mask status of the corresponding swi xirq number."

group d:0xD0231004++0x03
    line.long 0x00 "RIENABLE,Register Interrupt xIRQ Enable Set Register"
        hexmask.long.byte 0x00 0.--7. 1. " RI_ENB_SET                ,register interrupt enable set  each bit defines the mask status of the corresponding ri xirq number.  0 = no effect  1 = corresponding ri is enabled  reading from this register reflects the mask status of the corresponding ri xirq number."

group d:0xD0231008++0x03
    line.long 0x00 "XSWIENABLE,Cross-Assert Interrupt xIRQ Enable Set Register"
        bitfld.long 0x00 0. " XSWI_ENB                  ,cross-assert interrupt enable set  defines the mask status of the corresponding cross-assert xirq number.  0 = corresponding xswi is masked  1 = corresponding xswi is enabled  reading from this register reflects the mask status of the corresponding cross-assert xirq number." "0,1"

group d:0xD023100C++0x03
    line.long 0x00 "EIRQENABLE,Error Interrupt xIRQ Enable Set Register"
        bitfld.long 0x00 0.--2. " EI_ENB_SET                ,error interrupt enable set  each bit defines the mask status of the corresponding ei xirq number.  0 = no effect  1 = corresponding ei is enabled  reading from this register reflects the mask status of the corresponding ei xirq number." "0,1,2,3,4,5,6,7"

group d:0xD0231020++0x03
    line.long 0x00 "HWIENABLEn0,Hardware Interrupt Bank n xIRQ Enable Set Register"

group d:0xD023102C++0x03
    line.long 0x00 "HWIENABLEn1,Hardware Interrupt Bank n xIRQ Enable Set Register"
        hexmask.long.word 0x00 0.--15. 1. " HWI_N_ENB_SET             ,hardware interrupt bank n enable set  each bit defines the mask status of the corresponding hwi xirq number + 16*n. (where n = 0, 1, or 2 for mirq and n = 0, 1, 2, or 3 for airq)  0 = no effect  1 = corresponding hwi is enabled  reading from this register reflects the mask status of the corresponding hwi xirq number."

group d:0xD0231040++0x03
    line.long 0x00 "SWIENABLECLR,Software Interrupt xIRQ Enable Clr Register"
        hexmask.long.word 0x00 0.--15. 1. " SWI_ENB_CLR               ,software interrupt enable clear  each bit defines the mask status of the corresponding swi xirq number.  0 = no effect  1 = corresponding swi is masked  writing 1 sets the corresponding bit in the software interrupt xirq enable set register to 0."

group d:0xD0231044++0x03
    line.long 0x00 "RIENABLECLR,Register Interrupt xIRQ Enable Clr Register"
        hexmask.long.byte 0x00 0.--7. 1. " RI_ENB_CLR                ,register interrupt enable clear  each bit defines the mask status of the corresponding ri xirq number.  0 = no effect  1 = corresponding ri is masked  writing 1 sets the corresponding bit in the register interrupt xirq enable set register to 0."

group d:0xD0231048++0x03
    line.long 0x00 "EIRQENABLECLR,Error Interrupt xIRQ Enable Clr Register"
        bitfld.long 0x00 0.--2. " EI_ENB_CLR                ,error interrupt enable clear  each bit defines the mask status of the corresponding ei xirq number.  0 = no effect  1 = corresponding ei is masked  writing 1 sets the corresponding bit in the error interrupt xirq enable set register to 0." "0,1,2,3,4,5,6,7"

group d:0xD0231060++0x03
    line.long 0x00 "HWIENABLECLRn0,Hardware Interrupt Bank n xIRQ Enable Clr Register"

group d:0xD0231064++0x03
    line.long 0x00 "HWIENABLECLRn1,Hardware Interrupt Bank n xIRQ Enable Clr Register"
        hexmask.long.word 0x00 0.--15. 1. " HWI_N_ENB_CLR             ,hardware interrupt bank n enable clear  each bit defines the mask status of the corresponding hwi xirq number + 16*n. ((n = 0, 1, or 2 for mirq and n = 0, 1, 2, or 3 for airq)  0 = no effect  1 = corresponding hwi is masked  writing 1 sets the corresponding bit in the hardware interrupt bank n xirq enable set register to 0."

group d:0xD0231080++0x03
    line.long 0x00 "CIP,Current Interrupt Priority Register"
        bitfld.long 0x00 0.--3. " CIP                       ,current interrupt priority  when any irq is active, this register reads back the priority level of highest-priority interrupt, in the range 0x0000 (highest) to 0x000f (lowest).  when no irqs are active, this register reads back 0x000f." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"

group d:0xD0231084++0x03
    line.long 0x00 "CIN,Current Interrupt Number Register"
        hexmask.long.byte 0x00 0.--6. 1. " CIN                       ,current interrupt number  when no irq is active, this register reads back 0x007f.  when any irq is active, this register reads back the number of the highest-priority interrupt, in the range 0x0000 to t, where:  t = 16 + 1+ 8 + 3 + n(hwi)-1  (16 swi, 1 xswi, 8 ri, 3 eirq, and gnh hwis)."

group d:0xD0231088++0x03
    line.long 0x00 "AIM,Active Interrupt Mask Register"
        hexmask.long.word 0x00 0.--15. 1. " AIM                       ,active interrupt mask  returns a 16-bit value when read. each set bit indicates that there is an active interrupt at the corresponding priority level, with bit zero indicating level 0 (highest).  the highest-level bit set is used as a priority mask, preventing interrupts at lower priority from passing through onto the nirq output. it can be written directly, however, both read and write accesses are intended for test purposes only."

group d:0xD023108C++0x03
    line.long 0x00 "SYSREG,System Register"
        bitfld.long 0x00 0. " IRQCTRL_RST               ,irqctrl reset flag  this flag must be cleared for normal operation." "0,1"

group d:0xD0231090++0x03
    line.long 0x00 "SWICARRYSTATUS,Software Interrupt Carry Status Register"
        hexmask.long.word 0x00 0.--15. 1. " SWI_CS                    ,software interrupt carry status  each bit, when set, indicates an overflow or underflow of the corresponding swi counter. all bits are ored to generate an internal error swi_eirq, with curintnum = 27  when this register is written to, any bits set in the data value clear the corresponding bit(s) in the register, and clear to zero the corresponding swi counter.  it may be used to clear the counter(s) even if the carry flag is (are) not set."

group d:0xD0231094++0x03
    line.long 0x00 "RICARRYSTATUS,Register Interrupt Carry Status Register"
        hexmask.long.byte 0x00 0.--7. 1. " RI_CS                     ,register interrupt carry status  this bit, when set, indicates an overflow of the ri register. all bits are ored to generate an internal error ri_eirq, with curintnum = 26.  when this register is written to, any bits set in the data value clear the corresponding bit(s) in the register, and clear to zero the corresponding ri register bit(s). it may be used to clear the ri register bit(s) even if the carry flags are not set."

group d:0xD0231098++0x03
    line.long 0x00 "XSWICARRYSTATUS,Cross-Assertion Interrupt Carry Status Register"
        bitfld.long 0x00 0. " XSWI_CS                   ,cross-assertion interrupt carry status  this bit, when set, indicates an overflow or underflow of the xswi counter. this bit is used to generate an internal error xswi_eirq, with curintnum = 25  when this register is written to, any bits set in the data value clear the corresponding bit(s) in the register, and clear to zero the corresponding xswicounter.  it may be used to clear the counter(s) even if the carry flag is not set." "0,1"

group d:0xD023109C++0x03
    line.long 0x00 "CINVALUE,Current Interrupt Number Value Register"
        hexmask.long.byte 0x00 0.--6. 1. " CINV                      ,current interrupt number value  when no irq is active, this register reads back 0x007f.  when any irq is active, this register reads back the number of the highest-priority interrupt, in the range 0x0000 to t, where:  t = [16 + 8+ 1 + 3 + n(hwi)] - 1  (16 swi, 8 ri, 1 xswi, 3 eirq, and gnh hwis)"

group d:0xD02310A0++0x03
    line.long 0x00 "SWIPRIORITYn0,Software Interrupt n Priority Register"

group d:0xD02310DC++0x03
    line.long 0x00 "SWIPRIORITYn1,Software Interrupt n Priority Register"
        bitfld.long 0x00 0.--3. " SWIPN                     ,software interrupt n priority  defines the priority level, 0 to 15" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"

group d:0xD02310E0++0x03
    line.long 0x00 "RIPRIORITYn0,Register Interrupt n Priority Register"

group d:0xD02310FC++0x03
    line.long 0x00 "RIPRIORITYn1,Register Interrupt n Priority Register"
        bitfld.long 0x00 0.--3. " RIPN                      ,register interrupt n priority  defines the priority level, 0 to 15" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"

group d:0xD0231120++0x03
    line.long 0x00 "XSWIPRIORITY,Cross-Assert Interrupt Priority Register"
        bitfld.long 0x00 0.--3. " XSWIP                     ,cross-assert interrupt priority  defines the priority level, 0 to 15" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"

group d:0xD0231140++0x03
    line.long 0x00 "EXSWIPRIORITY,Cross-Assert Error Interrupt Priority Register"
        bitfld.long 0x00 0.--3. " XSWI_EIRQP                ,cross-assert error interrupt priority  defines the priority level, 0 to 15" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"

group d:0xD0231144++0x03
    line.long 0x00 "ERIPRIORITY,Register Error Interrupt Priority Register"
        bitfld.long 0x00 0.--3. " RI_EIRQP                  ,register error interrupt priority  defines the priority level, 0 to 15" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"

group d:0xD0231148++0x03
    line.long 0x00 "ESWPRIORITY,Software Error Interrupt Priority Register"
        bitfld.long 0x00 0.--3. " SWI_EIRQP                 ,software error interrupt priority  defines the priority level, 0 to 15" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"

group d:0xD0231200++0x03
    line.long 0x00 "HWPRIORITYn0,Hardware Interrupt n Priority Register"

group d:0xD02312C0++0x03
    line.long 0x00 "HWPRIORITYn1,Hardware Interrupt n Priority Register"
        bitfld.long 0x00 0.--3. " HWIPN                     ,hardware interrupt n priority  defines the priority level, 0 to 15" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"

group d:0xD0231300++0x03
    line.long 0x00 "MIRQ_DUMMY_READ,MIRQ Dummy Read Register"

group d:0xD0231400++0x03
    line.long 0x00 "SWICOUNTn,Software Interrupt n Count Register"
        bitfld.long 0x00 0.--4. " SWICN                     ,software interrupt n count  number of pending swi 0 irqs from the tcu. swi counter is decremented either when this register is written (any data) or curintnumber read is n.  n = 0, ..., 15" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"

group d:0xD0231440++0x03
    line.long 0x00 "RIREGISTER,RI Register"
        hexmask.long.byte 0x00 0.--7. 1. " RIR                       ,rir  this is an 8-bit register with each bit representing a separate register mirq. if a bit is set, a further attempt to set it triggers an overflow error by the register interrupt carry status register and ri_eirq interrupt.  each bit is reset by writing to the ri status register with the equivalent bit set in the write data.  when this register is written to, any bits set in the data value sets the corresponding bit in the register. these flags are cleared via the ri carry register."

group d:0xD0231460++0x03
    line.long 0x00 "XSWICOUNT,Cross-Assert Interrupt Count Register"
        bitfld.long 0x00 0.--4. " XSWIC                     ,cross-assert interrupt count  number of pending (received) cross-asserted interrupts. it is incremented on a cross-assertion from the other irqctrl instance and decremented when the curintnumber read is 24." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"

group d:0xD0231464++0x03
    line.long 0x00 "XSWIASSERT,Cross-Assert Interrupt Assert Register"
        bitfld.long 0x00 0. " XSWIA                     ,cross-assert interrupt assert  when written to (any value), an interrupt is cross-asserted. this is seen by the other instance of the irqctrl module and reflected by an increment in its xswi count register.  when read, this register reads back zero when it is safe for it to be written to." "0,1"

group d:0xD0231468++0x03
    line.long 0x00 "IRQSTATCTL,IRQ Status Control Register"
        bitfld.long 0x00 0.--1. " IRQSTATCTRL               ,irq status control  bit 0 of this register is a rw bit and can be used to enable or disable the nirq interrupt output of the module.  when set to 0, the nirq output is forced to an inactive state (active low signal).  bit 1 is a read-only bit that reflects the state of the internal nirq pending signal (the nirq output prior to the interrupt enabling gate).  this is intended mainly for debug." "0,1,2,3"

group d:0xD02318F8++0x03
    line.long 0x00 "STIKY_CLR0,AIRQ Interrupt Clear 0 Register"
        hexmask.long 0x00 0.--31. 1. " AIRQ_AIRQ_INT_CLR_0308    ,airq interrupt clear 0  to clear the interrupt sticky-bit, write 1.  there is no need to write 0, since the register clears itself (one-shot).  when level interrupt function is selected, these registers have no effect.  bit [0] refers to interrupt 0, bit [1] refers to interrupt 1, etc."

group d:0xD02318FC++0x03
    line.long 0x00 "STIKY_CLR1,AIRQ Interrupt Clear 1 Register"
        hexmask.long 0x00 0.--31. 1. " AIRQ_AIRQ_INT_CLR_1316    ,airq interrupt clear 1  to clear the interrupt sticky-bit, write 1.  there is no need to write 0, since the register clears itself (one-shot).  when level interrupt function is selected, these registers have no effect.  bit [0] refers to interrupt 32, bit [1] refers to interrupt 33, etc."

group d:0xD02318F0++0x03
    line.long 0x00 "EDGE_OR_LEVEL0,AIRQ Interrupt Sensitivity 0 Register"
        hexmask.long 0x00 0.--31. 1. " AIRQ_AIRQ_EDGE_LEVEL_0324 ,airq edge level 0  0 = originally level-sensitive interrupt (no sticky bit needed)  1 = originally edge-sensitive interrupt (sticky bit needed)  bit [0] refers to interrupt 0, bit [1] refers to interrupt 1, etc."

group d:0xD02318F4++0x03
    line.long 0x00 "EDGE_OR_LEVEL1,AIRQ Interrupt Sensitivity 1 Register"
        hexmask.long 0x00 0.--31. 1. " AIRQ_AIRQ_EDGE_LEVEL_1332 ,airq edge level 1  0 = originally level-sensitive interrupt (no sticky bit needed)  1 = originally edge-sensitive interrupt (sticky bit needed)  bit [0] refers to interrupt 32, bit [1] refers to interrupt 33, and so on."

tree.end

tree "usim"

width 12.

group d:0xD0292000++0x03
    line.long 0x00 "USIM_RBR,USIM Receive Buffer Register"
        bitfld.long 0x00 8. " PERR21           ,parity error  0 = either there was no parity error when receiving the character or the parity bit was masked by the <parity error mask> field in the usim fifo control register  1 = character was received with a parity error" "0,1"
        hexmask.long.byte 0x00 0.--7. 1. "     RB               ,data byte received"

group d:0xD0292004++0x03
    line.long 0x00 "USIM_THR,USIM Transmit Holding Register"
        hexmask.long.byte 0x00 0.--7. 1. " USIM1_TB31       ,data byte to be transmitted, least significant bit first"

group d:0xD0292008++0x03
    line.long 0x00 "USIM_IER,USIM Interrupt Enable Register"
        bitfld.long 0x00 15. " DMA_TX           ,dma transmitter request enable  0 = disabled  1 = enabled" "0,1"
        bitfld.long 0x00 14. "     DMA_RX           ,dma receiver request enable  0 = disabled  1 = enabled" "0,1"
        bitfld.long 0x00 13. "   DMA_TIME        ,enable dma receiver requests in event of time-out situation  0 = disabled  1 = enabled" "0,1"
        bitfld.long 0x00 10. "   SMARTCARD_DET46 ,smartcard detection  0 = disabled  1 = enabled" "0,1"
        textline "                      "
        bitfld.long 0x00 9. "TDR47            ,transmitter data refill interrupt  0 = disabled  1 = enabled" "0,1"
        bitfld.long 0x00 8. "     RDR48            ,receiver data ready interrupt  0 = disabled  1 = enabled" "0,1"
        bitfld.long 0x00 6. "   USIM1_BWT50     ,block waiting time interrupt  0 = disabled  1 = enabled" "0,1"
        bitfld.long 0x00 5. "   CWT51           ,character waiting time interrupt  0 = disabled  1 = enabled" "0,1"
        textline "                      "
        bitfld.long 0x00 4. "TIMEO52          ,receiver time-out interrupt  0 = disabled  1 = enabled" "0,1"
        bitfld.long 0x00 3. "     FRAMERR53        ,framing error interrupt  0 = disabled  1 = enabled" "0,1"
        bitfld.long 0x00 2. "   TOERR54         ,t=0 error interrupt enable  0 = disabled  1 = enabled" "0,1"
        bitfld.long 0x00 1. "   PERR55          ,parity error interrupt enable  0 = disabled  1 = enabled" "0,1"
        textline "                      "
        bitfld.long 0x00 0. "OVRN56           ,receiver data overrun interrupt enable  0 = disabled  1 = enabled" "0,1"

group d:0xD029200C++0x03
    line.long 0x00 "USIM_IIR,USIM Interrupt Identification Register"
        bitfld.long 0x00 10. " SMARTCARD_DET69  ,smartcard detection  0 = no interrupt  1 = interrupt has occurred" "0,1"
        bitfld.long 0x00 9. "     TDR70            ,transmitter data refill interrupt  0 = no interrupt  1 = interrupt has occurred" "0,1"
        bitfld.long 0x00 8. "   RDR71           ,receiver data ready interrupt  0 = no interrupt  1 = interrupt has occurred" "0,1"
        bitfld.long 0x00 6. "   USIM1_BWT73     ,block waiting time interrupt  0 = no interrupt  1 = interrupt has occurred" "0,1"
        textline "                      "
        bitfld.long 0x00 5. "CWT74            ,character waiting time interrupt  0 = no interrupt  1 = interrupt has occurred" "0,1"
        bitfld.long 0x00 4. "     TIMEO75          ,receiver time out interrupt  0 = no interrupt  1 = interrupt has occurred" "0,1"
        bitfld.long 0x00 3. "   FRAMERR76       ,framing error interrupt  0 = no interrupt  1 = interrupt has occurred" "0,1"
        bitfld.long 0x00 2. "   TOERR77         ,t=0 error interrupt  0 = no interrupt  1 = interrupt has occurred" "0,1"
        textline "                      "
        bitfld.long 0x00 1. "PERR78           ,parity error interrupt  0 = no interrupt  1 = interrupt has occurred" "0,1"
        bitfld.long 0x00 0. "     OVRN79           ,receiver data overrun interrupt  0 = no interrupt  1 = interrupt has occurred" "0,1"

group d:0xD0292010++0x03
    line.long 0x00 "USIM_FCR,USIM FIFO Control Register"
        bitfld.long 0x00 8. " TX_TL            ,transmitter interrupt trigger level (threshold)  sets interrupt/dma request trigger threshold for the tx fifo  0= trigger threshold is 0 bytes  1= trigger threshold is 8 bytes" "0,1"
        bitfld.long 0x00 6.--7. "     RX_TL            ,receiver interrupt trigger level (threshold)  set interrupt/dma request trigger threshold for the rx fifo  0x0 = trigger threshold is 1 byte  0x1 = trigger threshold is 4 bytes  0x2 = trigger threshold is 8 bytes  0x3 = trigger threshold is 12 bytes" "0,1,2,3"
        bitfld.long 0x00 3. "   PEM             ,parity error mask  0 = in t=1 mode only, bit 8 of the usim receive buffer register is asserted when a character with a parity error enters the rx fifo  1 = a parity error coming out of the rx fifo is masked and does not appear on bit 8 of the usim receive buffer register. evidence of a parity error can still be found in" "0,1"
        bitfld.long 0x00 2. "   TX_HOLD         ,transmit hold  when this field is 1, transmission stops after the current character has been transmitted. all the remaining characters in the tx fifo are held. transmission resumes when this bit is cleared to 0.  0 = transmission resumes  1 = transmission is stopped" "0,1"
        textline "                      "
        bitfld.long 0x00 1. "USIM1_RESETTF101 ,reset tx fifo  0 = no effect  1 = tx fifo is cleared" "0,1"
        bitfld.long 0x00 0. "     USIM1_RESETRF102 ,reset rx fifo  0 = no effect  1 = rx fifo is cleared" "0,1"

group d:0xD0292014++0x03
    line.long 0x00 "USIM_FSR,USIM FIFO Status Register"
        bitfld.long 0x00 10.--14. " PERR_NUM         ,parity error number  indicates the number of characters with a parity error in the rx fifo." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"
        bitfld.long 0x00 5.--9. "    TX_LENGTH        ,tx fifo length  indicates the number of characters in the tx fifo." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"
        bitfld.long 0x00 0.--4. "  RX_LENGTH       ,rx fifo length  indicates the number of characters in the rx fifo." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31"

group d:0xD0292018++0x03
    line.long 0x00 "USIM_ECR,USIM Error Control Register"
        bitfld.long 0x00 7. " T0_REPEAT        ,repeat character transmission  repeat character transmission until error trigger threshold is met again.  0 = character has been repeated  1 = character repeat in process" "0,1"
        bitfld.long 0x00 6. "     T0_CLR           ,clear t=0 error  0 = t=0 error has been cleared  1 = clearing of t=0 error in process" "0,1"
        bitfld.long 0x00 3.--4. "   PE_TL           ,parity error trigger level  0x0 = reception of a single parity error causes an interrupt to occur, if enabled  0x1 = reception of two consecutive parity errors causes an interrupt to occur, if enabled  0x2 = reception of three consecutive parity errors causes an interrupt to occur, if enabled  0x3 = reception of four consecutive parity errors causes an interrupt to occur, if enabled" "0,1,2,3"
        bitfld.long 0x00 0.--1. "   T0ERR_TL        ,t=0 error trigger level (threshold)  0x0 = reception of single t=0 error causes interrupt request and transmission hold  0x1 = reception of two consecutive t=0 errors causes interrupt request and transmission hold  0x2 = reception of three consecutive t=0 errors causes interrupt request and transmission hold  0x3 = reception of a four consecutive t=0 errors causes interrupt request and transmission hold" "0,1,2,3"

group d:0xD029201C++0x03
    line.long 0x00 "USIM_LCR,USIM Line Control Register"
        bitfld.long 0x00 4. " TX_T1            ,transmitter protocol  0 = t=0 protocol set for the transmitter  1 = t=1 protocol set for the transmitter" "0,1"
        bitfld.long 0x00 3. "     RX_T1            ,receiver protocol  0 = t=0 protocol set for the receiver  1 = t=1 protocol set for the receiver" "0,1"
        bitfld.long 0x00 2. "   USIM1_EPS148    ,even parity select (eps)  when this field is 0, an odd number of 0b1s are transmitted or checked in the data word bits and the parity bit. when this field is 1, an even number of 0b1s are transmitted or checked in the data word bits and parity bit.  0 = sends or checks for odd parity as required by inverse convention  1 = sends or checks for even parity as required by direct convention  see coding conventions section." "0,1"
        bitfld.long 0x00 1. "   ORDER           ,transmit/receive bit order  0 = regular format - lsb of data transmitted/received first (after start bit), msb of data transmitted/received last (and then guard time). this is used in direct convention. see coding conventions section.  1 = inverted format - msb of data transmitted/received first (after start bit), lsb of data transmitted/received last (and then guard time). this is used in inverse convention. see coding conventions section." "0,1"
        textline "                      "
        bitfld.long 0x00 0. "INVERSE          ,bit inversion  0 = 0b0 transmitted/received as vlow, 0b1 transmitted/received as vhigh. this is used in direct convention. see section 15.4.2.  1 = 0b1 transmitted/received as vlow, 0b0 transmitted/received as vhigh. this is used in inverse convention. see coding conventions section." "0,1"

group d:0xD0292020++0x03
    line.long 0x00 "USIM_USCCR,USIM SmartCard Control Register"
        bitfld.long 0x00 4. " TXD_FORCE        ,force txd  this bit always remains 0 unless running a de-activation process. during de-activation, the uio pin (txd) must be forced to vlow before selecting smartcard voltage supply pins to be driven with a lower voltage.  0 = txd indicates transmission  1 = txd is forced to vlow" "0,1"
        bitfld.long 0x00 1.--2. "     VCC              ,smartcard voltage  0x0 = usim smartcard at 0v (gnd)  0x1= usim smartcard at 3v  0x2 = usim smartcard at 1.8v  0x3 = reserved" "0,1,2,3"
        bitfld.long 0x00 0. "   RST_SMARTCARD_N ,smartcard reset  0 = reset the usim smartcard  1 = normal usim smartcard operation" "0,1"

group d:0xD0292024++0x03
    line.long 0x00 "USIM_LSR,USIM Line Status Register"
        bitfld.long 0x00 15. " USIM1_RXD174     ,reflects sampled data from uio pin  0 = uio pin is currently at logic 0b0  1 = uio pin is currently on logic 0b1" "0,1"
        bitfld.long 0x00 14. "     RX_WORKING       ,receiver working  0 = receiver idle  1 = receiver is in process" "0,1"
        bitfld.long 0x00 13. "   TX_WORKING      ,transmitter working  0 = transmitter idle  1 = transmitter in process" "0,1"
        bitfld.long 0x00 12. "   RX_EMPTY_N      ,rx fifo not empty  0 = rx fifo is empty  1 = rx fifo is not empty" "0,1"
        textline "                      "
        bitfld.long 0x00 11. "TDR178           ,transmitter data refill  0 = number of characters in the tx fifo is at or above the <transmitter interrupt trigger level (threshold)> field in the usim fifo control register  1 = number of characters in the tx fifo is less than the <transmitter interrupt trigger level (threshold)> field" "0,1"
        bitfld.long 0x00 6. "     USIM1_BWT180     ,block waiting time (bwt)  0 = bwt timeout period is not over  1 = bwt timeout period is over" "0,1"
        bitfld.long 0x00 5. "   CWT181          ,character waiting time (cwt)  0 = cwt timeout period is not over  1 = cwt timeout period is over" "0,1"
        bitfld.long 0x00 4. "   TIMEO182        ,receiver time out  0 = tor timeout period is not over  1 = tor timeout period is over" "0,1"
        textline "                      "
        bitfld.long 0x00 3. "FRAMERR183       ,framing error  0 = framing error has not occurred  1 = framing error has occurred" "0,1"
        bitfld.long 0x00 2. "     TOERR184         ,t=0 error  0 = during transmission, the number of consecutive t=0 errors did not meet the repetition trigger level, <t=0 error trigger level (threshold)> field in the usim error control register  1 = during transmission, the number of consecutive t=0 errors met the repetition trigger level, <t=0 error trigger level (threshold)> field" "0,1"
        bitfld.long 0x00 1. "   PERR185         ,parity error  0 = during reception, the number of consecutive parity errors did not met the repetition trigger threshold, <parity error trigger level> field in the usim error control register  1 = during reception, the number of consecutive parity errors met the repetition trigger threshold, <parity error trigger level>" "0,1"
        bitfld.long 0x00 0. "   OVRN186         ,receiver data overrun error  0 = overrun error has not occurred  1 = overrun error has occurred" "0,1"

group d:0xD0292028++0x03
    line.long 0x00 "USIM_EGTR,USIM Extra Guard Time Register"
        hexmask.long.byte 0x00 0.--7. 1. " EGTM             ,extra guard time moments  number of extra guard time moments, 0 to 255."

group d:0xD029202C++0x03
    line.long 0x00 "USIM_BGTR,USIM Block Guard Time Register"
        hexmask.long.byte 0x00 0.--7. 1. " BGT              ,block guard time  number of total block-guard time moments."

group d:0xD0292030++0x03
    line.long 0x00 "USIM_TOR,USIM Time-Out Register"
        hexmask.long.byte 0x00 0.--7. 1. " TO               ,time out  number of total timeout moments."

group d:0xD0292034++0x03
    line.long 0x00 "USIM_CLKR,USIM Clock Register"
        bitfld.long 0x00 15. " STOP_CLK_USIM    ,stop usim controller internal clock  0 = starts the usim controller internal clock, clk_usim  1 = stops the usim controller internal clock. does not stop the clock that controls the usim controller registers." "0,1"
        bitfld.long 0x00 14. "     STOP_LEVEL       ,stop level  0 = uclk stops on low  1 = uclk stops on high" "0,1"
        bitfld.long 0x00 13. "   STOP_UCLK       ,stop smartcard clock  0 = starts the uclk clock  1 = stops the uclk clock" "0,1"
        bitfld.long 0x00 12. "   RQST            ,clock change request  0 = request not occurring, this register may be updated  1 = request occurring, do not update this register" "0,1"
        textline "                      "
        hexmask.long.byte 0x00 0.--7. 1. "DIVISOR246       ,clock divisor  the uclk frequency is 48 mhz/divisor. a value of 0x0 results in unpredictable behavior."

group d:0xD0292038++0x03
    line.long 0x00 "USIM_DLR,USIM Divisor Latch Register"
        hexmask.long.word 0x00 0.--15. 1. " DIVISOR257       ,baud divisor  determines the number of internal usim cycles between samples, forcing the total length of a bit to be divisor*(factor+1)*(usim_cycle). the value of divisor must not be set to 0x0."

group d:0xD029203C++0x03
    line.long 0x00 "USIM_FLR,USIM Factor Latch Register"
        hexmask.long.byte 0x00 0.--7. 1. " FACTOR           ,baud factor  determines the number of samples per bit. number of samples would be (factor + 1). iso standard demands minimum of 6 samples, therefore, 5 is the minimum value for this field."

group d:0xD0292040++0x03
    line.long 0x00 "USIM_CWTR,USIM Character Waiting Time Register"
        hexmask.long.word 0x00 0.--15. 1. " CWT277           ,character waiting time  number of total character waiting-time moments"

group d:0xD0292044++0x03
    line.long 0x00 "USIM_BWTR,USIM Block Waiting Time Register"
        hexmask.long.word 0x00 0.--15. 1. " USIM1_BWT287     ,block waiting time  number of total block waiting-time moments"

tree.end

tree "usb_utmi(otg phy)"

width 19.

group d:0xD4207000++0x03
    line.long 0x00 "PLL_CTRL0,USB2 PHY PLL Register"
        bitfld.long 0x00 31. " PLL_READY                     ,pll ready  0 = pll not locked  1 = pll locked" "0,1"
        bitfld.long 0x00 30. "         R_ROTATE               ,rotate select  0 = control is rotated by 90 degrees  1 = reference resistor is parallel with the pad" "0,1"
        bitfld.long 0x00 28.--29. "     SEL_LPFR             ,select lpfr  0x0 = frefclk/refdiv[6:0] = 4 mhz to 5 mhz range  0x1 = frefclk/refdiv[6:0] is in 2 mhz to 2.5 mhz range  0x2 = frefclk/refdiv[6:0] is in 1 mhz to 1.25 mhz range  11 = reserved" "0,1,2,3"
        hexmask.long.word 0x00 16.--24. 1. "     FBDIV                   ,feedback clock divider select  0x00 to 0x0f = invalid  0x10 to 0x1ff = divided by 16 to 511 directly  default is set for 40 mhz refclk. if a refclk frequency other than 40 mhz is used, this value must be changed before powering up the pll."
        textline "                             "
        bitfld.long 0x00 14.--15. "VDDL                          ,pll 1.1v regulator output voltage control  0x0 = vdd  0x1 = 0.9v  0x2 = 1.0v  0x3 =1.1v" "0,1,2,3"
        bitfld.long 0x00 12.--13. "         VDDM                   ,1.8v regulator voltage control  0x0 = 1.7v  0x1 = 1.8v  0x2 = 1.9v  0x3 = 2.0v" "0,1,2,3"
        bitfld.long 0x00 8.--11. "     ICP                  ,pll charge-pump current select  icp[3:0] icp  0x0 = 15 <mu>a  0x1 = 20 <mu>a  0x2 = 25 <mu>a  0x3 = 30 <mu>a  0x4 = 35 <mu>a  0x5 = 40 <mu>a  0x6 = 45 <mu>a  0x7 = 50 <mu>a" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        hexmask.long.byte 0x00 0.--6. 1. "    REFDIV                  ,reference clock divider select  0x0 = bypass, equivalent to divided by 1  0x1 = invalid  0x2 = divided by 2  0x3 to 0x7f = divided by 3 to 127  default is set for 40 mhz refclk. if a refclk frequency other than 40 mhz is used, this value must be changed before powering up the pll."

group d:0xD4207004++0x03
    line.long 0x00 "PLL_CTRL1,PLL Control Register 1"
        bitfld.long 0x00 14. " PLL_STRESS_TEST               ,stress test mode  0 = normal mode  1 = stress test mode" "0,1"
        bitfld.long 0x00 13. "         CLK_BLK_EN             ,480 mhz clock block enable to avoid overshooting issue  0 = when lock detect and kvco calibration done, sent the clock out  1 = always sent clock out" "0,1"
        bitfld.long 0x00 12. "     REFCLK_SEL           ,refclk select  0 = choose refclkc_in1 for usb2 phy  1 = choose refclkc_in2" "0,1"
        bitfld.long 0x00 11. "     CLK160M_EN              ,160 mhz clock dig_clk160m output enable  1 = 160 mhz clock is enabled. it will output refclk before pll is locked or 160 mhz after pll is locked.  0 = 160 mhz clock is disabled" "0,1"
        textline "                             "
        bitfld.long 0x00 10. "TXCLK_EN                      ,enable 480 mhz clock output  0=disabled, no txclk 480mhz output  1=enabled" "0,1"
        bitfld.long 0x00 4.--7. "         TESTMON_PLL            ,controls test_pin analog test point  for marvell internal use only. default is high-z" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 3. "    PLL_SUSPEND_EN       ,pll suspend enable  0 = pll power is not affected by suspend  1 = suspendm is allowed to power down pll  for multi-port phy, if this field is 1 in all channels, suspend = 0 will power off pll, otherwise, pll power will not be affected by suspend" "0,1"
        bitfld.long 0x00 2. "     PLL_RESET               ,pll reset  0 = use por_reset to reset pll  1 = reset pll" "0,1"
        textline "                             "
        bitfld.long 0x00 1. "PU_PLL_BY_REG                 ,power up pll  0 = power up pll by pu_pll port  1 = power up pll by pu_pll register bit" "0,1"
        bitfld.long 0x00 0. "         PU_PLL42               ,power up  0 = power down usb phy pll  1 = power up usb phy pll  if suspendm from all channels are asserted and pll_suspend_en is 1, then pll will be powered off automatically even pu is 1. in addition, pll is always controlled by pin in scan mode. pll is always off in iddq_test mode." "0,1"

group d:0xD4207008++0x03
    line.long 0x00 "CALIBRATION_CTRL1,Calibration Control Register"
        bitfld.long 0x00 31. " PLLCAL_DONE                   ,pll calibration done  1 = pll calibration is done  0 = not done" "0,1"
        bitfld.long 0x00 28.--30. "         CURRENT_KVCO           ,kvco value currently used" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 24.--27. "     CURRENT_IMP          ,current imp value" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 23. "    IMPCAL_DONE             ,impedance calibration done  1 = impedance calibration is done  0 = not done" "0,1"
        textline "                             "
        bitfld.long 0x00 22. "PLLCAL_START                  ,pll calibration start  control kvco calibration for pll, every 0 to 1 transition will start vco calibration and keep this bit 1 unless you want to calibrate again. it is better to use vco calibration to cover all process corners." "0,1"
        bitfld.long 0x00 20.--21. "         PLLCAL                 ,change pll vco calibration voltage  0x0 = vdd  0x1 = 1.0v (default)  0x2 = 1.05v  0x3 = 1.1v" "0,1,2,3"
        bitfld.long 0x00 19. "     KVCO_EXT             ,select kvco control signal kvco_cal[2:0]  0 = select calibration kvco  1 = select register control kvco[2:0]" "0,1"
        bitfld.long 0x00 16.--18. "     UTM_KVCO56              ,pll kvco control  0x0 = high kvco  ...  0x7 = low kvco  this field is only valid if kvco_ext = 1." "0,1,2,3,4,5,6,7"
        textline "                             "
        bitfld.long 0x00 15. "VCOCAL_POL                    ,vcocal polarity  0 = use up/down signal from analog part  1 = invert up/down signal polarity" "0,1"
        bitfld.long 0x00 14. "         IMPCAL_POL             ,impcal polarity  0 = use up/down signal from analog part  1 = invert up/down signal polarity" "0,1"
        bitfld.long 0x00 13. "     IMPCAL_START         ,impedance calibration start  control impedance calibration, every 0 to 1 transition will start impedance calibration and keep this bit 1 unless you want to calibrate again,it is better to use impedance calibration to cover all process corners." "0,1"
        bitfld.long 0x00 12. "     EXT_RCAL_EN             ,impedance calibration enable control  0 = use the auto calibration results  1 = use the value set by ext_rcal[3:0]" "0,1"
        textline "                             "
        bitfld.long 0x00 11. "EXT_FS_IMP_EN                 ,fs impedance calibration enable control  0 = use the auto calibration results  1 = use the value set by ext_fs_imp[3:0]" "0,1"
        bitfld.long 0x00 8.--10. "         IMPCAL_VTH             ,impedance calibration threshold setting  vth[2:0] impedance  0x0 = 900/16 = 56 ohms  0x1 = 900/17 = 53 ohms  ...  0x4 = 900/20 = 45 ohms  ...  0x7 = 900/23 = 39 ohms  each product must tune this register respectively. in hs mode, with 45 ohm termination on dp/dm. sweep register setting to make sepp equal to 400 mv." "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 4.--7. "     EXT_RCAL             ,ext_rcal  refer to ext_fs_imp[3:0]" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 0.--3. "    EXT_FS_IMP              ,tx fs driver impedance adjusting for hs loading  target is 45 ohms  imp_cal[3:0] impedance (se)  0x0 = 900/12 = 75 ohms  0x1 = 900/13 = 69 ohms  0x2 = 900/14 = 64 ohms  …  0x8 = 900/20 = 45 ohms  …  0xf = 900/27 = 33 ohms  this is only used in testing mode, where reg_ex_fs_rcal_en = 1." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"

group d:0xD420700C++0x03
    line.long 0x00 "USB2_TX_0,Tx Channel Control Register 0"
        bitfld.long 0x00 25. " PU_BY_REG                     ,power control  0 = tx/rx channel power is controlled by pu_phyx port  1 = power is controlled by pu_ana register bit  the power is always controlled by pu_phyx pin in scan mode" "0,1"
        bitfld.long 0x00 24. "         PU_ANA                 ,power up tx/rx channel analog part  1 = power up tx/rx channel analog part  0 = turn it off" "0,1"
        bitfld.long 0x00 23. "     PU_VDDR18            ,reserved for analog part" "0,1"
        bitfld.long 0x00 20.--22. "     AMP                     ,tx output driver amplitude control  amp[2:0]  i (total) amp  0x0 = 12.6 ma 283.5 mv  0x1 = 14.4 ma 324.0 mv  0x2 = 16.2 ma 364.5 mv  0x3 = 18.0 ma 405.0 mv  0x4 = 19.8 ma 445.5 mv  0x5 = 21.6 ma 486.0 mv  0x6 = 23.4 ma 526.5 mv  0x7 = 25.2 ma 567.0 mv  from icc current" "0,1,2,3,4,5,6,7"
        textline "                             "
        bitfld.long 0x00 16.--19. "IMP_SEL_LS                    ,ls tx driver fine adjustment  this field controls 15 cells of the 27 ls tx driver cells. the total number of driver cells enabled is the sum of the cells enabled by drv_en_ls and by imp_sel_ls  for example, if drv_en_ls = 0x3 (enables 6 cells) and imp_sel_ls = 0x1 (enables 1 cell), the total number of ls driver cells is 7  imp_cal[3:0]  ls drive cell control  0x0 = no cell on  0x1 = 1 cell on  0x2 = 2 cells on  ...  0xf = 15 cells on" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 12.--15. "        DRV_EN_LS              ,ls tx driver strength coarse control  the whole ls driver includes 27 driver cells. drv_en_ls[3:0] controls 12 cells with granularity of 3 cells, imp_sel_ls[3:0] control 15 cells with granularity of 1 cell. according to chip test result, around 7 driver cells are optimal for ls eye.  0x1 = 3 programmable cell on  0x3 = 6 programmable cell on  0x7 = 9 programmable cell on  0xf = 12 programmable cell on  marvell recommends changing this field to 0x1 by software after power up. but still need to tune for optimal setting for ls eye with test result." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 8.--11. "    FSDRV_EN             ,fs driver enable  the whole fs driver includes 12 programmable driver cell and 15 calibration driver cell.  0x1 = 3 programmable cell on  0x3 = 6 programmable cell on  0x7 = 9 programmable cell on  0xf = 12 programmable cell on" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 6. "    LOWVDD_EN               ,low vdd enable  the design supports low regulator voltage for hs drive, when the regulator voltage for hs drive is low, the driver requires larger device.  0 = for 1.6v  1 = for 1.5v" "0,1"
        textline "                             "
        bitfld.long 0x00 4.--5. "HS_SR_SEL                     ,rise/fall time of hs transmitter control  0x00 = shortest rise/fall  0x11 = longest rise/fall" "0,1,2,3"
        bitfld.long 0x00 0.--3. "         HSDRV_EN               ,hs driver enable  the whole hs driver has been split into 4 small drivers. each register of sdrv_en[3:0] controls 1 small driver." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"

group d:0xD4207010++0x03
    line.long 0x00 "USB2_TX_1,Tx Channel Control Register 1"

group d:0xD4207014++0x03
    line.long 0x00 "USB2_RX_0,Rx Channel Control Register 0"
        bitfld.long 0x00 29. " CHIRPMODE_SEL                 ,chirp mode selection  0 = normal chirp mode  1 = special chirp mode  marvell recommends normal chirp mode for normal usb operation." "0,1"
        bitfld.long 0x00 28. "         SQ_ANA_DTC_SEL         ,analog squelch detect enable  0 = disable analog squelch detect  1 = enable analog squelch detect" "0,1"
        bitfld.long 0x00 26.--27. "     SQ_ANA_VREF          ,analog squelch detect reference voltage  0x0 = dp/dm valley voltage plus 55 mv  0x1 = dp/dm valley voltage plus 60 mv  0x2 = dp/dm valley voltage plus 65 mv  0x3 = dp/dm valley voltage plus 70 mv" "0,1,2,3"
        bitfld.long 0x00 25. "     RESET_EXT               ,register reset signal  0 = no reset  1 = reset" "0,1"
        textline "                             "
        bitfld.long 0x00 24. "RESET_EXT_EN                  ,reset signal select  0 = select internal reset signal  1 = select reset_ext register" "0,1"
        bitfld.long 0x00 20.--23. "         TESTMON                ,controls test_pin analog test point" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 19. "    STRESS_TEST_MODE     ,stress test mode  1 = stress test mode  0 = normal mode" "0,1"
        bitfld.long 0x00 16. "     SQ_VHL_SEL              ,sq threshold select  0 = vosl  1 = vosh" "0,1"
        textline "                             "
        bitfld.long 0x00 15. "SQ_DET_EN                     ,sq enable" "0,1"
        bitfld.long 0x00 14. "         SQ_CM_SEL              ,squelch and non-squelch threshold common mode  voltage moves down 120 mv to 240 mv." "0,1"
        bitfld.long 0x00 12.--13. "     SQ_DLY_SEL           ,sq delay select  0x0 = no delay  0x1 = delay 1 clock  0x2 = delay 2 clocks  0x3 = delay 3 clocks" "0,1,2,3"
        bitfld.long 0x00 10. "     LINESTATE_EN            ,linestate enable  always set to 1" "0,1"
        textline "                             "
        bitfld.long 0x00 8.--9. "DISCON_THRESH                 ,host disconnect detector threshold select  thresh[1:0] vh (mv)  0x0 = 260  0x1 = 270  0x2 = 280  0x3 = 290  the envelope detector circuits only use half amplitude of the single-ended signal to compare with the threshold." "0,1,2,3"
        bitfld.long 0x00 6.--7. "         RXVDDL                 ,rx regulator output voltage control  0x0 = vdd  0x1 = 1.1v  0x2 =1.2v  0x3 = 1.3v" "0,1,2,3"
        bitfld.long 0x00 4.--5. "     RXVDD18              ,1.8v regulator voltage control" "0,1,2,3"
        bitfld.long 0x00 0.--3. "     SQ_THRESH               ,squelch and un-squelch threshold select  th[3:0] vos v100h v150h vosl vosh (mv)  0x0 = 480 640 652.5 160 172.5  0x1 = 320 480 492.5 160 172.5  0x2 = 450 600 612.5 150 162.5  0x3 =300 450 462.5 150 162.5  0x4 =  420 560 572.5 140 152.5  0x5 = 280 420 432.5 140 152.5  0x6 = 390 520 532.5 130 142.5  0x7 = 260 390 402.5 130 142.5  0x8 = 360 480 492.5 120 132.5  0xa = 330 440 452.5 110 122.5  0xc = 300 400 412.5 100 112.5  0xd = 200 300 312.5 100 112.5  0xe = 270 360 372.5 90 102.5  0xf 180 270 282.5 90 102.5  vosh is the nominal squelch threshold. all other columns are for internal information only." "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"

group d:0xD4207018++0x03
    line.long 0x00 "USB2_RX_1,Rx Channel Control Register 1"
        bitfld.long 0x00 31. " REG_SQCAL_DONE                ,squelch calibration done  this field indicates whether squelch calibration is done or not.  0 = not done  1 = done" "0,1"
        bitfld.long 0x00 6.--7. "         SQ_DPDM_AMP_SEL        ,sq threshold select  0x0 = 130 mv  0x1 = 140 mv  0x2 = 150 mv  0x3 = 160 mv" "0,1,2,3"
        bitfld.long 0x00 5. "     REG_SQ_UD_SWAP       ,invert analog squelch calibration up/down signal polarity  0 = don’t invert  1 = invert" "0,1"
        bitfld.long 0x00 4. "     REG_SQCAL_START         ,squelch calibration start  every rising edge of this register bit starts squelch calibration." "0,1"
        textline "                             "
        bitfld.long 0x00 3. "EXT_SQ_AMP_CAL_EN             ,external squelch calibration enable" "0,1"
        bitfld.long 0x00 0.--2. "         EXT_SQ_AMP_CAL         ,external squelch calibration number" "0,1,2,3,4,5,6,7"

group d:0xD420701C++0x03
    line.long 0x00 "USB_DIG_0,Digital Control Register 0"
        bitfld.long 0x00 31. " BITSTAFFING_ERROR             ,hs bit stuffing error flag  write 1 to clear." "0,1"
        bitfld.long 0x00 30. "         LOSS_OF_SYNC_ERROR     ,hs loss of sync error flag  write 1 to clear" "0,1"
        bitfld.long 0x00 29. "     FIFO_OVF_ERROR       ,hs rx fifo overflow error flag  write 1 to clear." "0,1"
        bitfld.long 0x00 26. "     CORE_UTMI_SEL           ,utmi signal select  0 = allow reg_lat_utmi to work, actual utmi signals are not updated during packet is transferring  1 = always use utmi signals from controller.  this is the same as previous version." "0,1"
        textline "                             "
        bitfld.long 0x00 25. "SE1_FILT_SEL                  ,linestate se1 filter select  0 = filter se1  1 = don’t filter" "0,1"
        bitfld.long 0x00 24. "         SE0_FILT_SEL           ,linestate se0 filter select  0 = filter se0  1 = don’t filter" "0,1"
        bitfld.long 0x00 23. "     EDGE_OPT_EN          ,edge optimization selection  0 = no edge optimization  1 = optimize edge" "0,1"
        bitfld.long 0x00 22. "     STOP_AT_RXERR           ,stop at rx_error selection  this field is used to select to stop rx when rx_error is detected or not.  0 = rx_active will last until sq = 1  1 = rx_active is de-asserted after rx error is found. the early_tx_enable bit must be set to 0." "0,1"
        textline "                             "
        bitfld.long 0x00 21. "RX_RUNAWAY_EN                 ,rx run away enable  this field disables rx run away in case eop is not detected.  0 = rx run away is eliminated  1 = rx run away is allowed" "0,1"
        bitfld.long 0x00 20. "         LOSSOFSYNC_EN          ,loss of sync enable  this field enables loss of sync error to propagate to loss_of_sync_error register.  0 = disable  1 = enable" "0,1"
        bitfld.long 0x00 19. "     FIFOOVF_EN           ,fifo overflow error enable  this field enables fifo overflow error to propagate to rx_error.  0 = fifo_ovf will not assert rx_error  1 = enable" "0,1"
        bitfld.long 0x00 16.--18. "     SQ_FILT                 ,sq glitch filtering width select  this eliminates the glitch when sq = 0.  0x0 = no filtering  0x1 = filter 2 bits glitch  0x2 = filter 4 bits glitch  0x3 = filter 6 bits glitch  0x4 = filter 8 bits glitch  0x5 = filter 10 bits glitch  0x6 = filter 12 bits glitch  0x7 = filter 14 bits glitch" "0,1,2,3,4,5,6,7"
        textline "                             "
        bitfld.long 0x00 12.--14. "SQ_BLK                        ,sq block  this field is used to set the hs data bits to block after sq falling edge.  0x0 = no blocking  0x1 = block 1 bit  0x2 = block 2 bits  0x3 = block 3 bits  0x4 = block 4 bits  0x5 = block 5 bits  0x6 = block 6 bits  0x7 = block 7 bits  the blocked data bits are ignored." "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 11. "         EARLY_TX_ENABLE        ,early tx enable  0 = after controller asserts tx_valid, phy will check usb bus squelch status. if it is squelch, tx will start immediately, otherwise, it will wait for squelch.  1 = hs tx will start after controller asserts tx_valid" "0,1"
        bitfld.long 0x00 10. "     RXFILT2_EN           ,rx filter 2 enable  0 = no filter2  1 = enable rx data sample filter2  data 001100 is corrected to 000000.  data 110011 is corrected to 111111" "0,1"
        bitfld.long 0x00 9. "     RXFILT1_EN              ,rx filter 1 enable  0 = no filter1  1 = enable rx data sample filter1  data 010 is corrected to 000.  data 101 is corrected to 111" "0,1"
        textline "                             "
        bitfld.long 0x00 8. "LONG_EOP                      ,long hs eop  compatible to old controller, hs eop is 40 bits long." "0,1"
        bitfld.long 0x00 7. "         UTM_PLL_LOCK_BYPASS155 ,pll lock bypass  0 = output clk_out after pll is locked  1 = output clk_out after pll is on" "0,1"
        bitfld.long 0x00 6. "     CLK_SUSPEND_EN       ,clock suspend  0 = clk_out will be free-running clock  1 = enable utmi_suspendm to stop clk_out" "0,1"
        bitfld.long 0x00 5. "     HOST_DISCON_SEL1        ,host disconnect select 1  0 = enable suspend to gate off host_disconnect  1 = suspend does not gate off host_disconnect" "0,1"
        textline "                             "
        bitfld.long 0x00 4. "HOST_DISCON_SEL0              ,host disconnect select 0  0 = sample hs_disconnect at the end of sof eop only  1 = sample hs_disconnect during the whole sof eop" "0,1"
        bitfld.long 0x00 3. "         SYNCDET_WINDOW_EN      ,sync detection window enable  this field defines a time window after non-squelch as sync detection period.  0 = detect sync as long as squelch = 0  1 = detect sync in the first 64 or 40 hs bits time after squelch = 0" "0,1"
        bitfld.long 0x00 2. "     SYNCDET_WIN32        ,sync detect window select  0 = 64-bit window after sq = 0  1 = 40-bit window after sq = 0" "0,1"
        bitfld.long 0x00 0.--1. "     SYNC_NUM                ,minimum sync detect number of bits  0x0 = 00  0x1 = 0010  0x2 = 001010  0x3 = 00101010" "0,1,2,3"

group d:0xD4207020++0x03
    line.long 0x00 "USB2_DIG_1,Digital Control Register 1"
        bitfld.long 0x00 30. " REG_LSIDLE_PRE                ,fs/ls idle  0 = to drive fs idle after pre is sent  1 = to drive ls idle after pre is sent" "0,1"
        hexmask.long.byte 0x00 22.--29. 1. "         REG_CLK_OUT_DLY        ,clk_out delay  to set clk_out delay after analog part is powered up or suspendm rising edge. clk_out will start to output xcvr_clk after delay defined by this register.  0x0 = no delay  0x1 = delay by 256 hs bit time  0x2 = delay by 512 hs bit time  0xbc = about 100.25 <mu>s  0xff = about 136 <mu>s"
        bitfld.long 0x00 21. "    REG_SAMPLER_PREOFF   ,sampler pre shutoff  when reg_sampler_on=0, this bit controls if the sampler is turned off 2 hs bits before tx_enable=1  0 = sampler is off at tx_enable rising edge  1 = sampler is off 2 hs bits before tx_enable" "0,1"
        bitfld.long 0x00 20. "     REG_SAMPLER_ON          ,sampler control  to control if the sampler is always on or under register control.  0 = the rx sampler is controlled by reg_sampler_preoff and reg_sampleroff_dly [3:0]  1 = force sampler always on" "0,1"
        textline "                             "
        bitfld.long 0x00 16.--19. "REG_SAMPLEROFF_DLY            ,sampler off bits  when reg_sampler_on is 0, this bit controls the bits the sampler is turned off after tx_enable is 0. each step controls 2 hs bits off.  0x0 = sampler is turned on at tx_enable falling edge  0x1 = sampler is turned on 2 hs bits after tx_enable falling edge  0x8 = sampler is turned on 16 hs bits after tx_enable falling edge  0xf = sampler is turned on 30 hs bits after tx_enable falling edge" "0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15"
        bitfld.long 0x00 15. "        REG_SWAP_DPDM          ,swap dp/dm pad control  0 = dp/dm pads work as usb d+, d-  1 = dp/dm pads work as usb d-, d+" "0,1"
        bitfld.long 0x00 14. "     REG_LAT_UTMI         ,latch utmi xcvr_select, opmode, and term_select signals  0 = do not latch  1 = latch except during suspend" "0,1"
        bitfld.long 0x00 13. "     REG_OPMODE_SEL          ,opmode select  0 = use opmode from usb controller directly  1 = use opmode at tx_valid rising edge" "0,1"
        textline "                             "
        bitfld.long 0x00 12. "REG_FLSMODELP_EN              ,fs/ls serial mode low power enable  0 = do not enable fs/ls serial mode low power  1 = enable" "0,1"
        bitfld.long 0x00 11. "         REG_FREERUNCLK_EN      ,static enable for free running clock output  0 = free running clock is disabled  1 = free running clock is enabled" "0,1"
        bitfld.long 0x00 10. "     REG_NOVBUS_DPDM00    ,dp/dm pull  when vbus is off:  0 = does not pull-down dp/dm pads  1 = pull-down dp/dm pads to 0  when vbus is off, dp/dm is pulled low by default" "0,1"
        bitfld.long 0x00 7. "     REG_FS_EOP_MODE         ,enable 1–3 se0 fs eop detection" "0,1"
        textline "                             "
        bitfld.long 0x00 6. "REG_DP_PULLDOWN               ,pull-down dp  0 = no dp pull-down (default)  1 = manual dp pull-down" "0,1"
        bitfld.long 0x00 5. "         REG_DM_PULLDOWN        ,pull-down dm  0 = no dm pull-down (default)  1 = manual dp pull-down" "0,1"
        bitfld.long 0x00 4. "     REG_ARC_DPDM_MODE    ,use dp_pulldown and dm_pulldown from usb controller  0 = use register programmed pull-down  1 = user usb controller pull-down (default)" "0,1"
        bitfld.long 0x00 3. "     REG_FS_RX_ERROR_MODE2   ,disable multiple fs_rx_error within packet" "0,1"
        textline "                             "
        bitfld.long 0x00 2. "REG_FS_RX_ERROR_MODE1         ,enable fast fs_rx_error return to 0  valid only with reg_rx_error_mode is 1." "0,1"
        bitfld.long 0x00 1. "         REG_FS_RX_ERROR_MODE   ,enable fs rx_error return to 0 at 1 fs bit time" "0,1"
        bitfld.long 0x00 0. "     REG_FORCE_END_EN     ,force rx_active enable  this field is used to enable force rx_active to 0 when there are consecutive bit-stuff errors with length over 14fs bits time." "0,1"

group d:0xD4207024++0x03
    line.long 0x00 "USB2_TEST_0,USB2 Test Control Register 0"
        bitfld.long 0x00 31. " TEST_FAIL                     ,test error flag  0 = error not occurred  1 = error occurred  this flag must be read after test_done changes from 0 to 1. otherwise the read value is undefined." "0,1"
        bitfld.long 0x00 30. "         TEST_DONE              ,test finish indicator  0 = test not finished  1 = test finished  if test_done is not asserted after the time it should have been set, it is also a failed chip." "0,1"
        bitfld.long 0x00 29. "     REG_TEST_EN          ,test enable  1 = start loopback test" "0,1"
        bitfld.long 0x00 28. "     REG_TEST_DIG_LPBK       ,enable digital loopback  0 = analog loopback  1 = digital loopback" "0,1"
        textline "                             "
        bitfld.long 0x00 27. "REG_TEST_ANA_LPBK             ,enable analog loopback test mode" "0,1"
        bitfld.long 0x00 26. "         REG_TEST_BYPASS        ,enable bypass mode (bypass bitstuff/encoder)" "0,1"
        bitfld.long 0x00 25. "     REG_TEST_UTMI_SEL    ,enable utmi test registers  test_tx_bitstuff_en, test_suspendm, test_reset, test_term_select, test_xcvr_select, test_opmode.  this bit must be set to 0 for normal operation mode." "0,1"
        bitfld.long 0x00 23. "     REG_TEST_TX_BITSTUFF_EN ,utmi test mode tx_bitstuff_en" "0,1"
        textline "                             "
        bitfld.long 0x00 22. "REG_TEST_SUSPENDM             ,utmi test mode suspendm" "0,1"
        bitfld.long 0x00 21. "         REG_TEST_RESET         ,utmi test mode reset" "0,1"
        bitfld.long 0x00 20. "     REG_TEST_TERM_SELECT ,utmi test mode term_select" "0,1"
        bitfld.long 0x00 18.--19. "     REG_TEST_XVCR_SELECT    ,utmi test mode xcvr_select" "0,1,2,3"
        textline "                             "
        bitfld.long 0x00 16.--17. "REG_TEST_OP_MODE              ,utmi test mode op_mode" "0,1,2,3"
        bitfld.long 0x00 12.--14. "         REG_TEST_SKIP          ,digital loopback starting position  0x0 = no rotation  0x1 = rotate by 1-bit  0x2 = rotate by 2-bit  0x3 = rotate by 3-bit  0x4 = rotate by 4-bit  0x5 = rotate by 5-bit  0x6 = rotate by 6-bit  0x7 = rotate by 7-bit" "0,1,2,3,4,5,6,7"
        bitfld.long 0x00 8.--9. "     REG_TEST_MODE        ,programmable predefined tx pattern  0x0 = use tx_pattern register  0x1 = incremental pattern. 00, 01, 02, …, ff, 00  0x2 = circular pattern = 01->02->04->08->10->20->40->80->01  0x3= prbs pattern" "0,1,2,3"
        hexmask.long.byte 0x00 0.--7. 1. "     REG_TEST_TX_PATTERN     ,programmable tx pattern  for 16-bit mode, bits[15:8] pattern is the same as bits[7:0]. this pattern register is used when test_mode[1:0]=2’b00"

group d:0xD4207028++0x03
    line.long 0x00 "USB2_TEST_1,USB2 Test Control Register 1"
        hexmask.long.word 0x00 0.--10. 1. " TEST_LEN                      ,loopback test length  this is a new register for v2.0. the loopback test length can be any number of bytes from 1 to 2047.  0x00 = non-stop loopback test  0x01 to 0x7ff = 1 byte to 2047 bytes  it is recommended not to run loopback test longer than 1024 bytes."

group d:0xD420702C++0x03
    line.long 0x00 "RSVD1,Reserved"
        hexmask.long.word 0x00 16.--31. 1. " USB_MON                       ,usb2 phy mon_bus read out."
        hexmask.long.word 0x00 0.--15. 1. "      UTM_231                ,reserved for future use"
        hexmask.long.word 0x00 0.--15. 1. "  REG_MON_SEL          ,phy_mon digital test bus select"

group d:0xD4207030++0x03
    line.long 0x00 "RSVD2,Reserved"

group d:0xD4207034++0x03
    line.long 0x00 "USB2_OTG,USB2OTG Control Register"
        bitfld.long 0x00 5. " OTG_CONTROL_BY_PIN            ,otg control by pin  1 = otg power is controlled by pu pin. pu pin also controls rx/tx channel power  0=otg power is controlled by register bit pu_otg" "0,1"
        bitfld.long 0x00 4. "         PU_OTG                 ,power up otg  1= power up otg module if otg_by_pin=0  0=power down otg module if otg_by_pin=0  otg module is automatically turned off in iddq test mode or scan mode" "0,1"
        bitfld.long 0x00 0.--2. "     TESTMON_OTG          ,otg analog dc testing output control register  it is forced to 0x0 in scan mode inside the phy bit[2:0] otg_tp value  0x0 or 0x1 = hz  0x4 = vbus_limit up to 1.2v  0x5 = v1p0 1.0v  0x6 = vpbs18 1.08v at tt, 1.8v  0x7 = vbus_quarter 1.25v at vbus=5v" "0,1,2,3,4,5,6,7"

group d:0xD4207038++0x03
    line.long 0x00 "USB2_CHGDTC,USB2Charger Detector Control Register"
        bitfld.long 0x00 13. " ENABLE_SWITCH_DM              ,control connection between charge detect circuit and dm port  0 = turn off the switch  1 = turn on the switch" "0,1"
        bitfld.long 0x00 12. "         ENABLE_SWITCH_DP       ,control connection between charge detect circuit and dp port  0 = turn off the switch  1 = turn on the switch" "0,1"
        bitfld.long 0x00 10.--11. "     VSRC_CHARGE          ,controlled vsrc reference voltage  0x0 =  0.55v  0x1 = 0.6v (default)  0x2 = 0.65v  0x3 = 0.7v" "0,1,2,3"
        bitfld.long 0x00 8.--9. "     VDAT_CHARGE             ,controlled vdat reference voltage  0x0 = 0.3v  0x1 = 0.325v (default)  0x2 = 0.35v  0x3 = 0.4v" "0,1,2,3"
        textline "                             "
        bitfld.long 0x00 7. "CDP_DM_AUTO_SWITCH            ,dm control  1 = automatic turn on dm(d_minus) port switch when chg_dtc_out=1. this is for cdp detection only.  0 = dm switch still controlled by enable_switch_dm" "0,1"
        bitfld.long 0x00 6. "         DP_DM_SWAP_CTRL        ,dp/dm swap control  this bit is used for the charger detector.  0 = for portable device use. d+ is driven to 0.6v and d- is used to detect charger present or not.  1 = for downstream port charging. d- is driven to 0.6v and d+ is used to detect charger present or not" "0,1"
        bitfld.long 0x00 5. "     PU_CHRG_DTC          ,power-up signal for charge detect circuit  it is forced to 0 in scan mode or iddq test mode.  1 = power on  0 = power off  it is forced off in scan mode" "0,1"
        bitfld.long 0x00 4. "     PD_EN                   ,portable device mode  1 = to turn on portable device mode  0 = turn off  it is forced off in scan mode" "0,1"
        textline "                             "
        bitfld.long 0x00 3. "DCP_EN                        ,dedicated charger port mode  1 = to turn on dedicated charger port mode  0 = turn off  it is forced off in scan mode" "0,1"
        bitfld.long 0x00 2. "         CDP_EN                 ,charging downstream port mode  1 = to turn on charging downstream port mode  0 = turn off  it is forced off in scan mode" "0,1"
        bitfld.long 0x00 0.--1. "     TESTMON_CHRGDTC      ,analog dc test control signal for charge detector  it is forced to  in scan mode.  0x0 = tri-state at test_pin  0x1 = vref_0p6v 0.6v  0x2 = vdat_ref 0.325v  0x3 = chrg_dtc_out “0 or dvdd”" "0,1,2,3"

group d:0xD420703C++0x03
    line.long 0x00 "RSVD3,Reserved"

group d:0xD42070C0++0x03
    line.long 0x00 "IP_REVISION,IP Revision Register"
        hexmask.long.word 0x00 16.--31. 1. " PHY_IP_REVISION               ,read ip_revision[15:0]"
        hexmask.long.word 0x00 0.--15. 1. "      IP_REVISION            ,read phy_ip_revision[15:0]"

group d:0xD42070C4++0x03
    line.long 0x00 "USB_CTL,USB Control Register"
        bitfld.long 0x00 30. " M_VBUSVALID_M_BVALID_M_AVALID ,m_vbusvalid/m_bvalid/m_avalid control  whether use vbusvalid/bvalid/avalid from phy or register control:  bit [30] = 1, use usb_ctl[29]/[28]/[27] to control m_vbusvalid/m_bvalid/m_avalid seperatly   bit [30] = 0, use vbusvalid/bvalid/avalid from otg phy to m_vbusvalid/m_bvalid/m_avalid seperatly" "0,1"
        bitfld.long 0x00 29. "         M_VBUSVALID            ,m_vbusvalid control:   bit [29] = 1, m_vbusvalid =1,  bit [29] = 0, m_vbusvalid =0. only valid when usb_ctl[30]=1." "0,1"
        bitfld.long 0x00 28. "     M_BVALID             ,m_bvalid control:   bit [28] = 1, m_bvalid =1,  bit [28] = 0, m_bvalid =0. only valid when usb_ctl[30]=1." "0,1"
        bitfld.long 0x00 27. "     M_AVALID                ,m_avalid control:   bit [27] = 1, m_avalid =1,   bit [27] = 0, m_avalid =0. only valid when usb_ctl[30]=1." "0,1"
        textline "                             "
        bitfld.long 0x00 26. "VBUSVALID295                  ,phy vbus_on control :  bit [26] = 1,use m_avalid to control vbus_on  bit [26] = 0, don't us m_avalid to control vbus_on" "0,1"
        bitfld.long 0x00 25. "         VBUSVALID296           ,phy vbus_on control :  bit [25] = 1,use m_bvalid to control vbus_on  bit [25] = 0, don't us m_bvalid to control vbus_on" "0,1"
        bitfld.long 0x00 24. "     VBUSVALID297         ,phy vbus_on control :  bit [24] = 1,use m_vbusvalid to control vbus_on  bit [24] = 0, don't us m_vbusvalid to control vbus_on" "0,1"
        bitfld.long 0x00 12.--13. "     VBUS_ON                 ,phy vbus_on control :  bit [12] = 1, use bit[13] to control otg phy vbus_on  bit [12] = 0, use hw m_vbusvalid or m_bvalid or m_avalid  to vbus_on, according to bit[26:24] set." "0,1,2,3"
        textline "                             "
        bitfld.long 0x00 11. "OTG_SUSPENDM_EN               ,suspendm from otg controller will effect otg phy suspendm or not 1: when otg controller suspendm is not indicate phy suspend, phy will not suspend. when otg controller suspendm want phy suspend, then if phy suspend or not depend on icusb sph controller 0: suspendm of ogt phy will not be effected by otg controller" "0,1"
        bitfld.long 0x00 10. "         REG_XCVR_SELECT_1      ,register control to phy interface xcvr_select_1" "0,1"
        bitfld.long 0x00 8. "     REG_SEL              ,register select  1 = register bit used to control otg phy utmi  0 = controller controls otg phy utmi" "0,1"
        bitfld.long 0x00 6.--7. "     REG_OPMODE              ,register control to phy interface op_mode" "0,1,2,3"
        textline "                             "
        bitfld.long 0x00 5. "REG_TERM_SELECT               ,register control to phy interface term_select" "0,1"
        bitfld.long 0x00 4. "         REG_XCVR_SELECT_0      ,register control to phy interface xcvr_select_0" "0,1"
        bitfld.long 0x00 2.--3. "     TEST_USB_MODE        ,internal debug mode" "0,1,2,3"
        bitfld.long 0x00 1. "     PU_PLL308               ,control to otg phy pu_pll pin" "0,1"
        textline "                             "
        bitfld.long 0x00 0. "UTM_PU309                     ,control to otg phy pu pin and pu_otg pin" "0,1"

group d:0xD42070C8++0x03
    line.long 0x00 "USB_INT_MISC,USB Int Misc Register"
        bitfld.long 0x00 6. " CHRG_INT_CLR                  ,otg phy charge detection interrupt clear  1 = clear chrg detection interrupt  this bit will automatically return to 0 after programming to 0" "0,1"
        bitfld.long 0x00 5. "         CHRG_INT_EN            ,otg phy charger detection interrupt enable" "0,1"
        bitfld.long 0x00 4. "     CHRG_DTC_OUT         ,otg phy output chrg_dtc_out  chrg_dtc_out can reflect on this register bit" "0,1"
        bitfld.long 0x00 3. "     UTM_RESUME_INT320       ,usb resume interrupt status" "0,1"
        textline "                             "
        bitfld.long 0x00 2. "VBUSDTC_OUT                   ,otg phy output vbusdtc_out  vbusdtc_out can reflect on this register bit" "0,1"
        bitfld.long 0x00 1. "         USB_RESUME_INT_EN      ,usb resume interrupt enable" "0,1"
        bitfld.long 0x00 0. "     CORE_INTERRUPT       ,core interrupt  core interrupt is reflected on this register bit" "0,1"

group d:0xD42070CC++0x03
    line.long 0x00 "DBG_CTL,Debug Control Register"
        hexmask.long 0x00 0.--31. 1. " DBG_SEL                       ,used for cw debug signal selection"

group d:0xD42070D0++0x03
    line.long 0x00 "A_PHY1,A PHY 1 Register"
        bitfld.long 0x00 10. " CLK_SEL                       ,pwrctl 32k clock selection  1 = use 32k clock for pwrctl  0 = use otg phy output 60m clock" "0,1"
        bitfld.long 0x00 8. "         UTM_XCVR_UDRDIS341     ,xcvr clock disable. 1= xcvr_clk sent to usb2 otg controller will be invalid" "0,1"
        bitfld.long 0x00 6.--7. "     SRAM_RTC             ,software control to sram rtc" "0,1,2,3"
        bitfld.long 0x00 4.--5. "     SRAM_WTC                ,software control to sram wtc" "0,1,2,3"
        textline "                             "
        bitfld.long 0x00 3. "PU_SRAM_CTL                   ,1: usb resume will valid pu_pll pin of otg phy" "0,1"
        bitfld.long 0x00 2. "         INT_MASK_SEL           ,usb interrupt mask select  1 = usb interrupt will be masked when there is no upstream write cycle and usb interrupt is low  0 = usb interupt will be sent out directly" "0,1"
        bitfld.long 0x00 1. "     SRAM_PDWN            ,software ccontrol to sram powerdown" "0,1"

group d:0xD42070D4++0x03
    line.long 0x00 "A_PHY2,A PHY 2 Register"
        bitfld.long 0x00 0. " TX_BITSTUFF_EN                ,control otg phy pin tx_bitstuff_en" "0,1"

tree.end

