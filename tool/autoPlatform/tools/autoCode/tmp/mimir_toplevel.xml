<?xml version="1.0" encoding="UTF-8"?>
<!--
//============================================================================
//   The confidential and proprietary information contained in this file may
//   only be used by a person authorised under and to the extent permitted
//   by a subsisting licensing agreement from ARM Limited or its affiliates.
//
//          (C) COPYRIGHT 2015-2016 ARM Limited or its affiliates.
//              ALL RIGHTS RESERVED
//
//   This entire notice must be reproduced on all copies of this file
//   and copies of this file may only be made by a person if such person is
//   permitted to do so under the terms of a subsisting license agreement
//   from ARM Limited or its affiliates.
//============================================================================
-->
<spirit:component xmlns:spirit="http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009 http://www.spiritconsortium.org/XMLSchema/SPIRIT/1685-2009/index.xsd">
   <spirit:vendor>arm.com</spirit:vendor>
   <spirit:library>Mali</spirit:library>
   <spirit:name>mimir_toplevel</spirit:name>
   <spirit:version>r0p0-00eac0</spirit:version>
   <spirit:busInterfaces>
      <spirit:busInterface>
         <spirit:name>AXI4_Slave</spirit:name>
         <spirit:description>Interface for reading and writing control and discovery signals to the GPU</spirit:description>
         <spirit:busType spirit:library="AMBA4" spirit:name="AXI4" spirit:vendor="amba.com" spirit:version="r0p0_0" />
         <spirit:abstractionType spirit:library="AMBA4" spirit:name="AXI4_rtl" spirit:vendor="amba.com" spirit:version="r0p0_0" />
         <spirit:slave>
	   <spirit:memoryMapRef spirit:memoryMapRef="AXI4_Slave" />
	 </spirit:slave>
         <spirit:portMaps>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ACLKEN</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>ACLKENS</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ARVALID</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>ARVALIDS</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ARREADY</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>ARREADYS</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ARADDR</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>ARADDRS</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ARLEN</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>ARLENS</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ARCACHE</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>ARCACHES</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ARID</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>ARIDS</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ARSIZE</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>ARSIZES</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ARBURST</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>ARBURSTS</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ARLOCK</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>ARLOCKS</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ARPROT</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>ARPROTS</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ARUSER</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>ARUSERS</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>RVALID</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>RVALIDS</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>RREADY</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>RREADYS</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>RDATA</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>RDATAS</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>RRESP</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>RRESPS</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>RLAST</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>RLASTS</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>RID</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>RIDS</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>RUSER</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>RUSERS</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>AWVALID</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>AWVALIDS</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>AWREADY</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>AWREADYS</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>AWADDR</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>AWADDRS</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>AWLEN</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>AWLENS</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>AWCACHE</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>AWCACHES</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>AWID</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>AWIDS</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>AWSIZE</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>AWSIZES</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>AWBURST</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>AWBURSTS</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>AWLOCK</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>AWLOCKS</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>AWPROT</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>AWPROTS</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>AWUSER</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>AWUSERS</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>WVALID</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>WVALIDS</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>WREADY</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>WREADYS</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>WDATA</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>WDATAS</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>WLAST</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>WLASTS</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>WUSER</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>WUSERS</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>BVALID</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>BVALIDS</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>BREADY</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>BREADYS</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>BRESP</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>BRESPS</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>BID</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>BIDS</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>BUSER</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>BUSERS</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ACLK</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>CLK</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ARESETn</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>RESETn</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>WSTRB</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>WSTRBS</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
         </spirit:portMaps>
         
      </spirit:busInterface>
      <spirit:busInterface>
         <spirit:name>interrupt_Master_EVENT</spirit:name>
         <spirit:description>EVENT Interrupt</spirit:description>
         <spirit:busType spirit:library="generic" spirit:name="interrupt" spirit:vendor="arm.com" spirit:version="r0p0_0" />
         <spirit:abstractionType spirit:library="generic" spirit:name="interrupt_rtl" spirit:vendor="arm.com" spirit:version="r0p0_0" />
         <spirit:master />
         <spirit:portMaps>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>IRQ</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>IRQEVENT</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>CLK</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>CLK</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
         </spirit:portMaps>
         
      </spirit:busInterface>
      <spirit:busInterface>
         <spirit:name>interrupt_Master_JOB</spirit:name>
         <spirit:description>JOB Interrupt</spirit:description>
         <spirit:busType spirit:library="generic" spirit:name="interrupt" spirit:vendor="arm.com" spirit:version="r0p0_0" />
         <spirit:abstractionType spirit:library="generic" spirit:name="interrupt_rtl" spirit:vendor="arm.com" spirit:version="r0p0_0" />
         <spirit:master />
         <spirit:portMaps>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>IRQ</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>IRQJOB</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>CLK</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>CLK</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
         </spirit:portMaps>
         
      </spirit:busInterface>
      <spirit:busInterface>
         <spirit:name>interrupt_Master_MMU</spirit:name>
         <spirit:description>MMU Interrupt</spirit:description>
         <spirit:busType spirit:library="generic" spirit:name="interrupt" spirit:vendor="arm.com" spirit:version="r0p0_0" />
         <spirit:abstractionType spirit:library="generic" spirit:name="interrupt_rtl" spirit:vendor="arm.com" spirit:version="r0p0_0" />
         <spirit:master />
         <spirit:portMaps>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>IRQ</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>IRQMMU</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>CLK</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>CLK</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
         </spirit:portMaps>
         
      </spirit:busInterface>
      <spirit:busInterface>
         <spirit:name>interrupt_Master_GPU</spirit:name>
         <spirit:description>GPU Interrupt</spirit:description>
         <spirit:busType spirit:library="generic" spirit:name="interrupt" spirit:vendor="arm.com" spirit:version="r0p0_0" />
         <spirit:abstractionType spirit:library="generic" spirit:name="interrupt_rtl" spirit:vendor="arm.com" spirit:version="r0p0_0" />
         <spirit:master />
         <spirit:portMaps>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>IRQ</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>IRQGPU</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>CLK</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>CLK</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
         </spirit:portMaps>
         
      </spirit:busInterface>
      <spirit:busInterface>
         <spirit:name>ACE_Master_0</spirit:name>
         <spirit:description>ACE Master port</spirit:description>
         <spirit:busType spirit:library="AMBA4" spirit:name="ACE" spirit:vendor="amba.com" spirit:version="r0p0_0" />
         <spirit:abstractionType spirit:library="AMBA4" spirit:name="ACE_rtl" spirit:vendor="amba.com" spirit:version="r0p0_0" />
         <spirit:master>
         <spirit:addressSpaceRef spirit:addressSpaceRef="mimir" />
         </spirit:master>
         <spirit:portMaps>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ACLKEN</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>ACLKENM0</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>AWREADY</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>AWREADYM0</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>AWVALID</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>AWVALIDM0</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>AWID</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>AWIDM0</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>AWADDR</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>AWADDRM0</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>AWLEN</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>AWLENM0</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>AWSIZE</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>AWSIZEM0</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>AWBURST</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>AWBURSTM0</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>AWLOCK</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>AWLOCKM0</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>AWCACHE</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>AWCACHEM0</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>AWPROT</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>AWPROTM0</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>AWQOS</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>AWQOSM0</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>AWSNOOP</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>AWSNOOPM0</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>AWDOMAIN</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>AWDOMAINM0</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>AWBAR</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>AWBARM0</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>WREADY</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>WREADYM0</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>WVALID</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>WVALIDM0</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>WDATA</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>WDATAM0</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>WSTRB</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>WSTRBM0</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>WLAST</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>WLASTM0</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>BREADY</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>BREADYM0</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>BVALID</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>BVALIDM0</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>BID</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>BIDM0</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>BRESP</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>BRESPM0</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>WACK</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>WACKM0</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ARREADY</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>ARREADYM0</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ARVALID</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>ARVALIDM0</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ARID</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>ARIDM0</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ARADDR</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>ARADDRM0</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ARLEN</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>ARLENM0</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ARSIZE</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>ARSIZEM0</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ARBURST</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>ARBURSTM0</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ARLOCK</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>ARLOCKM0</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ARCACHE</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>ARCACHEM0</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ARPROT</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>ARPROTM0</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ARQOS</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>ARQOSM0</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ARSNOOP</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>ARSNOOPM0</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ARDOMAIN</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>ARDOMAINM0</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ARBAR</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>ARBARM0</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>RREADY</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>RREADYM0</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>RVALID</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>RVALIDM0</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>RID</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>RIDM0</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>RRESP</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>RRESPM0</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>RDATA</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>RDATAM0</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>RLAST</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>RLASTM0</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>RACK</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>RACKM0</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ACREADY</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>ACREADYM0</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ACVALID</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>ACVALIDM0</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ACPROT</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>ACPROTM0</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ACSNOOP</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>ACSNOOPM0</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>CRREADY</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>CRREADYM0</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>CRVALID</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>CRVALIDM0</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>CRRESP</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>CRRESPM0</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>CDREADY</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>CDREADYM0</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>CDVALID</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>CDVALIDM0</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>CDDATA</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>CDDATAM0</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>CDLAST</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>CDLASTM0</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ACLK</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>CLK</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ARESETn</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>RESETn</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ACADDR</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>ACADDRM0</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
         </spirit:portMaps>
         
      </spirit:busInterface>
      <spirit:busInterface>
         <spirit:name>ACE_Master_1</spirit:name>
         <spirit:description>ACE Master port</spirit:description>
         <spirit:busType spirit:library="AMBA4" spirit:name="ACE" spirit:vendor="amba.com" spirit:version="r0p0_0" />
         <spirit:abstractionType spirit:library="AMBA4" spirit:name="ACE_rtl" spirit:vendor="amba.com" spirit:version="r0p0_0" />
         <spirit:master>
         <spirit:addressSpaceRef spirit:addressSpaceRef="mimir" />
         </spirit:master>
         <spirit:portMaps>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ACLKEN</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>ACLKENM1</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>AWREADY</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>AWREADYM1</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>AWVALID</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>AWVALIDM1</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>AWID</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>AWIDM1</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>AWADDR</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>AWADDRM1</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>AWLEN</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>AWLENM1</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>AWSIZE</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>AWSIZEM1</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>AWBURST</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>AWBURSTM1</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>AWLOCK</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>AWLOCKM1</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>AWCACHE</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>AWCACHEM1</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>AWPROT</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>AWPROTM1</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>AWQOS</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>AWQOSM1</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>AWSNOOP</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>AWSNOOPM1</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>AWDOMAIN</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>AWDOMAINM1</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>AWBAR</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>AWBARM1</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>WREADY</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>WREADYM1</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>WVALID</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>WVALIDM1</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>WDATA</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>WDATAM1</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>WSTRB</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>WSTRBM1</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>WLAST</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>WLASTM1</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>BREADY</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>BREADYM1</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>BVALID</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>BVALIDM1</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>BID</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>BIDM1</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>BRESP</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>BRESPM1</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>WACK</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>WACKM1</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ARREADY</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>ARREADYM1</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ARVALID</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>ARVALIDM1</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ARID</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>ARIDM1</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ARADDR</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>ARADDRM1</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ARLEN</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>ARLENM1</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ARSIZE</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>ARSIZEM1</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ARBURST</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>ARBURSTM1</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ARLOCK</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>ARLOCKM1</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ARCACHE</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>ARCACHEM1</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ARPROT</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>ARPROTM1</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ARQOS</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>ARQOSM1</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ARSNOOP</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>ARSNOOPM1</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ARDOMAIN</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>ARDOMAINM1</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ARBAR</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>ARBARM1</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>RREADY</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>RREADYM1</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>RVALID</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>RVALIDM1</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>RID</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>RIDM1</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>RRESP</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>RRESPM1</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>RDATA</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>RDATAM1</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>RLAST</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>RLASTM1</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>RACK</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>RACKM1</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ACREADY</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>ACREADYM1</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ACVALID</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>ACVALIDM1</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ACADDR</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>ACADDRM1</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ACPROT</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>ACPROTM1</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ACSNOOP</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>ACSNOOPM1</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>CRREADY</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>CRREADYM1</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>CRVALID</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>CRVALIDM1</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>CRRESP</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>CRRESPM1</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>CDREADY</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>CDREADYM1</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>CDVALID</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>CDVALIDM1</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>CDDATA</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>CDDATAM1</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>CDLAST</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>CDLASTM1</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ACLK</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>CLK</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ARESETn</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>RESETn</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
         </spirit:portMaps>
         
      </spirit:busInterface>
      <spirit:busInterface>
         <spirit:name>ACE_Master_2</spirit:name>
         <spirit:description>ACE Master port</spirit:description>
         <spirit:busType spirit:library="AMBA4" spirit:name="ACE" spirit:vendor="amba.com" spirit:version="r0p0_0" />
         <spirit:abstractionType spirit:library="AMBA4" spirit:name="ACE_rtl" spirit:vendor="amba.com" spirit:version="r0p0_0" />
        <spirit:master>
         <spirit:addressSpaceRef spirit:addressSpaceRef="mimir" />
         </spirit:master>
         <spirit:portMaps>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ACLKEN</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>ACLKENM2</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>AWREADY</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>AWREADYM2</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>AWVALID</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>AWVALIDM2</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>AWID</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>AWIDM2</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>AWADDR</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>AWADDRM2</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>AWLEN</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>AWLENM2</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>AWSIZE</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>AWSIZEM2</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>AWBURST</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>AWBURSTM2</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>AWLOCK</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>AWLOCKM2</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>AWCACHE</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>AWCACHEM2</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>AWPROT</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>AWPROTM2</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>AWQOS</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>AWQOSM2</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>AWSNOOP</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>AWSNOOPM2</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>AWDOMAIN</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>AWDOMAINM2</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>AWBAR</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>AWBARM2</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>WREADY</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>WREADYM2</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>WVALID</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>WVALIDM2</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>WDATA</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>WDATAM2</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>WSTRB</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>WSTRBM2</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>WLAST</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>WLASTM2</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>BREADY</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>BREADYM2</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>BVALID</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>BVALIDM2</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>BID</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>BIDM2</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>BRESP</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>BRESPM2</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>WACK</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>WACKM2</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ARREADY</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>ARREADYM2</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ARVALID</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>ARVALIDM2</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ARID</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>ARIDM2</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ARADDR</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>ARADDRM2</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ARLEN</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>ARLENM2</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ARSIZE</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>ARSIZEM2</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ARBURST</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>ARBURSTM2</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ARLOCK</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>ARLOCKM2</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ARCACHE</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>ARCACHEM2</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ARPROT</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>ARPROTM2</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ARQOS</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>ARQOSM2</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ARSNOOP</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>ARSNOOPM2</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ARDOMAIN</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>ARDOMAINM2</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ARBAR</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>ARBARM2</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>RREADY</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>RREADYM2</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>RVALID</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>RVALIDM2</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>RID</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>RIDM2</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>RRESP</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>RRESPM2</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>RDATA</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>RDATAM2</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>RLAST</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>RLASTM2</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>RACK</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>RACKM2</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ACREADY</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>ACREADYM2</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ACVALID</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>ACVALIDM2</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ACADDR</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>ACADDRM2</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ACPROT</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>ACPROTM2</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ACSNOOP</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>ACSNOOPM2</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>CRREADY</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>CRREADYM2</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>CRVALID</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>CRVALIDM2</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>CRRESP</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>CRRESPM2</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>CDREADY</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>CDREADYM2</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>CDVALID</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>CDVALIDM2</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>CDDATA</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>CDDATAM2</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>CDLAST</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>CDLASTM2</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ACLK</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>CLK</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ARESETn</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>RESETn</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
         </spirit:portMaps>
         
      </spirit:busInterface>
      <spirit:busInterface>
         <spirit:name>ACE_Master_3</spirit:name>
         <spirit:description>ACE Master port</spirit:description>
         <spirit:busType spirit:library="AMBA4" spirit:name="ACE" spirit:vendor="amba.com" spirit:version="r0p0_0" />
         <spirit:abstractionType spirit:library="AMBA4" spirit:name="ACE_rtl" spirit:vendor="amba.com" spirit:version="r0p0_0" />
         <spirit:master>
         <spirit:addressSpaceRef spirit:addressSpaceRef="mimir" />
         </spirit:master>
         <spirit:portMaps>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ACLKEN</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>ACLKENM3</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>AWREADY</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>AWREADYM3</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>AWVALID</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>AWVALIDM3</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>AWID</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>AWIDM3</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>AWADDR</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>AWADDRM3</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>AWLEN</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>AWLENM3</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>AWSIZE</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>AWSIZEM3</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>AWBURST</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>AWBURSTM3</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>AWLOCK</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>AWLOCKM3</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>AWCACHE</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>AWCACHEM3</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>AWPROT</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>AWPROTM3</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>AWQOS</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>AWQOSM3</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>AWSNOOP</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>AWSNOOPM3</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>AWDOMAIN</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>AWDOMAINM3</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>AWBAR</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>AWBARM3</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>WREADY</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>WREADYM3</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>WVALID</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>WVALIDM3</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>WDATA</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>WDATAM3</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>WSTRB</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>WSTRBM3</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>WLAST</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>WLASTM3</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>BREADY</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>BREADYM3</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>BVALID</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>BVALIDM3</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>BID</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>BIDM3</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>BRESP</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>BRESPM3</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>WACK</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>WACKM3</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ARREADY</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>ARREADYM3</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ARVALID</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>ARVALIDM3</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ARID</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>ARIDM3</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ARADDR</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>ARADDRM3</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ARLEN</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>ARLENM3</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ARSIZE</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>ARSIZEM3</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ARBURST</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>ARBURSTM3</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ARLOCK</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>ARLOCKM3</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ARCACHE</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>ARCACHEM3</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ARPROT</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>ARPROTM3</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ARQOS</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>ARQOSM3</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ARSNOOP</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>ARSNOOPM3</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ARDOMAIN</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>ARDOMAINM3</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ARBAR</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>ARBARM3</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>RREADY</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>RREADYM3</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>RVALID</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>RVALIDM3</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>RID</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>RIDM3</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>RRESP</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>RRESPM3</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>RDATA</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>RDATAM3</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>RLAST</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>RLASTM3</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>RACK</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>RACKM3</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ACREADY</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>ACREADYM3</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ACVALID</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>ACVALIDM3</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ACADDR</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>ACADDRM3</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ACPROT</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>ACPROTM3</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ACSNOOP</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>ACSNOOPM3</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>CRREADY</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>CRREADYM3</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>CRVALID</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>CRVALIDM3</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>CRRESP</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>CRRESPM3</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>CDREADY</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>CDREADYM3</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>CDVALID</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>CDVALIDM3</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>CDDATA</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>CDDATAM3</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>CDLAST</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>CDLASTM3</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ACLK</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>CLK</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ARESETn</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>RESETn</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
         </spirit:portMaps>
         
      </spirit:busInterface>
      <spirit:busInterface>
         <spirit:name>Staticcfg_Slave_StripingGranule</spirit:name>
         <spirit:description>Memory striping granule</spirit:description>
         <spirit:busType spirit:library="generic" spirit:name="Staticcfg" spirit:vendor="arm.com" spirit:version="r0p0_0" />
         <spirit:abstractionType spirit:library="generic" spirit:name="Staticcfg_rtl" spirit:vendor="arm.com" spirit:version="r0p0_0" />
         <spirit:slave />
         <spirit:portMaps>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>CONFIGURATION</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>STRIPING_GRANULE</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
         </spirit:portMaps>
         
      </spirit:busInterface>
      <spirit:busInterface>
         <spirit:name>MBISTInterface_Slave</spirit:name>
         <spirit:description>Memory Built-in Self Test Interface</spirit:description>
         <spirit:busType spirit:library="generic" spirit:name="MBISTInterface" spirit:vendor="arm.com" spirit:version="r0p0_0" />
         <spirit:abstractionType spirit:library="generic" spirit:name="MBISTInterface_rtl" spirit:vendor="arm.com" spirit:version="r0p0_0" />
         <spirit:slave />
         <spirit:portMaps>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>CLK</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>CLK</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>MBISTREQ</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>MBISTREQ</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>nMBISTRESET</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>nMBISTRESET</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
         </spirit:portMaps>
         
      </spirit:busInterface>
      <spirit:busInterface>
         <spirit:name>HandShake_Master_0</spirit:name>
         <spirit:description>Coherency Enable/Disable Handshake</spirit:description>
         <spirit:busType spirit:library="generic" spirit:name="HandShake" spirit:vendor="arm.com" spirit:version="r0p0_0" />
         <spirit:abstractionType spirit:library="generic" spirit:name="HandShake_rtl" spirit:vendor="arm.com" spirit:version="r0p0_0" />
         <spirit:master />
         <spirit:portMaps>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>REQ</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>SYSCOREQM0</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ACK</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>SYSCOACKM0</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>CLK</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>CLK</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>RESETn</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>RESETn</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
         </spirit:portMaps>
         
      </spirit:busInterface>
      <spirit:busInterface>
         <spirit:name>HandShake_Master_1</spirit:name>
         <spirit:description>Coherency Enable/Disable Handshake</spirit:description>
         <spirit:busType spirit:library="generic" spirit:name="HandShake" spirit:vendor="arm.com" spirit:version="r0p0_0" />
         <spirit:abstractionType spirit:library="generic" spirit:name="HandShake_rtl" spirit:vendor="arm.com" spirit:version="r0p0_0" />
         <spirit:master />
         <spirit:portMaps>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>REQ</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>SYSCOREQM1</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ACK</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>SYSCOACKM1</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>CLK</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>CLK</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>RESETn</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>RESETn</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
         </spirit:portMaps>
         
      </spirit:busInterface>
      <spirit:busInterface>
         <spirit:name>HandShake_Master_2</spirit:name>
         <spirit:description>Coherency Enable/Disable Handshake</spirit:description>
         <spirit:busType spirit:library="generic" spirit:name="HandShake" spirit:vendor="arm.com" spirit:version="r0p0_0" />
         <spirit:abstractionType spirit:library="generic" spirit:name="HandShake_rtl" spirit:vendor="arm.com" spirit:version="r0p0_0" />
         <spirit:master />
         <spirit:portMaps>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>REQ</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>SYSCOREQM2</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ACK</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>SYSCOACKM2</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>CLK</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>CLK</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>RESETn</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>RESETn</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
         </spirit:portMaps>
         
      </spirit:busInterface>
      <spirit:busInterface>
         <spirit:name>HandShake_Master_3</spirit:name>
         <spirit:description>Coherency Enable/Disable Handshake</spirit:description>
         <spirit:busType spirit:library="generic" spirit:name="HandShake" spirit:vendor="arm.com" spirit:version="r0p0_0" />
         <spirit:abstractionType spirit:library="generic" spirit:name="HandShake_rtl" spirit:vendor="arm.com" spirit:version="r0p0_0" />
         <spirit:master />
         <spirit:portMaps>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>REQ</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>SYSCOREQM3</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ACK</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>SYSCOACKM3</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>RESETn</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>RESETn</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>CLK</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>CLK</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
         </spirit:portMaps>
         
      </spirit:busInterface>
      <spirit:busInterface>
         <spirit:name>DFTInterface_Slave</spirit:name>
         <spirit:description>Design for test Interface</spirit:description>
         <spirit:busType spirit:library="generic" spirit:name="DFTInterface" spirit:vendor="arm.com" spirit:version="r0p0_1" />
         <spirit:abstractionType spirit:library="generic" spirit:name="DFTInterface_rtl" spirit:vendor="arm.com" spirit:version="r0p0_1" />
         <spirit:slave />
         <spirit:portMaps>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>DFTRSTDISABLE</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>DFTRSTDISABLE</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>DFTRAMHOLD</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>DFTRAMHOLD</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>DFTCLKCGEN</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>DFTCGEN</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>DFTCLKDISABLE</spirit:name>
                  <spirit:vector>
                     <spirit:left>16</spirit:left>
                     <spirit:right>16</spirit:right>
                  </spirit:vector>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>DFTTOPCLKDISABLE</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>DFTCLKDISABLE</spirit:name>
                  <spirit:vector>
                     <spirit:left>0</spirit:left>
                     <spirit:right>0</spirit:right>
                  </spirit:vector>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>DFTSC0CLKDISABLE</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>DFTCLKDISABLE</spirit:name>
                  <spirit:vector>
                     <spirit:left>1</spirit:left>
                     <spirit:right>1</spirit:right>
                  </spirit:vector>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>DFTSC1CLKDISABLE</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>DFTCLKDISABLE</spirit:name>
                  <spirit:vector>
                     <spirit:left>2</spirit:left>
                     <spirit:right>2</spirit:right>
                  </spirit:vector>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>DFTSC2CLKDISABLE</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>DFTCLKDISABLE</spirit:name>
                  <spirit:vector>
                     <spirit:left>3</spirit:left>
                     <spirit:right>3</spirit:right>
                  </spirit:vector>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>DFTSC3CLKDISABLE</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>DFTCLKDISABLE</spirit:name>
                  <spirit:vector>
                     <spirit:left>4</spirit:left>
                     <spirit:right>4</spirit:right>
                  </spirit:vector>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>DFTSC4CLKDISABLE</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>DFTCLKDISABLE</spirit:name>
                  <spirit:vector>
                     <spirit:left>5</spirit:left>
                     <spirit:right>5</spirit:right>
                  </spirit:vector>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>DFTSC5CLKDISABLE</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>DFTCLKDISABLE</spirit:name>
                  <spirit:vector>
                     <spirit:left>6</spirit:left>
                     <spirit:right>6</spirit:right>
                  </spirit:vector>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>DFTSC6CLKDISABLE</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>DFTCLKDISABLE</spirit:name>
                  <spirit:vector>
                     <spirit:left>7</spirit:left>
                     <spirit:right>7</spirit:right>
                  </spirit:vector>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>DFTSC7CLKDISABLE</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>DFTCLKDISABLE</spirit:name>
                  <spirit:vector>
                     <spirit:left>8</spirit:left>
                     <spirit:right>8</spirit:right>
                  </spirit:vector>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>DFTSC8CLKDISABLE</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>DFTCLKDISABLE</spirit:name>
                  <spirit:vector>
                     <spirit:left>9</spirit:left>
                     <spirit:right>9</spirit:right>
                  </spirit:vector>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>DFTSC9CLKDISABLE</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>DFTCLKDISABLE</spirit:name>
                  <spirit:vector>
                     <spirit:left>10</spirit:left>
                     <spirit:right>10</spirit:right>
                  </spirit:vector>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>DFTSC10CLKDISABLE</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>DFTCLKDISABLE</spirit:name>
                  <spirit:vector>
                     <spirit:left>11</spirit:left>
                     <spirit:right>11</spirit:right>
                  </spirit:vector>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>DFTSC11CLKDISABLE</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>DFTCLKDISABLE</spirit:name>
                  <spirit:vector>
                     <spirit:left>12</spirit:left>
                     <spirit:right>12</spirit:right>
                  </spirit:vector>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>DFTSC12CLKDISABLE</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>DFTCLKDISABLE</spirit:name>
                  <spirit:vector>
                     <spirit:left>13</spirit:left>
                     <spirit:right>13</spirit:right>
                  </spirit:vector>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>DFTSC13CLKDISABLE</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>DFTCLKDISABLE</spirit:name>
                  <spirit:vector>
                     <spirit:left>14</spirit:left>
                     <spirit:right>14</spirit:right>
                  </spirit:vector>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>DFTSC14CLKDISABLE</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>DFTCLKDISABLE</spirit:name>
                  <spirit:vector>
                     <spirit:left>15</spirit:left>
                     <spirit:right>15</spirit:right>
                  </spirit:vector>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>DFTSC15CLKDISABLE</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>DFTPWRUP</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>DFTPWRUP</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>DFTISODISABLE</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>DFTISODISABLE</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>DFTSCANMODE</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>DFTSCANMODE</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>DFTSE</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>DFTSE</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>CLK</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>CLK</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
         </spirit:portMaps>
         
      </spirit:busInterface>
      <spirit:busInterface>
         <spirit:name>ProtectedMode_Master_0</spirit:name>
         <spirit:description>Asserted if the GPU is in protected mode</spirit:description>
         <spirit:busType spirit:library="Media" spirit:name="ProtectedMode" spirit:vendor="arm.com" spirit:version="r0p0_0" />
         <spirit:abstractionType spirit:library="Media" spirit:name="ProtectedMode_rtl" spirit:vendor="arm.com" spirit:version="r0p0_0" />
         <spirit:master />
         <spirit:portMaps>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>PROTMODE</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>PROTMODEM0</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>CLK</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>CLK</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>RESETn</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>RESETn</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>CLKEN</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>ACLKENM0</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
         </spirit:portMaps>
         
      </spirit:busInterface>
      <spirit:busInterface>
         <spirit:name>ProtectedMode_Master_1</spirit:name>
         <spirit:description>Asserted if the GPU is in protected mode</spirit:description>
         <spirit:busType spirit:library="Media" spirit:name="ProtectedMode" spirit:vendor="arm.com" spirit:version="r0p0_0" />
         <spirit:abstractionType spirit:library="Media" spirit:name="ProtectedMode_rtl" spirit:vendor="arm.com" spirit:version="r0p0_0" />
         <spirit:master />
         <spirit:portMaps>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>PROTMODE</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>PROTMODEM1</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>CLK</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>CLK</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>RESETn</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>RESETn</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>CLKEN</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>ACLKENM1</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
         </spirit:portMaps>
         
      </spirit:busInterface>
      <spirit:busInterface>
         <spirit:name>ProtectedMode_Master_2</spirit:name>
         <spirit:description>Asserted if the GPU is in protected mode</spirit:description>
         <spirit:busType spirit:library="Media" spirit:name="ProtectedMode" spirit:vendor="arm.com" spirit:version="r0p0_0" />
         <spirit:abstractionType spirit:library="Media" spirit:name="ProtectedMode_rtl" spirit:vendor="arm.com" spirit:version="r0p0_0" />
         <spirit:master />
         <spirit:portMaps>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>PROTMODE</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>PROTMODEM2</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>CLK</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>CLK</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>RESETn</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>RESETn</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>CLKEN</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>ACLKENM2</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
         </spirit:portMaps>
         
      </spirit:busInterface>
      <spirit:busInterface>
         <spirit:name>ProtectedMode_Master_3</spirit:name>
         <spirit:description>Asserted if the GPU is in protected mode</spirit:description>
         <spirit:busType spirit:library="Media" spirit:name="ProtectedMode" spirit:vendor="arm.com" spirit:version="r0p0_0" />
         <spirit:abstractionType spirit:library="Media" spirit:name="ProtectedMode_rtl" spirit:vendor="arm.com" spirit:version="r0p0_0" />
         <spirit:master />
         <spirit:portMaps>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>PROTMODE</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>PROTMODEM3</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>CLK</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>CLK</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>RESETn</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>RESETn</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>CLKEN</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>ACLKENM3</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
         </spirit:portMaps>
         
      </spirit:busInterface>
      <spirit:busInterface>
         <spirit:name>Staticcfg_Slave_TextureFormat</spirit:name>
         <spirit:description>Texture format enable bits</spirit:description>
         <spirit:busType spirit:library="generic" spirit:name="Staticcfg" spirit:vendor="arm.com" spirit:version="r0p0_0" />
         <spirit:abstractionType spirit:library="generic" spirit:name="Staticcfg_rtl" spirit:vendor="arm.com" spirit:version="r0p0_0" />
         <spirit:slave />
         <spirit:portMaps>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>CONFIGURATION</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>TEXFMTENABLE</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
         </spirit:portMaps>
         
      </spirit:busInterface>
      <spirit:busInterface>
         <spirit:name>Q-Channel_Slave</spirit:name>
         <spirit:description>Q channel</spirit:description>
         <spirit:busType spirit:library="generic" spirit:name="Q-Channel" spirit:vendor="arm.com" spirit:version="r0p0_0" />
         <spirit:abstractionType spirit:library="generic" spirit:name="Q-Channel_rtl" spirit:vendor="arm.com" spirit:version="r0p0_0" />
         <spirit:slave />
         <spirit:portMaps>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>QACTIVE</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>QACTIVE</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>QACCEPTn</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>QACCEPTn</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>QREQn</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>QREQn</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>QDENY</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>QDENY</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
         </spirit:portMaps>
         
      </spirit:busInterface>
      <spirit:busInterface>
         <spirit:name>Wakeup_Slave</spirit:name>
         <spirit:description>Wake up interface for AXI slave</spirit:description>
         <spirit:busType spirit:library="generic" spirit:name="Wakeup" spirit:vendor="arm.com" spirit:version="r0p0_0" />
         <spirit:abstractionType spirit:library="generic" spirit:name="Wakeup_rtl" spirit:vendor="arm.com" spirit:version="r0p0_0" />
         <spirit:slave />
         <spirit:portMaps>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>WAKEUP</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>AWAKEUPS</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ACLK</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>CLK</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ACLKEN</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>ACLKENS</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ARESETn</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>RESETn</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
         </spirit:portMaps>
         
      </spirit:busInterface>
      <spirit:busInterface>
         <spirit:name>Wakeup_Master_0</spirit:name>
         <spirit:description>Wake up interface for ACE</spirit:description>
         <spirit:busType spirit:library="generic" spirit:name="Wakeup" spirit:vendor="arm.com" spirit:version="r0p0_0" />
         <spirit:abstractionType spirit:library="generic" spirit:name="Wakeup_rtl" spirit:vendor="arm.com" spirit:version="r0p0_0" />
         <spirit:master />
         <spirit:portMaps>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>WAKEUP</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>AWAKEUPM0</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ACLK</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>CLK</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ACLKEN</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>ACLKENM0</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ARESETn</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>RESETn</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
         </spirit:portMaps>
         
      </spirit:busInterface>
      <spirit:busInterface>
         <spirit:name>Wakeup_Master_1</spirit:name>
         <spirit:description>Wake up interface for ACE</spirit:description>
         <spirit:busType spirit:library="generic" spirit:name="Wakeup" spirit:vendor="arm.com" spirit:version="r0p0_0" />
         <spirit:abstractionType spirit:library="generic" spirit:name="Wakeup_rtl" spirit:vendor="arm.com" spirit:version="r0p0_0" />
         <spirit:master />
         <spirit:portMaps>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>WAKEUP</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>AWAKEUPM1</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ACLK</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>CLK</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ACLKEN</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>ACLKENM1</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ARESETn</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>RESETn</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
         </spirit:portMaps>
         
      </spirit:busInterface>
      <spirit:busInterface>
         <spirit:name>Wakeup_Master_2</spirit:name>
         <spirit:description>Wake up interface for ACE</spirit:description>
         <spirit:busType spirit:library="generic" spirit:name="Wakeup" spirit:vendor="arm.com" spirit:version="r0p0_0" />
         <spirit:abstractionType spirit:library="generic" spirit:name="Wakeup_rtl" spirit:vendor="arm.com" spirit:version="r0p0_0" />
         <spirit:master />
         <spirit:portMaps>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>WAKEUP</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>AWAKEUPM2</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ACLK</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>CLK</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ACLKEN</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>ACLKENM2</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ARESETn</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>RESETn</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
         </spirit:portMaps>
         
      </spirit:busInterface>
      <spirit:busInterface>
         <spirit:name>Wakeup_Master_3</spirit:name>
         <spirit:description>Wake up interface for ACE</spirit:description>
         <spirit:busType spirit:library="generic" spirit:name="Wakeup" spirit:vendor="arm.com" spirit:version="r0p0_0" />
         <spirit:abstractionType spirit:library="generic" spirit:name="Wakeup_rtl" spirit:vendor="arm.com" spirit:version="r0p0_0" />
         <spirit:master />
         <spirit:portMaps>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>WAKEUP</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>AWAKEUPM3</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ACLK</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>CLK</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ACLKEN</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>ACLKENM3</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>ARESETn</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>RESETn</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
         </spirit:portMaps>
         
      </spirit:busInterface>
      <spirit:busInterface>
         <spirit:name>Staticcfg_Slave_CoherencyFeatures</spirit:name>
         <spirit:description>Coherency modes supported</spirit:description>
         <spirit:busType spirit:library="generic" spirit:name="Staticcfg" spirit:vendor="arm.com" spirit:version="r0p0_0" />
         <spirit:abstractionType spirit:library="generic" spirit:name="Staticcfg_rtl" spirit:vendor="arm.com" spirit:version="r0p0_0" />
         <spirit:slave />
         <spirit:portMaps>
            <spirit:portMap>
               <spirit:logicalPort>
                  <spirit:name>CONFIGURATION</spirit:name>
               </spirit:logicalPort>
               <spirit:physicalPort>
                  <spirit:name>COHERENCYFEATURES</spirit:name>
               </spirit:physicalPort>
            </spirit:portMap>
         </spirit:portMaps>
         
      </spirit:busInterface>
   </spirit:busInterfaces>
   <spirit:addressSpaces>
   <spirit:addressSpace>
   <spirit:name>mimir</spirit:name>
   <spirit:description>ACE Bus address space</spirit:description>
   <spirit:range>1099511627776</spirit:range>
   <spirit:width>40</spirit:width>
   </spirit:addressSpace>
   </spirit:addressSpaces>
   <spirit:memoryMaps>
  <spirit:memoryMap>
    <spirit:name>AXI4_Slave</spirit:name>
    <spirit:description>GPU registers accessible from the host AXI interface</spirit:description>
    <spirit:addressBlock>
      <spirit:name>jm_gpu_regs</spirit:name>
      <spirit:baseAddress>0</spirit:baseAddress>
      <spirit:range>1408</spirit:range>
      <spirit:width>32</spirit:width>
      <spirit:usage>register</spirit:usage>
      <spirit:register>
        <spirit:name>GPU_ID</spirit:name>
        <spirit:displayName>GPU_ID</spirit:displayName>
        <spirit:description>   Contains information related to the model and revision of the GPU.  Removed GPU IDs and product_id_t.  Removed erroneous PRODUCT_ID field. </spirit:description>
        <spirit:addressOffset>0x0</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x60a00002</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>VERSION_MINOR</spirit:name>
          <spirit:displayName>VERSION_MINOR</spirit:displayName>
          <spirit:description>   It contains the minor release number of the GPU. This is the "P" part of an "RnPn" release number. </spirit:description>
          <spirit:bitOffset>4</spirit:bitOffset>
          <spirit:bitWidth>8</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>VERSION_MAJOR</spirit:name>
          <spirit:displayName>VERSION_MAJOR</spirit:displayName>
          <spirit:description>   It contains the major release number of the GPU. This is the "R" part of an "RnPn" release number. </spirit:description>
          <spirit:bitOffset>12</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>PRODUCT_MAJOR</spirit:name>
          <spirit:displayName>PRODUCT_MAJOR</spirit:displayName>
          <spirit:description>   This field contains a value indicating a product release within a product generation implementing a particular major version of the architecture.  The first product implementing a particular major version of the architecture would have 0 in this field. In order that this is not affected by release scheduling, it is recommended that this number is allocated early in the project.  For example, since the Mali-T820, Mali-T860, Mali-T830, and Mali-T880 GPUs are based on the same major architecture version, they would have been labelled products 0, 1, 2 and 3 under this scheme.  To identify a single product, regardless of revisions, it is sufficient to look only at the  ARCH_MAJOR and PRODUCT_MAJOR fields.
						This is to avoid the problem of reallocating PRODUCT_MAJOR IDs at every minor version of the architecture. So, for example, assume that the Mimir GPU was released at architecture revision 6.0.7, and assigned  PRODUCT_MAJOR ID 0 . If we then release a new GPU called (say) Thunnorad at architecture version 6.0.9, then this would be assigned  PRODUCT_MAJOR ID 1 , as it is the second product for
						major architecture version 6, not the first product at minor architecture version 6.0.9. This also allows us to also update Mimir to 6.0.9 at a future release without having to reassign its  PRODUCT_MAJOR ID. Clarified what parts of the product ID identify a product as opposed to revisions. </spirit:description>
          <spirit:bitOffset>16</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>ARCH_MINOR</spirit:name>
          <spirit:displayName>ARCH_MINOR</spirit:displayName>
          <spirit:description>   This field contains the minor revision value for the version of the architecture implemented by this hardware. For example, for architecture version 6.1.0, this field would be set to 1. </spirit:description>
          <spirit:bitOffset>24</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>ARCH_MAJOR</spirit:name>
          <spirit:displayName>ARCH_MAJOR</spirit:displayName>
          <spirit:description>   This field contains the major revision value for the version of the architecture implemented by this hardware. For example, for architecture version 6.1.0, this field would be set to 6. </spirit:description>
          <spirit:bitOffset>28</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>ARCH_REV</spirit:name>
          <spirit:displayName>ARCH_REV</spirit:displayName>
          <spirit:description>   This field contains the patch revision value for the version of the architecture implemented by this hardware.
					This is a signed value to allow for preview releases, so for instance previews of Architecture spec version 6.1.0 might be labelled 6.1.-8 and 6.1.-7. </spirit:description>
          <spirit:bitOffset>20</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>VERSION_STATUS</spirit:name>
          <spirit:displayName>VERSION_STATUS</spirit:displayName>
          <spirit:description>   It contains the status of the GPU release. This has no architecturally defined values, but should reset to 0  at each minor or major release, and increases by one for each intermediate release status (alpha, beta, EAC, etc.)  The named values indicated here will be valid for one particular implementation only.  VERSION_STATUS should be reset to 0 at each minor or major release.  VERSION_STATUS is now defined as an enum included from the implementation config file. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>beta</spirit:name>
              <spirit:description> Beta </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>dev_15</spirit:name>
              <spirit:description> Development release 15 </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>eac</spirit:name>
              <spirit:description> EAC </spirit:description>
              <spirit:value>2</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>L2_FEATURES</spirit:name>
        <spirit:displayName>L2_FEATURES</spirit:displayName>
        <spirit:description>   Contains information about the features of the level 2 cache. </spirit:description>
        <spirit:addressOffset>0x4</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value spirit:dependency="((spirit:decode('117440512')+(spirit:decode(id('CONFIG_L2_CACHE_SIZE'))+spirit:decode('15'))*spirit:decode('65536'))+spirit:decode('518'))" spirit:format="long" spirit:resolve="dependent">0x7110206</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>LINE_SIZE</spirit:name>
          <spirit:displayName>LINE_SIZE</spirit:displayName>
          <spirit:description>   It contains the base-2 logarithm of the cache's line size, in bytes. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>8</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>ASSOCIATIVITY</spirit:name>
          <spirit:displayName>ASSOCIATIVITY</spirit:displayName>
          <spirit:description>   It contains the base-2 logarithm of the cache's associativity (number of ways). </spirit:description>
          <spirit:bitOffset>8</spirit:bitOffset>
          <spirit:bitWidth>8</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>CACHE_SIZE</spirit:name>
          <spirit:displayName>CACHE_SIZE</spirit:displayName>
          <spirit:description>   It contains the base-2 logarithm of the cache's total size, in bytes. </spirit:description>
          <spirit:bitOffset>16</spirit:bitOffset>
          <spirit:bitWidth>8</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>EXTERNAL_BUS_WIDTH</spirit:name>
          <spirit:displayName>EXTERNAL_BUS_WIDTH</spirit:displayName>
          <spirit:description>   It contains the base-2 logarithm of the cache's external data bus size, in bits. </spirit:description>
          <spirit:bitOffset>24</spirit:bitOffset>
          <spirit:bitWidth>8</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>TILER_FEATURES</spirit:name>
        <spirit:displayName>TILER_FEATURES</spirit:displayName>
        <spirit:description>   Contains information about the features of the tiler. </spirit:description>
        <spirit:addressOffset>0xc</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x809</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>Res1</spirit:name>
          <spirit:displayName>Res1</spirit:displayName>
          <spirit:description>Res1</spirit:description>
          <spirit:bitOffset>6</spirit:bitOffset>
          <spirit:bitWidth>2</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>Res2</spirit:name>
          <spirit:displayName>Res2</spirit:displayName>
          <spirit:description>Res2</spirit:description>
          <spirit:bitOffset>12</spirit:bitOffset>
          <spirit:bitWidth>20</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>BIN_SIZE</spirit:name>
          <spirit:displayName>BIN_SIZE</spirit:displayName>
          <spirit:description>   It contains the base-2 logarithm of the tiler's bin size, in bytes. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>6</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>MAX_LEVELS</spirit:name>
          <spirit:displayName>MAX_LEVELS</spirit:displayName>
          <spirit:description>   It specifies the maximum number of hierarchy levels may be enabled at any one time. This is the maximum number of "1" bits in the Hierarchy Mask field of the Frame Buffer Descriptor. </spirit:description>
          <spirit:bitOffset>8</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>MEM_FEATURES</spirit:name>
        <spirit:displayName>MEM_FEATURES</spirit:displayName>
        <spirit:description>   Contains information about the features of the memory system. </spirit:description>
        <spirit:addressOffset>0x10</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value spirit:dependency="((spirit:decode(id('CONFIG_L2_COUNT'))*spirit:decode('256'))+spirit:decode('1'))" spirit:format="long" spirit:resolve="dependent">0x1</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>Res3</spirit:name>
          <spirit:displayName>Res3</spirit:displayName>
          <spirit:description>Res3</spirit:description>
          <spirit:bitOffset>2</spirit:bitOffset>
          <spirit:bitWidth>6</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>Res4</spirit:name>
          <spirit:displayName>Res4</spirit:displayName>
          <spirit:description>Res4</spirit:description>
          <spirit:bitOffset>12</spirit:bitOffset>
          <spirit:bitWidth>20</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>L2_SLICES</spirit:name>
          <spirit:displayName>L2_SLICES</spirit:displayName>
          <spirit:description>   It contains the number of slices in the level 2 cache, minus 1. </spirit:description>
          <spirit:bitOffset>8</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>COHERENT_CORE_GROUP</spirit:name>
          <spirit:displayName>COHERENT_CORE_GROUP</spirit:displayName>
          <spirit:description>COHERENT_CORE_GROUP</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> Shader cores within a core group are not coherent with one another. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Shader cores within a core group are coherent with one another. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>COHERENT_SUPER_GROUP</spirit:name>
          <spirit:displayName>COHERENT_SUPER_GROUP</spirit:displayName>
          <spirit:description>COHERENT_SUPER_GROUP</spirit:description>
          <spirit:bitOffset>1</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> Shader cores within a core supergroup are not coherent with one another. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Shader cores within a core supergroup are coherent with one another. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>MMU_FEATURES</spirit:name>
        <spirit:displayName>MMU_FEATURES</spirit:displayName>
        <spirit:description>   Describes the configuration of the Memory Management Unit in the GPU. </spirit:description>
        <spirit:addressOffset>0x14</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x2830</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>Res5</spirit:name>
          <spirit:displayName>Res5</spirit:displayName>
          <spirit:description>Res5</spirit:description>
          <spirit:bitOffset>24</spirit:bitOffset>
          <spirit:bitWidth>8</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>VA_BITS</spirit:name>
          <spirit:displayName>VA_BITS</spirit:displayName>
          <spirit:description>   The number of bits which are significant for virtual addresses. All 64 bits of an address are decoded, but only the region from 0 to 2  VA_BITS -1 can be mapped to physical memory. Other address ranges result in a translation fault.</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>8</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>PA_BITS</spirit:name>
          <spirit:displayName>PA_BITS</spirit:displayName>
          <spirit:description>   The number of bits which are significant for physical addresses. All 64 bits of an address are decoded, but only the region from 0 to 2  PA_BITS -1 corresponds to real physical memory. Other address ranges result in a translation fault.
						Note that this does not guarantee that this amount of physical memory is actually available, just that there is the potential to attach it exists.</spirit:description>
          <spirit:bitOffset>8</spirit:bitOffset>
          <spirit:bitWidth>8</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>IPA_BITS</spirit:name>
          <spirit:displayName>IPA_BITS</spirit:displayName>
          <spirit:description>   The number of bits which are significant for intermediate physical addresses. All 64 bits of an address are decoded, but only the region from 0 to 2  IPA_BITS -1 correspond to addressable intermediate-physical memory. Other address ranges result in a translation fault. If this is 0, this indicates that there is no Stage 2 translation. In this case, the Stage 1 translation therefore translates directly from virtual addresses to physical addresses.  Added  IPA_BITS to MMU_FEATURES register.</spirit:description>
          <spirit:bitOffset>16</spirit:bitOffset>
          <spirit:bitWidth>8</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>AS_PRESENT</spirit:name>
        <spirit:displayName>AS_PRESENT</spirit:displayName>
        <spirit:description>   Contains information about which address spaces are present on this GPU. </spirit:description>
        <spirit:addressOffset>0x18</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0xff</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>AS_PRESENT</spirit:name>
          <spirit:displayName>AS_PRESENT</spirit:displayName>
          <spirit:description>   Indicates which address spaces are actually available in the hardware. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> Address space  n is not available.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Address space  n is available.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>JS_PRESENT</spirit:name>
        <spirit:displayName>JS_PRESENT</spirit:displayName>
        <spirit:description>   Contains information about which job slots are present on this GPU. </spirit:description>
        <spirit:addressOffset>0x1c</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x7</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>JS_PRESENT</spirit:name>
          <spirit:displayName>JS_PRESENT</spirit:displayName>
          <spirit:description>   Indicates which job slots are actually available in the hardware. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> Job slot  n is not available.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Job slot  n is available.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>GPU_IRQ_RAWSTAT</spirit:name>
        <spirit:displayName>GPU_IRQ_RAWSTAT</spirit:displayName>
        <spirit:description>   This register contains the raw unmasked interrupt sources for GPU-wide status and exception handling.  Writing to this register will force bits on, but will not clear them. The new state is the logical OR of the previous state and the written value.  Writing a zero to a bit will have no effect. Use the GPU_IRQ_CLEAR register to clear interrupts. </spirit:description>
        <spirit:addressOffset>0x20</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>Res6</spirit:name>
          <spirit:displayName>Res6</spirit:displayName>
          <spirit:description>Res6</spirit:description>
          <spirit:bitOffset>1</spirit:bitOffset>
          <spirit:bitWidth>6</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>Res7</spirit:name>
          <spirit:displayName>Res7</spirit:displayName>
          <spirit:description>Res7</spirit:description>
          <spirit:bitOffset>11</spirit:bitOffset>
          <spirit:bitWidth>5</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>Res8</spirit:name>
          <spirit:displayName>Res8</spirit:displayName>
          <spirit:description>Res8</spirit:description>
          <spirit:bitOffset>18</spirit:bitOffset>
          <spirit:bitWidth>14</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>GPU_FAULT</spirit:name>
          <spirit:displayName>GPU_FAULT</spirit:displayName>
          <spirit:description>GPU_FAULT</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   No GPU fault. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   If a GPU Fault is reported (for example a bus fault occurs when writing back a cache line), the GPU_FAULT bit is set, the fault type is placed in the GPU_FAULTSTATUS register, and the address causing the fault is put in the  GPU_FAULTADDRESS register. This fault is treated as a GPU exception. See  ExceptionStatus for information on fault codes and additional data locations.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>MULTIPLE_GPU_FAULTS</spirit:name>
          <spirit:displayName>MULTIPLE_GPU_FAULTS</spirit:displayName>
          <spirit:description>MULTIPLE_GPU_FAULTS</spirit:description>
          <spirit:bitOffset>7</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   No multiple fault. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   If the GPU Fault flag is already set, then the MULTIPLE_GPU_FAULTS bit is set, but the address and status registers are not updated. The core will not stop execution but data may be lost.  This fault is treated as a GPU exception. See  ExceptionStatus for information on fault codes and additional data locations.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>RESET_COMPLETED</spirit:name>
          <spirit:displayName>RESET_COMPLETED</spirit:displayName>
          <spirit:description>   Modified reset values for registers. </spirit:description>
          <spirit:bitOffset>8</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Reset not completed. The flag will typically be in this state for an implementation-defined number of cycles after a reset. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Reset has completed. This is intended to be used to monitor SOFT_RESET commands, which may take some time. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>POWER_CHANGED_SINGLE</spirit:name>
          <spirit:displayName>POWER_CHANGED_SINGLE</spirit:displayName>
          <spirit:description>POWER_CHANGED_SINGLE</spirit:description>
          <spirit:bitOffset>9</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   No power changes. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   This event is triggered when the power manager returns to being idle after a single core has changed power state.  The POWER_CHANGED_SINGLE event should be used in conjunction with the *_READY and *_PWRTRANS registers, together with knowledge of previous writes to *_PRWON and *_PWROFF registers, to decide which cores have changed state. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>POWER_CHANGED_ALL</spirit:name>
          <spirit:displayName>POWER_CHANGED_ALL</spirit:displayName>
          <spirit:description>POWER_CHANGED_ALL</spirit:description>
          <spirit:bitOffset>10</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   No power changes. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   This event is triggered when the power manager returns to being idle after all cores have changed power state. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>PRFCNT_SAMPLE_COMPLETED</spirit:name>
          <spirit:displayName>PRFCNT_SAMPLE_COMPLETED</spirit:displayName>
          <spirit:description>PRFCNT_SAMPLE_COMPLETED</spirit:description>
          <spirit:bitOffset>16</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Performance counts not complete. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   This flag  will be set only after the completion of a manually-triggered PRFCNT_SAMPLE command (see  GPU_COMMAND ). It will not be set during tile-mode performance counting.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>CLEAN_CACHES_COMPLETED</spirit:name>
          <spirit:displayName>CLEAN_CACHES_COMPLETED</spirit:displayName>
          <spirit:description>CLEAN_CACHES_COMPLETED</spirit:description>
          <spirit:bitOffset>17</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Cache clean not completed. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   This flag  will be set only after the completion of a manually-triggered CLEAN_CACHES or CLEAN_INV_CACHES command (see  GPU_COMMAND ). It will not be set during job chain execution.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>GPU_IRQ_CLEAR</spirit:name>
        <spirit:displayName>GPU_IRQ_CLEAR</spirit:displayName>
        <spirit:description>   This register has the same layout as GPU_IRQ_RAWSTAT. Write a one to a bit in this register to clear the corresponding bit in GPU_IRQ_RAWSTAT. </spirit:description>
        <spirit:addressOffset>0x24</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>Res9</spirit:name>
          <spirit:displayName>Res9</spirit:displayName>
          <spirit:description>Res9</spirit:description>
          <spirit:bitOffset>1</spirit:bitOffset>
          <spirit:bitWidth>6</spirit:bitWidth>
          <spirit:access>write-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>Res10</spirit:name>
          <spirit:displayName>Res10</spirit:displayName>
          <spirit:description>Res10</spirit:description>
          <spirit:bitOffset>11</spirit:bitOffset>
          <spirit:bitWidth>5</spirit:bitWidth>
          <spirit:access>write-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>Res11</spirit:name>
          <spirit:displayName>Res11</spirit:displayName>
          <spirit:description>Res11</spirit:description>
          <spirit:bitOffset>18</spirit:bitOffset>
          <spirit:bitWidth>14</spirit:bitWidth>
          <spirit:access>write-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>GPU_FAULT</spirit:name>
          <spirit:displayName>GPU_FAULT</spirit:displayName>
          <spirit:description>GPU_FAULT</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>write-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   No GPU fault. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   If a GPU Fault is reported (for example a bus fault occurs when writing back a cache line), the GPU_FAULT bit is set, the fault type is placed in the GPU_FAULTSTATUS register, and the address causing the fault is put in the  GPU_FAULTADDRESS register. This fault is treated as a GPU exception. See  ExceptionStatus for information on fault codes and additional data locations.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>MULTIPLE_GPU_FAULTS</spirit:name>
          <spirit:displayName>MULTIPLE_GPU_FAULTS</spirit:displayName>
          <spirit:description>MULTIPLE_GPU_FAULTS</spirit:description>
          <spirit:bitOffset>7</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>write-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   No multiple fault. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   If the GPU Fault flag is already set, then the MULTIPLE_GPU_FAULTS bit is set, but the address and status registers are not updated. The core will not stop execution but data may be lost.  This fault is treated as a GPU exception. See  ExceptionStatus for information on fault codes and additional data locations.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>RESET_COMPLETED</spirit:name>
          <spirit:displayName>RESET_COMPLETED</spirit:displayName>
          <spirit:description>   Modified reset values for registers. </spirit:description>
          <spirit:bitOffset>8</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>write-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Reset not completed. The flag will typically be in this state for an implementation-defined number of cycles after a reset. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Reset has completed. This is intended to be used to monitor SOFT_RESET commands, which may take some time. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>POWER_CHANGED_SINGLE</spirit:name>
          <spirit:displayName>POWER_CHANGED_SINGLE</spirit:displayName>
          <spirit:description>POWER_CHANGED_SINGLE</spirit:description>
          <spirit:bitOffset>9</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>write-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   No power changes. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   This event is triggered when the power manager returns to being idle after a single core has changed power state.  The POWER_CHANGED_SINGLE event should be used in conjunction with the *_READY and *_PWRTRANS registers, together with knowledge of previous writes to *_PRWON and *_PWROFF registers, to decide which cores have changed state. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>POWER_CHANGED_ALL</spirit:name>
          <spirit:displayName>POWER_CHANGED_ALL</spirit:displayName>
          <spirit:description>POWER_CHANGED_ALL</spirit:description>
          <spirit:bitOffset>10</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>write-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   No power changes. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   This event is triggered when the power manager returns to being idle after all cores have changed power state. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>PRFCNT_SAMPLE_COMPLETED</spirit:name>
          <spirit:displayName>PRFCNT_SAMPLE_COMPLETED</spirit:displayName>
          <spirit:description>PRFCNT_SAMPLE_COMPLETED</spirit:description>
          <spirit:bitOffset>16</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>write-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Performance counts not complete. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   This flag  will be set only after the completion of a manually-triggered PRFCNT_SAMPLE command (see  GPU_COMMAND ). It will not be set during tile-mode performance counting.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>CLEAN_CACHES_COMPLETED</spirit:name>
          <spirit:displayName>CLEAN_CACHES_COMPLETED</spirit:displayName>
          <spirit:description>CLEAN_CACHES_COMPLETED</spirit:description>
          <spirit:bitOffset>17</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>write-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Cache clean not completed. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   This flag  will be set only after the completion of a manually-triggered CLEAN_CACHES or CLEAN_INV_CACHES command (see  GPU_COMMAND ). It will not be set during job chain execution.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>GPU_IRQ_MASK</spirit:name>
        <spirit:displayName>GPU_IRQ_MASK</spirit:displayName>
        <spirit:description>   This register has the same layout as GPU_IRQ_RAWSTAT. Set each bit in this to one to enable the corresponding interrupt source, and to zero to disable it. </spirit:description>
        <spirit:addressOffset>0x28</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>Res12</spirit:name>
          <spirit:displayName>Res12</spirit:displayName>
          <spirit:description>Res12</spirit:description>
          <spirit:bitOffset>1</spirit:bitOffset>
          <spirit:bitWidth>6</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>Res13</spirit:name>
          <spirit:displayName>Res13</spirit:displayName>
          <spirit:description>Res13</spirit:description>
          <spirit:bitOffset>11</spirit:bitOffset>
          <spirit:bitWidth>5</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>Res14</spirit:name>
          <spirit:displayName>Res14</spirit:displayName>
          <spirit:description>Res14</spirit:description>
          <spirit:bitOffset>18</spirit:bitOffset>
          <spirit:bitWidth>14</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>GPU_FAULT</spirit:name>
          <spirit:displayName>GPU_FAULT</spirit:displayName>
          <spirit:description>GPU_FAULT</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   No GPU fault. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   If a GPU Fault is reported (for example a bus fault occurs when writing back a cache line), the GPU_FAULT bit is set, the fault type is placed in the GPU_FAULTSTATUS register, and the address causing the fault is put in the  GPU_FAULTADDRESS register. This fault is treated as a GPU exception. See  ExceptionStatus for information on fault codes and additional data locations.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>MULTIPLE_GPU_FAULTS</spirit:name>
          <spirit:displayName>MULTIPLE_GPU_FAULTS</spirit:displayName>
          <spirit:description>MULTIPLE_GPU_FAULTS</spirit:description>
          <spirit:bitOffset>7</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   No multiple fault. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   If the GPU Fault flag is already set, then the MULTIPLE_GPU_FAULTS bit is set, but the address and status registers are not updated. The core will not stop execution but data may be lost.  This fault is treated as a GPU exception. See  ExceptionStatus for information on fault codes and additional data locations.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>RESET_COMPLETED</spirit:name>
          <spirit:displayName>RESET_COMPLETED</spirit:displayName>
          <spirit:description>   Modified reset values for registers. </spirit:description>
          <spirit:bitOffset>8</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Reset not completed. The flag will typically be in this state for an implementation-defined number of cycles after a reset. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Reset has completed. This is intended to be used to monitor SOFT_RESET commands, which may take some time. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>POWER_CHANGED_SINGLE</spirit:name>
          <spirit:displayName>POWER_CHANGED_SINGLE</spirit:displayName>
          <spirit:description>POWER_CHANGED_SINGLE</spirit:description>
          <spirit:bitOffset>9</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   No power changes. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   This event is triggered when the power manager returns to being idle after a single core has changed power state.  The POWER_CHANGED_SINGLE event should be used in conjunction with the *_READY and *_PWRTRANS registers, together with knowledge of previous writes to *_PRWON and *_PWROFF registers, to decide which cores have changed state. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>POWER_CHANGED_ALL</spirit:name>
          <spirit:displayName>POWER_CHANGED_ALL</spirit:displayName>
          <spirit:description>POWER_CHANGED_ALL</spirit:description>
          <spirit:bitOffset>10</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   No power changes. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   This event is triggered when the power manager returns to being idle after all cores have changed power state. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>PRFCNT_SAMPLE_COMPLETED</spirit:name>
          <spirit:displayName>PRFCNT_SAMPLE_COMPLETED</spirit:displayName>
          <spirit:description>PRFCNT_SAMPLE_COMPLETED</spirit:description>
          <spirit:bitOffset>16</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Performance counts not complete. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   This flag  will be set only after the completion of a manually-triggered PRFCNT_SAMPLE command (see  GPU_COMMAND ). It will not be set during tile-mode performance counting.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>CLEAN_CACHES_COMPLETED</spirit:name>
          <spirit:displayName>CLEAN_CACHES_COMPLETED</spirit:displayName>
          <spirit:description>CLEAN_CACHES_COMPLETED</spirit:description>
          <spirit:bitOffset>17</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Cache clean not completed. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   This flag  will be set only after the completion of a manually-triggered CLEAN_CACHES or CLEAN_INV_CACHES command (see  GPU_COMMAND ). It will not be set during job chain execution.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>GPU_IRQ_STATUS</spirit:name>
        <spirit:displayName>GPU_IRQ_STATUS</spirit:displayName>
        <spirit:description>   This register has the same layout as GPU_IRQ_RAWSTAT. This register contains the result of anding together GPU_IRQ_RAWSTAT and GPU_IRQ_MASK. If any bits in this register are set, the external GPU control interrupt line is asserted, signaling an interrupt request to the CPU. </spirit:description>
        <spirit:addressOffset>0x2c</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>Res15</spirit:name>
          <spirit:displayName>Res15</spirit:displayName>
          <spirit:description>Res15</spirit:description>
          <spirit:bitOffset>1</spirit:bitOffset>
          <spirit:bitWidth>6</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>Res16</spirit:name>
          <spirit:displayName>Res16</spirit:displayName>
          <spirit:description>Res16</spirit:description>
          <spirit:bitOffset>11</spirit:bitOffset>
          <spirit:bitWidth>5</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>Res17</spirit:name>
          <spirit:displayName>Res17</spirit:displayName>
          <spirit:description>Res17</spirit:description>
          <spirit:bitOffset>18</spirit:bitOffset>
          <spirit:bitWidth>14</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>GPU_FAULT</spirit:name>
          <spirit:displayName>GPU_FAULT</spirit:displayName>
          <spirit:description>GPU_FAULT</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   No GPU fault. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   If a GPU Fault is reported (for example a bus fault occurs when writing back a cache line), the GPU_FAULT bit is set, the fault type is placed in the GPU_FAULTSTATUS register, and the address causing the fault is put in the  GPU_FAULTADDRESS register. This fault is treated as a GPU exception. See  ExceptionStatus for information on fault codes and additional data locations.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>MULTIPLE_GPU_FAULTS</spirit:name>
          <spirit:displayName>MULTIPLE_GPU_FAULTS</spirit:displayName>
          <spirit:description>MULTIPLE_GPU_FAULTS</spirit:description>
          <spirit:bitOffset>7</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   No multiple fault. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   If the GPU Fault flag is already set, then the MULTIPLE_GPU_FAULTS bit is set, but the address and status registers are not updated. The core will not stop execution but data may be lost.  This fault is treated as a GPU exception. See  ExceptionStatus for information on fault codes and additional data locations.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>RESET_COMPLETED</spirit:name>
          <spirit:displayName>RESET_COMPLETED</spirit:displayName>
          <spirit:description>   Modified reset values for registers. </spirit:description>
          <spirit:bitOffset>8</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Reset not completed. The flag will typically be in this state for an implementation-defined number of cycles after a reset. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Reset has completed. This is intended to be used to monitor SOFT_RESET commands, which may take some time. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>POWER_CHANGED_SINGLE</spirit:name>
          <spirit:displayName>POWER_CHANGED_SINGLE</spirit:displayName>
          <spirit:description>POWER_CHANGED_SINGLE</spirit:description>
          <spirit:bitOffset>9</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   No power changes. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   This event is triggered when the power manager returns to being idle after a single core has changed power state.  The POWER_CHANGED_SINGLE event should be used in conjunction with the *_READY and *_PWRTRANS registers, together with knowledge of previous writes to *_PRWON and *_PWROFF registers, to decide which cores have changed state. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>POWER_CHANGED_ALL</spirit:name>
          <spirit:displayName>POWER_CHANGED_ALL</spirit:displayName>
          <spirit:description>POWER_CHANGED_ALL</spirit:description>
          <spirit:bitOffset>10</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   No power changes. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   This event is triggered when the power manager returns to being idle after all cores have changed power state. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>PRFCNT_SAMPLE_COMPLETED</spirit:name>
          <spirit:displayName>PRFCNT_SAMPLE_COMPLETED</spirit:displayName>
          <spirit:description>PRFCNT_SAMPLE_COMPLETED</spirit:description>
          <spirit:bitOffset>16</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Performance counts not complete. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   This flag  will be set only after the completion of a manually-triggered PRFCNT_SAMPLE command (see  GPU_COMMAND ). It will not be set during tile-mode performance counting.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>CLEAN_CACHES_COMPLETED</spirit:name>
          <spirit:displayName>CLEAN_CACHES_COMPLETED</spirit:displayName>
          <spirit:description>CLEAN_CACHES_COMPLETED</spirit:description>
          <spirit:bitOffset>17</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Cache clean not completed. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   This flag  will be set only after the completion of a manually-triggered CLEAN_CACHES or CLEAN_INV_CACHES command (see  GPU_COMMAND ). It will not be set during job chain execution.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>GPU_COMMAND</spirit:name>
        <spirit:displayName>GPU_COMMAND</spirit:displayName>
        <spirit:description>   Writing values to this register will perform GPU-wide commands.  During SOFT_RESET or HARD_RESET commands, the Job Manager retains the value of GPU_IRQ_MASK[RESET_COMPLETED]. </spirit:description>
        <spirit:addressOffset>0x30</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>GPU_COMMAND</spirit:name>
          <spirit:displayName>GPU_COMMAND</spirit:displayName>
          <spirit:description>   Added SET_SECURE_MODE to GPU_COMMAND register.  Changed SET_SECURE_MODE to SET_PROTECTED_MODE. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>write-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NOP</spirit:name>
              <spirit:description> No operation, nothing happens. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>SOFT_RESET</spirit:name>
              <spirit:description> Stop all external bus interfaces, and then reset the entire GPU.
			This will leave the state of active jobs  UNDEFINED , but will leave the external bus in a defined and idle state.
			A SOFT_RESET may take some time. Use the RESET_COMPLETED interrupt to see when the reset has completed.
			During a SOFT_RESET, the IRQ masks for the RESET_COMPLETED interrupt are preserved.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>HARD_RESET</spirit:name>
              <spirit:description> Immediately reset the entire GPU.
			A HARD_RESET may take some time. Use the RESET_COMPLETED interrupt to see when the reset has completed.
			During a HARD_RESET, the IRQ masks for the RESET_COMPLETED interrupt are preserved.  This will leave the state of currently active jobs  UNDEFINED , will likely lose data, and may leave the system bus in an inconsistent state!
				Use only as a last resort when nothing else works!</spirit:description>
              <spirit:value>2</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>PRFCNT_CLEAR</spirit:name>
              <spirit:description> Clear all performance counters, setting them all to zero. </spirit:description>
              <spirit:value>3</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>PRFCNT_SAMPLE</spirit:name>
              <spirit:description> Sample all performance counters, writing them out to memory. The mode setting in the PRFCNT_CONFIG register determines whether to automatically clear the counters after writing. They may also be cleared explicitly using the PRFCNT_CLEAR command.
			Issuing this command while the PRFCNT_ACTIVE bit in the GPU_STATUS register is high is  UNDEFINED .</spirit:description>
              <spirit:value>4</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>CYCLE_COUNT_START</spirit:name>
              <spirit:description> Starts the cycle counter, and system timestamp propagation. </spirit:description>
              <spirit:value>5</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>CYCLE_COUNT_STOP</spirit:name>
              <spirit:description> Stops the cycle counter, and system timestamp propagation. </spirit:description>
              <spirit:value>6</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>CLEAN_CACHES</spirit:name>
              <spirit:description> Clean all caches. </spirit:description>
              <spirit:value>7</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>CLEAN_INV_CACHES</spirit:name>
              <spirit:description> Clean and invalidate all caches. </spirit:description>
              <spirit:value>8</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>SET_PROTECTED_MODE</spirit:name>
              <spirit:description> Places the GPU in protected mode. </spirit:description>
              <spirit:value>9</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>GPU_STATUS</spirit:name>
        <spirit:displayName>GPU_STATUS</spirit:displayName>
        <spirit:description>   The GPU status register contains a set of flags showing the overall state of the GPU. </spirit:description>
        <spirit:addressOffset>0x34</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>Res18</spirit:name>
          <spirit:displayName>Res18</spirit:displayName>
          <spirit:description>Res18</spirit:description>
          <spirit:bitOffset>8</spirit:bitOffset>
          <spirit:bitWidth>24</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>GPU_ACTIVE</spirit:name>
          <spirit:displayName>GPU_ACTIVE</spirit:displayName>
          <spirit:description>GPU_ACTIVE</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> The GPU is completely inactive. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Any part of the GPU is active. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>PWR_ACTIVE</spirit:name>
          <spirit:displayName>PWR_ACTIVE</spirit:displayName>
          <spirit:description>PWR_ACTIVE</spirit:description>
          <spirit:bitOffset>1</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> The power manager is inactive, and the GPU is in a stable power state. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> The power manager is active, and the power state of the GPU is changing. When this flag is set, do not attempt to send additional commands to the power manager. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>PRFCNT_ACTIVE</spirit:name>
          <spirit:displayName>PRFCNT_ACTIVE</spirit:displayName>
          <spirit:description>PRFCNT_ACTIVE</spirit:description>
          <spirit:bitOffset>2</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> The performance counters are not accessing memory. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> The performance counters are writing counter values to memory. When this flag is set, do not attempt to send additional commands to the performance counter block. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>JOB_ACTIVE</spirit:name>
          <spirit:displayName>JOB_ACTIVE</spirit:displayName>
          <spirit:description>JOB_ACTIVE</spirit:description>
          <spirit:bitOffset>3</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> The job slots are completely inactive. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> At least one job slot is active. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>PAGE_FAULT</spirit:name>
          <spirit:displayName>PAGE_FAULT</spirit:displayName>
          <spirit:description>PAGE_FAULT</spirit:description>
          <spirit:bitOffset>4</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> No page faults are currently being reported. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> A page fault has been reported and not yet cleared. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>IRQ_ACTIVE</spirit:name>
          <spirit:displayName>IRQ_ACTIVE</spirit:displayName>
          <spirit:description>IRQ_ACTIVE</spirit:description>
          <spirit:bitOffset>5</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> The interrupts are completely inactive. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> At least one interrupt has been signalled and not yet cleared. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>CYCLE_COUNT_ACTIVE</spirit:name>
          <spirit:displayName>CYCLE_COUNT_ACTIVE</spirit:displayName>
          <spirit:description>CYCLE_COUNT_ACTIVE</spirit:description>
          <spirit:bitOffset>6</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> The cycle counter is inactive. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> The cycle counter is active. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>PROTECTED_MODE_ACTIVE</spirit:name>
          <spirit:displayName>PROTECTED_MODE_ACTIVE</spirit:displayName>
          <spirit:description>   Added protected mode indicator to GPU_STATUS register. </spirit:description>
          <spirit:bitOffset>7</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> The GPU is running in user mode. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> The GPU is running in protected mode. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>LATEST_FLUSH</spirit:name>
        <spirit:displayName>LATEST_FLUSH</spirit:displayName>
        <spirit:description>   If cache flush reduction is enabled, then this register contains the Flush ID associated with the lastest clean-and-invalidate operation.  This value is set to 0xFFFFE0 on reset, and incremented by the hardware every time a cache flush is performed by the GPU.  When enqueuing a new job chain, the value in this register should be used to set the  FLUSH_ID_NEXT register of the new job chain.
					It is then possible for the GPU to determine if the GPU cache has already been flushed since submission of the job. If so, we may be able to
					determine that the memory state between CPU and GPU is already consistent and the GPU need not issue another cache flush. Further details on which cache flushes may be suppressed can be found in the description of the  ENABLE_FLUSH_REDUCTION flag.</spirit:description>
        <spirit:addressOffset>0x38</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0xffffe0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>Res19</spirit:name>
          <spirit:displayName>Res19</spirit:displayName>
          <spirit:description>Res19</spirit:description>
          <spirit:bitOffset>24</spirit:bitOffset>
          <spirit:bitWidth>8</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>FLUSH_ID</spirit:name>
          <spirit:displayName>FLUSH_ID</spirit:displayName>
          <spirit:description>   When operating in "cache flush reduction" mode, each job chain has an associated ID which is used to identify cache flushes.  This ID is a sequential 24-bit value. When the job manager is asked to perform a flush, it compares the job chain flush ID with the latest flush ID. If the job chain ID is equal to the latest flush, then a flush is performed.  Care must be taken in the overflow case. If the software setting up the ID detects that an overflow may occur, the job chain should be tagged with the maximum value of the  LATEST_FLUSH register. This ensures that flushes are correctly performed, at the possible cost of a few redundant flushes. Added cache flush reduction  LATEST_FLUSH.flush_id field narrowed to 24 bits, changed reset value.  Cache flush actually happens when FLUSH_ID_NEXT is equal to LATEST_FLUSH in flush reduction mode. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>24</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>GPU_FAULTSTATUS</spirit:name>
        <spirit:displayName>GPU_FAULTSTATUS</spirit:displayName>
        <spirit:description>   This register contains extended status information after a fault. If read before a fault occurs, its contents are the reset value, 0, which indicates no fault.  See  ExceptionStatus for details on the contents and layout of the fault status value. If multiple faults occur before the first is handled, the subsequent faults are ignored. They may fault again after handling the first one. Software must indicate that it has handled the fault by clearing the appropriate interrupt bit.  If the GPU is in protected mode, this register will read as zero.  Changed access type of GPU_FAULTSTATUS register when in protected mode. </spirit:description>
        <spirit:addressOffset>0x3c</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>exception_data</spirit:name>
          <spirit:displayName>exception_data</spirit:displayName>
          <spirit:description> This can be interpretted as a bitfield that may include access type and source ID. </spirit:description>
          <spirit:bitOffset>8</spirit:bitOffset>
          <spirit:bitWidth>24</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>exception_type</spirit:name>
          <spirit:displayName>exception_type</spirit:displayName>
          <spirit:description>   Added new MMU exception types.  Changed INTERRUPTED exception type to SUSPENDED.  Added exception types for new events EUREKA and KABOOM.  Removed aliases for OK - used to also be called IDLE and NOT_STARTED.  Documented that a KABOOM instruction will cause other jobs to hard-stop.  Removed OUT_OF_MEMORY_AFBC error as it can only occur with non-sparse allocation (now removed).  Removed INSTR_TYPE_MISMATCH, INSTR_OPERAND_FAULT, INSTR_TLS_FAULT, INSTR_ALIGN_FAULT; added IMPRECISE_FAULT (0x5B).  Split SHAREABILITY_FAULT into GPU_SHAREABILITY_FAULT, SYSTEM_SHAREABILITY_FAULT and GPU_CACHEABILITY_FAULT. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>8</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>OK</spirit:name>
              <spirit:description>   This indicates that the GPU has completed its work and is in a state ready to receive new commands. Its precise meaning depends on its usage:    In the job status field, this indicates that the job has not been started. This should be the initial state of a newly created job.  In the job slot status register, this indicates that the job slot is idle.  In the GPU and MMU exception status registers, this indicates that no exception has yet been received.  No additional error information is available (or indeed required). </spirit:description>
              <spirit:value>0x00</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>DONE</spirit:name>
              <spirit:description> The job completed successfully. The fault value is written to the job descriptor.
			The job descriptors fault address field contains the TIMESTAMP value when the job completed.
			If a job is terminated early using the  EUREKA instruction, then that job will be marked with the EUREKA exception status but the job chain status as a whole will still be DONE.</spirit:description>
              <spirit:value>0x01</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>SUSPENDED</spirit:name>
              <spirit:description> The job was interrupted by a SUSPEND command. The fault value is written both to the job slot  STATUS register and the job descriptor.
			The job descriptor contains the partition index of the first task to be interrupted. The fault address field contains the TIMESTAMP value when the job was interrupted.</spirit:description>
              <spirit:value>0x02</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>STOPPED</spirit:name>
              <spirit:description> The job was interrupted by a SOFT_STOP command. The fault value is written both to the job slot  STATUS register and the job descriptor.
			The job descriptor contains the partition index of the first task that was not completed. This will be the index of the first task issued if the job is resumed. The fault address is UNDEFINED .</spirit:description>
              <spirit:value>0x03</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TERMINATED</spirit:name>
              <spirit:description> The job was interrupted by a HARD_STOP command or a  KABOOM instruction from another job. The fault value is written both to the job slot STATUS register and the job descriptor.
			This status is treated in the same way as an error condition. The job descriptor contains the partition index of the first task to be terminated. The fault address field contains the TIMESTAMP value when the job was interrupted.</spirit:description>
              <spirit:value>0x04</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>KABOOM</spirit:name>
              <spirit:description> The job was interrupted by a shader executing a  KABOOM instruction. The fault value is written both to the job slot STATUS register and the job descriptor.
			This status is treated in the same way as an error condition. The job descriptor contains the partition index of the first task to be terminated. The fault address field contains the TIMESTAMP value when the job was interrupted.</spirit:description>
              <spirit:value>0x05</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>EUREKA</spirit:name>
              <spirit:description> The job was interrupted by a shader executing a  EUREKA instruction. The fault value is written only to the job descriptor, and does not affect subsequent jobs in the job chain.
			The job descriptor contains the partition index of the first task to be terminated. The fault address field contains the TIMESTAMP value when the job was interrupted.</spirit:description>
              <spirit:value>0x06</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ACTIVE</spirit:name>
              <spirit:description> In the JSn_STATUS register, this indicates that the job slot is active.
			The JSn_HEAD and JSn_TAIL registers contain the range of job descriptors currently in progress. </spirit:description>
              <spirit:value>0x08</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>JOB_CONFIG_FAULT</spirit:name>
              <spirit:description>   The job configuration specified in the job slot registers is invalid, so it is not possible to read job descriptors.
				For example this includes setting a NULL job descriptor pointer, selecting an address space that isnt present.
				No additional information is available. </spirit:description>
              <spirit:value>0x40</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>JOB_POWER_FAULT</spirit:name>
              <spirit:description>   The job could not be executed because the part of the memory system required to access job descriptors was not powered on.
				No additional information is available. </spirit:description>
              <spirit:value>0x41</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>JOB_READ_FAULT</spirit:name>
              <spirit:description>   Reading a job descriptor into the Job manager failed.
				The JSn_HEAD register contains the virtual address of the job descriptor that could not be read. </spirit:description>
              <spirit:value>0x42</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>JOB_WRITE_FAULT</spirit:name>
              <spirit:description>   Writing a job descriptor from the Job manager failed.
				The JSn_TAIL register contains the virtual address of the job descriptor that could not be written. </spirit:description>
              <spirit:value>0x43</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>JOB_AFFINITY_FAULT</spirit:name>
              <spirit:description>   The job could not be executed because the specified affinity mask does not intersect any available cores.
				No additional information is available. </spirit:description>
              <spirit:value>0x44</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>JOB_BUS_FAULT</spirit:name>
              <spirit:description>   A bus access failed while executing a job.
				The job descriptor contains the virtual address of the failing access, the type of access, and which part of the GPU initiated the access.
				This error code may also be reported if a bus fault occurs while writing the performance counters to memory. In this case, the GPU_FAULT* registers are updated, but the active JASID is not reported. It is possible to distinguish this case from a genuine Job Bus Fault exception by examining the SOURCE_ID field. </spirit:description>
              <spirit:value>0x48</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>INSTR_INVALID_PC</spirit:name>
              <spirit:description>   A shader instruction with an illegal program counter was executed.
				The job descriptors fault address field contains the offending program counter value. </spirit:description>
              <spirit:value>0x50</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>INSTR_INVALID_ENC</spirit:name>
              <spirit:description>   A shader instruction with an illegal encoding was executed.
				The job descriptors fault address field contains the program counter used to reach the offending instruction. </spirit:description>
              <spirit:value>0x51</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>INSTR_BARRIER_FAULT</spirit:name>
              <spirit:description>   A shader instruction was executed that failed to complete an instruction barrier.
				The job descriptors fault address field contains the program counter used to reach the offending instruction. </spirit:description>
              <spirit:value>0x55</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>DATA_INVALID_FAULT</spirit:name>
              <spirit:description>   Any data structure read as part of the job contains invalid combinations of data.
				The job descriptors fault address field contains the virtual address of the invalid data structure. </spirit:description>
              <spirit:value>0x58</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TILE_RANGE_FAULT</spirit:name>
              <spirit:description>   Tile or fragment shading was asked to process a tile that is entirely outside the bounding box of the frame.
				The job descriptors fault address field contains the coordinates of the top left corner of the failing tile, with X in the bits [15:0], and Y in the bits [31:16].  Clarified description of TILE_RANGE_FAULT. </spirit:description>
              <spirit:value>0x59</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ADDR_RANGE_FAULT</spirit:name>
              <spirit:description>   A virtual address has been found that exceeds the virtual address range.
				The job descriptors fault address field contains the virtual address which is out of range. </spirit:description>
              <spirit:value>0x5A</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>IMPRECISE_FAULT</spirit:name>
              <spirit:description>   A fault has been generated without precise fault information.
				This can happen if appropriate source information is not available at the point where the fault happens.
				The job descriptors fault address field may contain a virtual address related to the fault. </spirit:description>
              <spirit:value>0x5B</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>OUT_OF_MEMORY</spirit:name>
              <spirit:description>   The tiler ran out of memory when executing a job.
				The job descriptors fault address field contains the index of the last completed vertex sent through the tiler. </spirit:description>
              <spirit:value>0x60</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>UNKNOWN</spirit:name>
              <spirit:description>   If multiple jobs in a job chain fail, only the first one the reports an error will set and return full error information. Subsequent failing jobs will not update the error status registers, and may write an error status of UNKNOWN.
				Note that the first job to fail may not be the first job in the chain, which may lead to jobs with  UNKNOWN error status being encountered first when traversing the job chain.
				For example, you may see: Done, Done, Unknown, Bus Error, Unknown, New. In this case, the first two jobs ran successfully, the fourth job hit a bus error, and then jobs three and five also failed. The sixth and subsequent jobs had not been started at that point.</spirit:description>
              <spirit:value>0x7F</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>DELAYED_BUS_FAULT</spirit:name>
              <spirit:description>   The GPU received a bus fault for access to physical memory where the original virtual address is no longer available. This is the result of evicting a dirty line from a cache.
				This may also be triggered by a bus fault during a Tiler cache flush operation. In this case, the address reported in  GPU_FAULTADDRESS is a virtual address.</spirit:description>
              <spirit:value>0x80</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>GPU_SHAREABILITY_FAULT</spirit:name>
              <spirit:description>   A cache has detected that the same line has been accessed as both shareable and non-shareable memory from inside the GPU. Coherency after this point can no longer be guaranteed. </spirit:description>
              <spirit:value>0x88</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>SYSTEM_SHAREABILITY_FAULT</spirit:name>
              <spirit:description>   A cache has detected that the same line has been accessed as both shareable and non-shareable memory from outside the GPU. Coherency after this point can no longer be guaranteed. </spirit:description>
              <spirit:value>0x89</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>GPU_CACHEABILITY_FAULT</spirit:name>
              <spirit:description>   A cache has detected that the same line has been accessed as both cacheable and non-cacheable memory from inside the GPU. Non-cacheable memory may have been cached. </spirit:description>
              <spirit:value>0x8A</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TRANSLATION_FAULT_0</spirit:name>
              <spirit:description>   A memory access hit an invalid table entry at level 0 of the translation table. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xC0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TRANSLATION_FAULT_1</spirit:name>
              <spirit:description>   A memory access hit an invalid table entry at level 1 of the translation table. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xC1</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TRANSLATION_FAULT_2</spirit:name>
              <spirit:description>   A memory access hit an invalid table entry at level 2 of the translation table. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xC2</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TRANSLATION_FAULT_3</spirit:name>
              <spirit:description>   A memory access hit an invalid table entry at level 3 of the translation table. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xC3</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TRANSLATION_FAULT_IDENTITY</spirit:name>
              <spirit:description>   In IDENTITY translation mode, the virtual address exceeds the maximum physical address. </spirit:description>
              <spirit:value>0xC7</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>PERMISSION_FAULT_0</spirit:name>
              <spirit:description>   A memory access could not be allowed due to the permission flags set in level 0 of the translation table. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set. Added MMU translation level information to permission fault. </spirit:description>
              <spirit:value>0xC8</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>PERMISSION_FAULT_1</spirit:name>
              <spirit:description>   A memory access could not be allowed due to the permission flags set in level 1 of the translation table. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xC9</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>PERMISSION_FAULT_2</spirit:name>
              <spirit:description>   A memory access could not be allowed due to the permission flags set in level 2 of the translation table. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xCA</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>PERMISSION_FAULT_3</spirit:name>
              <spirit:description>   A memory access could not be allowed due to the permission flags set in level 3 of the translation table. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xCB</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TRANSTAB_BUS_FAULT_0</spirit:name>
              <spirit:description>   A bus fault occurred while reading level 0 of the translation tables. The appropriate  BUS_ERROR flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xD0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TRANSTAB_BUS_FAULT_1</spirit:name>
              <spirit:description>   A bus fault occurred while reading level 1 of the translation tables. The appropriate  BUS_ERROR flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xD1</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TRANSTAB_BUS_FAULT_2</spirit:name>
              <spirit:description>   A bus fault occurred while reading level 2 of the translation tables. The appropriate  BUS_ERROR flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xD2</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TRANSTAB_BUS_FAULT_3</spirit:name>
              <spirit:description>   A bus fault occurred while reading level 3 of the translation tables. The appropriate  BUS_ERROR flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xD3</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ACCESS_FLAG_0</spirit:name>
              <spirit:description>   A memory access hit a translation table entry with the ACCESS_FLAG bit set in level 0 of the translation table. This is not treated as a fault by the accessor. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set. Added MMU translation level information to access flag fault. </spirit:description>
              <spirit:value>0xD8</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ACCESS_FLAG_1</spirit:name>
              <spirit:description>   A memory access hit a translation table entry with the ACCESS_FLAG bit set in level 1 of the translation table. This is not treated as a fault by the accessor. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xD9</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ACCESS_FLAG_2</spirit:name>
              <spirit:description>   A memory access hit a translation table entry with the ACCESS_FLAG bit set in level 2 of the translation table. This is not treated as a fault by the accessor. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xDA</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ACCESS_FLAG_3</spirit:name>
              <spirit:description>   A memory access hit a translation table entry with the ACCESS_FLAG bit set in level 3 of the translation table. This is not treated as a fault by the accessor. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xDB</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ADDRESS_SIZE_FAULT_IN0</spirit:name>
              <spirit:description>   An input address size fault occurred while reading level 0 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ADDRESS_SIZE_FAULT_IN1</spirit:name>
              <spirit:description>   An input address size fault occurred while reading level 1 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE1</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ADDRESS_SIZE_FAULT_IN2</spirit:name>
              <spirit:description>   An input address size fault occurred while reading level 2 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE2</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ADDRESS_SIZE_FAULT_IN3</spirit:name>
              <spirit:description>   An input address size fault occurred while reading level 3 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE3</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ADDRESS_SIZE_FAULT_OUT0</spirit:name>
              <spirit:description>   An output address size fault occurred while reading level 0 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE4</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ADDRESS_SIZE_FAULT_OUT1</spirit:name>
              <spirit:description>   An output address size fault occurred while reading level 1 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE5</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ADDRESS_SIZE_FAULT_OUT2</spirit:name>
              <spirit:description>   An output address size fault occurred while reading level 2 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE6</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ADDRESS_SIZE_FAULT_OUT3</spirit:name>
              <spirit:description>   An output address size fault occurred while reading level 3 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE7</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>MEMORY_ATTRIBUTE_FAULT_0</spirit:name>
              <spirit:description>   A memory access could not be allowed due to an attempt to access a page with its memory attribute set to  FAULT in the MEMATTR register. This fault happened when reading level 0 of the translation tables. The appropriate PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE8</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>MEMORY_ATTRIBUTE_FAULT_1</spirit:name>
              <spirit:description>   A memory access could not be allowed due to an attempt to access a page with its memory attribute set to  FAULT in the MEMATTR register. This fault happened when reading level 1 of the translation tables. The appropriate PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE9</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>MEMORY_ATTRIBUTE_FAULT_2</spirit:name>
              <spirit:description>   A memory access could not be allowed due to an attempt to access a page with its memory attribute set to  FAULT in the MEMATTR register. This fault happened when reading level 2 of the translation tables. The appropriate PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xEA</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>MEMORY_ATTRIBUTE_FAULT_3</spirit:name>
              <spirit:description>   A memory access could not be allowed due to an attempt to access a page with its memory attribute set to  FAULT in the MEMATTR register. This fault happened when reading level 3 of the translation tables. The appropriate PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xEB</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>MEMORY_ATTRIBUTE_NONCACHEABLE_0</spirit:name>
              <spirit:description>   A memory access could not be allowed due to an attempt to access a non-cacheable page from a bus master which does not support non-cacheable accessess. This fault happened when reading level 0 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xEC</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>MEMORY_ATTRIBUTE_NONCACHEABLE_1</spirit:name>
              <spirit:description>   A memory access could not be allowed due to an attempt to access a non-cacheable page from a bus master which does not support non-cacheable accessess. This fault happened when reading level 1 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xED</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>MEMORY_ATTRIBUTE_NONCACHEABLE_2</spirit:name>
              <spirit:description>   A memory access could not be allowed due to an attempt to access a non-cacheable page from a bus master which does not support non-cacheable accessess. This fault happened when reading level 2 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xEE</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>MEMORY_ATTRIBUTE_NONCACHEABLE_3</spirit:name>
              <spirit:description>   A memory access could not be allowed due to an attempt to access a non-cacheable page from a bus master which does not support non-cacheable accessess. This fault happened when reading level 3 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xEF</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>GPU_FAULTADDRESS_LO</spirit:name>
        <spirit:displayName>GPU_FAULTADDRESS_LO</spirit:displayName>
        <spirit:description>   If a GPU exception occurs, then the physical address causing the fault is shown in this register.  If multiple faults occur before the first is handled, the subsequent faults are ignored. They may fault again after handling the first one. Software must indicate that it has handled the fault by clearing the appropriate interrupt bit. </spirit:description>
        <spirit:addressOffset>0x40</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>GPU_FAULTADDRESS_LO</spirit:name>
          <spirit:displayName>GPU_FAULTADDRESS_LO</spirit:displayName>
          <spirit:description>   It contains the physical address at which the GPU fault occurred. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>GPU_FAULTADDRESS_HI</spirit:name>
        <spirit:displayName>GPU_FAULTADDRESS_HI</spirit:displayName>
        <spirit:description>   If a GPU exception occurs, then the physical address causing the fault is shown in this register.  If multiple faults occur before the first is handled, the subsequent faults are ignored. They may fault again after handling the first one. Software must indicate that it has handled the fault by clearing the appropriate interrupt bit. </spirit:description>
        <spirit:addressOffset>0x44</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>GPU_FAULTADDRESS_HI</spirit:name>
          <spirit:displayName>GPU_FAULTADDRESS_HI</spirit:displayName>
          <spirit:description>   It contains the physical address at which the GPU fault occurred. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>PWR_KEY</spirit:name>
        <spirit:displayName>PWR_KEY</spirit:displayName>
        <spirit:description>   The power manager key register must be written before any of the power control override registers can be written to.  Since incorrectly setting any of the PWR_OVERRIDEn registers may potentially lock up or damage a device, they are write protected by default.  By writing the value 0x2968A819 to this register, the PWR_OVERRIDEn registers are temporarily made writable. The next write access to the GPU can then update them. If writing multiple registers, the PWR_KEY register must be written before each register is updated.  The registers are write protected automatically after any write access to the GPU. If the first write after unlocking the registers are not to any of the power override registers, the registers are still write protected, causing any later update attempt to be ignored. </spirit:description>
        <spirit:addressOffset>0x50</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>PWR_KEY</spirit:name>
          <spirit:displayName>PWR_KEY</spirit:displayName>
          <spirit:description>   It must be written with the value 0x2968A819 to unlock writes to the other power state registers. This key value was generated at random, and has no special significance except that it is unlikely to occur by chance. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>write-only</spirit:access>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>PWR_OVERRIDE0</spirit:name>
        <spirit:displayName>PWR_OVERRIDE0</spirit:displayName>
        <spirit:description>   The power manager override register 0 allows aspects of how individual cores are powered up and down to be overridden.  This register is write protected by default. A special key value must be written to the PWR_KEY register to allow this register to be updated.  The override fields allow the low-level signals used for controlling power gating to behave differently from normal. This can be used for testing, or for working around power gating problems. As such, they require low-level understanding of the implementation details of the power domain controller.  The override values are propagated to individual power domains on any power up or power down operation. To change the override modes for a power domain, the power state of the domain must be changed. Domains that are powered on must be powered off, and domains that are powered off must be powered on.  Writing to this register while any power change commands are pending is  UNDEFINED . Setting incorrect values in this register may cause  UNPREDICTABLE behaviour of the entire system. Do not write to this register unless explicitly specified by the device manufacturer. The only guaranteed safe value for this register is 0. Removed CLKEN_OVERRIDE from PWR_OVERRIDE0 register. </spirit:description>
        <spirit:addressOffset>0x54</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>Res20</spirit:name>
          <spirit:displayName>Res20</spirit:displayName>
          <spirit:description>Res20</spirit:description>
          <spirit:bitOffset>6</spirit:bitOffset>
          <spirit:bitWidth>2</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>Res21</spirit:name>
          <spirit:displayName>Res21</spirit:displayName>
          <spirit:description>Res21</spirit:description>
          <spirit:bitOffset>22</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>Res22</spirit:name>
          <spirit:displayName>Res22</spirit:displayName>
          <spirit:description>Res22</spirit:description>
          <spirit:bitOffset>30</spirit:bitOffset>
          <spirit:bitWidth>2</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>PWRTRANS_LIMIT</spirit:name>
          <spirit:displayName>PWRTRANS_LIMIT</spirit:displayName>
          <spirit:description>   It contains the number of power domains which may be in transition at any one time, minus 1. </spirit:description>
          <spirit:bitOffset>16</spirit:bitOffset>
          <spirit:bitWidth>6</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>THROTTLE_LIMIT</spirit:name>
          <spirit:displayName>THROTTLE_LIMIT</spirit:displayName>
          <spirit:description>   This field contains the number of shader cores which may be in startup at any one time, minus 1.
						A core is considered to be starting after the core is sent a task (load_descriptor/run),
						until the first response to a RUN command (which includes LOAD_DESCRIPTOR with run_immediately).  If the  THROTTLE_ENABLE flag is clear, then this field is ignored. The intent of this is to smooth out sudden changes in dynamic power, in a similar way to how  PWRTRANS_LIMIT smooths out sudden changes in static power. Added core startup throttling fields to PWR_OVERRIDE0 </spirit:description>
          <spirit:bitOffset>24</spirit:bitOffset>
          <spirit:bitWidth>6</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>PWRUP_OVERRIDE</spirit:name>
          <spirit:displayName>PWRUP_OVERRIDE</spirit:displayName>
          <spirit:description>   It overrides the handling of the power manager's PWRUP signal. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>2</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>OVERRIDE_NONE</spirit:name>
              <spirit:description> The signal behaves normally </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>OVERRIDE_INVERT</spirit:name>
              <spirit:description> The signal is inverted (on when normally off, and vice versa) </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>OVERRIDE_ON</spirit:name>
              <spirit:description> The signal is always kept on </spirit:description>
              <spirit:value>2</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>OVERRIDE_OFF</spirit:name>
              <spirit:description> The signal is always kept off </spirit:description>
              <spirit:value>3</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ISOLATE_OVERRIDE</spirit:name>
          <spirit:displayName>ISOLATE_OVERRIDE</spirit:displayName>
          <spirit:description>   It overrides the handling of the power manager's ISOLATE signal. </spirit:description>
          <spirit:bitOffset>2</spirit:bitOffset>
          <spirit:bitWidth>2</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>OVERRIDE_NONE</spirit:name>
              <spirit:description> The signal behaves normally </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>OVERRIDE_INVERT</spirit:name>
              <spirit:description> The signal is inverted (on when normally off, and vice versa) </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>OVERRIDE_ON</spirit:name>
              <spirit:description> The signal is always kept on </spirit:description>
              <spirit:value>2</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>OVERRIDE_OFF</spirit:name>
              <spirit:description> The signal is always kept off </spirit:description>
              <spirit:value>3</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>RESET_OVERRIDE</spirit:name>
          <spirit:displayName>RESET_OVERRIDE</spirit:displayName>
          <spirit:description>   It overrides the handling of the power manager's RESET signal. </spirit:description>
          <spirit:bitOffset>4</spirit:bitOffset>
          <spirit:bitWidth>2</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>OVERRIDE_NONE</spirit:name>
              <spirit:description> The signal behaves normally </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>OVERRIDE_INVERT</spirit:name>
              <spirit:description> The signal is inverted (on when normally off, and vice versa) </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>OVERRIDE_ON</spirit:name>
              <spirit:description> The signal is always kept on </spirit:description>
              <spirit:value>2</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>OVERRIDE_OFF</spirit:name>
              <spirit:description> The signal is always kept off </spirit:description>
              <spirit:value>3</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>PWRUP_ACK_OVERRIDE</spirit:name>
          <spirit:displayName>PWRUP_ACK_OVERRIDE</spirit:displayName>
          <spirit:description>   It overrides the handling of the power manager's PWRUP signal. </spirit:description>
          <spirit:bitOffset>8</spirit:bitOffset>
          <spirit:bitWidth>2</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>OVERRIDE_NONE</spirit:name>
              <spirit:description> The signal behaves normally </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>OVERRIDE_INVERT</spirit:name>
              <spirit:description> The signal is inverted (on when normally off, and vice versa) </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>OVERRIDE_ON</spirit:name>
              <spirit:description> The signal is always kept on </spirit:description>
              <spirit:value>2</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>OVERRIDE_OFF</spirit:name>
              <spirit:description> The signal is always kept off </spirit:description>
              <spirit:value>3</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ISOLATE_ACK_OVERRIDE</spirit:name>
          <spirit:displayName>ISOLATE_ACK_OVERRIDE</spirit:displayName>
          <spirit:description>   It overrides the handling of the power manager's PWRUP signal. </spirit:description>
          <spirit:bitOffset>10</spirit:bitOffset>
          <spirit:bitWidth>2</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>OVERRIDE_NONE</spirit:name>
              <spirit:description> The signal behaves normally </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>OVERRIDE_INVERT</spirit:name>
              <spirit:description> The signal is inverted (on when normally off, and vice versa) </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>OVERRIDE_ON</spirit:name>
              <spirit:description> The signal is always kept on </spirit:description>
              <spirit:value>2</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>OVERRIDE_OFF</spirit:name>
              <spirit:description> The signal is always kept off </spirit:description>
              <spirit:value>3</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>FUNC_ISO_OVERRIDE</spirit:name>
          <spirit:displayName>FUNC_ISO_OVERRIDE</spirit:displayName>
          <spirit:description>   It overrides the handling of the power manager's FUNC_ISOLATE signal.  Added FUNC_ISO_OVERRIDE field to PWR_OVERRIDE0 register. </spirit:description>
          <spirit:bitOffset>12</spirit:bitOffset>
          <spirit:bitWidth>2</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>OVERRIDE_NONE</spirit:name>
              <spirit:description> The signal behaves normally </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>OVERRIDE_INVERT</spirit:name>
              <spirit:description> The signal is inverted (on when normally off, and vice versa) </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>OVERRIDE_ON</spirit:name>
              <spirit:description> The signal is always kept on </spirit:description>
              <spirit:value>2</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>OVERRIDE_OFF</spirit:name>
              <spirit:description> The signal is always kept off </spirit:description>
              <spirit:value>3</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>FUNC_ISO_ACK_OVERRIDE</spirit:name>
          <spirit:displayName>FUNC_ISO_ACK_OVERRIDE</spirit:displayName>
          <spirit:description>   It overrides the handling of the power manager's FUNC_ISOLATE_ACK signal.  Added FUNC_ISO_ACK_OVERRIDE field to PWR_OVERRIDE0 register. </spirit:description>
          <spirit:bitOffset>14</spirit:bitOffset>
          <spirit:bitWidth>2</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>OVERRIDE_NONE</spirit:name>
              <spirit:description> The signal behaves normally </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>OVERRIDE_INVERT</spirit:name>
              <spirit:description> The signal is inverted (on when normally off, and vice versa) </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>OVERRIDE_ON</spirit:name>
              <spirit:description> The signal is always kept on </spirit:description>
              <spirit:value>2</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>OVERRIDE_OFF</spirit:name>
              <spirit:description> The signal is always kept off </spirit:description>
              <spirit:value>3</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>THROTTLE_ENABLE</spirit:name>
          <spirit:displayName>THROTTLE_ENABLE</spirit:displayName>
          <spirit:description>THROTTLE_ENABLE</spirit:description>
          <spirit:bitOffset>23</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Core startup throttling disabled. Any number of cores may start processing tasks at any time. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Core startup throttling enabled. A limited number of cores may start, controlled by the  THROTTLE_LIMIT field.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>PWR_OVERRIDE1</spirit:name>
        <spirit:displayName>PWR_OVERRIDE1</spirit:displayName>
        <spirit:description>   In addition to the power control values in power manager override register 0, the device manufacturer may also choose to use this register to affect how power management behaves.  Setting incorrect values in this register may cause  UNPREDICTABLE behaviour of the entire system. Do not write to this register unless explicitly specified by the device manufacturer. The only guaranteed safe value for this register is 0.</spirit:description>
        <spirit:addressOffset>0x58</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>PWR_OVERRIDE1</spirit:name>
          <spirit:displayName>PWR_OVERRIDE1</spirit:displayName>
          <spirit:description>   System-specific power control values. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>PRFCNT_BASE_LO</spirit:name>
        <spirit:displayName>PRFCNT_BASE_LO</spirit:displayName>
        <spirit:description>   This register contains the start of a memory region where the performance counter values can be written. The required size of this are depends on the GPU configuration and the setting in the PRFCNT_CONFIG register.  The address is a virtual address in the address space specified by the ADDRESS_SPACE field in the PRFCNT_CONFIG register.  Writing to this register while the GPU is active and the performance counters are enabled is  UNDEFINED .</spirit:description>
        <spirit:addressOffset>0x60</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>PRFCNT_BASE_LO</spirit:name>
          <spirit:displayName>PRFCNT_BASE_LO</spirit:displayName>
          <spirit:description>   It contains the base address of performance counter write area. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>PRFCNT_BASE_HI</spirit:name>
        <spirit:displayName>PRFCNT_BASE_HI</spirit:displayName>
        <spirit:description>   This register contains the start of a memory region where the performance counter values can be written. The required size of this are depends on the GPU configuration and the setting in the PRFCNT_CONFIG register.  The address is a virtual address in the address space specified by the ADDRESS_SPACE field in the PRFCNT_CONFIG register.  Writing to this register while the GPU is active and the performance counters are enabled is  UNDEFINED .</spirit:description>
        <spirit:addressOffset>0x64</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>PRFCNT_BASE_HI</spirit:name>
          <spirit:displayName>PRFCNT_BASE_HI</spirit:displayName>
          <spirit:description>   It contains the base address of performance counter write area. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>PRFCNT_CONFIG</spirit:name>
        <spirit:displayName>PRFCNT_CONFIG</spirit:displayName>
        <spirit:description>   The performance counter configuration register controls how the performance counters work. For more details, see the section on Performance Counters. </spirit:description>
        <spirit:addressOffset>0x68</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>Res23</spirit:name>
          <spirit:displayName>Res23</spirit:displayName>
          <spirit:description>Res23</spirit:description>
          <spirit:bitOffset>9</spirit:bitOffset>
          <spirit:bitWidth>23</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>ADDRESS_SPACE</spirit:name>
          <spirit:displayName>ADDRESS_SPACE</spirit:displayName>
          <spirit:description>   It contains the address space ID (ASID) used to translate virtual addresses when writing the performance counters to memory. Changing address space while the GPU is active and the counters are enabled is  UNDEFINED . Specifying an address space that is not supported (i.e. the corresponding bit in AS_PRESENT is 0) is UNDEFINED .</spirit:description>
          <spirit:bitOffset>4</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>MODE</spirit:name>
          <spirit:displayName>MODE</spirit:displayName>
          <spirit:description>   Manual counter writing no longer automatically clears counters. Tiled mode is unchanged.  Manual counter writing reverted to clear counters, new MANUAL_NO_CLEAR mode added. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>OFF</spirit:name>
              <spirit:description> The performance counters are disabled. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>MANUAL</spirit:name>
              <spirit:description> The performance counters are enabled, but are only written out when a PRFCNT_SAMPLE command is issued using the GPU_COMMAND register, then automatically cleared. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TILE</spirit:name>
              <spirit:description> The performance counters are enabled. Each time a tile finishes rendering, the counter values are written out, then automatically cleared. </spirit:description>
              <spirit:value>2</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>MANUAL_NO_CLEAR</spirit:name>
              <spirit:description> The performance counters are enabled, but are only written out when a PRFCNT_SAMPLE command is issued using the GPU_COMMAND register. They are not automatically cleared after writing. </spirit:description>
              <spirit:value>3</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>SET_SELECT</spirit:name>
          <spirit:displayName>SET_SELECT</spirit:displayName>
          <spirit:description>   This flag allows selection of additional sets of counter events.
							For those counter blocks that support it, this effectively selects between two sets of the event count inputs to the same counter block.
							Since there is only one flag, all functional blocks are switched at the same time.
							During switching, the counter values become  UNDEFINED as they may register counts from a mixture of sources.
							It is therefore recommended that, after switching, performance counters are cleared by writing PRFCNT_CLEAR to the GPU_COMMAND register. Added  SET_SELECT flag to PRFCNT_CONFIG .</spirit:description>
          <spirit:bitOffset>8</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> Select primary counter event set. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Select secondary counter event set. If a block has primary counter events only, then this flag has no effect. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>PRFCNT_JM_EN</spirit:name>
        <spirit:displayName>PRFCNT_JM_EN</spirit:displayName>
        <spirit:description>   Performance counter enable for Job Manager. </spirit:description>
        <spirit:addressOffset>0x6c</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>PRFCNT_JM_EN</spirit:name>
          <spirit:displayName>PRFCNT_JM_EN</spirit:displayName>
          <spirit:description>   The main use for this register is to reduce the bandwidth required to write out the performance counters to memory, and so reduce the impact the counters have on the performance of the GPU.  Bit 0 controls the writing of the performance metadata - the time stamp and counter enable mask.  Writing to these registers while performance counters are enabled is  UNDEFINED . Writing to these registers while the corresponding cores are powered off has no effect. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> Counters 4*n-4 through to 4*n-1 are disabled. They will not count and are not written to memory. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Counters 4*n-4 through to 4*n-1 are enabled. They will count and are written to memory. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>PRFCNT_SHADER_EN</spirit:name>
        <spirit:displayName>PRFCNT_SHADER_EN</spirit:displayName>
        <spirit:description>   Performance counter enable for shader cores. </spirit:description>
        <spirit:addressOffset>0x70</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>PRFCNT_SHADER_EN</spirit:name>
          <spirit:displayName>PRFCNT_SHADER_EN</spirit:displayName>
          <spirit:description>   The main use for this register is to reduce the bandwidth required to write out the performance counters to memory, and so reduce the impact the counters have on the performance of the GPU.  Bit 0 controls the writing of the performance metadata - the time stamp and counter enable mask.  Writing to these registers while performance counters are enabled is  UNDEFINED . Writing to these registers while the corresponding cores are powered off has no effect. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> Counters 4*n-4 through to 4*n-1 are disabled. They will not count and are not written to memory. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Counters 4*n-4 through to 4*n-1 are enabled. They will count and are written to memory. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>PRFCNT_TILER_EN</spirit:name>
        <spirit:displayName>PRFCNT_TILER_EN</spirit:displayName>
        <spirit:description>   Performance counter enable for tiler. </spirit:description>
        <spirit:addressOffset>0x74</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>PRFCNT_TILER_EN</spirit:name>
          <spirit:displayName>PRFCNT_TILER_EN</spirit:displayName>
          <spirit:description>   The main use for this register is to reduce the bandwidth required to write out the performance counters to memory, and so reduce the impact the counters have on the performance of the GPU.  Bit 0 controls the writing of the performance metadata - the time stamp and counter enable mask.  Writing to these registers while performance counters are enabled is  UNDEFINED . Writing to these registers while the corresponding cores are powered off has no effect. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> Counters 4*n-4 through to 4*n-1 are disabled. They will not count and are not written to memory. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Counters 4*n-4 through to 4*n-1 are enabled. They will count and are written to memory. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>PRFCNT_MMU_L2_EN</spirit:name>
        <spirit:displayName>PRFCNT_MMU_L2_EN</spirit:displayName>
        <spirit:description>   Performance counter enable for memory management unit and level 2 cache. </spirit:description>
        <spirit:addressOffset>0x7c</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>PRFCNT_MMU_L2_EN</spirit:name>
          <spirit:displayName>PRFCNT_MMU_L2_EN</spirit:displayName>
          <spirit:description>   The main use for this register is to reduce the bandwidth required to write out the performance counters to memory, and so reduce the impact the counters have on the performance of the GPU.  Bit 0 controls the writing of the performance metadata - the time stamp and counter enable mask.  Writing to these registers while performance counters are enabled is  UNDEFINED . Writing to these registers while the corresponding cores are powered off has no effect. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> Counters 4*n-4 through to 4*n-1 are disabled. They will not count and are not written to memory. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Counters 4*n-4 through to 4*n-1 are enabled. They will count and are written to memory. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>CYCLE_COUNT_LO</spirit:name>
        <spirit:displayName>CYCLE_COUNT_LO</spirit:displayName>
        <spirit:description>   The Job Manager contains a 64-bit cycle counter. This counter simply counts the number of clock cycles since it was started, the frequency of which is determined by the system as a whole and which may change due to voltage and frequency scaling. It therefore does not have a unique, fixed relationship with real time, but is guaranteed to be nondecreasing unless reset, and is very fine grained.  It is readable through the CYCLE_COUNT register, and can also be written to memory by a write value job.  This counter value is sent to each shader core, ensuring that all cores have a consistent and synchronized value readable from the shader.  The counter must be explicitly started. After reset the counter has value zero but is not running. To start the counter, issue a CYCLE_COUNT_START command to the GPU_COMMAND register.  When the GPU is not used, the counter should be stopped to reduce power consumption. To stop the counter, issue a CYCLE_COUNT_STOP command to the GPU_COMMAND register.  Note that this is implemented separately from, and in addition to, a system-wide constant-frequency counter </spirit:description>
        <spirit:addressOffset>0x90</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>CYCLE_COUNT_LO</spirit:name>
          <spirit:displayName>CYCLE_COUNT_LO</spirit:displayName>
          <spirit:description>   It contains the number of GPU clock cycles since the counter was started. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>CYCLE_COUNT_HI</spirit:name>
        <spirit:displayName>CYCLE_COUNT_HI</spirit:displayName>
        <spirit:description>   The Job Manager contains a 64-bit cycle counter. This counter simply counts the number of clock cycles since it was started, the frequency of which is determined by the system as a whole and which may change due to voltage and frequency scaling. It therefore does not have a unique, fixed relationship with real time, but is guaranteed to be nondecreasing unless reset, and is very fine grained.  It is readable through the CYCLE_COUNT register, and can also be written to memory by a write value job.  This counter value is sent to each shader core, ensuring that all cores have a consistent and synchronized value readable from the shader.  The counter must be explicitly started. After reset the counter has value zero but is not running. To start the counter, issue a CYCLE_COUNT_START command to the GPU_COMMAND register.  When the GPU is not used, the counter should be stopped to reduce power consumption. To stop the counter, issue a CYCLE_COUNT_STOP command to the GPU_COMMAND register.  Note that this is implemented separately from, and in addition to, a system-wide constant-frequency counter </spirit:description>
        <spirit:addressOffset>0x94</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>CYCLE_COUNT_HI</spirit:name>
          <spirit:displayName>CYCLE_COUNT_HI</spirit:displayName>
          <spirit:description>   It contains the number of GPU clock cycles since the counter was started. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>TIMESTAMP_LO</spirit:name>
        <spirit:displayName>TIMESTAMP_LO</spirit:displayName>
        <spirit:description>   This is a handy point from which the system global timestamp counter can be read. The value is the current broadcast value of the system time counter, as described in [7], which has a fixed relationship with real time and is coherent system-wide.  Although the time stamp value is continually updated externally from the GPU, propagation of the time stamp value to the GPU must be explicitly started in the same manned as the CYCLE_COUNT register, above.  So, after reset the current local copy of the timestamp has value zero and is not being actively updated. To start updates, issue a CYCLE_COUNT_START command to the GPU_COMMAND register.  When the GPU is not used, time stamp updates should be stopped to reduce power consumption. To stop the update, issue a CYCLE_COUNT_STOP command to the GPU_COMMAND register. </spirit:description>
        <spirit:addressOffset>0x98</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>TIMESTAMP_LO</spirit:name>
          <spirit:displayName>TIMESTAMP_LO</spirit:displayName>
          <spirit:description>   It contains the global time stamp value. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>TIMESTAMP_HI</spirit:name>
        <spirit:displayName>TIMESTAMP_HI</spirit:displayName>
        <spirit:description>   This is a handy point from which the system global timestamp counter can be read. The value is the current broadcast value of the system time counter, as described in [7], which has a fixed relationship with real time and is coherent system-wide.  Although the time stamp value is continually updated externally from the GPU, propagation of the time stamp value to the GPU must be explicitly started in the same manned as the CYCLE_COUNT register, above.  So, after reset the current local copy of the timestamp has value zero and is not being actively updated. To start updates, issue a CYCLE_COUNT_START command to the GPU_COMMAND register.  When the GPU is not used, time stamp updates should be stopped to reduce power consumption. To stop the update, issue a CYCLE_COUNT_STOP command to the GPU_COMMAND register. </spirit:description>
        <spirit:addressOffset>0x9c</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>TIMESTAMP_HI</spirit:name>
          <spirit:displayName>TIMESTAMP_HI</spirit:displayName>
          <spirit:description>   It contains the global time stamp value. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>THREAD_MAX_THREADS</spirit:name>
        <spirit:displayName>THREAD_MAX_THREADS</spirit:displayName>
        <spirit:description>   The maximum number of threads that can be in flight on each core. If this register is 0, then the information is not available on this implementation of the GPU. </spirit:description>
        <spirit:addressOffset>0xa0</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x180</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>THREAD_MAX_THREADS</spirit:name>
          <spirit:displayName>THREAD_MAX_THREADS</spirit:displayName>
          <spirit:description>   It contains the maximum number of threads per core. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>THREAD_MAX_WORKGROUP_SIZE</spirit:name>
        <spirit:displayName>THREAD_MAX_WORKGROUP_SIZE</spirit:displayName>
        <spirit:description>   The maximum number of threads in a single workgroup. If this register is 0, then the information is not available on this implementation of the GPU. </spirit:description>
        <spirit:addressOffset>0xa4</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x180</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>THREAD_MAX_WORKGROUP_SIZE</spirit:name>
          <spirit:displayName>THREAD_MAX_WORKGROUP_SIZE</spirit:displayName>
          <spirit:description>   It contains the maximum number of threads in a single workgroup. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>THREAD_MAX_BARRIER_SIZE</spirit:name>
        <spirit:displayName>THREAD_MAX_BARRIER_SIZE</spirit:displayName>
        <spirit:description>   The maximum number of threads which may be simultaneously waiting at a hardware barrier. If this register is 0, then the information is not available on this implementation of the GPU. </spirit:description>
        <spirit:addressOffset>0xa8</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x180</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>THREAD_MAX_BARRIER_SIZE</spirit:name>
          <spirit:displayName>THREAD_MAX_BARRIER_SIZE</spirit:displayName>
          <spirit:description>   It contains the maximum number of threads waiting at a barrier. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>THREAD_FEATURES</spirit:name>
        <spirit:displayName>THREAD_FEATURES</spirit:displayName>
        <spirit:description>   Describes other features of the GPUs threading system. If this register is 0, then the information is not available on this implementation of the GPU. </spirit:description>
        <spirit:addressOffset>0xac</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0xa046000</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>MAX_REGISTERS</spirit:name>
          <spirit:displayName>MAX_REGISTERS</spirit:displayName>
          <spirit:description>   It contains the total size of the register file available per core. Each register is 32 bits in size. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>16</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>MAX_TASK_QUEUE</spirit:name>
          <spirit:displayName>MAX_TASK_QUEUE</spirit:displayName>
          <spirit:description>   It contains the maximum number of tasks which may be sent to a core before it becomes blocked. </spirit:description>
          <spirit:bitOffset>16</spirit:bitOffset>
          <spirit:bitWidth>8</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>MAX_TG_SPLIT</spirit:name>
          <spirit:displayName>MAX_TG_SPLIT</spirit:displayName>
          <spirit:description>   This field contains the maximum allowed value of the  thread_group_split field in a job descriptor. This must be at least big enough to represent the largest supported workgroup size, even if this is represented using a non-compact encoding.
							An example of this would be a workgroup of size 5x5x5 work items which takes 9 bits rather than the expected 7 bits to encode.
							So for the relatively common maximum workgroup size of 256, this would need to be 10 or more.  Changed value of MAX_TG_SPLIT to 10, added note on why it has this value. </spirit:description>
          <spirit:bitOffset>24</spirit:bitOffset>
          <spirit:bitWidth>6</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>IMPLEMENTATION_TECHNOLOGY</spirit:name>
          <spirit:displayName>IMPLEMENTATION_TECHNOLOGY</spirit:displayName>
          <spirit:description>IMPLEMENTATION_TECHNOLOGY</spirit:description>
          <spirit:bitOffset>30</spirit:bitOffset>
          <spirit:bitWidth>2</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NOT_SPECIFIED</spirit:name>
              <spirit:description> Implementation technology not specified. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>SILICON</spirit:name>
              <spirit:description> GPU is implemented natively in silicon. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FPGA</spirit:name>
              <spirit:description> GPU is implemented as an FPGA image. </spirit:description>
              <spirit:value>2</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>SOFTWARE</spirit:name>
              <spirit:description> GPU is implemented in software, either as a model or as an RTL emulation. </spirit:description>
              <spirit:value>3</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>TEXTURE_FEATURES_0</spirit:name>
        <spirit:displayName>TEXTURE_FEATURES_0</spirit:displayName>
        <spirit:description>   Contains information about which job slots are present on this GPU. </spirit:description>
        <spirit:addressOffset>0xb0</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x1ffff9e</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>TEXTURE_FEATURES_0</spirit:name>
          <spirit:displayName>TEXTURE_FEATURES_0</spirit:displayName>
          <spirit:description>   Indicates which indexed texture formats are actually available in the hardware. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> Job slot  n is not available.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Job slot  n is available.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>TEXTURE_FEATURES_1</spirit:name>
        <spirit:displayName>TEXTURE_FEATURES_1</spirit:displayName>
        <spirit:description>   Each bit in this register indicates that the texture unit supports a specific indexed texture format in the range 32..63. </spirit:description>
        <spirit:addressOffset>0xb4</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0xff0fff</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>TEXTURE_FEATURES_1</spirit:name>
          <spirit:displayName>TEXTURE_FEATURES_1</spirit:displayName>
          <spirit:description>   Indicates which indexed texture formats are actually available in the hardware. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> Format  n +32 is not available.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Format  n +32 is available.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>TEXTURE_FEATURES_2</spirit:name>
        <spirit:displayName>TEXTURE_FEATURES_2</spirit:displayName>
        <spirit:description>   Each bit in this register indicates that the texture unit supports a specific indexed texture format in the range 64..95. </spirit:description>
        <spirit:addressOffset>0xb8</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0xfe3fffff</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>TEXTURE_FEATURES_2</spirit:name>
          <spirit:displayName>TEXTURE_FEATURES_2</spirit:displayName>
          <spirit:description>   Indicates which indexed texture formats are actually available in the hardware. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> Format  n +64 is not available.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Format  n +64 is available.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>JS0_FEATURES</spirit:name>
        <spirit:displayName>JS0_FEATURES</spirit:displayName>
        <spirit:description>   Contains various information of the features of Job Slot 0. </spirit:description>
        <spirit:addressOffset>0xc0</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x20e</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>Res24</spirit:name>
          <spirit:displayName>Res24</spirit:displayName>
          <spirit:description>Res24</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>Res25</spirit:name>
          <spirit:displayName>Res25</spirit:displayName>
          <spirit:description>Res25</spirit:description>
          <spirit:bitOffset>8</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>Res26</spirit:name>
          <spirit:displayName>Res26</spirit:displayName>
          <spirit:description>Res26</spirit:description>
          <spirit:bitOffset>11</spirit:bitOffset>
          <spirit:bitWidth>21</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>NULL</spirit:name>
          <spirit:displayName>NULL</spirit:displayName>
          <spirit:description>NULL</spirit:description>
          <spirit:bitOffset>1</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Null jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Null jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>WRITE_VALUE</spirit:name>
          <spirit:displayName>WRITE_VALUE</spirit:displayName>
          <spirit:description>   Corrected two references to Set value job. </spirit:description>
          <spirit:bitOffset>2</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Write value jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Write value jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>CACHE_FLUSH</spirit:name>
          <spirit:displayName>CACHE_FLUSH</spirit:displayName>
          <spirit:description>CACHE_FLUSH</spirit:description>
          <spirit:bitOffset>3</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Cache flush jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Cache flush are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>COMPUTE_SHADER</spirit:name>
          <spirit:displayName>COMPUTE_SHADER</spirit:displayName>
          <spirit:description>COMPUTE_SHADER</spirit:description>
          <spirit:bitOffset>4</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Compute shader jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Compute shader jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>VERTEX_SHADER</spirit:name>
          <spirit:displayName>VERTEX_SHADER</spirit:displayName>
          <spirit:description>VERTEX_SHADER</spirit:description>
          <spirit:bitOffset>5</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Vertex shader jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Vertex shader jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>GEOMETRY_SHADER</spirit:name>
          <spirit:displayName>GEOMETRY_SHADER</spirit:displayName>
          <spirit:description>GEOMETRY_SHADER</spirit:description>
          <spirit:bitOffset>6</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Geometry shader jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Geometry shader jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>TILER</spirit:name>
          <spirit:displayName>TILER</spirit:displayName>
          <spirit:description>TILER</spirit:description>
          <spirit:bitOffset>7</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Tiler jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Tiler jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>FRAGMENT_SHADER</spirit:name>
          <spirit:displayName>FRAGMENT_SHADER</spirit:displayName>
          <spirit:description>FRAGMENT_SHADER</spirit:description>
          <spirit:bitOffset>9</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Fragment shader jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Fragment shader jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>INDEXED_VERTEX_SHADER</spirit:name>
          <spirit:displayName>INDEXED_VERTEX_SHADER</spirit:displayName>
          <spirit:description>   Added INDEXED_VERTEX_SHADER flag to  JSn_FEATURES registers.</spirit:description>
          <spirit:bitOffset>10</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Indexed vertex shader jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Indexed vertex shader jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>JS1_FEATURES</spirit:name>
        <spirit:displayName>JS1_FEATURES</spirit:displayName>
        <spirit:description>   Contains various information of the features of Job Slot 1. </spirit:description>
        <spirit:addressOffset>0xc4</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x4fe</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>Res27</spirit:name>
          <spirit:displayName>Res27</spirit:displayName>
          <spirit:description>Res27</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>Res28</spirit:name>
          <spirit:displayName>Res28</spirit:displayName>
          <spirit:description>Res28</spirit:description>
          <spirit:bitOffset>8</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>Res29</spirit:name>
          <spirit:displayName>Res29</spirit:displayName>
          <spirit:description>Res29</spirit:description>
          <spirit:bitOffset>11</spirit:bitOffset>
          <spirit:bitWidth>21</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>NULL</spirit:name>
          <spirit:displayName>NULL</spirit:displayName>
          <spirit:description>NULL</spirit:description>
          <spirit:bitOffset>1</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Null jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Null jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>WRITE_VALUE</spirit:name>
          <spirit:displayName>WRITE_VALUE</spirit:displayName>
          <spirit:description>   Corrected two references to Set value job. </spirit:description>
          <spirit:bitOffset>2</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Write value jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Write value jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>CACHE_FLUSH</spirit:name>
          <spirit:displayName>CACHE_FLUSH</spirit:displayName>
          <spirit:description>CACHE_FLUSH</spirit:description>
          <spirit:bitOffset>3</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Cache flush jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Cache flush are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>COMPUTE_SHADER</spirit:name>
          <spirit:displayName>COMPUTE_SHADER</spirit:displayName>
          <spirit:description>COMPUTE_SHADER</spirit:description>
          <spirit:bitOffset>4</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Compute shader jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Compute shader jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>VERTEX_SHADER</spirit:name>
          <spirit:displayName>VERTEX_SHADER</spirit:displayName>
          <spirit:description>VERTEX_SHADER</spirit:description>
          <spirit:bitOffset>5</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Vertex shader jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Vertex shader jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>GEOMETRY_SHADER</spirit:name>
          <spirit:displayName>GEOMETRY_SHADER</spirit:displayName>
          <spirit:description>GEOMETRY_SHADER</spirit:description>
          <spirit:bitOffset>6</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Geometry shader jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Geometry shader jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>TILER</spirit:name>
          <spirit:displayName>TILER</spirit:displayName>
          <spirit:description>TILER</spirit:description>
          <spirit:bitOffset>7</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Tiler jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Tiler jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>FRAGMENT_SHADER</spirit:name>
          <spirit:displayName>FRAGMENT_SHADER</spirit:displayName>
          <spirit:description>FRAGMENT_SHADER</spirit:description>
          <spirit:bitOffset>9</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Fragment shader jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Fragment shader jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>INDEXED_VERTEX_SHADER</spirit:name>
          <spirit:displayName>INDEXED_VERTEX_SHADER</spirit:displayName>
          <spirit:description>   Added INDEXED_VERTEX_SHADER flag to  JSn_FEATURES registers.</spirit:description>
          <spirit:bitOffset>10</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Indexed vertex shader jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Indexed vertex shader jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>JS2_FEATURES</spirit:name>
        <spirit:displayName>JS2_FEATURES</spirit:displayName>
        <spirit:description>   Contains various information of the features of Job Slot 2. </spirit:description>
        <spirit:addressOffset>0xc8</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x7e</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>Res30</spirit:name>
          <spirit:displayName>Res30</spirit:displayName>
          <spirit:description>Res30</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>Res31</spirit:name>
          <spirit:displayName>Res31</spirit:displayName>
          <spirit:description>Res31</spirit:description>
          <spirit:bitOffset>8</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>Res32</spirit:name>
          <spirit:displayName>Res32</spirit:displayName>
          <spirit:description>Res32</spirit:description>
          <spirit:bitOffset>11</spirit:bitOffset>
          <spirit:bitWidth>21</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>NULL</spirit:name>
          <spirit:displayName>NULL</spirit:displayName>
          <spirit:description>NULL</spirit:description>
          <spirit:bitOffset>1</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Null jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Null jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>WRITE_VALUE</spirit:name>
          <spirit:displayName>WRITE_VALUE</spirit:displayName>
          <spirit:description>   Corrected two references to Set value job. </spirit:description>
          <spirit:bitOffset>2</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Write value jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Write value jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>CACHE_FLUSH</spirit:name>
          <spirit:displayName>CACHE_FLUSH</spirit:displayName>
          <spirit:description>CACHE_FLUSH</spirit:description>
          <spirit:bitOffset>3</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Cache flush jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Cache flush are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>COMPUTE_SHADER</spirit:name>
          <spirit:displayName>COMPUTE_SHADER</spirit:displayName>
          <spirit:description>COMPUTE_SHADER</spirit:description>
          <spirit:bitOffset>4</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Compute shader jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Compute shader jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>VERTEX_SHADER</spirit:name>
          <spirit:displayName>VERTEX_SHADER</spirit:displayName>
          <spirit:description>VERTEX_SHADER</spirit:description>
          <spirit:bitOffset>5</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Vertex shader jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Vertex shader jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>GEOMETRY_SHADER</spirit:name>
          <spirit:displayName>GEOMETRY_SHADER</spirit:displayName>
          <spirit:description>GEOMETRY_SHADER</spirit:description>
          <spirit:bitOffset>6</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Geometry shader jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Geometry shader jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>TILER</spirit:name>
          <spirit:displayName>TILER</spirit:displayName>
          <spirit:description>TILER</spirit:description>
          <spirit:bitOffset>7</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Tiler jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Tiler jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>FRAGMENT_SHADER</spirit:name>
          <spirit:displayName>FRAGMENT_SHADER</spirit:displayName>
          <spirit:description>FRAGMENT_SHADER</spirit:description>
          <spirit:bitOffset>9</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Fragment shader jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Fragment shader jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>INDEXED_VERTEX_SHADER</spirit:name>
          <spirit:displayName>INDEXED_VERTEX_SHADER</spirit:displayName>
          <spirit:description>   Added INDEXED_VERTEX_SHADER flag to  JSn_FEATURES registers.</spirit:description>
          <spirit:bitOffset>10</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Indexed vertex shader jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Indexed vertex shader jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>JS3_FEATURES</spirit:name>
        <spirit:displayName>JS3_FEATURES</spirit:displayName>
        <spirit:description>   Contains various information of the features of Job Slot 3. </spirit:description>
        <spirit:addressOffset>0xcc</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>Res33</spirit:name>
          <spirit:displayName>Res33</spirit:displayName>
          <spirit:description>Res33</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>Res34</spirit:name>
          <spirit:displayName>Res34</spirit:displayName>
          <spirit:description>Res34</spirit:description>
          <spirit:bitOffset>8</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>Res35</spirit:name>
          <spirit:displayName>Res35</spirit:displayName>
          <spirit:description>Res35</spirit:description>
          <spirit:bitOffset>11</spirit:bitOffset>
          <spirit:bitWidth>21</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>NULL</spirit:name>
          <spirit:displayName>NULL</spirit:displayName>
          <spirit:description>NULL</spirit:description>
          <spirit:bitOffset>1</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Null jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Null jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>WRITE_VALUE</spirit:name>
          <spirit:displayName>WRITE_VALUE</spirit:displayName>
          <spirit:description>   Corrected two references to Set value job. </spirit:description>
          <spirit:bitOffset>2</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Write value jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Write value jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>CACHE_FLUSH</spirit:name>
          <spirit:displayName>CACHE_FLUSH</spirit:displayName>
          <spirit:description>CACHE_FLUSH</spirit:description>
          <spirit:bitOffset>3</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Cache flush jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Cache flush are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>COMPUTE_SHADER</spirit:name>
          <spirit:displayName>COMPUTE_SHADER</spirit:displayName>
          <spirit:description>COMPUTE_SHADER</spirit:description>
          <spirit:bitOffset>4</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Compute shader jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Compute shader jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>VERTEX_SHADER</spirit:name>
          <spirit:displayName>VERTEX_SHADER</spirit:displayName>
          <spirit:description>VERTEX_SHADER</spirit:description>
          <spirit:bitOffset>5</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Vertex shader jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Vertex shader jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>GEOMETRY_SHADER</spirit:name>
          <spirit:displayName>GEOMETRY_SHADER</spirit:displayName>
          <spirit:description>GEOMETRY_SHADER</spirit:description>
          <spirit:bitOffset>6</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Geometry shader jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Geometry shader jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>TILER</spirit:name>
          <spirit:displayName>TILER</spirit:displayName>
          <spirit:description>TILER</spirit:description>
          <spirit:bitOffset>7</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Tiler jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Tiler jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>FRAGMENT_SHADER</spirit:name>
          <spirit:displayName>FRAGMENT_SHADER</spirit:displayName>
          <spirit:description>FRAGMENT_SHADER</spirit:description>
          <spirit:bitOffset>9</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Fragment shader jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Fragment shader jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>INDEXED_VERTEX_SHADER</spirit:name>
          <spirit:displayName>INDEXED_VERTEX_SHADER</spirit:displayName>
          <spirit:description>   Added INDEXED_VERTEX_SHADER flag to  JSn_FEATURES registers.</spirit:description>
          <spirit:bitOffset>10</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Indexed vertex shader jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Indexed vertex shader jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>JS4_FEATURES</spirit:name>
        <spirit:displayName>JS4_FEATURES</spirit:displayName>
        <spirit:description>   Contains various information of the features of Job Slot 4. </spirit:description>
        <spirit:addressOffset>0xd0</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>Res36</spirit:name>
          <spirit:displayName>Res36</spirit:displayName>
          <spirit:description>Res36</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>Res37</spirit:name>
          <spirit:displayName>Res37</spirit:displayName>
          <spirit:description>Res37</spirit:description>
          <spirit:bitOffset>8</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>Res38</spirit:name>
          <spirit:displayName>Res38</spirit:displayName>
          <spirit:description>Res38</spirit:description>
          <spirit:bitOffset>11</spirit:bitOffset>
          <spirit:bitWidth>21</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>NULL</spirit:name>
          <spirit:displayName>NULL</spirit:displayName>
          <spirit:description>NULL</spirit:description>
          <spirit:bitOffset>1</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Null jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Null jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>WRITE_VALUE</spirit:name>
          <spirit:displayName>WRITE_VALUE</spirit:displayName>
          <spirit:description>   Corrected two references to Set value job. </spirit:description>
          <spirit:bitOffset>2</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Write value jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Write value jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>CACHE_FLUSH</spirit:name>
          <spirit:displayName>CACHE_FLUSH</spirit:displayName>
          <spirit:description>CACHE_FLUSH</spirit:description>
          <spirit:bitOffset>3</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Cache flush jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Cache flush are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>COMPUTE_SHADER</spirit:name>
          <spirit:displayName>COMPUTE_SHADER</spirit:displayName>
          <spirit:description>COMPUTE_SHADER</spirit:description>
          <spirit:bitOffset>4</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Compute shader jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Compute shader jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>VERTEX_SHADER</spirit:name>
          <spirit:displayName>VERTEX_SHADER</spirit:displayName>
          <spirit:description>VERTEX_SHADER</spirit:description>
          <spirit:bitOffset>5</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Vertex shader jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Vertex shader jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>GEOMETRY_SHADER</spirit:name>
          <spirit:displayName>GEOMETRY_SHADER</spirit:displayName>
          <spirit:description>GEOMETRY_SHADER</spirit:description>
          <spirit:bitOffset>6</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Geometry shader jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Geometry shader jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>TILER</spirit:name>
          <spirit:displayName>TILER</spirit:displayName>
          <spirit:description>TILER</spirit:description>
          <spirit:bitOffset>7</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Tiler jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Tiler jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>FRAGMENT_SHADER</spirit:name>
          <spirit:displayName>FRAGMENT_SHADER</spirit:displayName>
          <spirit:description>FRAGMENT_SHADER</spirit:description>
          <spirit:bitOffset>9</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Fragment shader jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Fragment shader jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>INDEXED_VERTEX_SHADER</spirit:name>
          <spirit:displayName>INDEXED_VERTEX_SHADER</spirit:displayName>
          <spirit:description>   Added INDEXED_VERTEX_SHADER flag to  JSn_FEATURES registers.</spirit:description>
          <spirit:bitOffset>10</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Indexed vertex shader jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Indexed vertex shader jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>JS5_FEATURES</spirit:name>
        <spirit:displayName>JS5_FEATURES</spirit:displayName>
        <spirit:description>   Contains various information of the features of Job Slot 5. </spirit:description>
        <spirit:addressOffset>0xd4</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>Res39</spirit:name>
          <spirit:displayName>Res39</spirit:displayName>
          <spirit:description>Res39</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>Res40</spirit:name>
          <spirit:displayName>Res40</spirit:displayName>
          <spirit:description>Res40</spirit:description>
          <spirit:bitOffset>8</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>Res41</spirit:name>
          <spirit:displayName>Res41</spirit:displayName>
          <spirit:description>Res41</spirit:description>
          <spirit:bitOffset>11</spirit:bitOffset>
          <spirit:bitWidth>21</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>NULL</spirit:name>
          <spirit:displayName>NULL</spirit:displayName>
          <spirit:description>NULL</spirit:description>
          <spirit:bitOffset>1</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Null jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Null jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>WRITE_VALUE</spirit:name>
          <spirit:displayName>WRITE_VALUE</spirit:displayName>
          <spirit:description>   Corrected two references to Set value job. </spirit:description>
          <spirit:bitOffset>2</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Write value jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Write value jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>CACHE_FLUSH</spirit:name>
          <spirit:displayName>CACHE_FLUSH</spirit:displayName>
          <spirit:description>CACHE_FLUSH</spirit:description>
          <spirit:bitOffset>3</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Cache flush jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Cache flush are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>COMPUTE_SHADER</spirit:name>
          <spirit:displayName>COMPUTE_SHADER</spirit:displayName>
          <spirit:description>COMPUTE_SHADER</spirit:description>
          <spirit:bitOffset>4</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Compute shader jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Compute shader jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>VERTEX_SHADER</spirit:name>
          <spirit:displayName>VERTEX_SHADER</spirit:displayName>
          <spirit:description>VERTEX_SHADER</spirit:description>
          <spirit:bitOffset>5</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Vertex shader jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Vertex shader jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>GEOMETRY_SHADER</spirit:name>
          <spirit:displayName>GEOMETRY_SHADER</spirit:displayName>
          <spirit:description>GEOMETRY_SHADER</spirit:description>
          <spirit:bitOffset>6</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Geometry shader jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Geometry shader jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>TILER</spirit:name>
          <spirit:displayName>TILER</spirit:displayName>
          <spirit:description>TILER</spirit:description>
          <spirit:bitOffset>7</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Tiler jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Tiler jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>FRAGMENT_SHADER</spirit:name>
          <spirit:displayName>FRAGMENT_SHADER</spirit:displayName>
          <spirit:description>FRAGMENT_SHADER</spirit:description>
          <spirit:bitOffset>9</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Fragment shader jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Fragment shader jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>INDEXED_VERTEX_SHADER</spirit:name>
          <spirit:displayName>INDEXED_VERTEX_SHADER</spirit:displayName>
          <spirit:description>   Added INDEXED_VERTEX_SHADER flag to  JSn_FEATURES registers.</spirit:description>
          <spirit:bitOffset>10</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Indexed vertex shader jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Indexed vertex shader jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>JS6_FEATURES</spirit:name>
        <spirit:displayName>JS6_FEATURES</spirit:displayName>
        <spirit:description>   Contains various information of the features of Job Slot 6. </spirit:description>
        <spirit:addressOffset>0xd8</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>Res42</spirit:name>
          <spirit:displayName>Res42</spirit:displayName>
          <spirit:description>Res42</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>Res43</spirit:name>
          <spirit:displayName>Res43</spirit:displayName>
          <spirit:description>Res43</spirit:description>
          <spirit:bitOffset>8</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>Res44</spirit:name>
          <spirit:displayName>Res44</spirit:displayName>
          <spirit:description>Res44</spirit:description>
          <spirit:bitOffset>11</spirit:bitOffset>
          <spirit:bitWidth>21</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>NULL</spirit:name>
          <spirit:displayName>NULL</spirit:displayName>
          <spirit:description>NULL</spirit:description>
          <spirit:bitOffset>1</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Null jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Null jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>WRITE_VALUE</spirit:name>
          <spirit:displayName>WRITE_VALUE</spirit:displayName>
          <spirit:description>   Corrected two references to Set value job. </spirit:description>
          <spirit:bitOffset>2</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Write value jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Write value jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>CACHE_FLUSH</spirit:name>
          <spirit:displayName>CACHE_FLUSH</spirit:displayName>
          <spirit:description>CACHE_FLUSH</spirit:description>
          <spirit:bitOffset>3</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Cache flush jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Cache flush are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>COMPUTE_SHADER</spirit:name>
          <spirit:displayName>COMPUTE_SHADER</spirit:displayName>
          <spirit:description>COMPUTE_SHADER</spirit:description>
          <spirit:bitOffset>4</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Compute shader jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Compute shader jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>VERTEX_SHADER</spirit:name>
          <spirit:displayName>VERTEX_SHADER</spirit:displayName>
          <spirit:description>VERTEX_SHADER</spirit:description>
          <spirit:bitOffset>5</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Vertex shader jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Vertex shader jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>GEOMETRY_SHADER</spirit:name>
          <spirit:displayName>GEOMETRY_SHADER</spirit:displayName>
          <spirit:description>GEOMETRY_SHADER</spirit:description>
          <spirit:bitOffset>6</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Geometry shader jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Geometry shader jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>TILER</spirit:name>
          <spirit:displayName>TILER</spirit:displayName>
          <spirit:description>TILER</spirit:description>
          <spirit:bitOffset>7</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Tiler jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Tiler jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>FRAGMENT_SHADER</spirit:name>
          <spirit:displayName>FRAGMENT_SHADER</spirit:displayName>
          <spirit:description>FRAGMENT_SHADER</spirit:description>
          <spirit:bitOffset>9</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Fragment shader jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Fragment shader jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>INDEXED_VERTEX_SHADER</spirit:name>
          <spirit:displayName>INDEXED_VERTEX_SHADER</spirit:displayName>
          <spirit:description>   Added INDEXED_VERTEX_SHADER flag to  JSn_FEATURES registers.</spirit:description>
          <spirit:bitOffset>10</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Indexed vertex shader jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Indexed vertex shader jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>JS7_FEATURES</spirit:name>
        <spirit:displayName>JS7_FEATURES</spirit:displayName>
        <spirit:description>   Contains various information of the features of Job Slot 7. </spirit:description>
        <spirit:addressOffset>0xdc</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>Res45</spirit:name>
          <spirit:displayName>Res45</spirit:displayName>
          <spirit:description>Res45</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>Res46</spirit:name>
          <spirit:displayName>Res46</spirit:displayName>
          <spirit:description>Res46</spirit:description>
          <spirit:bitOffset>8</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>Res47</spirit:name>
          <spirit:displayName>Res47</spirit:displayName>
          <spirit:description>Res47</spirit:description>
          <spirit:bitOffset>11</spirit:bitOffset>
          <spirit:bitWidth>21</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>NULL</spirit:name>
          <spirit:displayName>NULL</spirit:displayName>
          <spirit:description>NULL</spirit:description>
          <spirit:bitOffset>1</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Null jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Null jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>WRITE_VALUE</spirit:name>
          <spirit:displayName>WRITE_VALUE</spirit:displayName>
          <spirit:description>   Corrected two references to Set value job. </spirit:description>
          <spirit:bitOffset>2</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Write value jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Write value jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>CACHE_FLUSH</spirit:name>
          <spirit:displayName>CACHE_FLUSH</spirit:displayName>
          <spirit:description>CACHE_FLUSH</spirit:description>
          <spirit:bitOffset>3</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Cache flush jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Cache flush are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>COMPUTE_SHADER</spirit:name>
          <spirit:displayName>COMPUTE_SHADER</spirit:displayName>
          <spirit:description>COMPUTE_SHADER</spirit:description>
          <spirit:bitOffset>4</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Compute shader jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Compute shader jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>VERTEX_SHADER</spirit:name>
          <spirit:displayName>VERTEX_SHADER</spirit:displayName>
          <spirit:description>VERTEX_SHADER</spirit:description>
          <spirit:bitOffset>5</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Vertex shader jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Vertex shader jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>GEOMETRY_SHADER</spirit:name>
          <spirit:displayName>GEOMETRY_SHADER</spirit:displayName>
          <spirit:description>GEOMETRY_SHADER</spirit:description>
          <spirit:bitOffset>6</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Geometry shader jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Geometry shader jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>TILER</spirit:name>
          <spirit:displayName>TILER</spirit:displayName>
          <spirit:description>TILER</spirit:description>
          <spirit:bitOffset>7</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Tiler jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Tiler jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>FRAGMENT_SHADER</spirit:name>
          <spirit:displayName>FRAGMENT_SHADER</spirit:displayName>
          <spirit:description>FRAGMENT_SHADER</spirit:description>
          <spirit:bitOffset>9</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Fragment shader jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Fragment shader jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>INDEXED_VERTEX_SHADER</spirit:name>
          <spirit:displayName>INDEXED_VERTEX_SHADER</spirit:displayName>
          <spirit:description>   Added INDEXED_VERTEX_SHADER flag to  JSn_FEATURES registers.</spirit:description>
          <spirit:bitOffset>10</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Indexed vertex shader jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Indexed vertex shader jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>JS8_FEATURES</spirit:name>
        <spirit:displayName>JS8_FEATURES</spirit:displayName>
        <spirit:description>   Contains various information of the features of Job Slot 8. </spirit:description>
        <spirit:addressOffset>0xe0</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>Res48</spirit:name>
          <spirit:displayName>Res48</spirit:displayName>
          <spirit:description>Res48</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>Res49</spirit:name>
          <spirit:displayName>Res49</spirit:displayName>
          <spirit:description>Res49</spirit:description>
          <spirit:bitOffset>8</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>Res50</spirit:name>
          <spirit:displayName>Res50</spirit:displayName>
          <spirit:description>Res50</spirit:description>
          <spirit:bitOffset>11</spirit:bitOffset>
          <spirit:bitWidth>21</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>NULL</spirit:name>
          <spirit:displayName>NULL</spirit:displayName>
          <spirit:description>NULL</spirit:description>
          <spirit:bitOffset>1</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Null jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Null jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>WRITE_VALUE</spirit:name>
          <spirit:displayName>WRITE_VALUE</spirit:displayName>
          <spirit:description>   Corrected two references to Set value job. </spirit:description>
          <spirit:bitOffset>2</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Write value jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Write value jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>CACHE_FLUSH</spirit:name>
          <spirit:displayName>CACHE_FLUSH</spirit:displayName>
          <spirit:description>CACHE_FLUSH</spirit:description>
          <spirit:bitOffset>3</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Cache flush jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Cache flush are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>COMPUTE_SHADER</spirit:name>
          <spirit:displayName>COMPUTE_SHADER</spirit:displayName>
          <spirit:description>COMPUTE_SHADER</spirit:description>
          <spirit:bitOffset>4</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Compute shader jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Compute shader jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>VERTEX_SHADER</spirit:name>
          <spirit:displayName>VERTEX_SHADER</spirit:displayName>
          <spirit:description>VERTEX_SHADER</spirit:description>
          <spirit:bitOffset>5</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Vertex shader jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Vertex shader jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>GEOMETRY_SHADER</spirit:name>
          <spirit:displayName>GEOMETRY_SHADER</spirit:displayName>
          <spirit:description>GEOMETRY_SHADER</spirit:description>
          <spirit:bitOffset>6</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Geometry shader jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Geometry shader jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>TILER</spirit:name>
          <spirit:displayName>TILER</spirit:displayName>
          <spirit:description>TILER</spirit:description>
          <spirit:bitOffset>7</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Tiler jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Tiler jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>FRAGMENT_SHADER</spirit:name>
          <spirit:displayName>FRAGMENT_SHADER</spirit:displayName>
          <spirit:description>FRAGMENT_SHADER</spirit:description>
          <spirit:bitOffset>9</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Fragment shader jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Fragment shader jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>INDEXED_VERTEX_SHADER</spirit:name>
          <spirit:displayName>INDEXED_VERTEX_SHADER</spirit:displayName>
          <spirit:description>   Added INDEXED_VERTEX_SHADER flag to  JSn_FEATURES registers.</spirit:description>
          <spirit:bitOffset>10</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Indexed vertex shader jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Indexed vertex shader jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>JS9_FEATURES</spirit:name>
        <spirit:displayName>JS9_FEATURES</spirit:displayName>
        <spirit:description>   Contains various information of the features of Job Slot 9. </spirit:description>
        <spirit:addressOffset>0xe4</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>Res51</spirit:name>
          <spirit:displayName>Res51</spirit:displayName>
          <spirit:description>Res51</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>Res52</spirit:name>
          <spirit:displayName>Res52</spirit:displayName>
          <spirit:description>Res52</spirit:description>
          <spirit:bitOffset>8</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>Res53</spirit:name>
          <spirit:displayName>Res53</spirit:displayName>
          <spirit:description>Res53</spirit:description>
          <spirit:bitOffset>11</spirit:bitOffset>
          <spirit:bitWidth>21</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>NULL</spirit:name>
          <spirit:displayName>NULL</spirit:displayName>
          <spirit:description>NULL</spirit:description>
          <spirit:bitOffset>1</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Null jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Null jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>WRITE_VALUE</spirit:name>
          <spirit:displayName>WRITE_VALUE</spirit:displayName>
          <spirit:description>   Corrected two references to Set value job. </spirit:description>
          <spirit:bitOffset>2</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Write value jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Write value jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>CACHE_FLUSH</spirit:name>
          <spirit:displayName>CACHE_FLUSH</spirit:displayName>
          <spirit:description>CACHE_FLUSH</spirit:description>
          <spirit:bitOffset>3</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Cache flush jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Cache flush are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>COMPUTE_SHADER</spirit:name>
          <spirit:displayName>COMPUTE_SHADER</spirit:displayName>
          <spirit:description>COMPUTE_SHADER</spirit:description>
          <spirit:bitOffset>4</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Compute shader jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Compute shader jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>VERTEX_SHADER</spirit:name>
          <spirit:displayName>VERTEX_SHADER</spirit:displayName>
          <spirit:description>VERTEX_SHADER</spirit:description>
          <spirit:bitOffset>5</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Vertex shader jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Vertex shader jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>GEOMETRY_SHADER</spirit:name>
          <spirit:displayName>GEOMETRY_SHADER</spirit:displayName>
          <spirit:description>GEOMETRY_SHADER</spirit:description>
          <spirit:bitOffset>6</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Geometry shader jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Geometry shader jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>TILER</spirit:name>
          <spirit:displayName>TILER</spirit:displayName>
          <spirit:description>TILER</spirit:description>
          <spirit:bitOffset>7</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Tiler jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Tiler jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>FRAGMENT_SHADER</spirit:name>
          <spirit:displayName>FRAGMENT_SHADER</spirit:displayName>
          <spirit:description>FRAGMENT_SHADER</spirit:description>
          <spirit:bitOffset>9</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Fragment shader jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Fragment shader jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>INDEXED_VERTEX_SHADER</spirit:name>
          <spirit:displayName>INDEXED_VERTEX_SHADER</spirit:displayName>
          <spirit:description>   Added INDEXED_VERTEX_SHADER flag to  JSn_FEATURES registers.</spirit:description>
          <spirit:bitOffset>10</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Indexed vertex shader jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Indexed vertex shader jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>JS10_FEATURES</spirit:name>
        <spirit:displayName>JS10_FEATURES</spirit:displayName>
        <spirit:description>   Contains various information of the features of Job Slot 10. </spirit:description>
        <spirit:addressOffset>0xe8</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>Res54</spirit:name>
          <spirit:displayName>Res54</spirit:displayName>
          <spirit:description>Res54</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>Res55</spirit:name>
          <spirit:displayName>Res55</spirit:displayName>
          <spirit:description>Res55</spirit:description>
          <spirit:bitOffset>8</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>Res56</spirit:name>
          <spirit:displayName>Res56</spirit:displayName>
          <spirit:description>Res56</spirit:description>
          <spirit:bitOffset>11</spirit:bitOffset>
          <spirit:bitWidth>21</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>NULL</spirit:name>
          <spirit:displayName>NULL</spirit:displayName>
          <spirit:description>NULL</spirit:description>
          <spirit:bitOffset>1</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Null jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Null jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>WRITE_VALUE</spirit:name>
          <spirit:displayName>WRITE_VALUE</spirit:displayName>
          <spirit:description>   Corrected two references to Set value job. </spirit:description>
          <spirit:bitOffset>2</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Write value jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Write value jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>CACHE_FLUSH</spirit:name>
          <spirit:displayName>CACHE_FLUSH</spirit:displayName>
          <spirit:description>CACHE_FLUSH</spirit:description>
          <spirit:bitOffset>3</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Cache flush jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Cache flush are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>COMPUTE_SHADER</spirit:name>
          <spirit:displayName>COMPUTE_SHADER</spirit:displayName>
          <spirit:description>COMPUTE_SHADER</spirit:description>
          <spirit:bitOffset>4</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Compute shader jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Compute shader jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>VERTEX_SHADER</spirit:name>
          <spirit:displayName>VERTEX_SHADER</spirit:displayName>
          <spirit:description>VERTEX_SHADER</spirit:description>
          <spirit:bitOffset>5</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Vertex shader jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Vertex shader jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>GEOMETRY_SHADER</spirit:name>
          <spirit:displayName>GEOMETRY_SHADER</spirit:displayName>
          <spirit:description>GEOMETRY_SHADER</spirit:description>
          <spirit:bitOffset>6</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Geometry shader jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Geometry shader jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>TILER</spirit:name>
          <spirit:displayName>TILER</spirit:displayName>
          <spirit:description>TILER</spirit:description>
          <spirit:bitOffset>7</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Tiler jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Tiler jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>FRAGMENT_SHADER</spirit:name>
          <spirit:displayName>FRAGMENT_SHADER</spirit:displayName>
          <spirit:description>FRAGMENT_SHADER</spirit:description>
          <spirit:bitOffset>9</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Fragment shader jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Fragment shader jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>INDEXED_VERTEX_SHADER</spirit:name>
          <spirit:displayName>INDEXED_VERTEX_SHADER</spirit:displayName>
          <spirit:description>   Added INDEXED_VERTEX_SHADER flag to  JSn_FEATURES registers.</spirit:description>
          <spirit:bitOffset>10</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Indexed vertex shader jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Indexed vertex shader jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>JS11_FEATURES</spirit:name>
        <spirit:displayName>JS11_FEATURES</spirit:displayName>
        <spirit:description>   Contains various information of the features of Job Slot 11. </spirit:description>
        <spirit:addressOffset>0xec</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>Res57</spirit:name>
          <spirit:displayName>Res57</spirit:displayName>
          <spirit:description>Res57</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>Res58</spirit:name>
          <spirit:displayName>Res58</spirit:displayName>
          <spirit:description>Res58</spirit:description>
          <spirit:bitOffset>8</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>Res59</spirit:name>
          <spirit:displayName>Res59</spirit:displayName>
          <spirit:description>Res59</spirit:description>
          <spirit:bitOffset>11</spirit:bitOffset>
          <spirit:bitWidth>21</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>NULL</spirit:name>
          <spirit:displayName>NULL</spirit:displayName>
          <spirit:description>NULL</spirit:description>
          <spirit:bitOffset>1</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Null jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Null jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>WRITE_VALUE</spirit:name>
          <spirit:displayName>WRITE_VALUE</spirit:displayName>
          <spirit:description>   Corrected two references to Set value job. </spirit:description>
          <spirit:bitOffset>2</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Write value jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Write value jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>CACHE_FLUSH</spirit:name>
          <spirit:displayName>CACHE_FLUSH</spirit:displayName>
          <spirit:description>CACHE_FLUSH</spirit:description>
          <spirit:bitOffset>3</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Cache flush jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Cache flush are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>COMPUTE_SHADER</spirit:name>
          <spirit:displayName>COMPUTE_SHADER</spirit:displayName>
          <spirit:description>COMPUTE_SHADER</spirit:description>
          <spirit:bitOffset>4</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Compute shader jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Compute shader jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>VERTEX_SHADER</spirit:name>
          <spirit:displayName>VERTEX_SHADER</spirit:displayName>
          <spirit:description>VERTEX_SHADER</spirit:description>
          <spirit:bitOffset>5</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Vertex shader jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Vertex shader jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>GEOMETRY_SHADER</spirit:name>
          <spirit:displayName>GEOMETRY_SHADER</spirit:displayName>
          <spirit:description>GEOMETRY_SHADER</spirit:description>
          <spirit:bitOffset>6</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Geometry shader jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Geometry shader jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>TILER</spirit:name>
          <spirit:displayName>TILER</spirit:displayName>
          <spirit:description>TILER</spirit:description>
          <spirit:bitOffset>7</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Tiler jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Tiler jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>FRAGMENT_SHADER</spirit:name>
          <spirit:displayName>FRAGMENT_SHADER</spirit:displayName>
          <spirit:description>FRAGMENT_SHADER</spirit:description>
          <spirit:bitOffset>9</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Fragment shader jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Fragment shader jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>INDEXED_VERTEX_SHADER</spirit:name>
          <spirit:displayName>INDEXED_VERTEX_SHADER</spirit:displayName>
          <spirit:description>   Added INDEXED_VERTEX_SHADER flag to  JSn_FEATURES registers.</spirit:description>
          <spirit:bitOffset>10</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Indexed vertex shader jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Indexed vertex shader jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>JS12_FEATURES</spirit:name>
        <spirit:displayName>JS12_FEATURES</spirit:displayName>
        <spirit:description>   Contains various information of the features of Job Slot 12. </spirit:description>
        <spirit:addressOffset>0xf0</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>Res60</spirit:name>
          <spirit:displayName>Res60</spirit:displayName>
          <spirit:description>Res60</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>Res61</spirit:name>
          <spirit:displayName>Res61</spirit:displayName>
          <spirit:description>Res61</spirit:description>
          <spirit:bitOffset>8</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>Res62</spirit:name>
          <spirit:displayName>Res62</spirit:displayName>
          <spirit:description>Res62</spirit:description>
          <spirit:bitOffset>11</spirit:bitOffset>
          <spirit:bitWidth>21</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>NULL</spirit:name>
          <spirit:displayName>NULL</spirit:displayName>
          <spirit:description>NULL</spirit:description>
          <spirit:bitOffset>1</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Null jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Null jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>WRITE_VALUE</spirit:name>
          <spirit:displayName>WRITE_VALUE</spirit:displayName>
          <spirit:description>   Corrected two references to Set value job. </spirit:description>
          <spirit:bitOffset>2</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Write value jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Write value jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>CACHE_FLUSH</spirit:name>
          <spirit:displayName>CACHE_FLUSH</spirit:displayName>
          <spirit:description>CACHE_FLUSH</spirit:description>
          <spirit:bitOffset>3</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Cache flush jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Cache flush are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>COMPUTE_SHADER</spirit:name>
          <spirit:displayName>COMPUTE_SHADER</spirit:displayName>
          <spirit:description>COMPUTE_SHADER</spirit:description>
          <spirit:bitOffset>4</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Compute shader jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Compute shader jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>VERTEX_SHADER</spirit:name>
          <spirit:displayName>VERTEX_SHADER</spirit:displayName>
          <spirit:description>VERTEX_SHADER</spirit:description>
          <spirit:bitOffset>5</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Vertex shader jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Vertex shader jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>GEOMETRY_SHADER</spirit:name>
          <spirit:displayName>GEOMETRY_SHADER</spirit:displayName>
          <spirit:description>GEOMETRY_SHADER</spirit:description>
          <spirit:bitOffset>6</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Geometry shader jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Geometry shader jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>TILER</spirit:name>
          <spirit:displayName>TILER</spirit:displayName>
          <spirit:description>TILER</spirit:description>
          <spirit:bitOffset>7</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Tiler jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Tiler jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>FRAGMENT_SHADER</spirit:name>
          <spirit:displayName>FRAGMENT_SHADER</spirit:displayName>
          <spirit:description>FRAGMENT_SHADER</spirit:description>
          <spirit:bitOffset>9</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Fragment shader jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Fragment shader jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>INDEXED_VERTEX_SHADER</spirit:name>
          <spirit:displayName>INDEXED_VERTEX_SHADER</spirit:displayName>
          <spirit:description>   Added INDEXED_VERTEX_SHADER flag to  JSn_FEATURES registers.</spirit:description>
          <spirit:bitOffset>10</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Indexed vertex shader jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Indexed vertex shader jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>JS13_FEATURES</spirit:name>
        <spirit:displayName>JS13_FEATURES</spirit:displayName>
        <spirit:description>   Contains various information of the features of Job Slot 13. </spirit:description>
        <spirit:addressOffset>0xf4</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>Res63</spirit:name>
          <spirit:displayName>Res63</spirit:displayName>
          <spirit:description>Res63</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>Res64</spirit:name>
          <spirit:displayName>Res64</spirit:displayName>
          <spirit:description>Res64</spirit:description>
          <spirit:bitOffset>8</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>Res65</spirit:name>
          <spirit:displayName>Res65</spirit:displayName>
          <spirit:description>Res65</spirit:description>
          <spirit:bitOffset>11</spirit:bitOffset>
          <spirit:bitWidth>21</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>NULL</spirit:name>
          <spirit:displayName>NULL</spirit:displayName>
          <spirit:description>NULL</spirit:description>
          <spirit:bitOffset>1</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Null jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Null jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>WRITE_VALUE</spirit:name>
          <spirit:displayName>WRITE_VALUE</spirit:displayName>
          <spirit:description>   Corrected two references to Set value job. </spirit:description>
          <spirit:bitOffset>2</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Write value jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Write value jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>CACHE_FLUSH</spirit:name>
          <spirit:displayName>CACHE_FLUSH</spirit:displayName>
          <spirit:description>CACHE_FLUSH</spirit:description>
          <spirit:bitOffset>3</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Cache flush jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Cache flush are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>COMPUTE_SHADER</spirit:name>
          <spirit:displayName>COMPUTE_SHADER</spirit:displayName>
          <spirit:description>COMPUTE_SHADER</spirit:description>
          <spirit:bitOffset>4</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Compute shader jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Compute shader jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>VERTEX_SHADER</spirit:name>
          <spirit:displayName>VERTEX_SHADER</spirit:displayName>
          <spirit:description>VERTEX_SHADER</spirit:description>
          <spirit:bitOffset>5</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Vertex shader jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Vertex shader jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>GEOMETRY_SHADER</spirit:name>
          <spirit:displayName>GEOMETRY_SHADER</spirit:displayName>
          <spirit:description>GEOMETRY_SHADER</spirit:description>
          <spirit:bitOffset>6</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Geometry shader jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Geometry shader jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>TILER</spirit:name>
          <spirit:displayName>TILER</spirit:displayName>
          <spirit:description>TILER</spirit:description>
          <spirit:bitOffset>7</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Tiler jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Tiler jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>FRAGMENT_SHADER</spirit:name>
          <spirit:displayName>FRAGMENT_SHADER</spirit:displayName>
          <spirit:description>FRAGMENT_SHADER</spirit:description>
          <spirit:bitOffset>9</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Fragment shader jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Fragment shader jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>INDEXED_VERTEX_SHADER</spirit:name>
          <spirit:displayName>INDEXED_VERTEX_SHADER</spirit:displayName>
          <spirit:description>   Added INDEXED_VERTEX_SHADER flag to  JSn_FEATURES registers.</spirit:description>
          <spirit:bitOffset>10</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Indexed vertex shader jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Indexed vertex shader jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>JS14_FEATURES</spirit:name>
        <spirit:displayName>JS14_FEATURES</spirit:displayName>
        <spirit:description>   Contains various information of the features of Job Slot 14. </spirit:description>
        <spirit:addressOffset>0xf8</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>Res66</spirit:name>
          <spirit:displayName>Res66</spirit:displayName>
          <spirit:description>Res66</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>Res67</spirit:name>
          <spirit:displayName>Res67</spirit:displayName>
          <spirit:description>Res67</spirit:description>
          <spirit:bitOffset>8</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>Res68</spirit:name>
          <spirit:displayName>Res68</spirit:displayName>
          <spirit:description>Res68</spirit:description>
          <spirit:bitOffset>11</spirit:bitOffset>
          <spirit:bitWidth>21</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>NULL</spirit:name>
          <spirit:displayName>NULL</spirit:displayName>
          <spirit:description>NULL</spirit:description>
          <spirit:bitOffset>1</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Null jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Null jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>WRITE_VALUE</spirit:name>
          <spirit:displayName>WRITE_VALUE</spirit:displayName>
          <spirit:description>   Corrected two references to Set value job. </spirit:description>
          <spirit:bitOffset>2</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Write value jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Write value jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>CACHE_FLUSH</spirit:name>
          <spirit:displayName>CACHE_FLUSH</spirit:displayName>
          <spirit:description>CACHE_FLUSH</spirit:description>
          <spirit:bitOffset>3</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Cache flush jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Cache flush are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>COMPUTE_SHADER</spirit:name>
          <spirit:displayName>COMPUTE_SHADER</spirit:displayName>
          <spirit:description>COMPUTE_SHADER</spirit:description>
          <spirit:bitOffset>4</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Compute shader jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Compute shader jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>VERTEX_SHADER</spirit:name>
          <spirit:displayName>VERTEX_SHADER</spirit:displayName>
          <spirit:description>VERTEX_SHADER</spirit:description>
          <spirit:bitOffset>5</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Vertex shader jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Vertex shader jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>GEOMETRY_SHADER</spirit:name>
          <spirit:displayName>GEOMETRY_SHADER</spirit:displayName>
          <spirit:description>GEOMETRY_SHADER</spirit:description>
          <spirit:bitOffset>6</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Geometry shader jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Geometry shader jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>TILER</spirit:name>
          <spirit:displayName>TILER</spirit:displayName>
          <spirit:description>TILER</spirit:description>
          <spirit:bitOffset>7</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Tiler jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Tiler jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>FRAGMENT_SHADER</spirit:name>
          <spirit:displayName>FRAGMENT_SHADER</spirit:displayName>
          <spirit:description>FRAGMENT_SHADER</spirit:description>
          <spirit:bitOffset>9</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Fragment shader jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Fragment shader jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>INDEXED_VERTEX_SHADER</spirit:name>
          <spirit:displayName>INDEXED_VERTEX_SHADER</spirit:displayName>
          <spirit:description>   Added INDEXED_VERTEX_SHADER flag to  JSn_FEATURES registers.</spirit:description>
          <spirit:bitOffset>10</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Indexed vertex shader jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Indexed vertex shader jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>JS15_FEATURES</spirit:name>
        <spirit:displayName>JS15_FEATURES</spirit:displayName>
        <spirit:description>   Contains various information of the features of Job Slot 15. </spirit:description>
        <spirit:addressOffset>0xfc</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>Res69</spirit:name>
          <spirit:displayName>Res69</spirit:displayName>
          <spirit:description>Res69</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>Res70</spirit:name>
          <spirit:displayName>Res70</spirit:displayName>
          <spirit:description>Res70</spirit:description>
          <spirit:bitOffset>8</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>Res71</spirit:name>
          <spirit:displayName>Res71</spirit:displayName>
          <spirit:description>Res71</spirit:description>
          <spirit:bitOffset>11</spirit:bitOffset>
          <spirit:bitWidth>21</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>NULL</spirit:name>
          <spirit:displayName>NULL</spirit:displayName>
          <spirit:description>NULL</spirit:description>
          <spirit:bitOffset>1</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Null jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Null jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>WRITE_VALUE</spirit:name>
          <spirit:displayName>WRITE_VALUE</spirit:displayName>
          <spirit:description>   Corrected two references to Set value job. </spirit:description>
          <spirit:bitOffset>2</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Write value jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Write value jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>CACHE_FLUSH</spirit:name>
          <spirit:displayName>CACHE_FLUSH</spirit:displayName>
          <spirit:description>CACHE_FLUSH</spirit:description>
          <spirit:bitOffset>3</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Cache flush jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Cache flush are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>COMPUTE_SHADER</spirit:name>
          <spirit:displayName>COMPUTE_SHADER</spirit:displayName>
          <spirit:description>COMPUTE_SHADER</spirit:description>
          <spirit:bitOffset>4</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Compute shader jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Compute shader jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>VERTEX_SHADER</spirit:name>
          <spirit:displayName>VERTEX_SHADER</spirit:displayName>
          <spirit:description>VERTEX_SHADER</spirit:description>
          <spirit:bitOffset>5</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Vertex shader jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Vertex shader jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>GEOMETRY_SHADER</spirit:name>
          <spirit:displayName>GEOMETRY_SHADER</spirit:displayName>
          <spirit:description>GEOMETRY_SHADER</spirit:description>
          <spirit:bitOffset>6</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Geometry shader jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Geometry shader jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>TILER</spirit:name>
          <spirit:displayName>TILER</spirit:displayName>
          <spirit:description>TILER</spirit:description>
          <spirit:bitOffset>7</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Tiler jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Tiler jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>FRAGMENT_SHADER</spirit:name>
          <spirit:displayName>FRAGMENT_SHADER</spirit:displayName>
          <spirit:description>FRAGMENT_SHADER</spirit:description>
          <spirit:bitOffset>9</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Fragment shader jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Fragment shader jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>INDEXED_VERTEX_SHADER</spirit:name>
          <spirit:displayName>INDEXED_VERTEX_SHADER</spirit:displayName>
          <spirit:description>   Added INDEXED_VERTEX_SHADER flag to  JSn_FEATURES registers.</spirit:description>
          <spirit:bitOffset>10</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description>   Indexed vertex shader jobs are not supported on this job slot. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description>   Indexed vertex shader jobs are supported and may be issued to this job slot. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>SHADER_PRESENT_LO</spirit:name>
        <spirit:displayName>SHADER_PRESENT_LO</spirit:displayName>
        <spirit:description>SHADER_PRESENT_LO</spirit:description>
        <spirit:addressOffset>0x100</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value spirit:dependency="(((spirit:decode(id('CONFIG_SELECT_CORES'))&gt;0)*(spirit:decode(id('CONFIG_SELECT_CORES'))))+((spirit:decode(id('CONFIG_SELECT_CORES'))=0)*(((spirit:decode(id('CONFIG_CORE_COUNT'))=32)*spirit:decode('4294967295'))+((spirit:decode(id('CONFIG_CORE_COUNT'))=24)*spirit:decode('4294967295'))+((spirit:decode(id('CONFIG_CORE_COUNT'))=16)*spirit:decode('65535'))+((spirit:decode(id('CONFIG_CORE_COUNT'))=12)*spirit:decode('4095'))+((spirit:decode(id('CONFIG_CORE_COUNT'))=10)*spirit:decode('1023'))+((spirit:decode(id('CONFIG_CORE_COUNT'))=8)*spirit:decode('255'))+((spirit:decode(id('CONFIG_CORE_COUNT'))=7)*spirit:decode('127'))+((spirit:decode(id('CONFIG_CORE_COUNT'))=6)*spirit:decode('119'))+((spirit:decode(id('CONFIG_CORE_COUNT'))=5)*spirit:decode('55'))+((spirit:decode(id('CONFIG_CORE_COUNT'))=4)*spirit:decode('15'))+((spirit:decode(id('CONFIG_CORE_COUNT'))=3)*spirit:decode('7'))+((spirit:decode(id('CONFIG_CORE_COUNT'))=2)*(spirit:decode(id('CONFIG_L2_COUNT'))=2)*spirit:decode('17'))+((spirit:decode(id('CONFIG_CORE_COUNT'))=2)*(spirit:decode(id('CONFIG_L2_COUNT'))=1)*spirit:decode('3'))+((spirit:decode(id('CONFIG_CORE_COUNT'))=1)*spirit:decode('1')))))" spirit:format="long" spirit:resolve="dependent">0xff</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>SHADER_PRESENT_LO</spirit:name>
          <spirit:displayName>SHADER_PRESENT_LO</spirit:displayName>
          <spirit:description>   Indicates which shader cores are actually available in the hardware. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> Shader core  n is not available.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Shader core  n is available.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>SHADER_PRESENT_HI</spirit:name>
        <spirit:displayName>SHADER_PRESENT_HI</spirit:displayName>
        <spirit:description>SHADER_PRESENT_HI</spirit:description>
        <spirit:addressOffset>0x104</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>SHADER_PRESENT_HI</spirit:name>
          <spirit:displayName>SHADER_PRESENT_HI</spirit:displayName>
          <spirit:description>   Indicates which shader cores are actually available in the hardware. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> Shader core  n is not available.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Shader core  n is available.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>TILER_PRESENT_LO</spirit:name>
        <spirit:displayName>TILER_PRESENT_LO</spirit:displayName>
        <spirit:description>TILER_PRESENT_LO</spirit:description>
        <spirit:addressOffset>0x110</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x1</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>TILER_PRESENT_LO</spirit:name>
          <spirit:displayName>TILER_PRESENT_LO</spirit:displayName>
          <spirit:description>   Indicates which tilers are actually available in the hardware. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> Tiler  n is not available.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Tiler  n is available.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>TILER_PRESENT_HI</spirit:name>
        <spirit:displayName>TILER_PRESENT_HI</spirit:displayName>
        <spirit:description>TILER_PRESENT_HI</spirit:description>
        <spirit:addressOffset>0x114</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>TILER_PRESENT_HI</spirit:name>
          <spirit:displayName>TILER_PRESENT_HI</spirit:displayName>
          <spirit:description>   Indicates which tilers are actually available in the hardware. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> Tiler  n is not available.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Tiler  n is available.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>L2_PRESENT_LO</spirit:name>
        <spirit:displayName>L2_PRESENT_LO</spirit:displayName>
        <spirit:description>L2_PRESENT_LO</spirit:description>
        <spirit:addressOffset>0x120</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value spirit:dependency="(((spirit:decode(id('CONFIG_L2_COUNT'))&gt;3)*spirit:decode('8'))+((spirit:decode(id('CONFIG_L2_COUNT'))&gt;2)*spirit:decode('4'))+((spirit:decode(id('CONFIG_L2_COUNT'))&gt;1)*spirit:decode('2'))+((spirit:decode(id('CONFIG_L2_COUNT'))&gt;0)*spirit:decode('1')))" spirit:format="long" spirit:resolve="dependent">0x1</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>L2_PRESENT_LO</spirit:name>
          <spirit:displayName>L2_PRESENT_LO</spirit:displayName>
          <spirit:description>   Indicates which Level 2 caches are actually available in the hardware.  Where a number of shader cores share a L2 cache instance, the L2 cache instance is reported on the lowest-numbered core. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> L2 Cache  n is not available.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> L2 Cache  n is available.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>L2_PRESENT_HI</spirit:name>
        <spirit:displayName>L2_PRESENT_HI</spirit:displayName>
        <spirit:description>L2_PRESENT_HI</spirit:description>
        <spirit:addressOffset>0x124</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>L2_PRESENT_HI</spirit:name>
          <spirit:displayName>L2_PRESENT_HI</spirit:displayName>
          <spirit:description>   Indicates which Level 2 caches are actually available in the hardware.  Where a number of shader cores share a L2 cache instance, the L2 cache instance is reported on the lowest-numbered core. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> L2 Cache  n is not available.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> L2 Cache  n is available.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>SHADER_READY_LO</spirit:name>
        <spirit:displayName>SHADER_READY_LO</spirit:displayName>
        <spirit:description>SHADER_READY_LO</spirit:description>
        <spirit:addressOffset>0x140</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>SHADER_READY_LO</spirit:name>
          <spirit:displayName>SHADER_READY_LO</spirit:displayName>
          <spirit:description>   Indicates which shader cores are powered up and ready. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> Shader core  n is not ready.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Shader core  n is ready.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>SHADER_READY_HI</spirit:name>
        <spirit:displayName>SHADER_READY_HI</spirit:displayName>
        <spirit:description>SHADER_READY_HI</spirit:description>
        <spirit:addressOffset>0x144</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>SHADER_READY_HI</spirit:name>
          <spirit:displayName>SHADER_READY_HI</spirit:displayName>
          <spirit:description>   Indicates which shader cores are powered up and ready. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> Shader core  n is not ready.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Shader core  n is ready.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>TILER_READY_LO</spirit:name>
        <spirit:displayName>TILER_READY_LO</spirit:displayName>
        <spirit:description>TILER_READY_LO</spirit:description>
        <spirit:addressOffset>0x150</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>TILER_READY_LO</spirit:name>
          <spirit:displayName>TILER_READY_LO</spirit:displayName>
          <spirit:description>   Indicates which tiler units are powered up and ready. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> Tiler  n is not ready.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Tiler  n is ready.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>TILER_READY_HI</spirit:name>
        <spirit:displayName>TILER_READY_HI</spirit:displayName>
        <spirit:description>TILER_READY_HI</spirit:description>
        <spirit:addressOffset>0x154</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>TILER_READY_HI</spirit:name>
          <spirit:displayName>TILER_READY_HI</spirit:displayName>
          <spirit:description>   Indicates which tiler units are powered up and ready. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> Tiler  n is not ready.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Tiler  n is ready.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>L2_READY_LO</spirit:name>
        <spirit:displayName>L2_READY_LO</spirit:displayName>
        <spirit:description>L2_READY_LO</spirit:description>
        <spirit:addressOffset>0x160</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>L2_READY_LO</spirit:name>
          <spirit:displayName>L2_READY_LO</spirit:displayName>
          <spirit:description>   Indicates which level 2 caches are powered up and ready. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> L2 cache  n is not ready.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> L2 cache  n is ready.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>L2_READY_HI</spirit:name>
        <spirit:displayName>L2_READY_HI</spirit:displayName>
        <spirit:description>L2_READY_HI</spirit:description>
        <spirit:addressOffset>0x164</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>L2_READY_HI</spirit:name>
          <spirit:displayName>L2_READY_HI</spirit:displayName>
          <spirit:description>   Indicates which level 2 caches are powered up and ready. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> L2 cache  n is not ready.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> L2 cache  n is ready.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>SHADER_PWRON_LO</spirit:name>
        <spirit:displayName>SHADER_PWRON_LO</spirit:displayName>
        <spirit:description>SHADER_PWRON_LO</spirit:description>
        <spirit:addressOffset>0x180</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>SHADER_PWRON_LO</spirit:name>
          <spirit:displayName>SHADER_PWRON_LO</spirit:displayName>
          <spirit:description>   Requests that shader cores are to be powered on. This register should only be written when all previous power transitions have been completed, otherwise results are  UNDEFINED .</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>write-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> Shader core  n 's power state is not changed.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Shader core  n should be powered on.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>SHADER_PWRON_HI</spirit:name>
        <spirit:displayName>SHADER_PWRON_HI</spirit:displayName>
        <spirit:description>SHADER_PWRON_HI</spirit:description>
        <spirit:addressOffset>0x184</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>SHADER_PWRON_HI</spirit:name>
          <spirit:displayName>SHADER_PWRON_HI</spirit:displayName>
          <spirit:description>   Requests that shader cores are to be powered on. This register should only be written when all previous power transitions have been completed, otherwise results are  UNDEFINED .</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>write-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> Shader core  n 's power state is not changed.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Shader core  n should be powered on.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>TILER_PWRON_LO</spirit:name>
        <spirit:displayName>TILER_PWRON_LO</spirit:displayName>
        <spirit:description>TILER_PWRON_LO</spirit:description>
        <spirit:addressOffset>0x190</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>TILER_PWRON_LO</spirit:name>
          <spirit:displayName>TILER_PWRON_LO</spirit:displayName>
          <spirit:description>   Requests that tiler units are to be powered on. This register should only be written when all previous power transitions have been completed, otherwise results are  UNDEFINED .</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>write-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> Tile unit  n 's power state is not changed.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Tiler unit  n should be powered on.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>TILER_PWRON_HI</spirit:name>
        <spirit:displayName>TILER_PWRON_HI</spirit:displayName>
        <spirit:description>TILER_PWRON_HI</spirit:description>
        <spirit:addressOffset>0x194</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>TILER_PWRON_HI</spirit:name>
          <spirit:displayName>TILER_PWRON_HI</spirit:displayName>
          <spirit:description>   Requests that tiler units are to be powered on. This register should only be written when all previous power transitions have been completed, otherwise results are  UNDEFINED .</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>write-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> Tile unit  n 's power state is not changed.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Tiler unit  n should be powered on.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>L2_PWRON_LO</spirit:name>
        <spirit:displayName>L2_PWRON_LO</spirit:displayName>
        <spirit:description>L2_PWRON_LO</spirit:description>
        <spirit:addressOffset>0x1a0</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>L2_PWRON_LO</spirit:name>
          <spirit:displayName>L2_PWRON_LO</spirit:displayName>
          <spirit:description>   Requests that level 2 caches are to be powered on. This register should only be written when all previous power transitions have been completed, otherwise results are  UNDEFINED .</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>write-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> Level 2 cache  n 's power state is not changed.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Level 2 cache  n should be powered on.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>L2_PWRON_HI</spirit:name>
        <spirit:displayName>L2_PWRON_HI</spirit:displayName>
        <spirit:description>L2_PWRON_HI</spirit:description>
        <spirit:addressOffset>0x1a4</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>L2_PWRON_HI</spirit:name>
          <spirit:displayName>L2_PWRON_HI</spirit:displayName>
          <spirit:description>   Requests that level 2 caches are to be powered on. This register should only be written when all previous power transitions have been completed, otherwise results are  UNDEFINED .</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>write-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> Level 2 cache  n 's power state is not changed.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Level 2 cache  n should be powered on.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>SHADER_PWROFF_LO</spirit:name>
        <spirit:displayName>SHADER_PWROFF_LO</spirit:displayName>
        <spirit:description>SHADER_PWROFF_LO</spirit:description>
        <spirit:addressOffset>0x1c0</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>SHADER_PWROFF_LO</spirit:name>
          <spirit:displayName>SHADER_PWROFF_LO</spirit:displayName>
          <spirit:description>   Requests that shader cores are to be powered off. This register should only be written when all previous power transitions have been completed, otherwise results are  UNDEFINED . Power domains may contain multiple cores. In this case, a power domain must not be powered off until all cores within that domain are marked as powered off.
							A core will therefore never be powered off "implicitly" by powering down another core, but it may be kept powered if it shares a power domain with another active core.
							It is therefore necessary to know the relationship between cores and power domains to determine the most appropriate set of cores to power down.  The relationship of cores to power domains is implementation dependent. 
							It often depends not only on the GPU model, but also on the details of system integration, and may vary across different system designs from the same vendor.
							Please refer to implementation notes for your system to determine the mapping of cores to power domains.  Clarified power-off behavior for multi-core power domains. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>write-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> Shader core  n 's power state is not changed.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Shader core  n should be powered off.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>SHADER_PWROFF_HI</spirit:name>
        <spirit:displayName>SHADER_PWROFF_HI</spirit:displayName>
        <spirit:description>SHADER_PWROFF_HI</spirit:description>
        <spirit:addressOffset>0x1c4</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>SHADER_PWROFF_HI</spirit:name>
          <spirit:displayName>SHADER_PWROFF_HI</spirit:displayName>
          <spirit:description>   Requests that shader cores are to be powered off. This register should only be written when all previous power transitions have been completed, otherwise results are  UNDEFINED . Power domains may contain multiple cores. In this case, a power domain must not be powered off until all cores within that domain are marked as powered off.
							A core will therefore never be powered off "implicitly" by powering down another core, but it may be kept powered if it shares a power domain with another active core.
							It is therefore necessary to know the relationship between cores and power domains to determine the most appropriate set of cores to power down.  The relationship of cores to power domains is implementation dependent. 
							It often depends not only on the GPU model, but also on the details of system integration, and may vary across different system designs from the same vendor.
							Please refer to implementation notes for your system to determine the mapping of cores to power domains.  Clarified power-off behavior for multi-core power domains. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>write-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> Shader core  n 's power state is not changed.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Shader core  n should be powered off.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>TILER_PWROFF_LO</spirit:name>
        <spirit:displayName>TILER_PWROFF_LO</spirit:displayName>
        <spirit:description>TILER_PWROFF_LO</spirit:description>
        <spirit:addressOffset>0x1d0</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>TILER_PWROFF_LO</spirit:name>
          <spirit:displayName>TILER_PWROFF_LO</spirit:displayName>
          <spirit:description>   Requests that tiler units are to be powered off. This register should only be written when all previous power transitions have been completed, otherwise results are  UNDEFINED .</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>write-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> Tiler unit  n 's power state is not changed.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Tiler unit  n should be powered off.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>TILER_PWROFF_HI</spirit:name>
        <spirit:displayName>TILER_PWROFF_HI</spirit:displayName>
        <spirit:description>TILER_PWROFF_HI</spirit:description>
        <spirit:addressOffset>0x1d4</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>TILER_PWROFF_HI</spirit:name>
          <spirit:displayName>TILER_PWROFF_HI</spirit:displayName>
          <spirit:description>   Requests that tiler units are to be powered off. This register should only be written when all previous power transitions have been completed, otherwise results are  UNDEFINED .</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>write-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> Tiler unit  n 's power state is not changed.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Tiler unit  n should be powered off.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>L2_PWROFF_LO</spirit:name>
        <spirit:displayName>L2_PWROFF_LO</spirit:displayName>
        <spirit:description>L2_PWROFF_LO</spirit:description>
        <spirit:addressOffset>0x1e0</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>L2_PWROFF_LO</spirit:name>
          <spirit:displayName>L2_PWROFF_LO</spirit:displayName>
          <spirit:description>   Requests that level 2 caches are to be powered off. This register should only be written when all previous power transitions have been completed, otherwise results are  UNDEFINED .</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>write-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> L2 cache  n 's power state is not changed.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> L2 cache  n should be powered off.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>L2_PWROFF_HI</spirit:name>
        <spirit:displayName>L2_PWROFF_HI</spirit:displayName>
        <spirit:description>L2_PWROFF_HI</spirit:description>
        <spirit:addressOffset>0x1e4</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>L2_PWROFF_HI</spirit:name>
          <spirit:displayName>L2_PWROFF_HI</spirit:displayName>
          <spirit:description>   Requests that level 2 caches are to be powered off. This register should only be written when all previous power transitions have been completed, otherwise results are  UNDEFINED .</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>write-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> L2 cache  n 's power state is not changed.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> L2 cache  n should be powered off.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>SHADER_PWRTRANS_LO</spirit:name>
        <spirit:displayName>SHADER_PWRTRANS_LO</spirit:displayName>
        <spirit:description>SHADER_PWRTRANS_LO</spirit:description>
        <spirit:addressOffset>0x200</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>SHADER_PWRTRANS_LO</spirit:name>
          <spirit:displayName>SHADER_PWRTRANS_LO</spirit:displayName>
          <spirit:description>   Indicates which shader cores are currently changing power state. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> Shader core  n is in a stable power state (on or off).</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Shader core  n is transitioning from on to off, or vice versa.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>SHADER_PWRTRANS_HI</spirit:name>
        <spirit:displayName>SHADER_PWRTRANS_HI</spirit:displayName>
        <spirit:description>SHADER_PWRTRANS_HI</spirit:description>
        <spirit:addressOffset>0x204</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>SHADER_PWRTRANS_HI</spirit:name>
          <spirit:displayName>SHADER_PWRTRANS_HI</spirit:displayName>
          <spirit:description>   Indicates which shader cores are currently changing power state. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> Shader core  n is in a stable power state (on or off).</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Shader core  n is transitioning from on to off, or vice versa.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>TILER_PWRTRANS_LO</spirit:name>
        <spirit:displayName>TILER_PWRTRANS_LO</spirit:displayName>
        <spirit:description>TILER_PWRTRANS_LO</spirit:description>
        <spirit:addressOffset>0x210</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>TILER_PWRTRANS_LO</spirit:name>
          <spirit:displayName>TILER_PWRTRANS_LO</spirit:displayName>
          <spirit:description>   Indicates which tiler units are currently changing power state. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> Tiler unit  n is in a stable power state (on or off).</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Tiler unit  n is transitioning from on to off, or vice versa.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>TILER_PWRTRANS_HI</spirit:name>
        <spirit:displayName>TILER_PWRTRANS_HI</spirit:displayName>
        <spirit:description>TILER_PWRTRANS_HI</spirit:description>
        <spirit:addressOffset>0x214</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>TILER_PWRTRANS_HI</spirit:name>
          <spirit:displayName>TILER_PWRTRANS_HI</spirit:displayName>
          <spirit:description>   Indicates which tiler units are currently changing power state. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> Tiler unit  n is in a stable power state (on or off).</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Tiler unit  n is transitioning from on to off, or vice versa.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>L2_PWRTRANS_LO</spirit:name>
        <spirit:displayName>L2_PWRTRANS_LO</spirit:displayName>
        <spirit:description>L2_PWRTRANS_LO</spirit:description>
        <spirit:addressOffset>0x220</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>L2_PWRTRANS_LO</spirit:name>
          <spirit:displayName>L2_PWRTRANS_LO</spirit:displayName>
          <spirit:description>   Indicates which level 2 caches are currently changing power state. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> L2 Cache  n is in a stable power state (on or off).</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> L2 Cache  n is transitioning from on to off, or vice versa.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>L2_PWRTRANS_HI</spirit:name>
        <spirit:displayName>L2_PWRTRANS_HI</spirit:displayName>
        <spirit:description>L2_PWRTRANS_HI</spirit:description>
        <spirit:addressOffset>0x224</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>L2_PWRTRANS_HI</spirit:name>
          <spirit:displayName>L2_PWRTRANS_HI</spirit:displayName>
          <spirit:description>   Indicates which level 2 caches are currently changing power state. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> L2 Cache  n is in a stable power state (on or off).</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> L2 Cache  n is transitioning from on to off, or vice versa.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>SHADER_PWRACTIVE_LO</spirit:name>
        <spirit:displayName>SHADER_PWRACTIVE_LO</spirit:displayName>
        <spirit:description>SHADER_PWRACTIVE_LO</spirit:description>
        <spirit:addressOffset>0x240</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>SHADER_PWRACTIVE_LO</spirit:name>
          <spirit:displayName>SHADER_PWRACTIVE_LO</spirit:displayName>
          <spirit:description>   Indicates which shader cores are currently active and processing data. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> Shader core  n is idle.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Shader core  n is busy.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>SHADER_PWRACTIVE_HI</spirit:name>
        <spirit:displayName>SHADER_PWRACTIVE_HI</spirit:displayName>
        <spirit:description>SHADER_PWRACTIVE_HI</spirit:description>
        <spirit:addressOffset>0x244</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>SHADER_PWRACTIVE_HI</spirit:name>
          <spirit:displayName>SHADER_PWRACTIVE_HI</spirit:displayName>
          <spirit:description>   Indicates which shader cores are currently active and processing data. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> Shader core  n is idle.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Shader core  n is busy.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>TILER_PWRACTIVE_LO</spirit:name>
        <spirit:displayName>TILER_PWRACTIVE_LO</spirit:displayName>
        <spirit:description>TILER_PWRACTIVE_LO</spirit:description>
        <spirit:addressOffset>0x250</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>TILER_PWRACTIVE_LO</spirit:name>
          <spirit:displayName>TILER_PWRACTIVE_LO</spirit:displayName>
          <spirit:description>   Indicates which tiler units are currently active and processing data. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> Tiler unit  n is idle.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Tiler unit  n is busy.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>TILER_PWRACTIVE_HI</spirit:name>
        <spirit:displayName>TILER_PWRACTIVE_HI</spirit:displayName>
        <spirit:description>TILER_PWRACTIVE_HI</spirit:description>
        <spirit:addressOffset>0x254</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>TILER_PWRACTIVE_HI</spirit:name>
          <spirit:displayName>TILER_PWRACTIVE_HI</spirit:displayName>
          <spirit:description>   Indicates which tiler units are currently active and processing data. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> Tiler unit  n is idle.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Tiler unit  n is busy.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>L2_PWRACTIVE_LO</spirit:name>
        <spirit:displayName>L2_PWRACTIVE_LO</spirit:displayName>
        <spirit:description>L2_PWRACTIVE_LO</spirit:description>
        <spirit:addressOffset>0x260</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>L2_PWRACTIVE_LO</spirit:name>
          <spirit:displayName>L2_PWRACTIVE_LO</spirit:displayName>
          <spirit:description>   Indicates which level 2 cache units are currently active and processing data. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> L2 cache  n is idle.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> L2 cache  n is busy.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>L2_PWRACTIVE_HI</spirit:name>
        <spirit:displayName>L2_PWRACTIVE_HI</spirit:displayName>
        <spirit:description>L2_PWRACTIVE_HI</spirit:description>
        <spirit:addressOffset>0x264</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>L2_PWRACTIVE_HI</spirit:name>
          <spirit:displayName>L2_PWRACTIVE_HI</spirit:displayName>
          <spirit:description>   Indicates which level 2 cache units are currently active and processing data. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> L2 cache  n is idle.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> L2 cache  n is busy.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>COHERENCY_FEATURES</spirit:name>
        <spirit:displayName>COHERENCY_FEATURES</spirit:displayName>
        <spirit:description>   The Bifrost GPUs may support multiple coherency protocols. This register contains one boolean value for each protocol supported. At least one coherency protocol must be supported.  Changed for MIDHARC-184 </spirit:description>
        <spirit:addressOffset>0x300</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>Res72</spirit:name>
          <spirit:displayName>Res72</spirit:displayName>
          <spirit:description>Res72</spirit:description>
          <spirit:bitOffset>2</spirit:bitOffset>
          <spirit:bitWidth>29</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>no_coherency</spirit:name>
          <spirit:displayName>no_coherency</spirit:displayName>
          <spirit:description>   This bit is reserved to give a guaranteed zero that can be used to disable coherency.  Reserved a bit for "no coherency" protocol in COHERENCY_FEATURES. </spirit:description>
          <spirit:bitOffset>31</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>ACE_LITE</spirit:name>
          <spirit:displayName>ACE_LITE</spirit:displayName>
          <spirit:description>ACE_LITE</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> Interconnect does not support the ACE-lite coherency protocol. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Interconnect supports the ACE-lite coherency protocol. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ACE</spirit:name>
          <spirit:displayName>ACE</spirit:displayName>
          <spirit:description>ACE</spirit:description>
          <spirit:bitOffset>1</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> Interconnect does not support the ACE coherency protocol. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Interconnect supports the ACE coherency protocol. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>COHERENCY_ENABLE</spirit:name>
        <spirit:displayName>COHERENCY_ENABLE</spirit:displayName>
        <spirit:description>   This register contains an index indicating which coherency protocol should be enabled. The index values correspond to the bit numbers in the  COHERENCY_FEATURES register. At least one coherency protocol must be supported. If the indexed bit is 0, then coherency is disabled. The  no_coherency bit is reserved to give a guaranteed zero that can always be used to disable coherency. Changed for MIDHARC-184  Added behavior for "no coherency" protocol in COHERENCY_ENABLE. </spirit:description>
        <spirit:addressOffset>0x304</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>L2_CACHE_PROTOCOL_SELECT</spirit:name>
          <spirit:displayName>L2_CACHE_PROTOCOL_SELECT</spirit:displayName>
          <spirit:description>L2_CACHE_PROTOCOL_SELECT</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>ace_lite</spirit:name>
              <spirit:description> Select ACE-Lite protocol. This may only be selected if the  ace_lite flag is set. If not, then coherency is disabled.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ace</spirit:name>
              <spirit:description> Select ACE protocol. This may only be selected if the  ace flag is set. If not, then coherency is disabled.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>no_coherency</spirit:name>
              <spirit:description> Disable coherency. </spirit:description>
              <spirit:value>31</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>GPU_USER_IN_0</spirit:name>
        <spirit:displayName>GPU_USER_IN_0</spirit:displayName>
        <spirit:description>   The Bifrost GPUs all allow vendors to specify up to 1024 user input signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_IN signals are connected to the GPU_USER_IN  n registers. The signals and registers are numbered consecutively from zero, and signal USER_IN[i] will appear at bit position [i % 32] in register GPU_USER_IN[i/32].</spirit:description>
        <spirit:addressOffset>0x400</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>GPU_USER_IN_0</spirit:name>
          <spirit:displayName>GPU_USER_IN_0</spirit:displayName>
          <spirit:description>GPU_USER_IN_0</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> User input N*32 +  n reads as 0.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> User input N*32 +  n reads as 1.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>GPU_USER_IN_1</spirit:name>
        <spirit:displayName>GPU_USER_IN_1</spirit:displayName>
        <spirit:description>   The Bifrost GPUs all allow vendors to specify up to 1024 user input signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_IN signals are connected to the GPU_USER_IN  n registers. The signals and registers are numbered consecutively from zero, and signal USER_IN[i] will appear at bit position [i % 32] in register GPU_USER_IN[i/32].</spirit:description>
        <spirit:addressOffset>0x404</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>GPU_USER_IN_1</spirit:name>
          <spirit:displayName>GPU_USER_IN_1</spirit:displayName>
          <spirit:description>GPU_USER_IN_1</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> User input N*32 +  n reads as 0.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> User input N*32 +  n reads as 1.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>GPU_USER_IN_2</spirit:name>
        <spirit:displayName>GPU_USER_IN_2</spirit:displayName>
        <spirit:description>   The Bifrost GPUs all allow vendors to specify up to 1024 user input signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_IN signals are connected to the GPU_USER_IN  n registers. The signals and registers are numbered consecutively from zero, and signal USER_IN[i] will appear at bit position [i % 32] in register GPU_USER_IN[i/32].</spirit:description>
        <spirit:addressOffset>0x408</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>GPU_USER_IN_2</spirit:name>
          <spirit:displayName>GPU_USER_IN_2</spirit:displayName>
          <spirit:description>GPU_USER_IN_2</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> User input N*32 +  n reads as 0.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> User input N*32 +  n reads as 1.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>GPU_USER_IN_3</spirit:name>
        <spirit:displayName>GPU_USER_IN_3</spirit:displayName>
        <spirit:description>   The Bifrost GPUs all allow vendors to specify up to 1024 user input signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_IN signals are connected to the GPU_USER_IN  n registers. The signals and registers are numbered consecutively from zero, and signal USER_IN[i] will appear at bit position [i % 32] in register GPU_USER_IN[i/32].</spirit:description>
        <spirit:addressOffset>0x40c</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>GPU_USER_IN_3</spirit:name>
          <spirit:displayName>GPU_USER_IN_3</spirit:displayName>
          <spirit:description>GPU_USER_IN_3</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> User input N*32 +  n reads as 0.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> User input N*32 +  n reads as 1.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>GPU_USER_IN_4</spirit:name>
        <spirit:displayName>GPU_USER_IN_4</spirit:displayName>
        <spirit:description>   The Bifrost GPUs all allow vendors to specify up to 1024 user input signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_IN signals are connected to the GPU_USER_IN  n registers. The signals and registers are numbered consecutively from zero, and signal USER_IN[i] will appear at bit position [i % 32] in register GPU_USER_IN[i/32].</spirit:description>
        <spirit:addressOffset>0x410</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>GPU_USER_IN_4</spirit:name>
          <spirit:displayName>GPU_USER_IN_4</spirit:displayName>
          <spirit:description>GPU_USER_IN_4</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> User input N*32 +  n reads as 0.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> User input N*32 +  n reads as 1.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>GPU_USER_IN_5</spirit:name>
        <spirit:displayName>GPU_USER_IN_5</spirit:displayName>
        <spirit:description>   The Bifrost GPUs all allow vendors to specify up to 1024 user input signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_IN signals are connected to the GPU_USER_IN  n registers. The signals and registers are numbered consecutively from zero, and signal USER_IN[i] will appear at bit position [i % 32] in register GPU_USER_IN[i/32].</spirit:description>
        <spirit:addressOffset>0x414</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>GPU_USER_IN_5</spirit:name>
          <spirit:displayName>GPU_USER_IN_5</spirit:displayName>
          <spirit:description>GPU_USER_IN_5</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> User input N*32 +  n reads as 0.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> User input N*32 +  n reads as 1.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>GPU_USER_IN_6</spirit:name>
        <spirit:displayName>GPU_USER_IN_6</spirit:displayName>
        <spirit:description>   The Bifrost GPUs all allow vendors to specify up to 1024 user input signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_IN signals are connected to the GPU_USER_IN  n registers. The signals and registers are numbered consecutively from zero, and signal USER_IN[i] will appear at bit position [i % 32] in register GPU_USER_IN[i/32].</spirit:description>
        <spirit:addressOffset>0x418</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>GPU_USER_IN_6</spirit:name>
          <spirit:displayName>GPU_USER_IN_6</spirit:displayName>
          <spirit:description>GPU_USER_IN_6</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> User input N*32 +  n reads as 0.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> User input N*32 +  n reads as 1.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>GPU_USER_IN_7</spirit:name>
        <spirit:displayName>GPU_USER_IN_7</spirit:displayName>
        <spirit:description>   The Bifrost GPUs all allow vendors to specify up to 1024 user input signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_IN signals are connected to the GPU_USER_IN  n registers. The signals and registers are numbered consecutively from zero, and signal USER_IN[i] will appear at bit position [i % 32] in register GPU_USER_IN[i/32].</spirit:description>
        <spirit:addressOffset>0x41c</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>GPU_USER_IN_7</spirit:name>
          <spirit:displayName>GPU_USER_IN_7</spirit:displayName>
          <spirit:description>GPU_USER_IN_7</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> User input N*32 +  n reads as 0.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> User input N*32 +  n reads as 1.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>GPU_USER_IN_8</spirit:name>
        <spirit:displayName>GPU_USER_IN_8</spirit:displayName>
        <spirit:description>   The Bifrost GPUs all allow vendors to specify up to 1024 user input signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_IN signals are connected to the GPU_USER_IN  n registers. The signals and registers are numbered consecutively from zero, and signal USER_IN[i] will appear at bit position [i % 32] in register GPU_USER_IN[i/32].</spirit:description>
        <spirit:addressOffset>0x420</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>GPU_USER_IN_8</spirit:name>
          <spirit:displayName>GPU_USER_IN_8</spirit:displayName>
          <spirit:description>GPU_USER_IN_8</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> User input N*32 +  n reads as 0.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> User input N*32 +  n reads as 1.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>GPU_USER_IN_9</spirit:name>
        <spirit:displayName>GPU_USER_IN_9</spirit:displayName>
        <spirit:description>   The Bifrost GPUs all allow vendors to specify up to 1024 user input signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_IN signals are connected to the GPU_USER_IN  n registers. The signals and registers are numbered consecutively from zero, and signal USER_IN[i] will appear at bit position [i % 32] in register GPU_USER_IN[i/32].</spirit:description>
        <spirit:addressOffset>0x424</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>GPU_USER_IN_9</spirit:name>
          <spirit:displayName>GPU_USER_IN_9</spirit:displayName>
          <spirit:description>GPU_USER_IN_9</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> User input N*32 +  n reads as 0.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> User input N*32 +  n reads as 1.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>GPU_USER_IN_10</spirit:name>
        <spirit:displayName>GPU_USER_IN_10</spirit:displayName>
        <spirit:description>   The Bifrost GPUs all allow vendors to specify up to 1024 user input signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_IN signals are connected to the GPU_USER_IN  n registers. The signals and registers are numbered consecutively from zero, and signal USER_IN[i] will appear at bit position [i % 32] in register GPU_USER_IN[i/32].</spirit:description>
        <spirit:addressOffset>0x428</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>GPU_USER_IN_10</spirit:name>
          <spirit:displayName>GPU_USER_IN_10</spirit:displayName>
          <spirit:description>GPU_USER_IN_10</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> User input N*32 +  n reads as 0.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> User input N*32 +  n reads as 1.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>GPU_USER_IN_11</spirit:name>
        <spirit:displayName>GPU_USER_IN_11</spirit:displayName>
        <spirit:description>   The Bifrost GPUs all allow vendors to specify up to 1024 user input signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_IN signals are connected to the GPU_USER_IN  n registers. The signals and registers are numbered consecutively from zero, and signal USER_IN[i] will appear at bit position [i % 32] in register GPU_USER_IN[i/32].</spirit:description>
        <spirit:addressOffset>0x42c</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>GPU_USER_IN_11</spirit:name>
          <spirit:displayName>GPU_USER_IN_11</spirit:displayName>
          <spirit:description>GPU_USER_IN_11</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> User input N*32 +  n reads as 0.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> User input N*32 +  n reads as 1.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>GPU_USER_IN_12</spirit:name>
        <spirit:displayName>GPU_USER_IN_12</spirit:displayName>
        <spirit:description>   The Bifrost GPUs all allow vendors to specify up to 1024 user input signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_IN signals are connected to the GPU_USER_IN  n registers. The signals and registers are numbered consecutively from zero, and signal USER_IN[i] will appear at bit position [i % 32] in register GPU_USER_IN[i/32].</spirit:description>
        <spirit:addressOffset>0x430</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>GPU_USER_IN_12</spirit:name>
          <spirit:displayName>GPU_USER_IN_12</spirit:displayName>
          <spirit:description>GPU_USER_IN_12</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> User input N*32 +  n reads as 0.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> User input N*32 +  n reads as 1.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>GPU_USER_IN_13</spirit:name>
        <spirit:displayName>GPU_USER_IN_13</spirit:displayName>
        <spirit:description>   The Bifrost GPUs all allow vendors to specify up to 1024 user input signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_IN signals are connected to the GPU_USER_IN  n registers. The signals and registers are numbered consecutively from zero, and signal USER_IN[i] will appear at bit position [i % 32] in register GPU_USER_IN[i/32].</spirit:description>
        <spirit:addressOffset>0x434</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>GPU_USER_IN_13</spirit:name>
          <spirit:displayName>GPU_USER_IN_13</spirit:displayName>
          <spirit:description>GPU_USER_IN_13</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> User input N*32 +  n reads as 0.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> User input N*32 +  n reads as 1.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>GPU_USER_IN_14</spirit:name>
        <spirit:displayName>GPU_USER_IN_14</spirit:displayName>
        <spirit:description>   The Bifrost GPUs all allow vendors to specify up to 1024 user input signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_IN signals are connected to the GPU_USER_IN  n registers. The signals and registers are numbered consecutively from zero, and signal USER_IN[i] will appear at bit position [i % 32] in register GPU_USER_IN[i/32].</spirit:description>
        <spirit:addressOffset>0x438</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>GPU_USER_IN_14</spirit:name>
          <spirit:displayName>GPU_USER_IN_14</spirit:displayName>
          <spirit:description>GPU_USER_IN_14</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> User input N*32 +  n reads as 0.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> User input N*32 +  n reads as 1.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>GPU_USER_IN_15</spirit:name>
        <spirit:displayName>GPU_USER_IN_15</spirit:displayName>
        <spirit:description>   The Bifrost GPUs all allow vendors to specify up to 1024 user input signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_IN signals are connected to the GPU_USER_IN  n registers. The signals and registers are numbered consecutively from zero, and signal USER_IN[i] will appear at bit position [i % 32] in register GPU_USER_IN[i/32].</spirit:description>
        <spirit:addressOffset>0x43c</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>GPU_USER_IN_15</spirit:name>
          <spirit:displayName>GPU_USER_IN_15</spirit:displayName>
          <spirit:description>GPU_USER_IN_15</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> User input N*32 +  n reads as 0.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> User input N*32 +  n reads as 1.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>GPU_USER_IN_16</spirit:name>
        <spirit:displayName>GPU_USER_IN_16</spirit:displayName>
        <spirit:description>   The Bifrost GPUs all allow vendors to specify up to 1024 user input signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_IN signals are connected to the GPU_USER_IN  n registers. The signals and registers are numbered consecutively from zero, and signal USER_IN[i] will appear at bit position [i % 32] in register GPU_USER_IN[i/32].</spirit:description>
        <spirit:addressOffset>0x440</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>GPU_USER_IN_16</spirit:name>
          <spirit:displayName>GPU_USER_IN_16</spirit:displayName>
          <spirit:description>GPU_USER_IN_16</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> User input N*32 +  n reads as 0.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> User input N*32 +  n reads as 1.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>GPU_USER_IN_17</spirit:name>
        <spirit:displayName>GPU_USER_IN_17</spirit:displayName>
        <spirit:description>   The Bifrost GPUs all allow vendors to specify up to 1024 user input signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_IN signals are connected to the GPU_USER_IN  n registers. The signals and registers are numbered consecutively from zero, and signal USER_IN[i] will appear at bit position [i % 32] in register GPU_USER_IN[i/32].</spirit:description>
        <spirit:addressOffset>0x444</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>GPU_USER_IN_17</spirit:name>
          <spirit:displayName>GPU_USER_IN_17</spirit:displayName>
          <spirit:description>GPU_USER_IN_17</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> User input N*32 +  n reads as 0.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> User input N*32 +  n reads as 1.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>GPU_USER_IN_18</spirit:name>
        <spirit:displayName>GPU_USER_IN_18</spirit:displayName>
        <spirit:description>   The Bifrost GPUs all allow vendors to specify up to 1024 user input signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_IN signals are connected to the GPU_USER_IN  n registers. The signals and registers are numbered consecutively from zero, and signal USER_IN[i] will appear at bit position [i % 32] in register GPU_USER_IN[i/32].</spirit:description>
        <spirit:addressOffset>0x448</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>GPU_USER_IN_18</spirit:name>
          <spirit:displayName>GPU_USER_IN_18</spirit:displayName>
          <spirit:description>GPU_USER_IN_18</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> User input N*32 +  n reads as 0.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> User input N*32 +  n reads as 1.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>GPU_USER_IN_19</spirit:name>
        <spirit:displayName>GPU_USER_IN_19</spirit:displayName>
        <spirit:description>   The Bifrost GPUs all allow vendors to specify up to 1024 user input signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_IN signals are connected to the GPU_USER_IN  n registers. The signals and registers are numbered consecutively from zero, and signal USER_IN[i] will appear at bit position [i % 32] in register GPU_USER_IN[i/32].</spirit:description>
        <spirit:addressOffset>0x44c</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>GPU_USER_IN_19</spirit:name>
          <spirit:displayName>GPU_USER_IN_19</spirit:displayName>
          <spirit:description>GPU_USER_IN_19</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> User input N*32 +  n reads as 0.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> User input N*32 +  n reads as 1.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>GPU_USER_IN_20</spirit:name>
        <spirit:displayName>GPU_USER_IN_20</spirit:displayName>
        <spirit:description>   The Bifrost GPUs all allow vendors to specify up to 1024 user input signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_IN signals are connected to the GPU_USER_IN  n registers. The signals and registers are numbered consecutively from zero, and signal USER_IN[i] will appear at bit position [i % 32] in register GPU_USER_IN[i/32].</spirit:description>
        <spirit:addressOffset>0x450</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>GPU_USER_IN_20</spirit:name>
          <spirit:displayName>GPU_USER_IN_20</spirit:displayName>
          <spirit:description>GPU_USER_IN_20</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> User input N*32 +  n reads as 0.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> User input N*32 +  n reads as 1.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>GPU_USER_IN_21</spirit:name>
        <spirit:displayName>GPU_USER_IN_21</spirit:displayName>
        <spirit:description>   The Bifrost GPUs all allow vendors to specify up to 1024 user input signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_IN signals are connected to the GPU_USER_IN  n registers. The signals and registers are numbered consecutively from zero, and signal USER_IN[i] will appear at bit position [i % 32] in register GPU_USER_IN[i/32].</spirit:description>
        <spirit:addressOffset>0x454</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>GPU_USER_IN_21</spirit:name>
          <spirit:displayName>GPU_USER_IN_21</spirit:displayName>
          <spirit:description>GPU_USER_IN_21</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> User input N*32 +  n reads as 0.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> User input N*32 +  n reads as 1.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>GPU_USER_IN_22</spirit:name>
        <spirit:displayName>GPU_USER_IN_22</spirit:displayName>
        <spirit:description>   The Bifrost GPUs all allow vendors to specify up to 1024 user input signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_IN signals are connected to the GPU_USER_IN  n registers. The signals and registers are numbered consecutively from zero, and signal USER_IN[i] will appear at bit position [i % 32] in register GPU_USER_IN[i/32].</spirit:description>
        <spirit:addressOffset>0x458</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>GPU_USER_IN_22</spirit:name>
          <spirit:displayName>GPU_USER_IN_22</spirit:displayName>
          <spirit:description>GPU_USER_IN_22</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> User input N*32 +  n reads as 0.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> User input N*32 +  n reads as 1.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>GPU_USER_IN_23</spirit:name>
        <spirit:displayName>GPU_USER_IN_23</spirit:displayName>
        <spirit:description>   The Bifrost GPUs all allow vendors to specify up to 1024 user input signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_IN signals are connected to the GPU_USER_IN  n registers. The signals and registers are numbered consecutively from zero, and signal USER_IN[i] will appear at bit position [i % 32] in register GPU_USER_IN[i/32].</spirit:description>
        <spirit:addressOffset>0x45c</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>GPU_USER_IN_23</spirit:name>
          <spirit:displayName>GPU_USER_IN_23</spirit:displayName>
          <spirit:description>GPU_USER_IN_23</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> User input N*32 +  n reads as 0.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> User input N*32 +  n reads as 1.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>GPU_USER_IN_24</spirit:name>
        <spirit:displayName>GPU_USER_IN_24</spirit:displayName>
        <spirit:description>   The Bifrost GPUs all allow vendors to specify up to 1024 user input signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_IN signals are connected to the GPU_USER_IN  n registers. The signals and registers are numbered consecutively from zero, and signal USER_IN[i] will appear at bit position [i % 32] in register GPU_USER_IN[i/32].</spirit:description>
        <spirit:addressOffset>0x460</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>GPU_USER_IN_24</spirit:name>
          <spirit:displayName>GPU_USER_IN_24</spirit:displayName>
          <spirit:description>GPU_USER_IN_24</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> User input N*32 +  n reads as 0.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> User input N*32 +  n reads as 1.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>GPU_USER_IN_25</spirit:name>
        <spirit:displayName>GPU_USER_IN_25</spirit:displayName>
        <spirit:description>   The Bifrost GPUs all allow vendors to specify up to 1024 user input signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_IN signals are connected to the GPU_USER_IN  n registers. The signals and registers are numbered consecutively from zero, and signal USER_IN[i] will appear at bit position [i % 32] in register GPU_USER_IN[i/32].</spirit:description>
        <spirit:addressOffset>0x464</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>GPU_USER_IN_25</spirit:name>
          <spirit:displayName>GPU_USER_IN_25</spirit:displayName>
          <spirit:description>GPU_USER_IN_25</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> User input N*32 +  n reads as 0.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> User input N*32 +  n reads as 1.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>GPU_USER_IN_26</spirit:name>
        <spirit:displayName>GPU_USER_IN_26</spirit:displayName>
        <spirit:description>   The Bifrost GPUs all allow vendors to specify up to 1024 user input signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_IN signals are connected to the GPU_USER_IN  n registers. The signals and registers are numbered consecutively from zero, and signal USER_IN[i] will appear at bit position [i % 32] in register GPU_USER_IN[i/32].</spirit:description>
        <spirit:addressOffset>0x468</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>GPU_USER_IN_26</spirit:name>
          <spirit:displayName>GPU_USER_IN_26</spirit:displayName>
          <spirit:description>GPU_USER_IN_26</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> User input N*32 +  n reads as 0.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> User input N*32 +  n reads as 1.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>GPU_USER_IN_27</spirit:name>
        <spirit:displayName>GPU_USER_IN_27</spirit:displayName>
        <spirit:description>   The Bifrost GPUs all allow vendors to specify up to 1024 user input signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_IN signals are connected to the GPU_USER_IN  n registers. The signals and registers are numbered consecutively from zero, and signal USER_IN[i] will appear at bit position [i % 32] in register GPU_USER_IN[i/32].</spirit:description>
        <spirit:addressOffset>0x46c</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>GPU_USER_IN_27</spirit:name>
          <spirit:displayName>GPU_USER_IN_27</spirit:displayName>
          <spirit:description>GPU_USER_IN_27</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> User input N*32 +  n reads as 0.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> User input N*32 +  n reads as 1.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>GPU_USER_IN_28</spirit:name>
        <spirit:displayName>GPU_USER_IN_28</spirit:displayName>
        <spirit:description>   The Bifrost GPUs all allow vendors to specify up to 1024 user input signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_IN signals are connected to the GPU_USER_IN  n registers. The signals and registers are numbered consecutively from zero, and signal USER_IN[i] will appear at bit position [i % 32] in register GPU_USER_IN[i/32].</spirit:description>
        <spirit:addressOffset>0x470</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>GPU_USER_IN_28</spirit:name>
          <spirit:displayName>GPU_USER_IN_28</spirit:displayName>
          <spirit:description>GPU_USER_IN_28</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> User input N*32 +  n reads as 0.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> User input N*32 +  n reads as 1.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>GPU_USER_IN_29</spirit:name>
        <spirit:displayName>GPU_USER_IN_29</spirit:displayName>
        <spirit:description>   The Bifrost GPUs all allow vendors to specify up to 1024 user input signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_IN signals are connected to the GPU_USER_IN  n registers. The signals and registers are numbered consecutively from zero, and signal USER_IN[i] will appear at bit position [i % 32] in register GPU_USER_IN[i/32].</spirit:description>
        <spirit:addressOffset>0x474</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>GPU_USER_IN_29</spirit:name>
          <spirit:displayName>GPU_USER_IN_29</spirit:displayName>
          <spirit:description>GPU_USER_IN_29</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> User input N*32 +  n reads as 0.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> User input N*32 +  n reads as 1.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>GPU_USER_IN_30</spirit:name>
        <spirit:displayName>GPU_USER_IN_30</spirit:displayName>
        <spirit:description>   The Bifrost GPUs all allow vendors to specify up to 1024 user input signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_IN signals are connected to the GPU_USER_IN  n registers. The signals and registers are numbered consecutively from zero, and signal USER_IN[i] will appear at bit position [i % 32] in register GPU_USER_IN[i/32].</spirit:description>
        <spirit:addressOffset>0x478</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>GPU_USER_IN_30</spirit:name>
          <spirit:displayName>GPU_USER_IN_30</spirit:displayName>
          <spirit:description>GPU_USER_IN_30</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> User input N*32 +  n reads as 0.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> User input N*32 +  n reads as 1.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>GPU_USER_IN_31</spirit:name>
        <spirit:displayName>GPU_USER_IN_31</spirit:displayName>
        <spirit:description>   The Bifrost GPUs all allow vendors to specify up to 1024 user input signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_IN signals are connected to the GPU_USER_IN  n registers. The signals and registers are numbered consecutively from zero, and signal USER_IN[i] will appear at bit position [i % 32] in register GPU_USER_IN[i/32].</spirit:description>
        <spirit:addressOffset>0x47c</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>GPU_USER_IN_31</spirit:name>
          <spirit:displayName>GPU_USER_IN_31</spirit:displayName>
          <spirit:description>GPU_USER_IN_31</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> User input N*32 +  n reads as 0.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> User input N*32 +  n reads as 1.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>GPU_USER_OUT_0</spirit:name>
        <spirit:displayName>GPU_USER_OUT_0</spirit:displayName>
        <spirit:description>   The Bifrost GPUs all allow vendors to specify up to 1024 user output signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_OUT signals are connected to the GPU_USER_OUT  n registers. The signals and registers are numbered consecutively from zero, and signal USER_OUT[i] will appear at bit position [i % 32] in register GPU_USER_OUT[i/32].</spirit:description>
        <spirit:addressOffset>0x500</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>GPU_USER_OUT_0</spirit:name>
          <spirit:displayName>GPU_USER_OUT_0</spirit:displayName>
          <spirit:description>GPU_USER_OUT_0</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> User output N*32 +  n should be set to 0.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> User output N*32 +  n should be set to 1.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>GPU_USER_OUT_1</spirit:name>
        <spirit:displayName>GPU_USER_OUT_1</spirit:displayName>
        <spirit:description>   The Bifrost GPUs all allow vendors to specify up to 1024 user output signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_OUT signals are connected to the GPU_USER_OUT  n registers. The signals and registers are numbered consecutively from zero, and signal USER_OUT[i] will appear at bit position [i % 32] in register GPU_USER_OUT[i/32].</spirit:description>
        <spirit:addressOffset>0x504</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>GPU_USER_OUT_1</spirit:name>
          <spirit:displayName>GPU_USER_OUT_1</spirit:displayName>
          <spirit:description>GPU_USER_OUT_1</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> User output N*32 +  n should be set to 0.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> User output N*32 +  n should be set to 1.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>GPU_USER_OUT_2</spirit:name>
        <spirit:displayName>GPU_USER_OUT_2</spirit:displayName>
        <spirit:description>   The Bifrost GPUs all allow vendors to specify up to 1024 user output signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_OUT signals are connected to the GPU_USER_OUT  n registers. The signals and registers are numbered consecutively from zero, and signal USER_OUT[i] will appear at bit position [i % 32] in register GPU_USER_OUT[i/32].</spirit:description>
        <spirit:addressOffset>0x508</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>GPU_USER_OUT_2</spirit:name>
          <spirit:displayName>GPU_USER_OUT_2</spirit:displayName>
          <spirit:description>GPU_USER_OUT_2</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> User output N*32 +  n should be set to 0.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> User output N*32 +  n should be set to 1.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>GPU_USER_OUT_3</spirit:name>
        <spirit:displayName>GPU_USER_OUT_3</spirit:displayName>
        <spirit:description>   The Bifrost GPUs all allow vendors to specify up to 1024 user output signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_OUT signals are connected to the GPU_USER_OUT  n registers. The signals and registers are numbered consecutively from zero, and signal USER_OUT[i] will appear at bit position [i % 32] in register GPU_USER_OUT[i/32].</spirit:description>
        <spirit:addressOffset>0x50c</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>GPU_USER_OUT_3</spirit:name>
          <spirit:displayName>GPU_USER_OUT_3</spirit:displayName>
          <spirit:description>GPU_USER_OUT_3</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> User output N*32 +  n should be set to 0.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> User output N*32 +  n should be set to 1.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>GPU_USER_OUT_4</spirit:name>
        <spirit:displayName>GPU_USER_OUT_4</spirit:displayName>
        <spirit:description>   The Bifrost GPUs all allow vendors to specify up to 1024 user output signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_OUT signals are connected to the GPU_USER_OUT  n registers. The signals and registers are numbered consecutively from zero, and signal USER_OUT[i] will appear at bit position [i % 32] in register GPU_USER_OUT[i/32].</spirit:description>
        <spirit:addressOffset>0x510</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>GPU_USER_OUT_4</spirit:name>
          <spirit:displayName>GPU_USER_OUT_4</spirit:displayName>
          <spirit:description>GPU_USER_OUT_4</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> User output N*32 +  n should be set to 0.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> User output N*32 +  n should be set to 1.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>GPU_USER_OUT_5</spirit:name>
        <spirit:displayName>GPU_USER_OUT_5</spirit:displayName>
        <spirit:description>   The Bifrost GPUs all allow vendors to specify up to 1024 user output signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_OUT signals are connected to the GPU_USER_OUT  n registers. The signals and registers are numbered consecutively from zero, and signal USER_OUT[i] will appear at bit position [i % 32] in register GPU_USER_OUT[i/32].</spirit:description>
        <spirit:addressOffset>0x514</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>GPU_USER_OUT_5</spirit:name>
          <spirit:displayName>GPU_USER_OUT_5</spirit:displayName>
          <spirit:description>GPU_USER_OUT_5</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> User output N*32 +  n should be set to 0.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> User output N*32 +  n should be set to 1.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>GPU_USER_OUT_6</spirit:name>
        <spirit:displayName>GPU_USER_OUT_6</spirit:displayName>
        <spirit:description>   The Bifrost GPUs all allow vendors to specify up to 1024 user output signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_OUT signals are connected to the GPU_USER_OUT  n registers. The signals and registers are numbered consecutively from zero, and signal USER_OUT[i] will appear at bit position [i % 32] in register GPU_USER_OUT[i/32].</spirit:description>
        <spirit:addressOffset>0x518</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>GPU_USER_OUT_6</spirit:name>
          <spirit:displayName>GPU_USER_OUT_6</spirit:displayName>
          <spirit:description>GPU_USER_OUT_6</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> User output N*32 +  n should be set to 0.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> User output N*32 +  n should be set to 1.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>GPU_USER_OUT_7</spirit:name>
        <spirit:displayName>GPU_USER_OUT_7</spirit:displayName>
        <spirit:description>   The Bifrost GPUs all allow vendors to specify up to 1024 user output signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_OUT signals are connected to the GPU_USER_OUT  n registers. The signals and registers are numbered consecutively from zero, and signal USER_OUT[i] will appear at bit position [i % 32] in register GPU_USER_OUT[i/32].</spirit:description>
        <spirit:addressOffset>0x51c</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>GPU_USER_OUT_7</spirit:name>
          <spirit:displayName>GPU_USER_OUT_7</spirit:displayName>
          <spirit:description>GPU_USER_OUT_7</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> User output N*32 +  n should be set to 0.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> User output N*32 +  n should be set to 1.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>GPU_USER_OUT_8</spirit:name>
        <spirit:displayName>GPU_USER_OUT_8</spirit:displayName>
        <spirit:description>   The Bifrost GPUs all allow vendors to specify up to 1024 user output signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_OUT signals are connected to the GPU_USER_OUT  n registers. The signals and registers are numbered consecutively from zero, and signal USER_OUT[i] will appear at bit position [i % 32] in register GPU_USER_OUT[i/32].</spirit:description>
        <spirit:addressOffset>0x520</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>GPU_USER_OUT_8</spirit:name>
          <spirit:displayName>GPU_USER_OUT_8</spirit:displayName>
          <spirit:description>GPU_USER_OUT_8</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> User output N*32 +  n should be set to 0.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> User output N*32 +  n should be set to 1.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>GPU_USER_OUT_9</spirit:name>
        <spirit:displayName>GPU_USER_OUT_9</spirit:displayName>
        <spirit:description>   The Bifrost GPUs all allow vendors to specify up to 1024 user output signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_OUT signals are connected to the GPU_USER_OUT  n registers. The signals and registers are numbered consecutively from zero, and signal USER_OUT[i] will appear at bit position [i % 32] in register GPU_USER_OUT[i/32].</spirit:description>
        <spirit:addressOffset>0x524</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>GPU_USER_OUT_9</spirit:name>
          <spirit:displayName>GPU_USER_OUT_9</spirit:displayName>
          <spirit:description>GPU_USER_OUT_9</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> User output N*32 +  n should be set to 0.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> User output N*32 +  n should be set to 1.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>GPU_USER_OUT_10</spirit:name>
        <spirit:displayName>GPU_USER_OUT_10</spirit:displayName>
        <spirit:description>   The Bifrost GPUs all allow vendors to specify up to 1024 user output signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_OUT signals are connected to the GPU_USER_OUT  n registers. The signals and registers are numbered consecutively from zero, and signal USER_OUT[i] will appear at bit position [i % 32] in register GPU_USER_OUT[i/32].</spirit:description>
        <spirit:addressOffset>0x528</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>GPU_USER_OUT_10</spirit:name>
          <spirit:displayName>GPU_USER_OUT_10</spirit:displayName>
          <spirit:description>GPU_USER_OUT_10</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> User output N*32 +  n should be set to 0.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> User output N*32 +  n should be set to 1.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>GPU_USER_OUT_11</spirit:name>
        <spirit:displayName>GPU_USER_OUT_11</spirit:displayName>
        <spirit:description>   The Bifrost GPUs all allow vendors to specify up to 1024 user output signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_OUT signals are connected to the GPU_USER_OUT  n registers. The signals and registers are numbered consecutively from zero, and signal USER_OUT[i] will appear at bit position [i % 32] in register GPU_USER_OUT[i/32].</spirit:description>
        <spirit:addressOffset>0x52c</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>GPU_USER_OUT_11</spirit:name>
          <spirit:displayName>GPU_USER_OUT_11</spirit:displayName>
          <spirit:description>GPU_USER_OUT_11</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> User output N*32 +  n should be set to 0.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> User output N*32 +  n should be set to 1.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>GPU_USER_OUT_12</spirit:name>
        <spirit:displayName>GPU_USER_OUT_12</spirit:displayName>
        <spirit:description>   The Bifrost GPUs all allow vendors to specify up to 1024 user output signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_OUT signals are connected to the GPU_USER_OUT  n registers. The signals and registers are numbered consecutively from zero, and signal USER_OUT[i] will appear at bit position [i % 32] in register GPU_USER_OUT[i/32].</spirit:description>
        <spirit:addressOffset>0x530</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>GPU_USER_OUT_12</spirit:name>
          <spirit:displayName>GPU_USER_OUT_12</spirit:displayName>
          <spirit:description>GPU_USER_OUT_12</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> User output N*32 +  n should be set to 0.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> User output N*32 +  n should be set to 1.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>GPU_USER_OUT_13</spirit:name>
        <spirit:displayName>GPU_USER_OUT_13</spirit:displayName>
        <spirit:description>   The Bifrost GPUs all allow vendors to specify up to 1024 user output signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_OUT signals are connected to the GPU_USER_OUT  n registers. The signals and registers are numbered consecutively from zero, and signal USER_OUT[i] will appear at bit position [i % 32] in register GPU_USER_OUT[i/32].</spirit:description>
        <spirit:addressOffset>0x534</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>GPU_USER_OUT_13</spirit:name>
          <spirit:displayName>GPU_USER_OUT_13</spirit:displayName>
          <spirit:description>GPU_USER_OUT_13</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> User output N*32 +  n should be set to 0.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> User output N*32 +  n should be set to 1.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>GPU_USER_OUT_14</spirit:name>
        <spirit:displayName>GPU_USER_OUT_14</spirit:displayName>
        <spirit:description>   The Bifrost GPUs all allow vendors to specify up to 1024 user output signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_OUT signals are connected to the GPU_USER_OUT  n registers. The signals and registers are numbered consecutively from zero, and signal USER_OUT[i] will appear at bit position [i % 32] in register GPU_USER_OUT[i/32].</spirit:description>
        <spirit:addressOffset>0x538</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>GPU_USER_OUT_14</spirit:name>
          <spirit:displayName>GPU_USER_OUT_14</spirit:displayName>
          <spirit:description>GPU_USER_OUT_14</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> User output N*32 +  n should be set to 0.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> User output N*32 +  n should be set to 1.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>GPU_USER_OUT_15</spirit:name>
        <spirit:displayName>GPU_USER_OUT_15</spirit:displayName>
        <spirit:description>   The Bifrost GPUs all allow vendors to specify up to 1024 user output signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_OUT signals are connected to the GPU_USER_OUT  n registers. The signals and registers are numbered consecutively from zero, and signal USER_OUT[i] will appear at bit position [i % 32] in register GPU_USER_OUT[i/32].</spirit:description>
        <spirit:addressOffset>0x53c</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>GPU_USER_OUT_15</spirit:name>
          <spirit:displayName>GPU_USER_OUT_15</spirit:displayName>
          <spirit:description>GPU_USER_OUT_15</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> User output N*32 +  n should be set to 0.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> User output N*32 +  n should be set to 1.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>GPU_USER_OUT_16</spirit:name>
        <spirit:displayName>GPU_USER_OUT_16</spirit:displayName>
        <spirit:description>   The Bifrost GPUs all allow vendors to specify up to 1024 user output signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_OUT signals are connected to the GPU_USER_OUT  n registers. The signals and registers are numbered consecutively from zero, and signal USER_OUT[i] will appear at bit position [i % 32] in register GPU_USER_OUT[i/32].</spirit:description>
        <spirit:addressOffset>0x540</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>GPU_USER_OUT_16</spirit:name>
          <spirit:displayName>GPU_USER_OUT_16</spirit:displayName>
          <spirit:description>GPU_USER_OUT_16</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> User output N*32 +  n should be set to 0.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> User output N*32 +  n should be set to 1.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>GPU_USER_OUT_17</spirit:name>
        <spirit:displayName>GPU_USER_OUT_17</spirit:displayName>
        <spirit:description>   The Bifrost GPUs all allow vendors to specify up to 1024 user output signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_OUT signals are connected to the GPU_USER_OUT  n registers. The signals and registers are numbered consecutively from zero, and signal USER_OUT[i] will appear at bit position [i % 32] in register GPU_USER_OUT[i/32].</spirit:description>
        <spirit:addressOffset>0x544</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>GPU_USER_OUT_17</spirit:name>
          <spirit:displayName>GPU_USER_OUT_17</spirit:displayName>
          <spirit:description>GPU_USER_OUT_17</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> User output N*32 +  n should be set to 0.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> User output N*32 +  n should be set to 1.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>GPU_USER_OUT_18</spirit:name>
        <spirit:displayName>GPU_USER_OUT_18</spirit:displayName>
        <spirit:description>   The Bifrost GPUs all allow vendors to specify up to 1024 user output signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_OUT signals are connected to the GPU_USER_OUT  n registers. The signals and registers are numbered consecutively from zero, and signal USER_OUT[i] will appear at bit position [i % 32] in register GPU_USER_OUT[i/32].</spirit:description>
        <spirit:addressOffset>0x548</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>GPU_USER_OUT_18</spirit:name>
          <spirit:displayName>GPU_USER_OUT_18</spirit:displayName>
          <spirit:description>GPU_USER_OUT_18</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> User output N*32 +  n should be set to 0.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> User output N*32 +  n should be set to 1.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>GPU_USER_OUT_19</spirit:name>
        <spirit:displayName>GPU_USER_OUT_19</spirit:displayName>
        <spirit:description>   The Bifrost GPUs all allow vendors to specify up to 1024 user output signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_OUT signals are connected to the GPU_USER_OUT  n registers. The signals and registers are numbered consecutively from zero, and signal USER_OUT[i] will appear at bit position [i % 32] in register GPU_USER_OUT[i/32].</spirit:description>
        <spirit:addressOffset>0x54c</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>GPU_USER_OUT_19</spirit:name>
          <spirit:displayName>GPU_USER_OUT_19</spirit:displayName>
          <spirit:description>GPU_USER_OUT_19</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> User output N*32 +  n should be set to 0.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> User output N*32 +  n should be set to 1.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>GPU_USER_OUT_20</spirit:name>
        <spirit:displayName>GPU_USER_OUT_20</spirit:displayName>
        <spirit:description>   The Bifrost GPUs all allow vendors to specify up to 1024 user output signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_OUT signals are connected to the GPU_USER_OUT  n registers. The signals and registers are numbered consecutively from zero, and signal USER_OUT[i] will appear at bit position [i % 32] in register GPU_USER_OUT[i/32].</spirit:description>
        <spirit:addressOffset>0x550</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>GPU_USER_OUT_20</spirit:name>
          <spirit:displayName>GPU_USER_OUT_20</spirit:displayName>
          <spirit:description>GPU_USER_OUT_20</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> User output N*32 +  n should be set to 0.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> User output N*32 +  n should be set to 1.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>GPU_USER_OUT_21</spirit:name>
        <spirit:displayName>GPU_USER_OUT_21</spirit:displayName>
        <spirit:description>   The Bifrost GPUs all allow vendors to specify up to 1024 user output signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_OUT signals are connected to the GPU_USER_OUT  n registers. The signals and registers are numbered consecutively from zero, and signal USER_OUT[i] will appear at bit position [i % 32] in register GPU_USER_OUT[i/32].</spirit:description>
        <spirit:addressOffset>0x554</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>GPU_USER_OUT_21</spirit:name>
          <spirit:displayName>GPU_USER_OUT_21</spirit:displayName>
          <spirit:description>GPU_USER_OUT_21</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> User output N*32 +  n should be set to 0.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> User output N*32 +  n should be set to 1.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>GPU_USER_OUT_22</spirit:name>
        <spirit:displayName>GPU_USER_OUT_22</spirit:displayName>
        <spirit:description>   The Bifrost GPUs all allow vendors to specify up to 1024 user output signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_OUT signals are connected to the GPU_USER_OUT  n registers. The signals and registers are numbered consecutively from zero, and signal USER_OUT[i] will appear at bit position [i % 32] in register GPU_USER_OUT[i/32].</spirit:description>
        <spirit:addressOffset>0x558</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>GPU_USER_OUT_22</spirit:name>
          <spirit:displayName>GPU_USER_OUT_22</spirit:displayName>
          <spirit:description>GPU_USER_OUT_22</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> User output N*32 +  n should be set to 0.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> User output N*32 +  n should be set to 1.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>GPU_USER_OUT_23</spirit:name>
        <spirit:displayName>GPU_USER_OUT_23</spirit:displayName>
        <spirit:description>   The Bifrost GPUs all allow vendors to specify up to 1024 user output signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_OUT signals are connected to the GPU_USER_OUT  n registers. The signals and registers are numbered consecutively from zero, and signal USER_OUT[i] will appear at bit position [i % 32] in register GPU_USER_OUT[i/32].</spirit:description>
        <spirit:addressOffset>0x55c</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>GPU_USER_OUT_23</spirit:name>
          <spirit:displayName>GPU_USER_OUT_23</spirit:displayName>
          <spirit:description>GPU_USER_OUT_23</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> User output N*32 +  n should be set to 0.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> User output N*32 +  n should be set to 1.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>GPU_USER_OUT_24</spirit:name>
        <spirit:displayName>GPU_USER_OUT_24</spirit:displayName>
        <spirit:description>   The Bifrost GPUs all allow vendors to specify up to 1024 user output signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_OUT signals are connected to the GPU_USER_OUT  n registers. The signals and registers are numbered consecutively from zero, and signal USER_OUT[i] will appear at bit position [i % 32] in register GPU_USER_OUT[i/32].</spirit:description>
        <spirit:addressOffset>0x560</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>GPU_USER_OUT_24</spirit:name>
          <spirit:displayName>GPU_USER_OUT_24</spirit:displayName>
          <spirit:description>GPU_USER_OUT_24</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> User output N*32 +  n should be set to 0.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> User output N*32 +  n should be set to 1.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>GPU_USER_OUT_25</spirit:name>
        <spirit:displayName>GPU_USER_OUT_25</spirit:displayName>
        <spirit:description>   The Bifrost GPUs all allow vendors to specify up to 1024 user output signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_OUT signals are connected to the GPU_USER_OUT  n registers. The signals and registers are numbered consecutively from zero, and signal USER_OUT[i] will appear at bit position [i % 32] in register GPU_USER_OUT[i/32].</spirit:description>
        <spirit:addressOffset>0x564</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>GPU_USER_OUT_25</spirit:name>
          <spirit:displayName>GPU_USER_OUT_25</spirit:displayName>
          <spirit:description>GPU_USER_OUT_25</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> User output N*32 +  n should be set to 0.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> User output N*32 +  n should be set to 1.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>GPU_USER_OUT_26</spirit:name>
        <spirit:displayName>GPU_USER_OUT_26</spirit:displayName>
        <spirit:description>   The Bifrost GPUs all allow vendors to specify up to 1024 user output signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_OUT signals are connected to the GPU_USER_OUT  n registers. The signals and registers are numbered consecutively from zero, and signal USER_OUT[i] will appear at bit position [i % 32] in register GPU_USER_OUT[i/32].</spirit:description>
        <spirit:addressOffset>0x568</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>GPU_USER_OUT_26</spirit:name>
          <spirit:displayName>GPU_USER_OUT_26</spirit:displayName>
          <spirit:description>GPU_USER_OUT_26</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> User output N*32 +  n should be set to 0.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> User output N*32 +  n should be set to 1.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>GPU_USER_OUT_27</spirit:name>
        <spirit:displayName>GPU_USER_OUT_27</spirit:displayName>
        <spirit:description>   The Bifrost GPUs all allow vendors to specify up to 1024 user output signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_OUT signals are connected to the GPU_USER_OUT  n registers. The signals and registers are numbered consecutively from zero, and signal USER_OUT[i] will appear at bit position [i % 32] in register GPU_USER_OUT[i/32].</spirit:description>
        <spirit:addressOffset>0x56c</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>GPU_USER_OUT_27</spirit:name>
          <spirit:displayName>GPU_USER_OUT_27</spirit:displayName>
          <spirit:description>GPU_USER_OUT_27</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> User output N*32 +  n should be set to 0.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> User output N*32 +  n should be set to 1.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>GPU_USER_OUT_28</spirit:name>
        <spirit:displayName>GPU_USER_OUT_28</spirit:displayName>
        <spirit:description>   The Bifrost GPUs all allow vendors to specify up to 1024 user output signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_OUT signals are connected to the GPU_USER_OUT  n registers. The signals and registers are numbered consecutively from zero, and signal USER_OUT[i] will appear at bit position [i % 32] in register GPU_USER_OUT[i/32].</spirit:description>
        <spirit:addressOffset>0x570</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>GPU_USER_OUT_28</spirit:name>
          <spirit:displayName>GPU_USER_OUT_28</spirit:displayName>
          <spirit:description>GPU_USER_OUT_28</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> User output N*32 +  n should be set to 0.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> User output N*32 +  n should be set to 1.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>GPU_USER_OUT_29</spirit:name>
        <spirit:displayName>GPU_USER_OUT_29</spirit:displayName>
        <spirit:description>   The Bifrost GPUs all allow vendors to specify up to 1024 user output signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_OUT signals are connected to the GPU_USER_OUT  n registers. The signals and registers are numbered consecutively from zero, and signal USER_OUT[i] will appear at bit position [i % 32] in register GPU_USER_OUT[i/32].</spirit:description>
        <spirit:addressOffset>0x574</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>GPU_USER_OUT_29</spirit:name>
          <spirit:displayName>GPU_USER_OUT_29</spirit:displayName>
          <spirit:description>GPU_USER_OUT_29</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> User output N*32 +  n should be set to 0.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> User output N*32 +  n should be set to 1.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>GPU_USER_OUT_30</spirit:name>
        <spirit:displayName>GPU_USER_OUT_30</spirit:displayName>
        <spirit:description>   The Bifrost GPUs all allow vendors to specify up to 1024 user output signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_OUT signals are connected to the GPU_USER_OUT  n registers. The signals and registers are numbered consecutively from zero, and signal USER_OUT[i] will appear at bit position [i % 32] in register GPU_USER_OUT[i/32].</spirit:description>
        <spirit:addressOffset>0x578</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>GPU_USER_OUT_30</spirit:name>
          <spirit:displayName>GPU_USER_OUT_30</spirit:displayName>
          <spirit:description>GPU_USER_OUT_30</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> User output N*32 +  n should be set to 0.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> User output N*32 +  n should be set to 1.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>GPU_USER_OUT_31</spirit:name>
        <spirit:displayName>GPU_USER_OUT_31</spirit:displayName>
        <spirit:description>   The Bifrost GPUs all allow vendors to specify up to 1024 user output signals. The meaning of these signals is not architecturally defined, and is entirely down to the vendor. Typical uses include sending additional information to power controllers or display controllers.  These USER_OUT signals are connected to the GPU_USER_OUT  n registers. The signals and registers are numbered consecutively from zero, and signal USER_OUT[i] will appear at bit position [i % 32] in register GPU_USER_OUT[i/32].</spirit:description>
        <spirit:addressOffset>0x57c</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>GPU_USER_OUT_31</spirit:name>
          <spirit:displayName>GPU_USER_OUT_31</spirit:displayName>
          <spirit:description>GPU_USER_OUT_31</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> User output N*32 +  n should be set to 0.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> User output N*32 +  n should be set to 1.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
    </spirit:addressBlock>
    <spirit:addressBlock>
      <spirit:name>jm_job_control_regs</spirit:name>
      <spirit:baseAddress>4096</spirit:baseAddress>
      <spirit:range>48</spirit:range>
      <spirit:width>32</spirit:width>
      <spirit:usage>register</spirit:usage>
      <spirit:register>
        <spirit:name>JOB_IRQ_RAWSTAT</spirit:name>
        <spirit:displayName>JOB_IRQ_RAWSTAT</spirit:displayName>
        <spirit:description>   This register contains the raw unmasked interrupt status for job management.  Writing a 1 to a bit in this register will force that bit on. Writing a zero to a bit will have no effect. Use the JOB_IRQ_CLEAR register to clear interrupts. Changes to bits corresponding to job slots which are not physically present may be ignored.  See  ExceptionStatus for information on exception types and locations of additional data. JOB_DONE interrupts are generated for any job chain that completes with an exception type that indicates no fault. JOB_FAIL interrupts are generated for all other exception types, including SUSPEND.</spirit:description>
        <spirit:addressOffset>0x0</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>JOB_DONE</spirit:name>
          <spirit:displayName>JOB_DONE</spirit:displayName>
          <spirit:description>JOB_DONE</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>16</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> No interrupt from job slot  n .</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Job slot  n has completed successfully.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>JOB_FAIL</spirit:name>
          <spirit:displayName>JOB_FAIL</spirit:displayName>
          <spirit:description>JOB_FAIL</spirit:description>
          <spirit:bitOffset>16</spirit:bitOffset>
          <spirit:bitWidth>16</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> No interrupt from job slot  n .</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Job slot  n has completed with an error.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>JOB_IRQ_CLEAR</spirit:name>
        <spirit:displayName>JOB_IRQ_CLEAR</spirit:displayName>
        <spirit:description>   This register has the same layout as JOB_IRQ_RAWSTAT. Write a one to a bit in this register to clear the corresponding bit in JOB_IRQ_RAWSTAT. This also atomically takes a snapshot of the corresponding job slots state in the corresponding bits of JOB_IRQ_JS_STATE. </spirit:description>
        <spirit:addressOffset>0x4</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>JOB_DONE</spirit:name>
          <spirit:displayName>JOB_DONE</spirit:displayName>
          <spirit:description>JOB_DONE</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>16</spirit:bitWidth>
          <spirit:access>write-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> No interrupt from job slot  n .</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Job slot  n has completed successfully.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>JOB_FAIL</spirit:name>
          <spirit:displayName>JOB_FAIL</spirit:displayName>
          <spirit:description>JOB_FAIL</spirit:description>
          <spirit:bitOffset>16</spirit:bitOffset>
          <spirit:bitWidth>16</spirit:bitWidth>
          <spirit:access>write-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> No interrupt from job slot  n .</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Job slot  n has completed with an error.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>JOB_IRQ_MASK</spirit:name>
        <spirit:displayName>JOB_IRQ_MASK</spirit:displayName>
        <spirit:description>   This register has the same layout as JOB_IRQ_RAWSTAT. Set each bit in this to one to enable the corresponding interrupt source, and to zero to disable it. </spirit:description>
        <spirit:addressOffset>0x8</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>JOB_DONE</spirit:name>
          <spirit:displayName>JOB_DONE</spirit:displayName>
          <spirit:description>JOB_DONE</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>16</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> No interrupt from job slot  n .</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Job slot  n has completed successfully.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>JOB_FAIL</spirit:name>
          <spirit:displayName>JOB_FAIL</spirit:displayName>
          <spirit:description>JOB_FAIL</spirit:description>
          <spirit:bitOffset>16</spirit:bitOffset>
          <spirit:bitWidth>16</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> No interrupt from job slot  n .</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Job slot  n has completed with an error.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>JOB_IRQ_STATUS</spirit:name>
        <spirit:displayName>JOB_IRQ_STATUS</spirit:displayName>
        <spirit:description>   This register has the same layout as JOB_IRQ_RAWSTAT. This register contains the result of anding together JOB_IRQ_RAWSTAT and JOB_IRQ_MASK. If any bits in this register are set, and the JOB_IRQ_THROTTLE counter is zero, then the external job control interrupt line is asserted, signaling an interrupt request to the CPU. </spirit:description>
        <spirit:addressOffset>0xc</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>JOB_DONE</spirit:name>
          <spirit:displayName>JOB_DONE</spirit:displayName>
          <spirit:description>JOB_DONE</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>16</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> No interrupt from job slot  n .</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Job slot  n has completed successfully.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>JOB_FAIL</spirit:name>
          <spirit:displayName>JOB_FAIL</spirit:displayName>
          <spirit:description>JOB_FAIL</spirit:description>
          <spirit:bitOffset>16</spirit:bitOffset>
          <spirit:bitWidth>16</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> No interrupt from job slot  n .</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Job slot  n has completed with an error.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>JOB_IRQ_JS_STATE</spirit:name>
        <spirit:displayName>JOB_IRQ_JS_STATE</spirit:displayName>
        <spirit:description>   This register contains an instantaneous snapshot of the state of the job chains, and is updated atomically in the same clock cycle as the interrupt flags are cleared (using JOB_IRQ_CLEAR).  If either bit JOB_ACTIVE[n] or JOB_NEXT_ACTIVE[n] is set in the value written to JOB_IRQ_CLEAR, then job slot  n is sampled on the same clock cycle, and both bits JOB_ACTIVE[n] and JOB_NEXT_ACTIVE[n] are updated in this register.</spirit:description>
        <spirit:addressOffset>0x10</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>JOB_ACTIVE</spirit:name>
          <spirit:displayName>JOB_ACTIVE</spirit:displayName>
          <spirit:description>JOB_ACTIVE</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>16</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> Job slot  n is idle.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Job slot  n is currently active.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>JOB_NEXT_ACTIVE</spirit:name>
          <spirit:displayName>JOB_NEXT_ACTIVE</spirit:displayName>
          <spirit:description>JOB_NEXT_ACTIVE</spirit:description>
          <spirit:bitOffset>16</spirit:bitOffset>
          <spirit:bitWidth>16</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> Job slot  n has no next job chain queued (JS n _COMMAND_NEXT is NOP).</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Job slot  n has a next job chain queued  (JS n _COMMAND_NEXT is not NOP).</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>JOB_IRQ_THROTTLE</spirit:name>
        <spirit:displayName>JOB_IRQ_THROTTLE</spirit:displayName>
        <spirit:description>   This register is used to suppress Job Done interrupts for a set amount of time. This allows software to throttle the interrupt load that the rest of the system is exposed to. </spirit:description>
        <spirit:addressOffset>0x14</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>JOB_IRQ_THROTTLE</spirit:name>
          <spirit:displayName>JOB_IRQ_THROTTLE</spirit:displayName>
          <spirit:description>   Writing a value to the register sets the value of a counter, which continuously counts down at the GPU clock frequency. Reading this register will return the current value of the counter.  While the counter is non-zero, no Job Done interrupts are generated. In this state, the GPU is considered to be active for power management purposes, so that the final interrupt will always be generated correctly, even if the core is being powered down.  The counter stops once it has counted down to zero, and must be reset by the driver. This is commonly done as part of the interrupt service routine. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>EVENT_IRQ_RAWSTAT</spirit:name>
        <spirit:displayName>EVENT_IRQ_RAWSTAT</spirit:displayName>
        <spirit:description>   This register contains the raw unmasked interrupt status for job event management.  Writing a 1 to a bit in this register will force that bit on. Writing a zero to a bit will have no effect. Use the EVENT_IRQ_CLEAR register to clear interrupts. Changes to bits corresponding to job slots which are not physically present may be ignored.  This is a separate interrupt from job status interrupts, and is triggered by use of  DOORBELL event-generating instructions in the shaders. Added registers for handling job events and their corresponding interrupts. </spirit:description>
        <spirit:addressOffset>0x20</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>Res73</spirit:name>
          <spirit:displayName>Res73</spirit:displayName>
          <spirit:description>Res73</spirit:description>
          <spirit:bitOffset>16</spirit:bitOffset>
          <spirit:bitWidth>16</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>EVENT_DONE</spirit:name>
          <spirit:displayName>EVENT_DONE</spirit:displayName>
          <spirit:description>EVENT_DONE</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>16</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> No interrupt from job slot  n .</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Job slot  n has posted a non-fault event (e.g. DOORBELL).</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>EVENT_IRQ_CLEAR</spirit:name>
        <spirit:displayName>EVENT_IRQ_CLEAR</spirit:displayName>
        <spirit:description>   This register has the same layout as EVENT_IRQ_RAWSTAT. Write a one to a bit in this register to clear the corresponding bit in EVENT_IRQ_RAWSTAT. </spirit:description>
        <spirit:addressOffset>0x24</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>Res74</spirit:name>
          <spirit:displayName>Res74</spirit:displayName>
          <spirit:description>Res74</spirit:description>
          <spirit:bitOffset>16</spirit:bitOffset>
          <spirit:bitWidth>16</spirit:bitWidth>
          <spirit:access>write-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>EVENT_DONE</spirit:name>
          <spirit:displayName>EVENT_DONE</spirit:displayName>
          <spirit:description>EVENT_DONE</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>16</spirit:bitWidth>
          <spirit:access>write-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> No interrupt from job slot  n .</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Job slot  n has posted a non-fault event (e.g. DOORBELL).</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>EVENT_IRQ_MASK</spirit:name>
        <spirit:displayName>EVENT_IRQ_MASK</spirit:displayName>
        <spirit:description>   This register has the same layout as EVENT_IRQ_RAWSTAT. Set each bit in this to one to enable the corresponding interrupt source, and to zero to disable it. </spirit:description>
        <spirit:addressOffset>0x28</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>Res75</spirit:name>
          <spirit:displayName>Res75</spirit:displayName>
          <spirit:description>Res75</spirit:description>
          <spirit:bitOffset>16</spirit:bitOffset>
          <spirit:bitWidth>16</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>EVENT_DONE</spirit:name>
          <spirit:displayName>EVENT_DONE</spirit:displayName>
          <spirit:description>EVENT_DONE</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>16</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> No interrupt from job slot  n .</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Job slot  n has posted a non-fault event (e.g. DOORBELL).</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>EVENT_IRQ_STATUS</spirit:name>
        <spirit:displayName>EVENT_IRQ_STATUS</spirit:displayName>
        <spirit:description>   This register has the same layout as EVENT_IRQ_RAWSTAT. This register contains the result of anding together EVENT_IRQ_RAWSTAT and EVENT_IRQ_MASK. If any bits in this register are set, and the JOB_IRQ_THROTTLE counter is zero, then the external job control interrupt line is asserted, signaling an interrupt request to the CPU. </spirit:description>
        <spirit:addressOffset>0x2c</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>Res76</spirit:name>
          <spirit:displayName>Res76</spirit:displayName>
          <spirit:description>Res76</spirit:description>
          <spirit:bitOffset>16</spirit:bitOffset>
          <spirit:bitWidth>16</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>EVENT_DONE</spirit:name>
          <spirit:displayName>EVENT_DONE</spirit:displayName>
          <spirit:description>EVENT_DONE</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>16</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> No interrupt from job slot  n .</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Job slot  n has posted a non-fault event (e.g. DOORBELL).</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
    </spirit:addressBlock>
    <spirit:addressBlock>
      <spirit:name>jm_job_slot0_regs</spirit:name>
      <spirit:baseAddress>6144</spirit:baseAddress>
      <spirit:range>128</spirit:range>
      <spirit:width>32</spirit:width>
      <spirit:usage>register</spirit:usage>
      <spirit:register>
        <spirit:name>JS0_HEAD_LO</spirit:name>
        <spirit:displayName>JS0_HEAD_LO</spirit:displayName>
        <spirit:description>   These registers exist for each supported job slot, with the prefix JS  n . To start a job chain, write the address to the first job descriptor into the JS  n _HEAD_NEXT register and write a START command to the JS n _COMMAND_NEXT register. When read, this register reflects the current position in the job chain. When the Job Manager has finished issuing tasks for a job, it will go on to the next job in the job chain, and update JS  n _HEAD. A job will disappear from JS  n _HEAD before it has finished processing all its tasks. See JS n _TAIL for how to discover this. Jobs newer than JS  n _HEAD may have been prefetched from memory, but will not yet have started processing. After an error, JS  n _HEAD contains the address of the first job (chronologically) that failed. The status registers contain the state of this job. If the GPU is in protected mode, this register will read as zero. </spirit:description>
        <spirit:addressOffset>0x0</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>JS0HEAD_LO</spirit:name>
          <spirit:displayName>JS0HEAD_LO</spirit:displayName>
          <spirit:description>   This register contains the address of the current job descriptor. The address is a virtual address in the address space specified by the ADDRESS_SPACE field in the JS  n _CONFIG register.</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>JS0_HEAD_HI</spirit:name>
        <spirit:displayName>JS0_HEAD_HI</spirit:displayName>
        <spirit:description>   These registers exist for each supported job slot, with the prefix JS  n . To start a job chain, write the address to the first job descriptor into the JS  n _HEAD_NEXT register and write a START command to the JS n _COMMAND_NEXT register. When read, this register reflects the current position in the job chain. When the Job Manager has finished issuing tasks for a job, it will go on to the next job in the job chain, and update JS  n _HEAD. A job will disappear from JS  n _HEAD before it has finished processing all its tasks. See JS n _TAIL for how to discover this. Jobs newer than JS  n _HEAD may have been prefetched from memory, but will not yet have started processing. After an error, JS  n _HEAD contains the address of the first job (chronologically) that failed. The status registers contain the state of this job. If the GPU is in protected mode, this register will read as zero. </spirit:description>
        <spirit:addressOffset>0x4</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>JS0HEAD_HI</spirit:name>
          <spirit:displayName>JS0HEAD_HI</spirit:displayName>
          <spirit:description>   This register contains the address of the current job descriptor. The address is a virtual address in the address space specified by the ADDRESS_SPACE field in the JS  n _CONFIG register.</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>JS0_TAIL_LO</spirit:name>
        <spirit:displayName>JS0_TAIL_LO</spirit:displayName>
        <spirit:description>   If the GPU is in protected mode, this register will read as zero. </spirit:description>
        <spirit:addressOffset>0x8</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>JS0TAIL_LO</spirit:name>
          <spirit:displayName>JS0TAIL_LO</spirit:displayName>
          <spirit:description>   This register contains the address of the oldest job that has finished issuing tasks, but is still running. The address is a virtual address in the address space specified by the ADDRESS_SPACE field in the JS  n _CONFIG register. All the jobs in a job chain from JS  n _TAIL to JS n _HEAD are in some way active in the GPU. Jobs older than JS n _TAIL are fully completed. Note that the value in the JS  n _TAIL register is updated when a new job starts. Therefore, this value is only valid while the JS n _STATUS register has the value ACTIVE. After an error, JS  n _TAIL contains the address of the first job in the chain that is not known to be successfully complete. Other jobs after this point may have completed successfully, but all jobs prior to this point are guaranteed have completed.
						In order to simplfy implementation of this feature, the position reported in JS n _TAIL is allowed to be conservative. However, scanning from this point forward in the chain will always be sufficient to identify all failing jobs.</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>JS0_TAIL_HI</spirit:name>
        <spirit:displayName>JS0_TAIL_HI</spirit:displayName>
        <spirit:description>   If the GPU is in protected mode, this register will read as zero. </spirit:description>
        <spirit:addressOffset>0xc</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>JS0TAIL_HI</spirit:name>
          <spirit:displayName>JS0TAIL_HI</spirit:displayName>
          <spirit:description>   This register contains the address of the oldest job that has finished issuing tasks, but is still running. The address is a virtual address in the address space specified by the ADDRESS_SPACE field in the JS  n _CONFIG register. All the jobs in a job chain from JS  n _TAIL to JS n _HEAD are in some way active in the GPU. Jobs older than JS n _TAIL are fully completed. Note that the value in the JS  n _TAIL register is updated when a new job starts. Therefore, this value is only valid while the JS n _STATUS register has the value ACTIVE. After an error, JS  n _TAIL contains the address of the first job in the chain that is not known to be successfully complete. Other jobs after this point may have completed successfully, but all jobs prior to this point are guaranteed have completed.
						In order to simplfy implementation of this feature, the position reported in JS n _TAIL is allowed to be conservative. However, scanning from this point forward in the chain will always be sufficient to identify all failing jobs.</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>JS0_AFFINITY_LO</spirit:name>
        <spirit:displayName>JS0_AFFINITY_LO</spirit:displayName>
        <spirit:description>   This register contains the current core affinity mask for this job slot. Only cores covered by the affinity mask are eligible for running tasks on. The mask is anded with the *_READY masks, and the resulting ones are the cores that can be used.  The affinity value is constant over a job chain. If you need to change affinity between jobs, then they must be split into separate job chains.See also JS  n _XAFFINITY</spirit:description>
        <spirit:addressOffset>0x10</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>JS0AFFINITY_LO</spirit:name>
          <spirit:displayName>JS0AFFINITY_LO</spirit:displayName>
          <spirit:description>JS0AFFINITY_LO</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> This job slot is not allowed to dispatch tasks to shader core  n .</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> This job slot is allowed to dispatch tasks to shader core  n .</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>JS0_AFFINITY_HI</spirit:name>
        <spirit:displayName>JS0_AFFINITY_HI</spirit:displayName>
        <spirit:description>   This register contains the current core affinity mask for this job slot. Only cores covered by the affinity mask are eligible for running tasks on. The mask is anded with the *_READY masks, and the resulting ones are the cores that can be used.  The affinity value is constant over a job chain. If you need to change affinity between jobs, then they must be split into separate job chains.See also JS  n _XAFFINITY</spirit:description>
        <spirit:addressOffset>0x14</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>JS0AFFINITY_HI</spirit:name>
          <spirit:displayName>JS0AFFINITY_HI</spirit:displayName>
          <spirit:description>JS0AFFINITY_HI</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> This job slot is not allowed to dispatch tasks to shader core  n .</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> This job slot is allowed to dispatch tasks to shader core  n .</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>JS0_CONFIG</spirit:name>
        <spirit:displayName>JS0_CONFIG</spirit:displayName>
        <spirit:description>   The job slot configuration register contains various configuration options for the jobs running in this job slot. </spirit:description>
        <spirit:addressOffset>0x18</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>Res77</spirit:name>
          <spirit:displayName>Res77</spirit:displayName>
          <spirit:description>Res77</spirit:description>
          <spirit:bitOffset>4</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>Res78</spirit:name>
          <spirit:displayName>Res78</spirit:displayName>
          <spirit:description>Res78</spirit:description>
          <spirit:bitOffset>20</spirit:bitOffset>
          <spirit:bitWidth>12</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>ADDRESS_SPACE</spirit:name>
          <spirit:displayName>ADDRESS_SPACE</spirit:displayName>
          <spirit:description>   This is the ID of the address space to use for execution of all the jobs in this job chain.
						Address space configuration values are read from the AS  n registers.
						Specifying an address space that is not supported (i.e. the corresponding bit in AS_PRESENT is 0) may result in UNDEFINED behavior.</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>JOB_CHAIN_FLAG</spirit:name>
          <spirit:displayName>JOB_CHAIN_FLAG</spirit:displayName>
          <spirit:description>   The JOB_CHAIN_FLAG is set and read by software, and is used to disambiguate short-running job chains. It has no effect on the execution of a job, but is transferred intact from the JS  n _CONFIG_NEXT register to the JS n _CONFIG register when a job starts.</spirit:description>
          <spirit:bitOffset>11</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>THREAD_PRI</spirit:name>
          <spirit:displayName>THREAD_PRI</spirit:displayName>
          <spirit:description>   The thread priority is ordered so that high values will cause threads to be issued faster. Priority values are relative to the other jobs running  if no other jobs are issuing threads, this job will never be throttled even with low priorities.  How the priority values affect issue rates from different slots is implementation dependent. </spirit:description>
          <spirit:bitOffset>16</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>START_FLUSH</spirit:name>
          <spirit:displayName>START_FLUSH</spirit:displayName>
          <spirit:description>   Before the job chain is started, the selected action is applied to all caches except the tiler cache.  Clarified that cache flush behavior for Mimir deviates from spec.  In this implementation (MIMIR), this behavior is not fully implemented.
								Any non-zero value in this field will cause both a clean  and an invalidate for the read-write caches.
								If the value is 3, then the read-only caches are also invalidated, as specified.
								The flush command goes to all GPU cores enabled in the affinity mask, and the L2 cache.</spirit:description>
          <spirit:bitOffset>8</spirit:bitOffset>
          <spirit:bitWidth>2</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NO_ACTION</spirit:name>
              <spirit:description> No action is performed </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>CLEAN</spirit:name>
              <spirit:description> Cleans the shader core's load/store cache and other read/write L1 caches. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>INVALIDATE</spirit:name>
              <spirit:description> Cleans and invalidates the shader core's load/store cache and other read/write L1 caches, and also invalidates all read-only caches, namely:   All DCDs with a matching JASID. Texture descriptor cache entries matching invalidated DCDs. Sampler descriptor cache entries matching invalidated DCDs. For fragment endpoints only, all vertex loader cache lines with zero reference count.</spirit:description>
              <spirit:value>3</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>END_FLUSH</spirit:name>
          <spirit:displayName>END_FLUSH</spirit:displayName>
          <spirit:description>   After the job chain is finished, the selected action is applied to all caches including the tiler cache. This happens when the job chain ends with a success code, or a fault code other than JOB_CONFIG_FAULT or JOB_POWER_FAULT. In the case of JOB_CONFIG_FAULT and JOB_POWER_FAULT, the job chain could not even start and so no cache flush on end takes place.  Clarified that cache flush behavior for Mimir deviates from spec.  In this implementation (MIMIR), this behavior is not fully implemented.
								The flush command goes only to the L2 cache. The tiler cache is not affected.
								Any non-zero value in this field will cause both a clean  and an invalidate.</spirit:description>
          <spirit:bitOffset>12</spirit:bitOffset>
          <spirit:bitWidth>2</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NO_ACTION</spirit:name>
              <spirit:description> No action is performed </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>CLEAN</spirit:name>
              <spirit:description> Cleans the shader core's load/store cache and other read/write L1 caches. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>INVALIDATE</spirit:name>
              <spirit:description> Cleans and invalidates the shader core's load/store cache and other read/write L1 caches, and also invalidates all read-only caches, namely:   All DCDs with a matching JASID. Texture descriptor cache entries matching invalidated DCDs. Sampler descriptor cache entries matching invalidated DCDs. For fragment endpoints only, all vertex loader cache lines with zero reference count.</spirit:description>
              <spirit:value>3</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>START_MMU</spirit:name>
          <spirit:displayName>START_MMU</spirit:displayName>
          <spirit:description>START_MMU</spirit:description>
          <spirit:bitOffset>10</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> No MMU actions </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Before the job chain is started, the MMU is instructed to update. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ENABLE_FLUSH_REDUCTION</spirit:name>
          <spirit:displayName>ENABLE_FLUSH_REDUCTION</spirit:displayName>
          <spirit:description>   When operating in "cache flush reduction" mode, each job chain has an associated ID which is used to identify cache flushes.  This ID is a sequential 32-bit value. When the job manager is asked to perform a suppressable flush, it compares the job chain flush ID with the latest flush ID. If the job chain ID is greater than the latest flush, then a flush is performed. Otherwise, the flush  may be suppressed. Not all flushes can be suppressed, and not all suppressable flushes may be suppressed in any particular hardware implementation. In particular:    A CLEAN_INVALIDATE operation can replace a CLEAN, but not the other way around.  A CLEAN_INVALIDATE operation can be suppressed at the start of a job chain.  A CLEAN or CLEAN_INVALIDATE operation at the end of a job chain cannot be suppressed in the general case.  If software can guarantee that it will not read the result of a job chain until another job chain has been completed, then this is a case where the CLEAN or CLEAN_INVALIDATE operation at the end of a job chain could be suppressed. It is, however, simpler for software to signal this guarantee by simply not enabling the end-of-chain cache flush at all.  Explicit cache flush jobs are assumed to have been placed into the job chain for a reason, and are therefore not suppressed.  Clarified cache flush reduction  Added cache flush reduction </spirit:description>
          <spirit:bitOffset>14</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> No cache flush reduction is applied. Cache flushes are executed as they are encountered. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Cache flush reduction is enabled. Redundant cache flushes may be eliminated by hardware. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>DISABLE_DESCRIPTOR_WRITEBACK</spirit:name>
          <spirit:displayName>DISABLE_DESCRIPTOR_WRITEBACK</spirit:displayName>
          <spirit:description>   Normally, the status of each job in the job chain is written back as it is completed. This flag allows software to suppress that mechanism in cases where it is not required. Regardless of the setting of this flag, a job slot's  STATUS register is always updated on completion of its job chain. One of the reasons for writing back the status to the job descriptors is to guard against infinite loops in job chains. If this flag is set, then that protection is disabled and additional steps should be taken to detect and mitigate infinite loops.  Added  DISABLE_DESCRIPTOR_WRITEBACK flag to job slot CONFIG register.</spirit:description>
          <spirit:bitOffset>15</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> Status is written to job descriptor upon job completion. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Status is not written to job descriptor upon job completion. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>JS0_XAFFINITY</spirit:name>
        <spirit:displayName>JS0_XAFFINITY</spirit:displayName>
        <spirit:description>   Additional affinity information for job slot  n exists in this register. Only resources covered by the affinity mask are eligible for receiving commands. The mask is anded with the appropriate bits from the TILER_PRESENT and L2_PRESENT masks, and the resulting ones are the resources that can be used.  The affinity value is constant over a job chain. If you need to change affinity between jobs, then they must be split into separate job chains. </spirit:description>
        <spirit:addressOffset>0x1c</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>Res79</spirit:name>
          <spirit:displayName>Res79</spirit:displayName>
          <spirit:description>Res79</spirit:description>
          <spirit:bitOffset>1</spirit:bitOffset>
          <spirit:bitWidth>7</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>XAFFINITY_ENABLE</spirit:name>
          <spirit:displayName>XAFFINITY_ENABLE</spirit:displayName>
          <spirit:description>XAFFINITY_ENABLE</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> This register is disabled.  Other fields in the register are ignored and treated as all-1s, so that all available resources are enabled. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> This register is enabled. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>TILER_ENABLE</spirit:name>
          <spirit:displayName>TILER_ENABLE</spirit:displayName>
          <spirit:description>   This field selects which tilers receive commands such as cache flushes and tiler jobs. </spirit:description>
          <spirit:bitOffset>8</spirit:bitOffset>
          <spirit:bitWidth>8</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> This job slot is not allowed to dispatch tasks to tiler unit  n .</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> This job slot is allowed to dispatch tasks to tiler unit  n .</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>CACHE_ENABLE</spirit:name>
          <spirit:displayName>CACHE_ENABLE</spirit:displayName>
          <spirit:description>   This field selects which level 2 caches receive commands such as cache flushes and tiler jobs. </spirit:description>
          <spirit:bitOffset>16</spirit:bitOffset>
          <spirit:bitWidth>16</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> This job slot is not allowed to dispatch tasks to L2 cache  n .</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> This job slot is allowed to dispatch tasks to L2 cache  n .</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>JS0_COMMAND</spirit:name>
        <spirit:displayName>JS0_COMMAND</spirit:displayName>
        <spirit:description>   Writing values to this register will control the job currently running in job slot  n . When the Job Manager encounters the end of a job chain, an interrupt is generated and (if appropriate) the contents of the next registers are transferred to the current registers, allowing immediate execution of a new job chain.  Jobs can be started only by writing to the JS  n _COMMAND_NEXT register, not this register, as this process depends on reliable transfer of the other values describing the job. A soft stop requests that no more tasks are issued for a job, and once all running tasks are finished, the job state is written to memory and the job suspended. It is possible to recover from this state and continue the job.  A hard stop simply aborts all running tasks for a job. No attempt is made to finish, write partial results, or save state. It will not be possible to resume a job after a hard stop, although it may be possible to restart it from scratch if it does not write to its own inputs. To do this, the driver must set the job status to STOPPED and also set the restart index to 0.  The conditional versions of SOFT_STOP and HARD_STOP are designed to eliminate race conditions when checking the JOB_CHAIN_FLAG, which is in the JS  n _CONFIG register. The stop command is only issued if the current state of the flag matches the value in the command name. If it does not match, then the command is treated like a NOP and nothing happens.</spirit:description>
        <spirit:addressOffset>0x20</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>JS0COMMAND</spirit:name>
          <spirit:displayName>JS0COMMAND</spirit:displayName>
          <spirit:description>   Added SUSPEND and RESUME commands to job chain  COMMAND register.</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>write-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NOP</spirit:name>
              <spirit:description> No operation, idle. Writing this value is ignored. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>START</spirit:name>
              <spirit:description> Start processing a job chain. Writing this value is ignored. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>SOFT_STOP</spirit:name>
              <spirit:description> Gently stop processing a job chain. Ignored if not running jobs. </spirit:description>
              <spirit:value>2</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>HARD_STOP</spirit:name>
              <spirit:description> Immediately stop processing a job chain. Ignored if not running jobs. </spirit:description>
              <spirit:value>3</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>SOFT_STOP_0</spirit:name>
              <spirit:description> Execute SOFT_STOP if JOB_CHAIN_FLAG is 0. </spirit:description>
              <spirit:value>4</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>HARD_STOP_0</spirit:name>
              <spirit:description> Execute HARD_STOP if JOB_CHAIN_FLAG is 0. </spirit:description>
              <spirit:value>5</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>SOFT_STOP_1</spirit:name>
              <spirit:description> Execute SOFT_STOP if JOB_CHAIN_FLAG is 1. </spirit:description>
              <spirit:value>6</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>HARD_STOP_1</spirit:name>
              <spirit:description> Execute HARD_STOP if JOB_CHAIN_FLAG is 1. </spirit:description>
              <spirit:value>7</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>SUSPEND</spirit:name>
              <spirit:description> Statefully suspend a job chain. Ignored if not running jobs. </spirit:description>
              <spirit:value>8</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>SUSPEND_0</spirit:name>
              <spirit:description> Execute SUSPEND if JOB_CHAIN_FLAG is 0. </spirit:description>
              <spirit:value>9</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>SUSPEND_1</spirit:name>
              <spirit:description> Execute SUSPEND if JOB_CHAIN_FLAG is 1. </spirit:description>
              <spirit:value>10</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>RESUME</spirit:name>
              <spirit:description> Resume a suspended job chain. </spirit:description>
              <spirit:value>11</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>JS0_STATUS</spirit:name>
        <spirit:displayName>JS0_STATUS</spirit:displayName>
        <spirit:description>   This register indicates the status of the job chain running in this job slot.  During typical operation, the status starts in state  NOT_STARTED , then switches to ACTIVE during job chain execution, and on completion the status will change to either DONE for successful execution, or another exception code if an error occurred. Corrected description of job slot STATUS register  If the GPU is in protected mode, this register will read as zero. </spirit:description>
        <spirit:addressOffset>0x24</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>Res80</spirit:name>
          <spirit:displayName>Res80</spirit:displayName>
          <spirit:description>Res80</spirit:description>
          <spirit:bitOffset>8</spirit:bitOffset>
          <spirit:bitWidth>24</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>EXCEPTION_TYPE</spirit:name>
          <spirit:displayName>EXCEPTION_TYPE</spirit:displayName>
          <spirit:description>   Added new MMU exception types.  Changed INTERRUPTED exception type to SUSPENDED.  Added exception types for new events EUREKA and KABOOM.  Removed aliases for OK - used to also be called IDLE and NOT_STARTED.  Documented that a KABOOM instruction will cause other jobs to hard-stop.  Removed OUT_OF_MEMORY_AFBC error as it can only occur with non-sparse allocation (now removed).  Removed INSTR_TYPE_MISMATCH, INSTR_OPERAND_FAULT, INSTR_TLS_FAULT, INSTR_ALIGN_FAULT; added IMPRECISE_FAULT (0x5B).  Split SHAREABILITY_FAULT into GPU_SHAREABILITY_FAULT, SYSTEM_SHAREABILITY_FAULT and GPU_CACHEABILITY_FAULT. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>8</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>OK</spirit:name>
              <spirit:description>   This indicates that the GPU has completed its work and is in a state ready to receive new commands. Its precise meaning depends on its usage:    In the job status field, this indicates that the job has not been started. This should be the initial state of a newly created job.  In the job slot status register, this indicates that the job slot is idle.  In the GPU and MMU exception status registers, this indicates that no exception has yet been received.  No additional error information is available (or indeed required). </spirit:description>
              <spirit:value>0x00</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>DONE</spirit:name>
              <spirit:description> The job completed successfully. The fault value is written to the job descriptor.
			The job descriptors fault address field contains the TIMESTAMP value when the job completed.
			If a job is terminated early using the  EUREKA instruction, then that job will be marked with the EUREKA exception status but the job chain status as a whole will still be DONE.</spirit:description>
              <spirit:value>0x01</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>SUSPENDED</spirit:name>
              <spirit:description> The job was interrupted by a SUSPEND command. The fault value is written both to the job slot  STATUS register and the job descriptor.
			The job descriptor contains the partition index of the first task to be interrupted. The fault address field contains the TIMESTAMP value when the job was interrupted.</spirit:description>
              <spirit:value>0x02</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>STOPPED</spirit:name>
              <spirit:description> The job was interrupted by a SOFT_STOP command. The fault value is written both to the job slot  STATUS register and the job descriptor.
			The job descriptor contains the partition index of the first task that was not completed. This will be the index of the first task issued if the job is resumed. The fault address is UNDEFINED .</spirit:description>
              <spirit:value>0x03</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TERMINATED</spirit:name>
              <spirit:description> The job was interrupted by a HARD_STOP command or a  KABOOM instruction from another job. The fault value is written both to the job slot STATUS register and the job descriptor.
			This status is treated in the same way as an error condition. The job descriptor contains the partition index of the first task to be terminated. The fault address field contains the TIMESTAMP value when the job was interrupted.</spirit:description>
              <spirit:value>0x04</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>KABOOM</spirit:name>
              <spirit:description> The job was interrupted by a shader executing a  KABOOM instruction. The fault value is written both to the job slot STATUS register and the job descriptor.
			This status is treated in the same way as an error condition. The job descriptor contains the partition index of the first task to be terminated. The fault address field contains the TIMESTAMP value when the job was interrupted.</spirit:description>
              <spirit:value>0x05</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>EUREKA</spirit:name>
              <spirit:description> The job was interrupted by a shader executing a  EUREKA instruction. The fault value is written only to the job descriptor, and does not affect subsequent jobs in the job chain.
			The job descriptor contains the partition index of the first task to be terminated. The fault address field contains the TIMESTAMP value when the job was interrupted.</spirit:description>
              <spirit:value>0x06</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ACTIVE</spirit:name>
              <spirit:description> In the JSn_STATUS register, this indicates that the job slot is active.
			The JSn_HEAD and JSn_TAIL registers contain the range of job descriptors currently in progress. </spirit:description>
              <spirit:value>0x08</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>JOB_CONFIG_FAULT</spirit:name>
              <spirit:description>   The job configuration specified in the job slot registers is invalid, so it is not possible to read job descriptors.
				For example this includes setting a NULL job descriptor pointer, selecting an address space that isnt present.
				No additional information is available. </spirit:description>
              <spirit:value>0x40</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>JOB_POWER_FAULT</spirit:name>
              <spirit:description>   The job could not be executed because the part of the memory system required to access job descriptors was not powered on.
				No additional information is available. </spirit:description>
              <spirit:value>0x41</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>JOB_READ_FAULT</spirit:name>
              <spirit:description>   Reading a job descriptor into the Job manager failed.
				The JSn_HEAD register contains the virtual address of the job descriptor that could not be read. </spirit:description>
              <spirit:value>0x42</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>JOB_WRITE_FAULT</spirit:name>
              <spirit:description>   Writing a job descriptor from the Job manager failed.
				The JSn_TAIL register contains the virtual address of the job descriptor that could not be written. </spirit:description>
              <spirit:value>0x43</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>JOB_AFFINITY_FAULT</spirit:name>
              <spirit:description>   The job could not be executed because the specified affinity mask does not intersect any available cores.
				No additional information is available. </spirit:description>
              <spirit:value>0x44</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>JOB_BUS_FAULT</spirit:name>
              <spirit:description>   A bus access failed while executing a job.
				The job descriptor contains the virtual address of the failing access, the type of access, and which part of the GPU initiated the access.
				This error code may also be reported if a bus fault occurs while writing the performance counters to memory. In this case, the GPU_FAULT* registers are updated, but the active JASID is not reported. It is possible to distinguish this case from a genuine Job Bus Fault exception by examining the SOURCE_ID field. </spirit:description>
              <spirit:value>0x48</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>INSTR_INVALID_PC</spirit:name>
              <spirit:description>   A shader instruction with an illegal program counter was executed.
				The job descriptors fault address field contains the offending program counter value. </spirit:description>
              <spirit:value>0x50</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>INSTR_INVALID_ENC</spirit:name>
              <spirit:description>   A shader instruction with an illegal encoding was executed.
				The job descriptors fault address field contains the program counter used to reach the offending instruction. </spirit:description>
              <spirit:value>0x51</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>INSTR_BARRIER_FAULT</spirit:name>
              <spirit:description>   A shader instruction was executed that failed to complete an instruction barrier.
				The job descriptors fault address field contains the program counter used to reach the offending instruction. </spirit:description>
              <spirit:value>0x55</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>DATA_INVALID_FAULT</spirit:name>
              <spirit:description>   Any data structure read as part of the job contains invalid combinations of data.
				The job descriptors fault address field contains the virtual address of the invalid data structure. </spirit:description>
              <spirit:value>0x58</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TILE_RANGE_FAULT</spirit:name>
              <spirit:description>   Tile or fragment shading was asked to process a tile that is entirely outside the bounding box of the frame.
				The job descriptors fault address field contains the coordinates of the top left corner of the failing tile, with X in the bits [15:0], and Y in the bits [31:16].  Clarified description of TILE_RANGE_FAULT. </spirit:description>
              <spirit:value>0x59</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ADDR_RANGE_FAULT</spirit:name>
              <spirit:description>   A virtual address has been found that exceeds the virtual address range.
				The job descriptors fault address field contains the virtual address which is out of range. </spirit:description>
              <spirit:value>0x5A</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>IMPRECISE_FAULT</spirit:name>
              <spirit:description>   A fault has been generated without precise fault information.
				This can happen if appropriate source information is not available at the point where the fault happens.
				The job descriptors fault address field may contain a virtual address related to the fault. </spirit:description>
              <spirit:value>0x5B</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>OUT_OF_MEMORY</spirit:name>
              <spirit:description>   The tiler ran out of memory when executing a job.
				The job descriptors fault address field contains the index of the last completed vertex sent through the tiler. </spirit:description>
              <spirit:value>0x60</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>UNKNOWN</spirit:name>
              <spirit:description>   If multiple jobs in a job chain fail, only the first one the reports an error will set and return full error information. Subsequent failing jobs will not update the error status registers, and may write an error status of UNKNOWN.
				Note that the first job to fail may not be the first job in the chain, which may lead to jobs with  UNKNOWN error status being encountered first when traversing the job chain.
				For example, you may see: Done, Done, Unknown, Bus Error, Unknown, New. In this case, the first two jobs ran successfully, the fourth job hit a bus error, and then jobs three and five also failed. The sixth and subsequent jobs had not been started at that point.</spirit:description>
              <spirit:value>0x7F</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>DELAYED_BUS_FAULT</spirit:name>
              <spirit:description>   The GPU received a bus fault for access to physical memory where the original virtual address is no longer available. This is the result of evicting a dirty line from a cache.
				This may also be triggered by a bus fault during a Tiler cache flush operation. In this case, the address reported in  GPU_FAULTADDRESS is a virtual address.</spirit:description>
              <spirit:value>0x80</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>GPU_SHAREABILITY_FAULT</spirit:name>
              <spirit:description>   A cache has detected that the same line has been accessed as both shareable and non-shareable memory from inside the GPU. Coherency after this point can no longer be guaranteed. </spirit:description>
              <spirit:value>0x88</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>SYSTEM_SHAREABILITY_FAULT</spirit:name>
              <spirit:description>   A cache has detected that the same line has been accessed as both shareable and non-shareable memory from outside the GPU. Coherency after this point can no longer be guaranteed. </spirit:description>
              <spirit:value>0x89</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>GPU_CACHEABILITY_FAULT</spirit:name>
              <spirit:description>   A cache has detected that the same line has been accessed as both cacheable and non-cacheable memory from inside the GPU. Non-cacheable memory may have been cached. </spirit:description>
              <spirit:value>0x8A</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TRANSLATION_FAULT_0</spirit:name>
              <spirit:description>   A memory access hit an invalid table entry at level 0 of the translation table. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xC0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TRANSLATION_FAULT_1</spirit:name>
              <spirit:description>   A memory access hit an invalid table entry at level 1 of the translation table. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xC1</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TRANSLATION_FAULT_2</spirit:name>
              <spirit:description>   A memory access hit an invalid table entry at level 2 of the translation table. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xC2</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TRANSLATION_FAULT_3</spirit:name>
              <spirit:description>   A memory access hit an invalid table entry at level 3 of the translation table. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xC3</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TRANSLATION_FAULT_IDENTITY</spirit:name>
              <spirit:description>   In IDENTITY translation mode, the virtual address exceeds the maximum physical address. </spirit:description>
              <spirit:value>0xC7</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>PERMISSION_FAULT_0</spirit:name>
              <spirit:description>   A memory access could not be allowed due to the permission flags set in level 0 of the translation table. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set. Added MMU translation level information to permission fault. </spirit:description>
              <spirit:value>0xC8</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>PERMISSION_FAULT_1</spirit:name>
              <spirit:description>   A memory access could not be allowed due to the permission flags set in level 1 of the translation table. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xC9</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>PERMISSION_FAULT_2</spirit:name>
              <spirit:description>   A memory access could not be allowed due to the permission flags set in level 2 of the translation table. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xCA</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>PERMISSION_FAULT_3</spirit:name>
              <spirit:description>   A memory access could not be allowed due to the permission flags set in level 3 of the translation table. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xCB</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TRANSTAB_BUS_FAULT_0</spirit:name>
              <spirit:description>   A bus fault occurred while reading level 0 of the translation tables. The appropriate  BUS_ERROR flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xD0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TRANSTAB_BUS_FAULT_1</spirit:name>
              <spirit:description>   A bus fault occurred while reading level 1 of the translation tables. The appropriate  BUS_ERROR flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xD1</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TRANSTAB_BUS_FAULT_2</spirit:name>
              <spirit:description>   A bus fault occurred while reading level 2 of the translation tables. The appropriate  BUS_ERROR flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xD2</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TRANSTAB_BUS_FAULT_3</spirit:name>
              <spirit:description>   A bus fault occurred while reading level 3 of the translation tables. The appropriate  BUS_ERROR flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xD3</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ACCESS_FLAG_0</spirit:name>
              <spirit:description>   A memory access hit a translation table entry with the ACCESS_FLAG bit set in level 0 of the translation table. This is not treated as a fault by the accessor. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set. Added MMU translation level information to access flag fault. </spirit:description>
              <spirit:value>0xD8</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ACCESS_FLAG_1</spirit:name>
              <spirit:description>   A memory access hit a translation table entry with the ACCESS_FLAG bit set in level 1 of the translation table. This is not treated as a fault by the accessor. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xD9</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ACCESS_FLAG_2</spirit:name>
              <spirit:description>   A memory access hit a translation table entry with the ACCESS_FLAG bit set in level 2 of the translation table. This is not treated as a fault by the accessor. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xDA</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ACCESS_FLAG_3</spirit:name>
              <spirit:description>   A memory access hit a translation table entry with the ACCESS_FLAG bit set in level 3 of the translation table. This is not treated as a fault by the accessor. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xDB</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ADDRESS_SIZE_FAULT_IN0</spirit:name>
              <spirit:description>   An input address size fault occurred while reading level 0 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ADDRESS_SIZE_FAULT_IN1</spirit:name>
              <spirit:description>   An input address size fault occurred while reading level 1 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE1</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ADDRESS_SIZE_FAULT_IN2</spirit:name>
              <spirit:description>   An input address size fault occurred while reading level 2 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE2</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ADDRESS_SIZE_FAULT_IN3</spirit:name>
              <spirit:description>   An input address size fault occurred while reading level 3 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE3</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ADDRESS_SIZE_FAULT_OUT0</spirit:name>
              <spirit:description>   An output address size fault occurred while reading level 0 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE4</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ADDRESS_SIZE_FAULT_OUT1</spirit:name>
              <spirit:description>   An output address size fault occurred while reading level 1 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE5</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ADDRESS_SIZE_FAULT_OUT2</spirit:name>
              <spirit:description>   An output address size fault occurred while reading level 2 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE6</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ADDRESS_SIZE_FAULT_OUT3</spirit:name>
              <spirit:description>   An output address size fault occurred while reading level 3 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE7</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>MEMORY_ATTRIBUTE_FAULT_0</spirit:name>
              <spirit:description>   A memory access could not be allowed due to an attempt to access a page with its memory attribute set to  FAULT in the MEMATTR register. This fault happened when reading level 0 of the translation tables. The appropriate PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE8</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>MEMORY_ATTRIBUTE_FAULT_1</spirit:name>
              <spirit:description>   A memory access could not be allowed due to an attempt to access a page with its memory attribute set to  FAULT in the MEMATTR register. This fault happened when reading level 1 of the translation tables. The appropriate PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE9</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>MEMORY_ATTRIBUTE_FAULT_2</spirit:name>
              <spirit:description>   A memory access could not be allowed due to an attempt to access a page with its memory attribute set to  FAULT in the MEMATTR register. This fault happened when reading level 2 of the translation tables. The appropriate PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xEA</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>MEMORY_ATTRIBUTE_FAULT_3</spirit:name>
              <spirit:description>   A memory access could not be allowed due to an attempt to access a page with its memory attribute set to  FAULT in the MEMATTR register. This fault happened when reading level 3 of the translation tables. The appropriate PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xEB</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>MEMORY_ATTRIBUTE_NONCACHEABLE_0</spirit:name>
              <spirit:description>   A memory access could not be allowed due to an attempt to access a non-cacheable page from a bus master which does not support non-cacheable accessess. This fault happened when reading level 0 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xEC</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>MEMORY_ATTRIBUTE_NONCACHEABLE_1</spirit:name>
              <spirit:description>   A memory access could not be allowed due to an attempt to access a non-cacheable page from a bus master which does not support non-cacheable accessess. This fault happened when reading level 1 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xED</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>MEMORY_ATTRIBUTE_NONCACHEABLE_2</spirit:name>
              <spirit:description>   A memory access could not be allowed due to an attempt to access a non-cacheable page from a bus master which does not support non-cacheable accessess. This fault happened when reading level 2 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xEE</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>MEMORY_ATTRIBUTE_NONCACHEABLE_3</spirit:name>
              <spirit:description>   A memory access could not be allowed due to an attempt to access a non-cacheable page from a bus master which does not support non-cacheable accessess. This fault happened when reading level 3 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xEF</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>JS0_FLUSH_ID</spirit:name>
        <spirit:displayName>JS0_FLUSH_ID</spirit:displayName>
        <spirit:description>   This register contains the current cache flush ID for this job slot. </spirit:description>
        <spirit:addressOffset>0x30</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>JS0FLUSH_ID</spirit:name>
          <spirit:displayName>JS0FLUSH_ID</spirit:displayName>
          <spirit:description>   When operating in "cache flush reduction" mode, each job chain has an associated ID which is used to identify cache flushes.  This ID is a sequential 32-bit value. When the job manager is asked to perform a flush, it compares the job chain flush ID with the latest flush ID. If the job chain ID is greater than the latest flush, then a flush is performed.  Care must be taken in the overflow case. If the software setting up the ID detects that an overflow may occur, the job chain should be tagged with the maximum value of the  LATEST_FLUSH register. This ensures that flushes are correctly performed, at the possible cost of a few redundant flushes. Added cache flush reduction </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>JS0_EVENT_0</spirit:name>
        <spirit:displayName>JS0_EVENT_0</spirit:displayName>
        <spirit:description>   This register is used to accumulate events for job chains where the job chain disambiguation bit is 0.  Added event registers to job slots. </spirit:description>
        <spirit:addressOffset>0x34</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>JS0EVENT_0</spirit:name>
          <spirit:displayName>JS0EVENT_0</spirit:displayName>
          <spirit:description>JS0EVENT_0</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> No event was received of type  n .</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> At least one event of type  n has been received.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>JS0_EVENT_1</spirit:name>
        <spirit:displayName>JS0_EVENT_1</spirit:displayName>
        <spirit:description>   This register is used to accumulate events for job chains where the job chain disambiguation bit is 1. </spirit:description>
        <spirit:addressOffset>0x38</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>JS0EVENT_1</spirit:name>
          <spirit:displayName>JS0EVENT_1</spirit:displayName>
          <spirit:description>JS0EVENT_1</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> No event was received of type  n .</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> At least one event of type  n has been received.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>JS0_EVENT_MASK</spirit:name>
        <spirit:displayName>JS0_EVENT_MASK</spirit:displayName>
        <spirit:description>   This register is the current event mask. </spirit:description>
        <spirit:addressOffset>0x3c</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>JS0EVENT_MASK</spirit:name>
          <spirit:displayName>JS0EVENT_MASK</spirit:displayName>
          <spirit:description>JS0EVENT_MASK</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> Event  n will not cause an interrupt.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Event  n will cause an interrupt.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>JS0_HEAD_NEXT_LO</spirit:name>
        <spirit:displayName>JS0_HEAD_NEXT_LO</spirit:displayName>
        <spirit:description>   This register contains the value to be transferred into the JS  n _HEAD register when the next job chain starts. See COMMAND_NEXT for details.</spirit:description>
        <spirit:addressOffset>0x40</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>JS0HEAD_NEXT_LO</spirit:name>
          <spirit:displayName>JS0HEAD_NEXT_LO</spirit:displayName>
          <spirit:description>   This register contains the address of the current job descriptor. The address is a virtual address in the address space specified by the ADDRESS_SPACE field in the JS  n _CONFIG register.</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>JS0_HEAD_NEXT_HI</spirit:name>
        <spirit:displayName>JS0_HEAD_NEXT_HI</spirit:displayName>
        <spirit:description>   This register contains the value to be transferred into the JS  n _HEAD register when the next job chain starts. See COMMAND_NEXT for details.</spirit:description>
        <spirit:addressOffset>0x44</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>JS0HEAD_NEXT_HI</spirit:name>
          <spirit:displayName>JS0HEAD_NEXT_HI</spirit:displayName>
          <spirit:description>   This register contains the address of the current job descriptor. The address is a virtual address in the address space specified by the ADDRESS_SPACE field in the JS  n _CONFIG register.</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>JS0_AFFINITY_NEXT_LO</spirit:name>
        <spirit:displayName>JS0_AFFINITY_NEXT_LO</spirit:displayName>
        <spirit:description>   This register contains the value to be transferred into the JS  n _AFFINITY register when the next job chain starts. See COMMAND_NEXT for details.</spirit:description>
        <spirit:addressOffset>0x50</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>JS0AFFINITY_NEXT_LO</spirit:name>
          <spirit:displayName>JS0AFFINITY_NEXT_LO</spirit:displayName>
          <spirit:description>JS0AFFINITY_NEXT_LO</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> This job slot is not allowed to dispatch tasks to shader core  n .</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> This job slot is allowed to dispatch tasks to shader core  n .</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>JS0_AFFINITY_NEXT_HI</spirit:name>
        <spirit:displayName>JS0_AFFINITY_NEXT_HI</spirit:displayName>
        <spirit:description>   This register contains the value to be transferred into the JS  n _AFFINITY register when the next job chain starts. See COMMAND_NEXT for details.</spirit:description>
        <spirit:addressOffset>0x54</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>JS0AFFINITY_NEXT_HI</spirit:name>
          <spirit:displayName>JS0AFFINITY_NEXT_HI</spirit:displayName>
          <spirit:description>JS0AFFINITY_NEXT_HI</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> This job slot is not allowed to dispatch tasks to shader core  n .</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> This job slot is allowed to dispatch tasks to shader core  n .</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>JS0_CONFIG_NEXT</spirit:name>
        <spirit:displayName>JS0_CONFIG_NEXT</spirit:displayName>
        <spirit:description>   This register contains the value to be transferred into the JS  n _CONFIG register when the next job chain starts. See COMMAND_NEXT for details.</spirit:description>
        <spirit:addressOffset>0x58</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>Res81</spirit:name>
          <spirit:displayName>Res81</spirit:displayName>
          <spirit:description>Res81</spirit:description>
          <spirit:bitOffset>4</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>Res82</spirit:name>
          <spirit:displayName>Res82</spirit:displayName>
          <spirit:description>Res82</spirit:description>
          <spirit:bitOffset>20</spirit:bitOffset>
          <spirit:bitWidth>12</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>ADDRESS_SPACE</spirit:name>
          <spirit:displayName>ADDRESS_SPACE</spirit:displayName>
          <spirit:description>   This is the ID of the address space to use for execution of all the jobs in this job chain.
						Address space configuration values are read from the AS  n registers.
						Specifying an address space that is not supported (i.e. the corresponding bit in AS_PRESENT is 0) may result in UNDEFINED behavior.</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>JOB_CHAIN_FLAG</spirit:name>
          <spirit:displayName>JOB_CHAIN_FLAG</spirit:displayName>
          <spirit:description>   The JOB_CHAIN_FLAG is set and read by software, and is used to disambiguate short-running job chains. It has no effect on the execution of a job, but is transferred intact from the JS  n _CONFIG_NEXT register to the JS n _CONFIG register when a job starts.</spirit:description>
          <spirit:bitOffset>11</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>THREAD_PRI</spirit:name>
          <spirit:displayName>THREAD_PRI</spirit:displayName>
          <spirit:description>   The thread priority is ordered so that high values will cause threads to be issued faster. Priority values are relative to the other jobs running  if no other jobs are issuing threads, this job will never be throttled even with low priorities.  How the priority values affect issue rates from different slots is implementation dependent. </spirit:description>
          <spirit:bitOffset>16</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>START_FLUSH</spirit:name>
          <spirit:displayName>START_FLUSH</spirit:displayName>
          <spirit:description>   Before the job chain is started, the selected action is applied to all caches except the tiler cache.  Clarified that cache flush behavior for Mimir deviates from spec.  In this implementation (MIMIR), this behavior is not fully implemented.
								Any non-zero value in this field will cause both a clean  and an invalidate for the read-write caches.
								If the value is 3, then the read-only caches are also invalidated, as specified.
								The flush command goes to all GPU cores enabled in the affinity mask, and the L2 cache.</spirit:description>
          <spirit:bitOffset>8</spirit:bitOffset>
          <spirit:bitWidth>2</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NO_ACTION</spirit:name>
              <spirit:description> No action is performed </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>CLEAN</spirit:name>
              <spirit:description> Cleans the shader core's load/store cache and other read/write L1 caches. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>INVALIDATE</spirit:name>
              <spirit:description> Cleans and invalidates the shader core's load/store cache and other read/write L1 caches, and also invalidates all read-only caches, namely:   All DCDs with a matching JASID. Texture descriptor cache entries matching invalidated DCDs. Sampler descriptor cache entries matching invalidated DCDs. For fragment endpoints only, all vertex loader cache lines with zero reference count.</spirit:description>
              <spirit:value>3</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>END_FLUSH</spirit:name>
          <spirit:displayName>END_FLUSH</spirit:displayName>
          <spirit:description>   After the job chain is finished, the selected action is applied to all caches including the tiler cache. This happens when the job chain ends with a success code, or a fault code other than JOB_CONFIG_FAULT or JOB_POWER_FAULT. In the case of JOB_CONFIG_FAULT and JOB_POWER_FAULT, the job chain could not even start and so no cache flush on end takes place.  Clarified that cache flush behavior for Mimir deviates from spec.  In this implementation (MIMIR), this behavior is not fully implemented.
								The flush command goes only to the L2 cache. The tiler cache is not affected.
								Any non-zero value in this field will cause both a clean  and an invalidate.</spirit:description>
          <spirit:bitOffset>12</spirit:bitOffset>
          <spirit:bitWidth>2</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NO_ACTION</spirit:name>
              <spirit:description> No action is performed </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>CLEAN</spirit:name>
              <spirit:description> Cleans the shader core's load/store cache and other read/write L1 caches. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>INVALIDATE</spirit:name>
              <spirit:description> Cleans and invalidates the shader core's load/store cache and other read/write L1 caches, and also invalidates all read-only caches, namely:   All DCDs with a matching JASID. Texture descriptor cache entries matching invalidated DCDs. Sampler descriptor cache entries matching invalidated DCDs. For fragment endpoints only, all vertex loader cache lines with zero reference count.</spirit:description>
              <spirit:value>3</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>START_MMU</spirit:name>
          <spirit:displayName>START_MMU</spirit:displayName>
          <spirit:description>START_MMU</spirit:description>
          <spirit:bitOffset>10</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> No MMU actions </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Before the job chain is started, the MMU is instructed to update. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ENABLE_FLUSH_REDUCTION</spirit:name>
          <spirit:displayName>ENABLE_FLUSH_REDUCTION</spirit:displayName>
          <spirit:description>   When operating in "cache flush reduction" mode, each job chain has an associated ID which is used to identify cache flushes.  This ID is a sequential 32-bit value. When the job manager is asked to perform a suppressable flush, it compares the job chain flush ID with the latest flush ID. If the job chain ID is greater than the latest flush, then a flush is performed. Otherwise, the flush  may be suppressed. Not all flushes can be suppressed, and not all suppressable flushes may be suppressed in any particular hardware implementation. In particular:    A CLEAN_INVALIDATE operation can replace a CLEAN, but not the other way around.  A CLEAN_INVALIDATE operation can be suppressed at the start of a job chain.  A CLEAN or CLEAN_INVALIDATE operation at the end of a job chain cannot be suppressed in the general case.  If software can guarantee that it will not read the result of a job chain until another job chain has been completed, then this is a case where the CLEAN or CLEAN_INVALIDATE operation at the end of a job chain could be suppressed. It is, however, simpler for software to signal this guarantee by simply not enabling the end-of-chain cache flush at all.  Explicit cache flush jobs are assumed to have been placed into the job chain for a reason, and are therefore not suppressed.  Clarified cache flush reduction  Added cache flush reduction </spirit:description>
          <spirit:bitOffset>14</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> No cache flush reduction is applied. Cache flushes are executed as they are encountered. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Cache flush reduction is enabled. Redundant cache flushes may be eliminated by hardware. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>DISABLE_DESCRIPTOR_WRITEBACK</spirit:name>
          <spirit:displayName>DISABLE_DESCRIPTOR_WRITEBACK</spirit:displayName>
          <spirit:description>   Normally, the status of each job in the job chain is written back as it is completed. This flag allows software to suppress that mechanism in cases where it is not required. Regardless of the setting of this flag, a job slot's  STATUS register is always updated on completion of its job chain. One of the reasons for writing back the status to the job descriptors is to guard against infinite loops in job chains. If this flag is set, then that protection is disabled and additional steps should be taken to detect and mitigate infinite loops.  Added  DISABLE_DESCRIPTOR_WRITEBACK flag to job slot CONFIG register.</spirit:description>
          <spirit:bitOffset>15</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> Status is written to job descriptor upon job completion. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Status is not written to job descriptor upon job completion. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>JS0_XAFFINITY_NEXT</spirit:name>
        <spirit:displayName>JS0_XAFFINITY_NEXT</spirit:displayName>
        <spirit:description>   This register contains the value to be transferred into the JS  n _XAFFINITY register when the next job chain starts. See COMMAND_NEXT for details.</spirit:description>
        <spirit:addressOffset>0x5c</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>Res83</spirit:name>
          <spirit:displayName>Res83</spirit:displayName>
          <spirit:description>Res83</spirit:description>
          <spirit:bitOffset>1</spirit:bitOffset>
          <spirit:bitWidth>7</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>XAFFINITY_ENABLE</spirit:name>
          <spirit:displayName>XAFFINITY_ENABLE</spirit:displayName>
          <spirit:description>XAFFINITY_ENABLE</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> This register is disabled.  Other fields in the register are ignored and treated as all-1s, so that all available resources are enabled. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> This register is enabled. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>TILER_ENABLE</spirit:name>
          <spirit:displayName>TILER_ENABLE</spirit:displayName>
          <spirit:description>   This field selects which tilers receive commands such as cache flushes and tiler jobs. </spirit:description>
          <spirit:bitOffset>8</spirit:bitOffset>
          <spirit:bitWidth>8</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> This job slot is not allowed to dispatch tasks to tiler unit  n .</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> This job slot is allowed to dispatch tasks to tiler unit  n .</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>CACHE_ENABLE</spirit:name>
          <spirit:displayName>CACHE_ENABLE</spirit:displayName>
          <spirit:description>   This field selects which level 2 caches receive commands such as cache flushes and tiler jobs. </spirit:description>
          <spirit:bitOffset>16</spirit:bitOffset>
          <spirit:bitWidth>16</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> This job slot is not allowed to dispatch tasks to L2 cache  n .</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> This job slot is allowed to dispatch tasks to L2 cache  n .</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>JS0_COMMAND_NEXT</spirit:name>
        <spirit:displayName>JS0_COMMAND_NEXT</spirit:displayName>
        <spirit:description>   When the current job chain is completed, if there are no unacknowledged errors from the previous job chain, and this register is not set to NOP,
					then the contents of the *_NEXT registers are transferred to the corresponding current * registers. This allows software to construct job chains one ahead and maintain throughput.  When the values are transferred, the JS  n _COMMAND_NEXT register is cleared, indicating a NOP. The register is then ready to accept a new command. The JS n _HEAD_NEXT register is also cleared at the same time. The state of the current job can be determined using JS n _STATUS. In order to prevent new chains being transferred in a half-completed state, data is transferred only when a START command is present in the JS  n _COMMAND_NEXT register. Therefore, software should initialize the other _NEXT registers first, and only write a START command to the JS n _COMMAND_NEXT register when the data for the next job is complete. If there is no job running in slot n when START is written to JS  n _COMMAND_NEXT, the next data is transferred immediately.
					If the next command value is anything except START, nothing happens. To stop jobs, write STOP commands to the JS  n _COMMAND register instead. If any status is returned from a job in the previous job chain other than DONE, the JOB_FAIL_  n bit for this job chain is set in the JOB_IRQ_RAWSTAT register, and the next job chain is not started. This allows software to retrieve the current register values. Software must indicate that it is ready to proceed by clearing the error interrupt bit, at which point the next job chain may be started.</spirit:description>
        <spirit:addressOffset>0x60</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>JS0COMMAND_NEXT</spirit:name>
          <spirit:displayName>JS0COMMAND_NEXT</spirit:displayName>
          <spirit:description>   Added SUSPEND and RESUME commands to job chain  COMMAND register.</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NOP</spirit:name>
              <spirit:description> No operation, idle. Writing this value is ignored. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>START</spirit:name>
              <spirit:description> Start processing a job chain. Writing this value is ignored. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>SOFT_STOP</spirit:name>
              <spirit:description> Gently stop processing a job chain. Ignored if not running jobs. </spirit:description>
              <spirit:value>2</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>HARD_STOP</spirit:name>
              <spirit:description> Immediately stop processing a job chain. Ignored if not running jobs. </spirit:description>
              <spirit:value>3</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>SOFT_STOP_0</spirit:name>
              <spirit:description> Execute SOFT_STOP if JOB_CHAIN_FLAG is 0. </spirit:description>
              <spirit:value>4</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>HARD_STOP_0</spirit:name>
              <spirit:description> Execute HARD_STOP if JOB_CHAIN_FLAG is 0. </spirit:description>
              <spirit:value>5</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>SOFT_STOP_1</spirit:name>
              <spirit:description> Execute SOFT_STOP if JOB_CHAIN_FLAG is 1. </spirit:description>
              <spirit:value>6</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>HARD_STOP_1</spirit:name>
              <spirit:description> Execute HARD_STOP if JOB_CHAIN_FLAG is 1. </spirit:description>
              <spirit:value>7</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>SUSPEND</spirit:name>
              <spirit:description> Statefully suspend a job chain. Ignored if not running jobs. </spirit:description>
              <spirit:value>8</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>SUSPEND_0</spirit:name>
              <spirit:description> Execute SUSPEND if JOB_CHAIN_FLAG is 0. </spirit:description>
              <spirit:value>9</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>SUSPEND_1</spirit:name>
              <spirit:description> Execute SUSPEND if JOB_CHAIN_FLAG is 1. </spirit:description>
              <spirit:value>10</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>RESUME</spirit:name>
              <spirit:description> Resume a suspended job chain. </spirit:description>
              <spirit:value>11</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>JS0_FLUSH_ID_NEXT</spirit:name>
        <spirit:displayName>JS0_FLUSH_ID_NEXT</spirit:displayName>
        <spirit:description>   This register contains the value to be transferred into the JS  n _FLUSH_ID register when the next job chain starts. See FLUSH_ID for details.</spirit:description>
        <spirit:addressOffset>0x70</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>JS0FLUSH_ID_NEXT</spirit:name>
          <spirit:displayName>JS0FLUSH_ID_NEXT</spirit:displayName>
          <spirit:description>   When operating in "cache flush reduction" mode, each job chain has an associated ID which is used to identify cache flushes.  This ID is a sequential 32-bit value. When the job manager is asked to perform a flush, it compares the job chain flush ID with the latest flush ID. If the job chain ID is greater than the latest flush, then a flush is performed.  Care must be taken in the overflow case. If the software setting up the ID detects that an overflow may occur, the job chain should be tagged with the maximum value of the  LATEST_FLUSH register. This ensures that flushes are correctly performed, at the possible cost of a few redundant flushes. Added cache flush reduction </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>JS0_EVENT_MASK_NEXT</spirit:name>
        <spirit:displayName>JS0_EVENT_MASK_NEXT</spirit:displayName>
        <spirit:description>   This register contains the value to be transferred into the JS  n _EVENT_MASK register when the next job chain starts. See EVENT_MASK for details.</spirit:description>
        <spirit:addressOffset>0x7c</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>JS0EVENT_MASK_NEXT</spirit:name>
          <spirit:displayName>JS0EVENT_MASK_NEXT</spirit:displayName>
          <spirit:description>JS0EVENT_MASK_NEXT</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> Event  n will not cause an interrupt.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Event  n will cause an interrupt.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
    </spirit:addressBlock>
    <spirit:addressBlock>
      <spirit:name>jm_job_slot1_regs</spirit:name>
      <spirit:baseAddress>6272</spirit:baseAddress>
      <spirit:range>128</spirit:range>
      <spirit:width>32</spirit:width>
      <spirit:usage>register</spirit:usage>
      <spirit:register>
        <spirit:name>JS1_HEAD_LO</spirit:name>
        <spirit:displayName>JS1_HEAD_LO</spirit:displayName>
        <spirit:description>   These registers exist for each supported job slot, with the prefix JS  n . To start a job chain, write the address to the first job descriptor into the JS  n _HEAD_NEXT register and write a START command to the JS n _COMMAND_NEXT register. When read, this register reflects the current position in the job chain. When the Job Manager has finished issuing tasks for a job, it will go on to the next job in the job chain, and update JS  n _HEAD. A job will disappear from JS  n _HEAD before it has finished processing all its tasks. See JS n _TAIL for how to discover this. Jobs newer than JS  n _HEAD may have been prefetched from memory, but will not yet have started processing. After an error, JS  n _HEAD contains the address of the first job (chronologically) that failed. The status registers contain the state of this job. If the GPU is in protected mode, this register will read as zero. </spirit:description>
        <spirit:addressOffset>0x0</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>JS1HEAD_LO</spirit:name>
          <spirit:displayName>JS1HEAD_LO</spirit:displayName>
          <spirit:description>   This register contains the address of the current job descriptor. The address is a virtual address in the address space specified by the ADDRESS_SPACE field in the JS  n _CONFIG register.</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>JS1_HEAD_HI</spirit:name>
        <spirit:displayName>JS1_HEAD_HI</spirit:displayName>
        <spirit:description>   These registers exist for each supported job slot, with the prefix JS  n . To start a job chain, write the address to the first job descriptor into the JS  n _HEAD_NEXT register and write a START command to the JS n _COMMAND_NEXT register. When read, this register reflects the current position in the job chain. When the Job Manager has finished issuing tasks for a job, it will go on to the next job in the job chain, and update JS  n _HEAD. A job will disappear from JS  n _HEAD before it has finished processing all its tasks. See JS n _TAIL for how to discover this. Jobs newer than JS  n _HEAD may have been prefetched from memory, but will not yet have started processing. After an error, JS  n _HEAD contains the address of the first job (chronologically) that failed. The status registers contain the state of this job. If the GPU is in protected mode, this register will read as zero. </spirit:description>
        <spirit:addressOffset>0x4</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>JS1HEAD_HI</spirit:name>
          <spirit:displayName>JS1HEAD_HI</spirit:displayName>
          <spirit:description>   This register contains the address of the current job descriptor. The address is a virtual address in the address space specified by the ADDRESS_SPACE field in the JS  n _CONFIG register.</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>JS1_TAIL_LO</spirit:name>
        <spirit:displayName>JS1_TAIL_LO</spirit:displayName>
        <spirit:description>   If the GPU is in protected mode, this register will read as zero. </spirit:description>
        <spirit:addressOffset>0x8</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>JS1TAIL_LO</spirit:name>
          <spirit:displayName>JS1TAIL_LO</spirit:displayName>
          <spirit:description>   This register contains the address of the oldest job that has finished issuing tasks, but is still running. The address is a virtual address in the address space specified by the ADDRESS_SPACE field in the JS  n _CONFIG register. All the jobs in a job chain from JS  n _TAIL to JS n _HEAD are in some way active in the GPU. Jobs older than JS n _TAIL are fully completed. Note that the value in the JS  n _TAIL register is updated when a new job starts. Therefore, this value is only valid while the JS n _STATUS register has the value ACTIVE. After an error, JS  n _TAIL contains the address of the first job in the chain that is not known to be successfully complete. Other jobs after this point may have completed successfully, but all jobs prior to this point are guaranteed have completed.
						In order to simplfy implementation of this feature, the position reported in JS n _TAIL is allowed to be conservative. However, scanning from this point forward in the chain will always be sufficient to identify all failing jobs.</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>JS1_TAIL_HI</spirit:name>
        <spirit:displayName>JS1_TAIL_HI</spirit:displayName>
        <spirit:description>   If the GPU is in protected mode, this register will read as zero. </spirit:description>
        <spirit:addressOffset>0xc</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>JS1TAIL_HI</spirit:name>
          <spirit:displayName>JS1TAIL_HI</spirit:displayName>
          <spirit:description>   This register contains the address of the oldest job that has finished issuing tasks, but is still running. The address is a virtual address in the address space specified by the ADDRESS_SPACE field in the JS  n _CONFIG register. All the jobs in a job chain from JS  n _TAIL to JS n _HEAD are in some way active in the GPU. Jobs older than JS n _TAIL are fully completed. Note that the value in the JS  n _TAIL register is updated when a new job starts. Therefore, this value is only valid while the JS n _STATUS register has the value ACTIVE. After an error, JS  n _TAIL contains the address of the first job in the chain that is not known to be successfully complete. Other jobs after this point may have completed successfully, but all jobs prior to this point are guaranteed have completed.
						In order to simplfy implementation of this feature, the position reported in JS n _TAIL is allowed to be conservative. However, scanning from this point forward in the chain will always be sufficient to identify all failing jobs.</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>JS1_AFFINITY_LO</spirit:name>
        <spirit:displayName>JS1_AFFINITY_LO</spirit:displayName>
        <spirit:description>   This register contains the current core affinity mask for this job slot. Only cores covered by the affinity mask are eligible for running tasks on. The mask is anded with the *_READY masks, and the resulting ones are the cores that can be used.  The affinity value is constant over a job chain. If you need to change affinity between jobs, then they must be split into separate job chains.See also JS  n _XAFFINITY</spirit:description>
        <spirit:addressOffset>0x10</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>JS1AFFINITY_LO</spirit:name>
          <spirit:displayName>JS1AFFINITY_LO</spirit:displayName>
          <spirit:description>JS1AFFINITY_LO</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> This job slot is not allowed to dispatch tasks to shader core  n .</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> This job slot is allowed to dispatch tasks to shader core  n .</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>JS1_AFFINITY_HI</spirit:name>
        <spirit:displayName>JS1_AFFINITY_HI</spirit:displayName>
        <spirit:description>   This register contains the current core affinity mask for this job slot. Only cores covered by the affinity mask are eligible for running tasks on. The mask is anded with the *_READY masks, and the resulting ones are the cores that can be used.  The affinity value is constant over a job chain. If you need to change affinity between jobs, then they must be split into separate job chains.See also JS  n _XAFFINITY</spirit:description>
        <spirit:addressOffset>0x14</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>JS1AFFINITY_HI</spirit:name>
          <spirit:displayName>JS1AFFINITY_HI</spirit:displayName>
          <spirit:description>JS1AFFINITY_HI</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> This job slot is not allowed to dispatch tasks to shader core  n .</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> This job slot is allowed to dispatch tasks to shader core  n .</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>JS1_CONFIG</spirit:name>
        <spirit:displayName>JS1_CONFIG</spirit:displayName>
        <spirit:description>   The job slot configuration register contains various configuration options for the jobs running in this job slot. </spirit:description>
        <spirit:addressOffset>0x18</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>Res84</spirit:name>
          <spirit:displayName>Res84</spirit:displayName>
          <spirit:description>Res84</spirit:description>
          <spirit:bitOffset>4</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>Res85</spirit:name>
          <spirit:displayName>Res85</spirit:displayName>
          <spirit:description>Res85</spirit:description>
          <spirit:bitOffset>20</spirit:bitOffset>
          <spirit:bitWidth>12</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>ADDRESS_SPACE</spirit:name>
          <spirit:displayName>ADDRESS_SPACE</spirit:displayName>
          <spirit:description>   This is the ID of the address space to use for execution of all the jobs in this job chain.
						Address space configuration values are read from the AS  n registers.
						Specifying an address space that is not supported (i.e. the corresponding bit in AS_PRESENT is 0) may result in UNDEFINED behavior.</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>JOB_CHAIN_FLAG</spirit:name>
          <spirit:displayName>JOB_CHAIN_FLAG</spirit:displayName>
          <spirit:description>   The JOB_CHAIN_FLAG is set and read by software, and is used to disambiguate short-running job chains. It has no effect on the execution of a job, but is transferred intact from the JS  n _CONFIG_NEXT register to the JS n _CONFIG register when a job starts.</spirit:description>
          <spirit:bitOffset>11</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>THREAD_PRI</spirit:name>
          <spirit:displayName>THREAD_PRI</spirit:displayName>
          <spirit:description>   The thread priority is ordered so that high values will cause threads to be issued faster. Priority values are relative to the other jobs running  if no other jobs are issuing threads, this job will never be throttled even with low priorities.  How the priority values affect issue rates from different slots is implementation dependent. </spirit:description>
          <spirit:bitOffset>16</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>START_FLUSH</spirit:name>
          <spirit:displayName>START_FLUSH</spirit:displayName>
          <spirit:description>   Before the job chain is started, the selected action is applied to all caches except the tiler cache.  Clarified that cache flush behavior for Mimir deviates from spec.  In this implementation (MIMIR), this behavior is not fully implemented.
								Any non-zero value in this field will cause both a clean  and an invalidate for the read-write caches.
								If the value is 3, then the read-only caches are also invalidated, as specified.
								The flush command goes to all GPU cores enabled in the affinity mask, and the L2 cache.</spirit:description>
          <spirit:bitOffset>8</spirit:bitOffset>
          <spirit:bitWidth>2</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NO_ACTION</spirit:name>
              <spirit:description> No action is performed </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>CLEAN</spirit:name>
              <spirit:description> Cleans the shader core's load/store cache and other read/write L1 caches. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>INVALIDATE</spirit:name>
              <spirit:description> Cleans and invalidates the shader core's load/store cache and other read/write L1 caches, and also invalidates all read-only caches, namely:   All DCDs with a matching JASID. Texture descriptor cache entries matching invalidated DCDs. Sampler descriptor cache entries matching invalidated DCDs. For fragment endpoints only, all vertex loader cache lines with zero reference count.</spirit:description>
              <spirit:value>3</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>END_FLUSH</spirit:name>
          <spirit:displayName>END_FLUSH</spirit:displayName>
          <spirit:description>   After the job chain is finished, the selected action is applied to all caches including the tiler cache. This happens when the job chain ends with a success code, or a fault code other than JOB_CONFIG_FAULT or JOB_POWER_FAULT. In the case of JOB_CONFIG_FAULT and JOB_POWER_FAULT, the job chain could not even start and so no cache flush on end takes place.  Clarified that cache flush behavior for Mimir deviates from spec.  In this implementation (MIMIR), this behavior is not fully implemented.
								The flush command goes only to the L2 cache. The tiler cache is not affected.
								Any non-zero value in this field will cause both a clean  and an invalidate.</spirit:description>
          <spirit:bitOffset>12</spirit:bitOffset>
          <spirit:bitWidth>2</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NO_ACTION</spirit:name>
              <spirit:description> No action is performed </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>CLEAN</spirit:name>
              <spirit:description> Cleans the shader core's load/store cache and other read/write L1 caches. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>INVALIDATE</spirit:name>
              <spirit:description> Cleans and invalidates the shader core's load/store cache and other read/write L1 caches, and also invalidates all read-only caches, namely:   All DCDs with a matching JASID. Texture descriptor cache entries matching invalidated DCDs. Sampler descriptor cache entries matching invalidated DCDs. For fragment endpoints only, all vertex loader cache lines with zero reference count.</spirit:description>
              <spirit:value>3</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>START_MMU</spirit:name>
          <spirit:displayName>START_MMU</spirit:displayName>
          <spirit:description>START_MMU</spirit:description>
          <spirit:bitOffset>10</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> No MMU actions </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Before the job chain is started, the MMU is instructed to update. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ENABLE_FLUSH_REDUCTION</spirit:name>
          <spirit:displayName>ENABLE_FLUSH_REDUCTION</spirit:displayName>
          <spirit:description>   When operating in "cache flush reduction" mode, each job chain has an associated ID which is used to identify cache flushes.  This ID is a sequential 32-bit value. When the job manager is asked to perform a suppressable flush, it compares the job chain flush ID with the latest flush ID. If the job chain ID is greater than the latest flush, then a flush is performed. Otherwise, the flush  may be suppressed. Not all flushes can be suppressed, and not all suppressable flushes may be suppressed in any particular hardware implementation. In particular:    A CLEAN_INVALIDATE operation can replace a CLEAN, but not the other way around.  A CLEAN_INVALIDATE operation can be suppressed at the start of a job chain.  A CLEAN or CLEAN_INVALIDATE operation at the end of a job chain cannot be suppressed in the general case.  If software can guarantee that it will not read the result of a job chain until another job chain has been completed, then this is a case where the CLEAN or CLEAN_INVALIDATE operation at the end of a job chain could be suppressed. It is, however, simpler for software to signal this guarantee by simply not enabling the end-of-chain cache flush at all.  Explicit cache flush jobs are assumed to have been placed into the job chain for a reason, and are therefore not suppressed.  Clarified cache flush reduction  Added cache flush reduction </spirit:description>
          <spirit:bitOffset>14</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> No cache flush reduction is applied. Cache flushes are executed as they are encountered. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Cache flush reduction is enabled. Redundant cache flushes may be eliminated by hardware. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>DISABLE_DESCRIPTOR_WRITEBACK</spirit:name>
          <spirit:displayName>DISABLE_DESCRIPTOR_WRITEBACK</spirit:displayName>
          <spirit:description>   Normally, the status of each job in the job chain is written back as it is completed. This flag allows software to suppress that mechanism in cases where it is not required. Regardless of the setting of this flag, a job slot's  STATUS register is always updated on completion of its job chain. One of the reasons for writing back the status to the job descriptors is to guard against infinite loops in job chains. If this flag is set, then that protection is disabled and additional steps should be taken to detect and mitigate infinite loops.  Added  DISABLE_DESCRIPTOR_WRITEBACK flag to job slot CONFIG register.</spirit:description>
          <spirit:bitOffset>15</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> Status is written to job descriptor upon job completion. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Status is not written to job descriptor upon job completion. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>JS1_XAFFINITY</spirit:name>
        <spirit:displayName>JS1_XAFFINITY</spirit:displayName>
        <spirit:description>   Additional affinity information for job slot  n exists in this register. Only resources covered by the affinity mask are eligible for receiving commands. The mask is anded with the appropriate bits from the TILER_PRESENT and L2_PRESENT masks, and the resulting ones are the resources that can be used.  The affinity value is constant over a job chain. If you need to change affinity between jobs, then they must be split into separate job chains. </spirit:description>
        <spirit:addressOffset>0x1c</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>Res86</spirit:name>
          <spirit:displayName>Res86</spirit:displayName>
          <spirit:description>Res86</spirit:description>
          <spirit:bitOffset>1</spirit:bitOffset>
          <spirit:bitWidth>7</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>XAFFINITY_ENABLE</spirit:name>
          <spirit:displayName>XAFFINITY_ENABLE</spirit:displayName>
          <spirit:description>XAFFINITY_ENABLE</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> This register is disabled.  Other fields in the register are ignored and treated as all-1s, so that all available resources are enabled. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> This register is enabled. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>TILER_ENABLE</spirit:name>
          <spirit:displayName>TILER_ENABLE</spirit:displayName>
          <spirit:description>   This field selects which tilers receive commands such as cache flushes and tiler jobs. </spirit:description>
          <spirit:bitOffset>8</spirit:bitOffset>
          <spirit:bitWidth>8</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> This job slot is not allowed to dispatch tasks to tiler unit  n .</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> This job slot is allowed to dispatch tasks to tiler unit  n .</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>CACHE_ENABLE</spirit:name>
          <spirit:displayName>CACHE_ENABLE</spirit:displayName>
          <spirit:description>   This field selects which level 2 caches receive commands such as cache flushes and tiler jobs. </spirit:description>
          <spirit:bitOffset>16</spirit:bitOffset>
          <spirit:bitWidth>16</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> This job slot is not allowed to dispatch tasks to L2 cache  n .</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> This job slot is allowed to dispatch tasks to L2 cache  n .</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>JS1_COMMAND</spirit:name>
        <spirit:displayName>JS1_COMMAND</spirit:displayName>
        <spirit:description>   Writing values to this register will control the job currently running in job slot  n . When the Job Manager encounters the end of a job chain, an interrupt is generated and (if appropriate) the contents of the next registers are transferred to the current registers, allowing immediate execution of a new job chain.  Jobs can be started only by writing to the JS  n _COMMAND_NEXT register, not this register, as this process depends on reliable transfer of the other values describing the job. A soft stop requests that no more tasks are issued for a job, and once all running tasks are finished, the job state is written to memory and the job suspended. It is possible to recover from this state and continue the job.  A hard stop simply aborts all running tasks for a job. No attempt is made to finish, write partial results, or save state. It will not be possible to resume a job after a hard stop, although it may be possible to restart it from scratch if it does not write to its own inputs. To do this, the driver must set the job status to STOPPED and also set the restart index to 0.  The conditional versions of SOFT_STOP and HARD_STOP are designed to eliminate race conditions when checking the JOB_CHAIN_FLAG, which is in the JS  n _CONFIG register. The stop command is only issued if the current state of the flag matches the value in the command name. If it does not match, then the command is treated like a NOP and nothing happens.</spirit:description>
        <spirit:addressOffset>0x20</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>JS1COMMAND</spirit:name>
          <spirit:displayName>JS1COMMAND</spirit:displayName>
          <spirit:description>   Added SUSPEND and RESUME commands to job chain  COMMAND register.</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>write-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NOP</spirit:name>
              <spirit:description> No operation, idle. Writing this value is ignored. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>START</spirit:name>
              <spirit:description> Start processing a job chain. Writing this value is ignored. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>SOFT_STOP</spirit:name>
              <spirit:description> Gently stop processing a job chain. Ignored if not running jobs. </spirit:description>
              <spirit:value>2</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>HARD_STOP</spirit:name>
              <spirit:description> Immediately stop processing a job chain. Ignored if not running jobs. </spirit:description>
              <spirit:value>3</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>SOFT_STOP_0</spirit:name>
              <spirit:description> Execute SOFT_STOP if JOB_CHAIN_FLAG is 0. </spirit:description>
              <spirit:value>4</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>HARD_STOP_0</spirit:name>
              <spirit:description> Execute HARD_STOP if JOB_CHAIN_FLAG is 0. </spirit:description>
              <spirit:value>5</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>SOFT_STOP_1</spirit:name>
              <spirit:description> Execute SOFT_STOP if JOB_CHAIN_FLAG is 1. </spirit:description>
              <spirit:value>6</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>HARD_STOP_1</spirit:name>
              <spirit:description> Execute HARD_STOP if JOB_CHAIN_FLAG is 1. </spirit:description>
              <spirit:value>7</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>SUSPEND</spirit:name>
              <spirit:description> Statefully suspend a job chain. Ignored if not running jobs. </spirit:description>
              <spirit:value>8</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>SUSPEND_0</spirit:name>
              <spirit:description> Execute SUSPEND if JOB_CHAIN_FLAG is 0. </spirit:description>
              <spirit:value>9</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>SUSPEND_1</spirit:name>
              <spirit:description> Execute SUSPEND if JOB_CHAIN_FLAG is 1. </spirit:description>
              <spirit:value>10</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>RESUME</spirit:name>
              <spirit:description> Resume a suspended job chain. </spirit:description>
              <spirit:value>11</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>JS1_STATUS</spirit:name>
        <spirit:displayName>JS1_STATUS</spirit:displayName>
        <spirit:description>   This register indicates the status of the job chain running in this job slot.  During typical operation, the status starts in state  NOT_STARTED , then switches to ACTIVE during job chain execution, and on completion the status will change to either DONE for successful execution, or another exception code if an error occurred. Corrected description of job slot STATUS register  If the GPU is in protected mode, this register will read as zero. </spirit:description>
        <spirit:addressOffset>0x24</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>Res87</spirit:name>
          <spirit:displayName>Res87</spirit:displayName>
          <spirit:description>Res87</spirit:description>
          <spirit:bitOffset>8</spirit:bitOffset>
          <spirit:bitWidth>24</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>EXCEPTION_TYPE</spirit:name>
          <spirit:displayName>EXCEPTION_TYPE</spirit:displayName>
          <spirit:description>   Added new MMU exception types.  Changed INTERRUPTED exception type to SUSPENDED.  Added exception types for new events EUREKA and KABOOM.  Removed aliases for OK - used to also be called IDLE and NOT_STARTED.  Documented that a KABOOM instruction will cause other jobs to hard-stop.  Removed OUT_OF_MEMORY_AFBC error as it can only occur with non-sparse allocation (now removed).  Removed INSTR_TYPE_MISMATCH, INSTR_OPERAND_FAULT, INSTR_TLS_FAULT, INSTR_ALIGN_FAULT; added IMPRECISE_FAULT (0x5B).  Split SHAREABILITY_FAULT into GPU_SHAREABILITY_FAULT, SYSTEM_SHAREABILITY_FAULT and GPU_CACHEABILITY_FAULT. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>8</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>OK</spirit:name>
              <spirit:description>   This indicates that the GPU has completed its work and is in a state ready to receive new commands. Its precise meaning depends on its usage:    In the job status field, this indicates that the job has not been started. This should be the initial state of a newly created job.  In the job slot status register, this indicates that the job slot is idle.  In the GPU and MMU exception status registers, this indicates that no exception has yet been received.  No additional error information is available (or indeed required). </spirit:description>
              <spirit:value>0x00</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>DONE</spirit:name>
              <spirit:description> The job completed successfully. The fault value is written to the job descriptor.
			The job descriptors fault address field contains the TIMESTAMP value when the job completed.
			If a job is terminated early using the  EUREKA instruction, then that job will be marked with the EUREKA exception status but the job chain status as a whole will still be DONE.</spirit:description>
              <spirit:value>0x01</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>SUSPENDED</spirit:name>
              <spirit:description> The job was interrupted by a SUSPEND command. The fault value is written both to the job slot  STATUS register and the job descriptor.
			The job descriptor contains the partition index of the first task to be interrupted. The fault address field contains the TIMESTAMP value when the job was interrupted.</spirit:description>
              <spirit:value>0x02</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>STOPPED</spirit:name>
              <spirit:description> The job was interrupted by a SOFT_STOP command. The fault value is written both to the job slot  STATUS register and the job descriptor.
			The job descriptor contains the partition index of the first task that was not completed. This will be the index of the first task issued if the job is resumed. The fault address is UNDEFINED .</spirit:description>
              <spirit:value>0x03</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TERMINATED</spirit:name>
              <spirit:description> The job was interrupted by a HARD_STOP command or a  KABOOM instruction from another job. The fault value is written both to the job slot STATUS register and the job descriptor.
			This status is treated in the same way as an error condition. The job descriptor contains the partition index of the first task to be terminated. The fault address field contains the TIMESTAMP value when the job was interrupted.</spirit:description>
              <spirit:value>0x04</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>KABOOM</spirit:name>
              <spirit:description> The job was interrupted by a shader executing a  KABOOM instruction. The fault value is written both to the job slot STATUS register and the job descriptor.
			This status is treated in the same way as an error condition. The job descriptor contains the partition index of the first task to be terminated. The fault address field contains the TIMESTAMP value when the job was interrupted.</spirit:description>
              <spirit:value>0x05</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>EUREKA</spirit:name>
              <spirit:description> The job was interrupted by a shader executing a  EUREKA instruction. The fault value is written only to the job descriptor, and does not affect subsequent jobs in the job chain.
			The job descriptor contains the partition index of the first task to be terminated. The fault address field contains the TIMESTAMP value when the job was interrupted.</spirit:description>
              <spirit:value>0x06</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ACTIVE</spirit:name>
              <spirit:description> In the JSn_STATUS register, this indicates that the job slot is active.
			The JSn_HEAD and JSn_TAIL registers contain the range of job descriptors currently in progress. </spirit:description>
              <spirit:value>0x08</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>JOB_CONFIG_FAULT</spirit:name>
              <spirit:description>   The job configuration specified in the job slot registers is invalid, so it is not possible to read job descriptors.
				For example this includes setting a NULL job descriptor pointer, selecting an address space that isnt present.
				No additional information is available. </spirit:description>
              <spirit:value>0x40</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>JOB_POWER_FAULT</spirit:name>
              <spirit:description>   The job could not be executed because the part of the memory system required to access job descriptors was not powered on.
				No additional information is available. </spirit:description>
              <spirit:value>0x41</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>JOB_READ_FAULT</spirit:name>
              <spirit:description>   Reading a job descriptor into the Job manager failed.
				The JSn_HEAD register contains the virtual address of the job descriptor that could not be read. </spirit:description>
              <spirit:value>0x42</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>JOB_WRITE_FAULT</spirit:name>
              <spirit:description>   Writing a job descriptor from the Job manager failed.
				The JSn_TAIL register contains the virtual address of the job descriptor that could not be written. </spirit:description>
              <spirit:value>0x43</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>JOB_AFFINITY_FAULT</spirit:name>
              <spirit:description>   The job could not be executed because the specified affinity mask does not intersect any available cores.
				No additional information is available. </spirit:description>
              <spirit:value>0x44</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>JOB_BUS_FAULT</spirit:name>
              <spirit:description>   A bus access failed while executing a job.
				The job descriptor contains the virtual address of the failing access, the type of access, and which part of the GPU initiated the access.
				This error code may also be reported if a bus fault occurs while writing the performance counters to memory. In this case, the GPU_FAULT* registers are updated, but the active JASID is not reported. It is possible to distinguish this case from a genuine Job Bus Fault exception by examining the SOURCE_ID field. </spirit:description>
              <spirit:value>0x48</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>INSTR_INVALID_PC</spirit:name>
              <spirit:description>   A shader instruction with an illegal program counter was executed.
				The job descriptors fault address field contains the offending program counter value. </spirit:description>
              <spirit:value>0x50</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>INSTR_INVALID_ENC</spirit:name>
              <spirit:description>   A shader instruction with an illegal encoding was executed.
				The job descriptors fault address field contains the program counter used to reach the offending instruction. </spirit:description>
              <spirit:value>0x51</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>INSTR_BARRIER_FAULT</spirit:name>
              <spirit:description>   A shader instruction was executed that failed to complete an instruction barrier.
				The job descriptors fault address field contains the program counter used to reach the offending instruction. </spirit:description>
              <spirit:value>0x55</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>DATA_INVALID_FAULT</spirit:name>
              <spirit:description>   Any data structure read as part of the job contains invalid combinations of data.
				The job descriptors fault address field contains the virtual address of the invalid data structure. </spirit:description>
              <spirit:value>0x58</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TILE_RANGE_FAULT</spirit:name>
              <spirit:description>   Tile or fragment shading was asked to process a tile that is entirely outside the bounding box of the frame.
				The job descriptors fault address field contains the coordinates of the top left corner of the failing tile, with X in the bits [15:0], and Y in the bits [31:16].  Clarified description of TILE_RANGE_FAULT. </spirit:description>
              <spirit:value>0x59</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ADDR_RANGE_FAULT</spirit:name>
              <spirit:description>   A virtual address has been found that exceeds the virtual address range.
				The job descriptors fault address field contains the virtual address which is out of range. </spirit:description>
              <spirit:value>0x5A</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>IMPRECISE_FAULT</spirit:name>
              <spirit:description>   A fault has been generated without precise fault information.
				This can happen if appropriate source information is not available at the point where the fault happens.
				The job descriptors fault address field may contain a virtual address related to the fault. </spirit:description>
              <spirit:value>0x5B</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>OUT_OF_MEMORY</spirit:name>
              <spirit:description>   The tiler ran out of memory when executing a job.
				The job descriptors fault address field contains the index of the last completed vertex sent through the tiler. </spirit:description>
              <spirit:value>0x60</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>UNKNOWN</spirit:name>
              <spirit:description>   If multiple jobs in a job chain fail, only the first one the reports an error will set and return full error information. Subsequent failing jobs will not update the error status registers, and may write an error status of UNKNOWN.
				Note that the first job to fail may not be the first job in the chain, which may lead to jobs with  UNKNOWN error status being encountered first when traversing the job chain.
				For example, you may see: Done, Done, Unknown, Bus Error, Unknown, New. In this case, the first two jobs ran successfully, the fourth job hit a bus error, and then jobs three and five also failed. The sixth and subsequent jobs had not been started at that point.</spirit:description>
              <spirit:value>0x7F</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>DELAYED_BUS_FAULT</spirit:name>
              <spirit:description>   The GPU received a bus fault for access to physical memory where the original virtual address is no longer available. This is the result of evicting a dirty line from a cache.
				This may also be triggered by a bus fault during a Tiler cache flush operation. In this case, the address reported in  GPU_FAULTADDRESS is a virtual address.</spirit:description>
              <spirit:value>0x80</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>GPU_SHAREABILITY_FAULT</spirit:name>
              <spirit:description>   A cache has detected that the same line has been accessed as both shareable and non-shareable memory from inside the GPU. Coherency after this point can no longer be guaranteed. </spirit:description>
              <spirit:value>0x88</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>SYSTEM_SHAREABILITY_FAULT</spirit:name>
              <spirit:description>   A cache has detected that the same line has been accessed as both shareable and non-shareable memory from outside the GPU. Coherency after this point can no longer be guaranteed. </spirit:description>
              <spirit:value>0x89</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>GPU_CACHEABILITY_FAULT</spirit:name>
              <spirit:description>   A cache has detected that the same line has been accessed as both cacheable and non-cacheable memory from inside the GPU. Non-cacheable memory may have been cached. </spirit:description>
              <spirit:value>0x8A</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TRANSLATION_FAULT_0</spirit:name>
              <spirit:description>   A memory access hit an invalid table entry at level 0 of the translation table. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xC0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TRANSLATION_FAULT_1</spirit:name>
              <spirit:description>   A memory access hit an invalid table entry at level 1 of the translation table. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xC1</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TRANSLATION_FAULT_2</spirit:name>
              <spirit:description>   A memory access hit an invalid table entry at level 2 of the translation table. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xC2</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TRANSLATION_FAULT_3</spirit:name>
              <spirit:description>   A memory access hit an invalid table entry at level 3 of the translation table. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xC3</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TRANSLATION_FAULT_IDENTITY</spirit:name>
              <spirit:description>   In IDENTITY translation mode, the virtual address exceeds the maximum physical address. </spirit:description>
              <spirit:value>0xC7</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>PERMISSION_FAULT_0</spirit:name>
              <spirit:description>   A memory access could not be allowed due to the permission flags set in level 0 of the translation table. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set. Added MMU translation level information to permission fault. </spirit:description>
              <spirit:value>0xC8</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>PERMISSION_FAULT_1</spirit:name>
              <spirit:description>   A memory access could not be allowed due to the permission flags set in level 1 of the translation table. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xC9</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>PERMISSION_FAULT_2</spirit:name>
              <spirit:description>   A memory access could not be allowed due to the permission flags set in level 2 of the translation table. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xCA</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>PERMISSION_FAULT_3</spirit:name>
              <spirit:description>   A memory access could not be allowed due to the permission flags set in level 3 of the translation table. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xCB</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TRANSTAB_BUS_FAULT_0</spirit:name>
              <spirit:description>   A bus fault occurred while reading level 0 of the translation tables. The appropriate  BUS_ERROR flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xD0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TRANSTAB_BUS_FAULT_1</spirit:name>
              <spirit:description>   A bus fault occurred while reading level 1 of the translation tables. The appropriate  BUS_ERROR flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xD1</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TRANSTAB_BUS_FAULT_2</spirit:name>
              <spirit:description>   A bus fault occurred while reading level 2 of the translation tables. The appropriate  BUS_ERROR flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xD2</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TRANSTAB_BUS_FAULT_3</spirit:name>
              <spirit:description>   A bus fault occurred while reading level 3 of the translation tables. The appropriate  BUS_ERROR flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xD3</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ACCESS_FLAG_0</spirit:name>
              <spirit:description>   A memory access hit a translation table entry with the ACCESS_FLAG bit set in level 0 of the translation table. This is not treated as a fault by the accessor. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set. Added MMU translation level information to access flag fault. </spirit:description>
              <spirit:value>0xD8</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ACCESS_FLAG_1</spirit:name>
              <spirit:description>   A memory access hit a translation table entry with the ACCESS_FLAG bit set in level 1 of the translation table. This is not treated as a fault by the accessor. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xD9</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ACCESS_FLAG_2</spirit:name>
              <spirit:description>   A memory access hit a translation table entry with the ACCESS_FLAG bit set in level 2 of the translation table. This is not treated as a fault by the accessor. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xDA</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ACCESS_FLAG_3</spirit:name>
              <spirit:description>   A memory access hit a translation table entry with the ACCESS_FLAG bit set in level 3 of the translation table. This is not treated as a fault by the accessor. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xDB</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ADDRESS_SIZE_FAULT_IN0</spirit:name>
              <spirit:description>   An input address size fault occurred while reading level 0 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ADDRESS_SIZE_FAULT_IN1</spirit:name>
              <spirit:description>   An input address size fault occurred while reading level 1 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE1</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ADDRESS_SIZE_FAULT_IN2</spirit:name>
              <spirit:description>   An input address size fault occurred while reading level 2 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE2</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ADDRESS_SIZE_FAULT_IN3</spirit:name>
              <spirit:description>   An input address size fault occurred while reading level 3 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE3</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ADDRESS_SIZE_FAULT_OUT0</spirit:name>
              <spirit:description>   An output address size fault occurred while reading level 0 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE4</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ADDRESS_SIZE_FAULT_OUT1</spirit:name>
              <spirit:description>   An output address size fault occurred while reading level 1 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE5</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ADDRESS_SIZE_FAULT_OUT2</spirit:name>
              <spirit:description>   An output address size fault occurred while reading level 2 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE6</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ADDRESS_SIZE_FAULT_OUT3</spirit:name>
              <spirit:description>   An output address size fault occurred while reading level 3 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE7</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>MEMORY_ATTRIBUTE_FAULT_0</spirit:name>
              <spirit:description>   A memory access could not be allowed due to an attempt to access a page with its memory attribute set to  FAULT in the MEMATTR register. This fault happened when reading level 0 of the translation tables. The appropriate PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE8</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>MEMORY_ATTRIBUTE_FAULT_1</spirit:name>
              <spirit:description>   A memory access could not be allowed due to an attempt to access a page with its memory attribute set to  FAULT in the MEMATTR register. This fault happened when reading level 1 of the translation tables. The appropriate PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE9</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>MEMORY_ATTRIBUTE_FAULT_2</spirit:name>
              <spirit:description>   A memory access could not be allowed due to an attempt to access a page with its memory attribute set to  FAULT in the MEMATTR register. This fault happened when reading level 2 of the translation tables. The appropriate PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xEA</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>MEMORY_ATTRIBUTE_FAULT_3</spirit:name>
              <spirit:description>   A memory access could not be allowed due to an attempt to access a page with its memory attribute set to  FAULT in the MEMATTR register. This fault happened when reading level 3 of the translation tables. The appropriate PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xEB</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>MEMORY_ATTRIBUTE_NONCACHEABLE_0</spirit:name>
              <spirit:description>   A memory access could not be allowed due to an attempt to access a non-cacheable page from a bus master which does not support non-cacheable accessess. This fault happened when reading level 0 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xEC</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>MEMORY_ATTRIBUTE_NONCACHEABLE_1</spirit:name>
              <spirit:description>   A memory access could not be allowed due to an attempt to access a non-cacheable page from a bus master which does not support non-cacheable accessess. This fault happened when reading level 1 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xED</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>MEMORY_ATTRIBUTE_NONCACHEABLE_2</spirit:name>
              <spirit:description>   A memory access could not be allowed due to an attempt to access a non-cacheable page from a bus master which does not support non-cacheable accessess. This fault happened when reading level 2 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xEE</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>MEMORY_ATTRIBUTE_NONCACHEABLE_3</spirit:name>
              <spirit:description>   A memory access could not be allowed due to an attempt to access a non-cacheable page from a bus master which does not support non-cacheable accessess. This fault happened when reading level 3 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xEF</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>JS1_FLUSH_ID</spirit:name>
        <spirit:displayName>JS1_FLUSH_ID</spirit:displayName>
        <spirit:description>   This register contains the current cache flush ID for this job slot. </spirit:description>
        <spirit:addressOffset>0x30</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>JS1FLUSH_ID</spirit:name>
          <spirit:displayName>JS1FLUSH_ID</spirit:displayName>
          <spirit:description>   When operating in "cache flush reduction" mode, each job chain has an associated ID which is used to identify cache flushes.  This ID is a sequential 32-bit value. When the job manager is asked to perform a flush, it compares the job chain flush ID with the latest flush ID. If the job chain ID is greater than the latest flush, then a flush is performed.  Care must be taken in the overflow case. If the software setting up the ID detects that an overflow may occur, the job chain should be tagged with the maximum value of the  LATEST_FLUSH register. This ensures that flushes are correctly performed, at the possible cost of a few redundant flushes. Added cache flush reduction </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>JS1_EVENT_0</spirit:name>
        <spirit:displayName>JS1_EVENT_0</spirit:displayName>
        <spirit:description>   This register is used to accumulate events for job chains where the job chain disambiguation bit is 0.  Added event registers to job slots. </spirit:description>
        <spirit:addressOffset>0x34</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>JS1EVENT_0</spirit:name>
          <spirit:displayName>JS1EVENT_0</spirit:displayName>
          <spirit:description>JS1EVENT_0</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> No event was received of type  n .</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> At least one event of type  n has been received.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>JS1_EVENT_1</spirit:name>
        <spirit:displayName>JS1_EVENT_1</spirit:displayName>
        <spirit:description>   This register is used to accumulate events for job chains where the job chain disambiguation bit is 1. </spirit:description>
        <spirit:addressOffset>0x38</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>JS1EVENT_1</spirit:name>
          <spirit:displayName>JS1EVENT_1</spirit:displayName>
          <spirit:description>JS1EVENT_1</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> No event was received of type  n .</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> At least one event of type  n has been received.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>JS1_EVENT_MASK</spirit:name>
        <spirit:displayName>JS1_EVENT_MASK</spirit:displayName>
        <spirit:description>   This register is the current event mask. </spirit:description>
        <spirit:addressOffset>0x3c</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>JS1EVENT_MASK</spirit:name>
          <spirit:displayName>JS1EVENT_MASK</spirit:displayName>
          <spirit:description>JS1EVENT_MASK</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> Event  n will not cause an interrupt.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Event  n will cause an interrupt.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>JS1_HEAD_NEXT_LO</spirit:name>
        <spirit:displayName>JS1_HEAD_NEXT_LO</spirit:displayName>
        <spirit:description>   This register contains the value to be transferred into the JS  n _HEAD register when the next job chain starts. See COMMAND_NEXT for details.</spirit:description>
        <spirit:addressOffset>0x40</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>JS1HEAD_NEXT_LO</spirit:name>
          <spirit:displayName>JS1HEAD_NEXT_LO</spirit:displayName>
          <spirit:description>   This register contains the address of the current job descriptor. The address is a virtual address in the address space specified by the ADDRESS_SPACE field in the JS  n _CONFIG register.</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>JS1_HEAD_NEXT_HI</spirit:name>
        <spirit:displayName>JS1_HEAD_NEXT_HI</spirit:displayName>
        <spirit:description>   This register contains the value to be transferred into the JS  n _HEAD register when the next job chain starts. See COMMAND_NEXT for details.</spirit:description>
        <spirit:addressOffset>0x44</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>JS1HEAD_NEXT_HI</spirit:name>
          <spirit:displayName>JS1HEAD_NEXT_HI</spirit:displayName>
          <spirit:description>   This register contains the address of the current job descriptor. The address is a virtual address in the address space specified by the ADDRESS_SPACE field in the JS  n _CONFIG register.</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>JS1_AFFINITY_NEXT_LO</spirit:name>
        <spirit:displayName>JS1_AFFINITY_NEXT_LO</spirit:displayName>
        <spirit:description>   This register contains the value to be transferred into the JS  n _AFFINITY register when the next job chain starts. See COMMAND_NEXT for details.</spirit:description>
        <spirit:addressOffset>0x50</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>JS1AFFINITY_NEXT_LO</spirit:name>
          <spirit:displayName>JS1AFFINITY_NEXT_LO</spirit:displayName>
          <spirit:description>JS1AFFINITY_NEXT_LO</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> This job slot is not allowed to dispatch tasks to shader core  n .</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> This job slot is allowed to dispatch tasks to shader core  n .</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>JS1_AFFINITY_NEXT_HI</spirit:name>
        <spirit:displayName>JS1_AFFINITY_NEXT_HI</spirit:displayName>
        <spirit:description>   This register contains the value to be transferred into the JS  n _AFFINITY register when the next job chain starts. See COMMAND_NEXT for details.</spirit:description>
        <spirit:addressOffset>0x54</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>JS1AFFINITY_NEXT_HI</spirit:name>
          <spirit:displayName>JS1AFFINITY_NEXT_HI</spirit:displayName>
          <spirit:description>JS1AFFINITY_NEXT_HI</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> This job slot is not allowed to dispatch tasks to shader core  n .</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> This job slot is allowed to dispatch tasks to shader core  n .</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>JS1_CONFIG_NEXT</spirit:name>
        <spirit:displayName>JS1_CONFIG_NEXT</spirit:displayName>
        <spirit:description>   This register contains the value to be transferred into the JS  n _CONFIG register when the next job chain starts. See COMMAND_NEXT for details.</spirit:description>
        <spirit:addressOffset>0x58</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>Res88</spirit:name>
          <spirit:displayName>Res88</spirit:displayName>
          <spirit:description>Res88</spirit:description>
          <spirit:bitOffset>4</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>Res89</spirit:name>
          <spirit:displayName>Res89</spirit:displayName>
          <spirit:description>Res89</spirit:description>
          <spirit:bitOffset>20</spirit:bitOffset>
          <spirit:bitWidth>12</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>ADDRESS_SPACE</spirit:name>
          <spirit:displayName>ADDRESS_SPACE</spirit:displayName>
          <spirit:description>   This is the ID of the address space to use for execution of all the jobs in this job chain.
						Address space configuration values are read from the AS  n registers.
						Specifying an address space that is not supported (i.e. the corresponding bit in AS_PRESENT is 0) may result in UNDEFINED behavior.</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>JOB_CHAIN_FLAG</spirit:name>
          <spirit:displayName>JOB_CHAIN_FLAG</spirit:displayName>
          <spirit:description>   The JOB_CHAIN_FLAG is set and read by software, and is used to disambiguate short-running job chains. It has no effect on the execution of a job, but is transferred intact from the JS  n _CONFIG_NEXT register to the JS n _CONFIG register when a job starts.</spirit:description>
          <spirit:bitOffset>11</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>THREAD_PRI</spirit:name>
          <spirit:displayName>THREAD_PRI</spirit:displayName>
          <spirit:description>   The thread priority is ordered so that high values will cause threads to be issued faster. Priority values are relative to the other jobs running  if no other jobs are issuing threads, this job will never be throttled even with low priorities.  How the priority values affect issue rates from different slots is implementation dependent. </spirit:description>
          <spirit:bitOffset>16</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>START_FLUSH</spirit:name>
          <spirit:displayName>START_FLUSH</spirit:displayName>
          <spirit:description>   Before the job chain is started, the selected action is applied to all caches except the tiler cache.  Clarified that cache flush behavior for Mimir deviates from spec.  In this implementation (MIMIR), this behavior is not fully implemented.
								Any non-zero value in this field will cause both a clean  and an invalidate for the read-write caches.
								If the value is 3, then the read-only caches are also invalidated, as specified.
								The flush command goes to all GPU cores enabled in the affinity mask, and the L2 cache.</spirit:description>
          <spirit:bitOffset>8</spirit:bitOffset>
          <spirit:bitWidth>2</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NO_ACTION</spirit:name>
              <spirit:description> No action is performed </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>CLEAN</spirit:name>
              <spirit:description> Cleans the shader core's load/store cache and other read/write L1 caches. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>INVALIDATE</spirit:name>
              <spirit:description> Cleans and invalidates the shader core's load/store cache and other read/write L1 caches, and also invalidates all read-only caches, namely:   All DCDs with a matching JASID. Texture descriptor cache entries matching invalidated DCDs. Sampler descriptor cache entries matching invalidated DCDs. For fragment endpoints only, all vertex loader cache lines with zero reference count.</spirit:description>
              <spirit:value>3</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>END_FLUSH</spirit:name>
          <spirit:displayName>END_FLUSH</spirit:displayName>
          <spirit:description>   After the job chain is finished, the selected action is applied to all caches including the tiler cache. This happens when the job chain ends with a success code, or a fault code other than JOB_CONFIG_FAULT or JOB_POWER_FAULT. In the case of JOB_CONFIG_FAULT and JOB_POWER_FAULT, the job chain could not even start and so no cache flush on end takes place.  Clarified that cache flush behavior for Mimir deviates from spec.  In this implementation (MIMIR), this behavior is not fully implemented.
								The flush command goes only to the L2 cache. The tiler cache is not affected.
								Any non-zero value in this field will cause both a clean  and an invalidate.</spirit:description>
          <spirit:bitOffset>12</spirit:bitOffset>
          <spirit:bitWidth>2</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NO_ACTION</spirit:name>
              <spirit:description> No action is performed </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>CLEAN</spirit:name>
              <spirit:description> Cleans the shader core's load/store cache and other read/write L1 caches. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>INVALIDATE</spirit:name>
              <spirit:description> Cleans and invalidates the shader core's load/store cache and other read/write L1 caches, and also invalidates all read-only caches, namely:   All DCDs with a matching JASID. Texture descriptor cache entries matching invalidated DCDs. Sampler descriptor cache entries matching invalidated DCDs. For fragment endpoints only, all vertex loader cache lines with zero reference count.</spirit:description>
              <spirit:value>3</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>START_MMU</spirit:name>
          <spirit:displayName>START_MMU</spirit:displayName>
          <spirit:description>START_MMU</spirit:description>
          <spirit:bitOffset>10</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> No MMU actions </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Before the job chain is started, the MMU is instructed to update. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ENABLE_FLUSH_REDUCTION</spirit:name>
          <spirit:displayName>ENABLE_FLUSH_REDUCTION</spirit:displayName>
          <spirit:description>   When operating in "cache flush reduction" mode, each job chain has an associated ID which is used to identify cache flushes.  This ID is a sequential 32-bit value. When the job manager is asked to perform a suppressable flush, it compares the job chain flush ID with the latest flush ID. If the job chain ID is greater than the latest flush, then a flush is performed. Otherwise, the flush  may be suppressed. Not all flushes can be suppressed, and not all suppressable flushes may be suppressed in any particular hardware implementation. In particular:    A CLEAN_INVALIDATE operation can replace a CLEAN, but not the other way around.  A CLEAN_INVALIDATE operation can be suppressed at the start of a job chain.  A CLEAN or CLEAN_INVALIDATE operation at the end of a job chain cannot be suppressed in the general case.  If software can guarantee that it will not read the result of a job chain until another job chain has been completed, then this is a case where the CLEAN or CLEAN_INVALIDATE operation at the end of a job chain could be suppressed. It is, however, simpler for software to signal this guarantee by simply not enabling the end-of-chain cache flush at all.  Explicit cache flush jobs are assumed to have been placed into the job chain for a reason, and are therefore not suppressed.  Clarified cache flush reduction  Added cache flush reduction </spirit:description>
          <spirit:bitOffset>14</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> No cache flush reduction is applied. Cache flushes are executed as they are encountered. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Cache flush reduction is enabled. Redundant cache flushes may be eliminated by hardware. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>DISABLE_DESCRIPTOR_WRITEBACK</spirit:name>
          <spirit:displayName>DISABLE_DESCRIPTOR_WRITEBACK</spirit:displayName>
          <spirit:description>   Normally, the status of each job in the job chain is written back as it is completed. This flag allows software to suppress that mechanism in cases where it is not required. Regardless of the setting of this flag, a job slot's  STATUS register is always updated on completion of its job chain. One of the reasons for writing back the status to the job descriptors is to guard against infinite loops in job chains. If this flag is set, then that protection is disabled and additional steps should be taken to detect and mitigate infinite loops.  Added  DISABLE_DESCRIPTOR_WRITEBACK flag to job slot CONFIG register.</spirit:description>
          <spirit:bitOffset>15</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> Status is written to job descriptor upon job completion. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Status is not written to job descriptor upon job completion. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>JS1_XAFFINITY_NEXT</spirit:name>
        <spirit:displayName>JS1_XAFFINITY_NEXT</spirit:displayName>
        <spirit:description>   This register contains the value to be transferred into the JS  n _XAFFINITY register when the next job chain starts. See COMMAND_NEXT for details.</spirit:description>
        <spirit:addressOffset>0x5c</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>Res90</spirit:name>
          <spirit:displayName>Res90</spirit:displayName>
          <spirit:description>Res90</spirit:description>
          <spirit:bitOffset>1</spirit:bitOffset>
          <spirit:bitWidth>7</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>XAFFINITY_ENABLE</spirit:name>
          <spirit:displayName>XAFFINITY_ENABLE</spirit:displayName>
          <spirit:description>XAFFINITY_ENABLE</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> This register is disabled.  Other fields in the register are ignored and treated as all-1s, so that all available resources are enabled. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> This register is enabled. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>TILER_ENABLE</spirit:name>
          <spirit:displayName>TILER_ENABLE</spirit:displayName>
          <spirit:description>   This field selects which tilers receive commands such as cache flushes and tiler jobs. </spirit:description>
          <spirit:bitOffset>8</spirit:bitOffset>
          <spirit:bitWidth>8</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> This job slot is not allowed to dispatch tasks to tiler unit  n .</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> This job slot is allowed to dispatch tasks to tiler unit  n .</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>CACHE_ENABLE</spirit:name>
          <spirit:displayName>CACHE_ENABLE</spirit:displayName>
          <spirit:description>   This field selects which level 2 caches receive commands such as cache flushes and tiler jobs. </spirit:description>
          <spirit:bitOffset>16</spirit:bitOffset>
          <spirit:bitWidth>16</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> This job slot is not allowed to dispatch tasks to L2 cache  n .</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> This job slot is allowed to dispatch tasks to L2 cache  n .</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>JS1_COMMAND_NEXT</spirit:name>
        <spirit:displayName>JS1_COMMAND_NEXT</spirit:displayName>
        <spirit:description>   When the current job chain is completed, if there are no unacknowledged errors from the previous job chain, and this register is not set to NOP,
					then the contents of the *_NEXT registers are transferred to the corresponding current * registers. This allows software to construct job chains one ahead and maintain throughput.  When the values are transferred, the JS  n _COMMAND_NEXT register is cleared, indicating a NOP. The register is then ready to accept a new command. The JS n _HEAD_NEXT register is also cleared at the same time. The state of the current job can be determined using JS n _STATUS. In order to prevent new chains being transferred in a half-completed state, data is transferred only when a START command is present in the JS  n _COMMAND_NEXT register. Therefore, software should initialize the other _NEXT registers first, and only write a START command to the JS n _COMMAND_NEXT register when the data for the next job is complete. If there is no job running in slot n when START is written to JS  n _COMMAND_NEXT, the next data is transferred immediately.
					If the next command value is anything except START, nothing happens. To stop jobs, write STOP commands to the JS  n _COMMAND register instead. If any status is returned from a job in the previous job chain other than DONE, the JOB_FAIL_  n bit for this job chain is set in the JOB_IRQ_RAWSTAT register, and the next job chain is not started. This allows software to retrieve the current register values. Software must indicate that it is ready to proceed by clearing the error interrupt bit, at which point the next job chain may be started.</spirit:description>
        <spirit:addressOffset>0x60</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>JS1COMMAND_NEXT</spirit:name>
          <spirit:displayName>JS1COMMAND_NEXT</spirit:displayName>
          <spirit:description>   Added SUSPEND and RESUME commands to job chain  COMMAND register.</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NOP</spirit:name>
              <spirit:description> No operation, idle. Writing this value is ignored. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>START</spirit:name>
              <spirit:description> Start processing a job chain. Writing this value is ignored. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>SOFT_STOP</spirit:name>
              <spirit:description> Gently stop processing a job chain. Ignored if not running jobs. </spirit:description>
              <spirit:value>2</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>HARD_STOP</spirit:name>
              <spirit:description> Immediately stop processing a job chain. Ignored if not running jobs. </spirit:description>
              <spirit:value>3</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>SOFT_STOP_0</spirit:name>
              <spirit:description> Execute SOFT_STOP if JOB_CHAIN_FLAG is 0. </spirit:description>
              <spirit:value>4</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>HARD_STOP_0</spirit:name>
              <spirit:description> Execute HARD_STOP if JOB_CHAIN_FLAG is 0. </spirit:description>
              <spirit:value>5</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>SOFT_STOP_1</spirit:name>
              <spirit:description> Execute SOFT_STOP if JOB_CHAIN_FLAG is 1. </spirit:description>
              <spirit:value>6</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>HARD_STOP_1</spirit:name>
              <spirit:description> Execute HARD_STOP if JOB_CHAIN_FLAG is 1. </spirit:description>
              <spirit:value>7</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>SUSPEND</spirit:name>
              <spirit:description> Statefully suspend a job chain. Ignored if not running jobs. </spirit:description>
              <spirit:value>8</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>SUSPEND_0</spirit:name>
              <spirit:description> Execute SUSPEND if JOB_CHAIN_FLAG is 0. </spirit:description>
              <spirit:value>9</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>SUSPEND_1</spirit:name>
              <spirit:description> Execute SUSPEND if JOB_CHAIN_FLAG is 1. </spirit:description>
              <spirit:value>10</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>RESUME</spirit:name>
              <spirit:description> Resume a suspended job chain. </spirit:description>
              <spirit:value>11</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>JS1_FLUSH_ID_NEXT</spirit:name>
        <spirit:displayName>JS1_FLUSH_ID_NEXT</spirit:displayName>
        <spirit:description>   This register contains the value to be transferred into the JS  n _FLUSH_ID register when the next job chain starts. See FLUSH_ID for details.</spirit:description>
        <spirit:addressOffset>0x70</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>JS1FLUSH_ID_NEXT</spirit:name>
          <spirit:displayName>JS1FLUSH_ID_NEXT</spirit:displayName>
          <spirit:description>   When operating in "cache flush reduction" mode, each job chain has an associated ID which is used to identify cache flushes.  This ID is a sequential 32-bit value. When the job manager is asked to perform a flush, it compares the job chain flush ID with the latest flush ID. If the job chain ID is greater than the latest flush, then a flush is performed.  Care must be taken in the overflow case. If the software setting up the ID detects that an overflow may occur, the job chain should be tagged with the maximum value of the  LATEST_FLUSH register. This ensures that flushes are correctly performed, at the possible cost of a few redundant flushes. Added cache flush reduction </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>JS1_EVENT_MASK_NEXT</spirit:name>
        <spirit:displayName>JS1_EVENT_MASK_NEXT</spirit:displayName>
        <spirit:description>   This register contains the value to be transferred into the JS  n _EVENT_MASK register when the next job chain starts. See EVENT_MASK for details.</spirit:description>
        <spirit:addressOffset>0x7c</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>JS1EVENT_MASK_NEXT</spirit:name>
          <spirit:displayName>JS1EVENT_MASK_NEXT</spirit:displayName>
          <spirit:description>JS1EVENT_MASK_NEXT</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> Event  n will not cause an interrupt.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Event  n will cause an interrupt.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
    </spirit:addressBlock>
    <spirit:addressBlock>
      <spirit:name>jm_job_slot2_regs</spirit:name>
      <spirit:baseAddress>6400</spirit:baseAddress>
      <spirit:range>128</spirit:range>
      <spirit:width>32</spirit:width>
      <spirit:usage>register</spirit:usage>
      <spirit:register>
        <spirit:name>JS2_HEAD_LO</spirit:name>
        <spirit:displayName>JS2_HEAD_LO</spirit:displayName>
        <spirit:description>   These registers exist for each supported job slot, with the prefix JS  n . To start a job chain, write the address to the first job descriptor into the JS  n _HEAD_NEXT register and write a START command to the JS n _COMMAND_NEXT register. When read, this register reflects the current position in the job chain. When the Job Manager has finished issuing tasks for a job, it will go on to the next job in the job chain, and update JS  n _HEAD. A job will disappear from JS  n _HEAD before it has finished processing all its tasks. See JS n _TAIL for how to discover this. Jobs newer than JS  n _HEAD may have been prefetched from memory, but will not yet have started processing. After an error, JS  n _HEAD contains the address of the first job (chronologically) that failed. The status registers contain the state of this job. If the GPU is in protected mode, this register will read as zero. </spirit:description>
        <spirit:addressOffset>0x0</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>JS2HEAD_LO</spirit:name>
          <spirit:displayName>JS2HEAD_LO</spirit:displayName>
          <spirit:description>   This register contains the address of the current job descriptor. The address is a virtual address in the address space specified by the ADDRESS_SPACE field in the JS  n _CONFIG register.</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>JS2_HEAD_HI</spirit:name>
        <spirit:displayName>JS2_HEAD_HI</spirit:displayName>
        <spirit:description>   These registers exist for each supported job slot, with the prefix JS  n . To start a job chain, write the address to the first job descriptor into the JS  n _HEAD_NEXT register and write a START command to the JS n _COMMAND_NEXT register. When read, this register reflects the current position in the job chain. When the Job Manager has finished issuing tasks for a job, it will go on to the next job in the job chain, and update JS  n _HEAD. A job will disappear from JS  n _HEAD before it has finished processing all its tasks. See JS n _TAIL for how to discover this. Jobs newer than JS  n _HEAD may have been prefetched from memory, but will not yet have started processing. After an error, JS  n _HEAD contains the address of the first job (chronologically) that failed. The status registers contain the state of this job. If the GPU is in protected mode, this register will read as zero. </spirit:description>
        <spirit:addressOffset>0x4</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>JS2HEAD_HI</spirit:name>
          <spirit:displayName>JS2HEAD_HI</spirit:displayName>
          <spirit:description>   This register contains the address of the current job descriptor. The address is a virtual address in the address space specified by the ADDRESS_SPACE field in the JS  n _CONFIG register.</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>JS2_TAIL_LO</spirit:name>
        <spirit:displayName>JS2_TAIL_LO</spirit:displayName>
        <spirit:description>   If the GPU is in protected mode, this register will read as zero. </spirit:description>
        <spirit:addressOffset>0x8</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>JS2TAIL_LO</spirit:name>
          <spirit:displayName>JS2TAIL_LO</spirit:displayName>
          <spirit:description>   This register contains the address of the oldest job that has finished issuing tasks, but is still running. The address is a virtual address in the address space specified by the ADDRESS_SPACE field in the JS  n _CONFIG register. All the jobs in a job chain from JS  n _TAIL to JS n _HEAD are in some way active in the GPU. Jobs older than JS n _TAIL are fully completed. Note that the value in the JS  n _TAIL register is updated when a new job starts. Therefore, this value is only valid while the JS n _STATUS register has the value ACTIVE. After an error, JS  n _TAIL contains the address of the first job in the chain that is not known to be successfully complete. Other jobs after this point may have completed successfully, but all jobs prior to this point are guaranteed have completed.
						In order to simplfy implementation of this feature, the position reported in JS n _TAIL is allowed to be conservative. However, scanning from this point forward in the chain will always be sufficient to identify all failing jobs.</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>JS2_TAIL_HI</spirit:name>
        <spirit:displayName>JS2_TAIL_HI</spirit:displayName>
        <spirit:description>   If the GPU is in protected mode, this register will read as zero. </spirit:description>
        <spirit:addressOffset>0xc</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>JS2TAIL_HI</spirit:name>
          <spirit:displayName>JS2TAIL_HI</spirit:displayName>
          <spirit:description>   This register contains the address of the oldest job that has finished issuing tasks, but is still running. The address is a virtual address in the address space specified by the ADDRESS_SPACE field in the JS  n _CONFIG register. All the jobs in a job chain from JS  n _TAIL to JS n _HEAD are in some way active in the GPU. Jobs older than JS n _TAIL are fully completed. Note that the value in the JS  n _TAIL register is updated when a new job starts. Therefore, this value is only valid while the JS n _STATUS register has the value ACTIVE. After an error, JS  n _TAIL contains the address of the first job in the chain that is not known to be successfully complete. Other jobs after this point may have completed successfully, but all jobs prior to this point are guaranteed have completed.
						In order to simplfy implementation of this feature, the position reported in JS n _TAIL is allowed to be conservative. However, scanning from this point forward in the chain will always be sufficient to identify all failing jobs.</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>JS2_AFFINITY_LO</spirit:name>
        <spirit:displayName>JS2_AFFINITY_LO</spirit:displayName>
        <spirit:description>   This register contains the current core affinity mask for this job slot. Only cores covered by the affinity mask are eligible for running tasks on. The mask is anded with the *_READY masks, and the resulting ones are the cores that can be used.  The affinity value is constant over a job chain. If you need to change affinity between jobs, then they must be split into separate job chains.See also JS  n _XAFFINITY</spirit:description>
        <spirit:addressOffset>0x10</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>JS2AFFINITY_LO</spirit:name>
          <spirit:displayName>JS2AFFINITY_LO</spirit:displayName>
          <spirit:description>JS2AFFINITY_LO</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> This job slot is not allowed to dispatch tasks to shader core  n .</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> This job slot is allowed to dispatch tasks to shader core  n .</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>JS2_AFFINITY_HI</spirit:name>
        <spirit:displayName>JS2_AFFINITY_HI</spirit:displayName>
        <spirit:description>   This register contains the current core affinity mask for this job slot. Only cores covered by the affinity mask are eligible for running tasks on. The mask is anded with the *_READY masks, and the resulting ones are the cores that can be used.  The affinity value is constant over a job chain. If you need to change affinity between jobs, then they must be split into separate job chains.See also JS  n _XAFFINITY</spirit:description>
        <spirit:addressOffset>0x14</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>JS2AFFINITY_HI</spirit:name>
          <spirit:displayName>JS2AFFINITY_HI</spirit:displayName>
          <spirit:description>JS2AFFINITY_HI</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> This job slot is not allowed to dispatch tasks to shader core  n .</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> This job slot is allowed to dispatch tasks to shader core  n .</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>JS2_CONFIG</spirit:name>
        <spirit:displayName>JS2_CONFIG</spirit:displayName>
        <spirit:description>   The job slot configuration register contains various configuration options for the jobs running in this job slot. </spirit:description>
        <spirit:addressOffset>0x18</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>Res91</spirit:name>
          <spirit:displayName>Res91</spirit:displayName>
          <spirit:description>Res91</spirit:description>
          <spirit:bitOffset>4</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>Res92</spirit:name>
          <spirit:displayName>Res92</spirit:displayName>
          <spirit:description>Res92</spirit:description>
          <spirit:bitOffset>20</spirit:bitOffset>
          <spirit:bitWidth>12</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>ADDRESS_SPACE</spirit:name>
          <spirit:displayName>ADDRESS_SPACE</spirit:displayName>
          <spirit:description>   This is the ID of the address space to use for execution of all the jobs in this job chain.
						Address space configuration values are read from the AS  n registers.
						Specifying an address space that is not supported (i.e. the corresponding bit in AS_PRESENT is 0) may result in UNDEFINED behavior.</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>JOB_CHAIN_FLAG</spirit:name>
          <spirit:displayName>JOB_CHAIN_FLAG</spirit:displayName>
          <spirit:description>   The JOB_CHAIN_FLAG is set and read by software, and is used to disambiguate short-running job chains. It has no effect on the execution of a job, but is transferred intact from the JS  n _CONFIG_NEXT register to the JS n _CONFIG register when a job starts.</spirit:description>
          <spirit:bitOffset>11</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>THREAD_PRI</spirit:name>
          <spirit:displayName>THREAD_PRI</spirit:displayName>
          <spirit:description>   The thread priority is ordered so that high values will cause threads to be issued faster. Priority values are relative to the other jobs running  if no other jobs are issuing threads, this job will never be throttled even with low priorities.  How the priority values affect issue rates from different slots is implementation dependent. </spirit:description>
          <spirit:bitOffset>16</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>START_FLUSH</spirit:name>
          <spirit:displayName>START_FLUSH</spirit:displayName>
          <spirit:description>   Before the job chain is started, the selected action is applied to all caches except the tiler cache.  Clarified that cache flush behavior for Mimir deviates from spec.  In this implementation (MIMIR), this behavior is not fully implemented.
								Any non-zero value in this field will cause both a clean  and an invalidate for the read-write caches.
								If the value is 3, then the read-only caches are also invalidated, as specified.
								The flush command goes to all GPU cores enabled in the affinity mask, and the L2 cache.</spirit:description>
          <spirit:bitOffset>8</spirit:bitOffset>
          <spirit:bitWidth>2</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NO_ACTION</spirit:name>
              <spirit:description> No action is performed </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>CLEAN</spirit:name>
              <spirit:description> Cleans the shader core's load/store cache and other read/write L1 caches. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>INVALIDATE</spirit:name>
              <spirit:description> Cleans and invalidates the shader core's load/store cache and other read/write L1 caches, and also invalidates all read-only caches, namely:   All DCDs with a matching JASID. Texture descriptor cache entries matching invalidated DCDs. Sampler descriptor cache entries matching invalidated DCDs. For fragment endpoints only, all vertex loader cache lines with zero reference count.</spirit:description>
              <spirit:value>3</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>END_FLUSH</spirit:name>
          <spirit:displayName>END_FLUSH</spirit:displayName>
          <spirit:description>   After the job chain is finished, the selected action is applied to all caches including the tiler cache. This happens when the job chain ends with a success code, or a fault code other than JOB_CONFIG_FAULT or JOB_POWER_FAULT. In the case of JOB_CONFIG_FAULT and JOB_POWER_FAULT, the job chain could not even start and so no cache flush on end takes place.  Clarified that cache flush behavior for Mimir deviates from spec.  In this implementation (MIMIR), this behavior is not fully implemented.
								The flush command goes only to the L2 cache. The tiler cache is not affected.
								Any non-zero value in this field will cause both a clean  and an invalidate.</spirit:description>
          <spirit:bitOffset>12</spirit:bitOffset>
          <spirit:bitWidth>2</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NO_ACTION</spirit:name>
              <spirit:description> No action is performed </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>CLEAN</spirit:name>
              <spirit:description> Cleans the shader core's load/store cache and other read/write L1 caches. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>INVALIDATE</spirit:name>
              <spirit:description> Cleans and invalidates the shader core's load/store cache and other read/write L1 caches, and also invalidates all read-only caches, namely:   All DCDs with a matching JASID. Texture descriptor cache entries matching invalidated DCDs. Sampler descriptor cache entries matching invalidated DCDs. For fragment endpoints only, all vertex loader cache lines with zero reference count.</spirit:description>
              <spirit:value>3</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>START_MMU</spirit:name>
          <spirit:displayName>START_MMU</spirit:displayName>
          <spirit:description>START_MMU</spirit:description>
          <spirit:bitOffset>10</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> No MMU actions </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Before the job chain is started, the MMU is instructed to update. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ENABLE_FLUSH_REDUCTION</spirit:name>
          <spirit:displayName>ENABLE_FLUSH_REDUCTION</spirit:displayName>
          <spirit:description>   When operating in "cache flush reduction" mode, each job chain has an associated ID which is used to identify cache flushes.  This ID is a sequential 32-bit value. When the job manager is asked to perform a suppressable flush, it compares the job chain flush ID with the latest flush ID. If the job chain ID is greater than the latest flush, then a flush is performed. Otherwise, the flush  may be suppressed. Not all flushes can be suppressed, and not all suppressable flushes may be suppressed in any particular hardware implementation. In particular:    A CLEAN_INVALIDATE operation can replace a CLEAN, but not the other way around.  A CLEAN_INVALIDATE operation can be suppressed at the start of a job chain.  A CLEAN or CLEAN_INVALIDATE operation at the end of a job chain cannot be suppressed in the general case.  If software can guarantee that it will not read the result of a job chain until another job chain has been completed, then this is a case where the CLEAN or CLEAN_INVALIDATE operation at the end of a job chain could be suppressed. It is, however, simpler for software to signal this guarantee by simply not enabling the end-of-chain cache flush at all.  Explicit cache flush jobs are assumed to have been placed into the job chain for a reason, and are therefore not suppressed.  Clarified cache flush reduction  Added cache flush reduction </spirit:description>
          <spirit:bitOffset>14</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> No cache flush reduction is applied. Cache flushes are executed as they are encountered. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Cache flush reduction is enabled. Redundant cache flushes may be eliminated by hardware. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>DISABLE_DESCRIPTOR_WRITEBACK</spirit:name>
          <spirit:displayName>DISABLE_DESCRIPTOR_WRITEBACK</spirit:displayName>
          <spirit:description>   Normally, the status of each job in the job chain is written back as it is completed. This flag allows software to suppress that mechanism in cases where it is not required. Regardless of the setting of this flag, a job slot's  STATUS register is always updated on completion of its job chain. One of the reasons for writing back the status to the job descriptors is to guard against infinite loops in job chains. If this flag is set, then that protection is disabled and additional steps should be taken to detect and mitigate infinite loops.  Added  DISABLE_DESCRIPTOR_WRITEBACK flag to job slot CONFIG register.</spirit:description>
          <spirit:bitOffset>15</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> Status is written to job descriptor upon job completion. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Status is not written to job descriptor upon job completion. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>JS2_XAFFINITY</spirit:name>
        <spirit:displayName>JS2_XAFFINITY</spirit:displayName>
        <spirit:description>   Additional affinity information for job slot  n exists in this register. Only resources covered by the affinity mask are eligible for receiving commands. The mask is anded with the appropriate bits from the TILER_PRESENT and L2_PRESENT masks, and the resulting ones are the resources that can be used.  The affinity value is constant over a job chain. If you need to change affinity between jobs, then they must be split into separate job chains. </spirit:description>
        <spirit:addressOffset>0x1c</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>Res93</spirit:name>
          <spirit:displayName>Res93</spirit:displayName>
          <spirit:description>Res93</spirit:description>
          <spirit:bitOffset>1</spirit:bitOffset>
          <spirit:bitWidth>7</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>XAFFINITY_ENABLE</spirit:name>
          <spirit:displayName>XAFFINITY_ENABLE</spirit:displayName>
          <spirit:description>XAFFINITY_ENABLE</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> This register is disabled.  Other fields in the register are ignored and treated as all-1s, so that all available resources are enabled. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> This register is enabled. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>TILER_ENABLE</spirit:name>
          <spirit:displayName>TILER_ENABLE</spirit:displayName>
          <spirit:description>   This field selects which tilers receive commands such as cache flushes and tiler jobs. </spirit:description>
          <spirit:bitOffset>8</spirit:bitOffset>
          <spirit:bitWidth>8</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> This job slot is not allowed to dispatch tasks to tiler unit  n .</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> This job slot is allowed to dispatch tasks to tiler unit  n .</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>CACHE_ENABLE</spirit:name>
          <spirit:displayName>CACHE_ENABLE</spirit:displayName>
          <spirit:description>   This field selects which level 2 caches receive commands such as cache flushes and tiler jobs. </spirit:description>
          <spirit:bitOffset>16</spirit:bitOffset>
          <spirit:bitWidth>16</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> This job slot is not allowed to dispatch tasks to L2 cache  n .</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> This job slot is allowed to dispatch tasks to L2 cache  n .</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>JS2_COMMAND</spirit:name>
        <spirit:displayName>JS2_COMMAND</spirit:displayName>
        <spirit:description>   Writing values to this register will control the job currently running in job slot  n . When the Job Manager encounters the end of a job chain, an interrupt is generated and (if appropriate) the contents of the next registers are transferred to the current registers, allowing immediate execution of a new job chain.  Jobs can be started only by writing to the JS  n _COMMAND_NEXT register, not this register, as this process depends on reliable transfer of the other values describing the job. A soft stop requests that no more tasks are issued for a job, and once all running tasks are finished, the job state is written to memory and the job suspended. It is possible to recover from this state and continue the job.  A hard stop simply aborts all running tasks for a job. No attempt is made to finish, write partial results, or save state. It will not be possible to resume a job after a hard stop, although it may be possible to restart it from scratch if it does not write to its own inputs. To do this, the driver must set the job status to STOPPED and also set the restart index to 0.  The conditional versions of SOFT_STOP and HARD_STOP are designed to eliminate race conditions when checking the JOB_CHAIN_FLAG, which is in the JS  n _CONFIG register. The stop command is only issued if the current state of the flag matches the value in the command name. If it does not match, then the command is treated like a NOP and nothing happens.</spirit:description>
        <spirit:addressOffset>0x20</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>JS2COMMAND</spirit:name>
          <spirit:displayName>JS2COMMAND</spirit:displayName>
          <spirit:description>   Added SUSPEND and RESUME commands to job chain  COMMAND register.</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>write-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NOP</spirit:name>
              <spirit:description> No operation, idle. Writing this value is ignored. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>START</spirit:name>
              <spirit:description> Start processing a job chain. Writing this value is ignored. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>SOFT_STOP</spirit:name>
              <spirit:description> Gently stop processing a job chain. Ignored if not running jobs. </spirit:description>
              <spirit:value>2</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>HARD_STOP</spirit:name>
              <spirit:description> Immediately stop processing a job chain. Ignored if not running jobs. </spirit:description>
              <spirit:value>3</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>SOFT_STOP_0</spirit:name>
              <spirit:description> Execute SOFT_STOP if JOB_CHAIN_FLAG is 0. </spirit:description>
              <spirit:value>4</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>HARD_STOP_0</spirit:name>
              <spirit:description> Execute HARD_STOP if JOB_CHAIN_FLAG is 0. </spirit:description>
              <spirit:value>5</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>SOFT_STOP_1</spirit:name>
              <spirit:description> Execute SOFT_STOP if JOB_CHAIN_FLAG is 1. </spirit:description>
              <spirit:value>6</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>HARD_STOP_1</spirit:name>
              <spirit:description> Execute HARD_STOP if JOB_CHAIN_FLAG is 1. </spirit:description>
              <spirit:value>7</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>SUSPEND</spirit:name>
              <spirit:description> Statefully suspend a job chain. Ignored if not running jobs. </spirit:description>
              <spirit:value>8</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>SUSPEND_0</spirit:name>
              <spirit:description> Execute SUSPEND if JOB_CHAIN_FLAG is 0. </spirit:description>
              <spirit:value>9</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>SUSPEND_1</spirit:name>
              <spirit:description> Execute SUSPEND if JOB_CHAIN_FLAG is 1. </spirit:description>
              <spirit:value>10</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>RESUME</spirit:name>
              <spirit:description> Resume a suspended job chain. </spirit:description>
              <spirit:value>11</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>JS2_STATUS</spirit:name>
        <spirit:displayName>JS2_STATUS</spirit:displayName>
        <spirit:description>   This register indicates the status of the job chain running in this job slot.  During typical operation, the status starts in state  NOT_STARTED , then switches to ACTIVE during job chain execution, and on completion the status will change to either DONE for successful execution, or another exception code if an error occurred. Corrected description of job slot STATUS register  If the GPU is in protected mode, this register will read as zero. </spirit:description>
        <spirit:addressOffset>0x24</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>Res94</spirit:name>
          <spirit:displayName>Res94</spirit:displayName>
          <spirit:description>Res94</spirit:description>
          <spirit:bitOffset>8</spirit:bitOffset>
          <spirit:bitWidth>24</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>EXCEPTION_TYPE</spirit:name>
          <spirit:displayName>EXCEPTION_TYPE</spirit:displayName>
          <spirit:description>   Added new MMU exception types.  Changed INTERRUPTED exception type to SUSPENDED.  Added exception types for new events EUREKA and KABOOM.  Removed aliases for OK - used to also be called IDLE and NOT_STARTED.  Documented that a KABOOM instruction will cause other jobs to hard-stop.  Removed OUT_OF_MEMORY_AFBC error as it can only occur with non-sparse allocation (now removed).  Removed INSTR_TYPE_MISMATCH, INSTR_OPERAND_FAULT, INSTR_TLS_FAULT, INSTR_ALIGN_FAULT; added IMPRECISE_FAULT (0x5B).  Split SHAREABILITY_FAULT into GPU_SHAREABILITY_FAULT, SYSTEM_SHAREABILITY_FAULT and GPU_CACHEABILITY_FAULT. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>8</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>OK</spirit:name>
              <spirit:description>   This indicates that the GPU has completed its work and is in a state ready to receive new commands. Its precise meaning depends on its usage:    In the job status field, this indicates that the job has not been started. This should be the initial state of a newly created job.  In the job slot status register, this indicates that the job slot is idle.  In the GPU and MMU exception status registers, this indicates that no exception has yet been received.  No additional error information is available (or indeed required). </spirit:description>
              <spirit:value>0x00</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>DONE</spirit:name>
              <spirit:description> The job completed successfully. The fault value is written to the job descriptor.
			The job descriptors fault address field contains the TIMESTAMP value when the job completed.
			If a job is terminated early using the  EUREKA instruction, then that job will be marked with the EUREKA exception status but the job chain status as a whole will still be DONE.</spirit:description>
              <spirit:value>0x01</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>SUSPENDED</spirit:name>
              <spirit:description> The job was interrupted by a SUSPEND command. The fault value is written both to the job slot  STATUS register and the job descriptor.
			The job descriptor contains the partition index of the first task to be interrupted. The fault address field contains the TIMESTAMP value when the job was interrupted.</spirit:description>
              <spirit:value>0x02</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>STOPPED</spirit:name>
              <spirit:description> The job was interrupted by a SOFT_STOP command. The fault value is written both to the job slot  STATUS register and the job descriptor.
			The job descriptor contains the partition index of the first task that was not completed. This will be the index of the first task issued if the job is resumed. The fault address is UNDEFINED .</spirit:description>
              <spirit:value>0x03</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TERMINATED</spirit:name>
              <spirit:description> The job was interrupted by a HARD_STOP command or a  KABOOM instruction from another job. The fault value is written both to the job slot STATUS register and the job descriptor.
			This status is treated in the same way as an error condition. The job descriptor contains the partition index of the first task to be terminated. The fault address field contains the TIMESTAMP value when the job was interrupted.</spirit:description>
              <spirit:value>0x04</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>KABOOM</spirit:name>
              <spirit:description> The job was interrupted by a shader executing a  KABOOM instruction. The fault value is written both to the job slot STATUS register and the job descriptor.
			This status is treated in the same way as an error condition. The job descriptor contains the partition index of the first task to be terminated. The fault address field contains the TIMESTAMP value when the job was interrupted.</spirit:description>
              <spirit:value>0x05</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>EUREKA</spirit:name>
              <spirit:description> The job was interrupted by a shader executing a  EUREKA instruction. The fault value is written only to the job descriptor, and does not affect subsequent jobs in the job chain.
			The job descriptor contains the partition index of the first task to be terminated. The fault address field contains the TIMESTAMP value when the job was interrupted.</spirit:description>
              <spirit:value>0x06</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ACTIVE</spirit:name>
              <spirit:description> In the JSn_STATUS register, this indicates that the job slot is active.
			The JSn_HEAD and JSn_TAIL registers contain the range of job descriptors currently in progress. </spirit:description>
              <spirit:value>0x08</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>JOB_CONFIG_FAULT</spirit:name>
              <spirit:description>   The job configuration specified in the job slot registers is invalid, so it is not possible to read job descriptors.
				For example this includes setting a NULL job descriptor pointer, selecting an address space that isnt present.
				No additional information is available. </spirit:description>
              <spirit:value>0x40</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>JOB_POWER_FAULT</spirit:name>
              <spirit:description>   The job could not be executed because the part of the memory system required to access job descriptors was not powered on.
				No additional information is available. </spirit:description>
              <spirit:value>0x41</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>JOB_READ_FAULT</spirit:name>
              <spirit:description>   Reading a job descriptor into the Job manager failed.
				The JSn_HEAD register contains the virtual address of the job descriptor that could not be read. </spirit:description>
              <spirit:value>0x42</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>JOB_WRITE_FAULT</spirit:name>
              <spirit:description>   Writing a job descriptor from the Job manager failed.
				The JSn_TAIL register contains the virtual address of the job descriptor that could not be written. </spirit:description>
              <spirit:value>0x43</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>JOB_AFFINITY_FAULT</spirit:name>
              <spirit:description>   The job could not be executed because the specified affinity mask does not intersect any available cores.
				No additional information is available. </spirit:description>
              <spirit:value>0x44</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>JOB_BUS_FAULT</spirit:name>
              <spirit:description>   A bus access failed while executing a job.
				The job descriptor contains the virtual address of the failing access, the type of access, and which part of the GPU initiated the access.
				This error code may also be reported if a bus fault occurs while writing the performance counters to memory. In this case, the GPU_FAULT* registers are updated, but the active JASID is not reported. It is possible to distinguish this case from a genuine Job Bus Fault exception by examining the SOURCE_ID field. </spirit:description>
              <spirit:value>0x48</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>INSTR_INVALID_PC</spirit:name>
              <spirit:description>   A shader instruction with an illegal program counter was executed.
				The job descriptors fault address field contains the offending program counter value. </spirit:description>
              <spirit:value>0x50</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>INSTR_INVALID_ENC</spirit:name>
              <spirit:description>   A shader instruction with an illegal encoding was executed.
				The job descriptors fault address field contains the program counter used to reach the offending instruction. </spirit:description>
              <spirit:value>0x51</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>INSTR_BARRIER_FAULT</spirit:name>
              <spirit:description>   A shader instruction was executed that failed to complete an instruction barrier.
				The job descriptors fault address field contains the program counter used to reach the offending instruction. </spirit:description>
              <spirit:value>0x55</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>DATA_INVALID_FAULT</spirit:name>
              <spirit:description>   Any data structure read as part of the job contains invalid combinations of data.
				The job descriptors fault address field contains the virtual address of the invalid data structure. </spirit:description>
              <spirit:value>0x58</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TILE_RANGE_FAULT</spirit:name>
              <spirit:description>   Tile or fragment shading was asked to process a tile that is entirely outside the bounding box of the frame.
				The job descriptors fault address field contains the coordinates of the top left corner of the failing tile, with X in the bits [15:0], and Y in the bits [31:16].  Clarified description of TILE_RANGE_FAULT. </spirit:description>
              <spirit:value>0x59</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ADDR_RANGE_FAULT</spirit:name>
              <spirit:description>   A virtual address has been found that exceeds the virtual address range.
				The job descriptors fault address field contains the virtual address which is out of range. </spirit:description>
              <spirit:value>0x5A</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>IMPRECISE_FAULT</spirit:name>
              <spirit:description>   A fault has been generated without precise fault information.
				This can happen if appropriate source information is not available at the point where the fault happens.
				The job descriptors fault address field may contain a virtual address related to the fault. </spirit:description>
              <spirit:value>0x5B</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>OUT_OF_MEMORY</spirit:name>
              <spirit:description>   The tiler ran out of memory when executing a job.
				The job descriptors fault address field contains the index of the last completed vertex sent through the tiler. </spirit:description>
              <spirit:value>0x60</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>UNKNOWN</spirit:name>
              <spirit:description>   If multiple jobs in a job chain fail, only the first one the reports an error will set and return full error information. Subsequent failing jobs will not update the error status registers, and may write an error status of UNKNOWN.
				Note that the first job to fail may not be the first job in the chain, which may lead to jobs with  UNKNOWN error status being encountered first when traversing the job chain.
				For example, you may see: Done, Done, Unknown, Bus Error, Unknown, New. In this case, the first two jobs ran successfully, the fourth job hit a bus error, and then jobs three and five also failed. The sixth and subsequent jobs had not been started at that point.</spirit:description>
              <spirit:value>0x7F</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>DELAYED_BUS_FAULT</spirit:name>
              <spirit:description>   The GPU received a bus fault for access to physical memory where the original virtual address is no longer available. This is the result of evicting a dirty line from a cache.
				This may also be triggered by a bus fault during a Tiler cache flush operation. In this case, the address reported in  GPU_FAULTADDRESS is a virtual address.</spirit:description>
              <spirit:value>0x80</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>GPU_SHAREABILITY_FAULT</spirit:name>
              <spirit:description>   A cache has detected that the same line has been accessed as both shareable and non-shareable memory from inside the GPU. Coherency after this point can no longer be guaranteed. </spirit:description>
              <spirit:value>0x88</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>SYSTEM_SHAREABILITY_FAULT</spirit:name>
              <spirit:description>   A cache has detected that the same line has been accessed as both shareable and non-shareable memory from outside the GPU. Coherency after this point can no longer be guaranteed. </spirit:description>
              <spirit:value>0x89</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>GPU_CACHEABILITY_FAULT</spirit:name>
              <spirit:description>   A cache has detected that the same line has been accessed as both cacheable and non-cacheable memory from inside the GPU. Non-cacheable memory may have been cached. </spirit:description>
              <spirit:value>0x8A</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TRANSLATION_FAULT_0</spirit:name>
              <spirit:description>   A memory access hit an invalid table entry at level 0 of the translation table. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xC0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TRANSLATION_FAULT_1</spirit:name>
              <spirit:description>   A memory access hit an invalid table entry at level 1 of the translation table. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xC1</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TRANSLATION_FAULT_2</spirit:name>
              <spirit:description>   A memory access hit an invalid table entry at level 2 of the translation table. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xC2</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TRANSLATION_FAULT_3</spirit:name>
              <spirit:description>   A memory access hit an invalid table entry at level 3 of the translation table. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xC3</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TRANSLATION_FAULT_IDENTITY</spirit:name>
              <spirit:description>   In IDENTITY translation mode, the virtual address exceeds the maximum physical address. </spirit:description>
              <spirit:value>0xC7</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>PERMISSION_FAULT_0</spirit:name>
              <spirit:description>   A memory access could not be allowed due to the permission flags set in level 0 of the translation table. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set. Added MMU translation level information to permission fault. </spirit:description>
              <spirit:value>0xC8</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>PERMISSION_FAULT_1</spirit:name>
              <spirit:description>   A memory access could not be allowed due to the permission flags set in level 1 of the translation table. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xC9</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>PERMISSION_FAULT_2</spirit:name>
              <spirit:description>   A memory access could not be allowed due to the permission flags set in level 2 of the translation table. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xCA</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>PERMISSION_FAULT_3</spirit:name>
              <spirit:description>   A memory access could not be allowed due to the permission flags set in level 3 of the translation table. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xCB</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TRANSTAB_BUS_FAULT_0</spirit:name>
              <spirit:description>   A bus fault occurred while reading level 0 of the translation tables. The appropriate  BUS_ERROR flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xD0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TRANSTAB_BUS_FAULT_1</spirit:name>
              <spirit:description>   A bus fault occurred while reading level 1 of the translation tables. The appropriate  BUS_ERROR flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xD1</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TRANSTAB_BUS_FAULT_2</spirit:name>
              <spirit:description>   A bus fault occurred while reading level 2 of the translation tables. The appropriate  BUS_ERROR flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xD2</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TRANSTAB_BUS_FAULT_3</spirit:name>
              <spirit:description>   A bus fault occurred while reading level 3 of the translation tables. The appropriate  BUS_ERROR flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xD3</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ACCESS_FLAG_0</spirit:name>
              <spirit:description>   A memory access hit a translation table entry with the ACCESS_FLAG bit set in level 0 of the translation table. This is not treated as a fault by the accessor. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set. Added MMU translation level information to access flag fault. </spirit:description>
              <spirit:value>0xD8</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ACCESS_FLAG_1</spirit:name>
              <spirit:description>   A memory access hit a translation table entry with the ACCESS_FLAG bit set in level 1 of the translation table. This is not treated as a fault by the accessor. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xD9</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ACCESS_FLAG_2</spirit:name>
              <spirit:description>   A memory access hit a translation table entry with the ACCESS_FLAG bit set in level 2 of the translation table. This is not treated as a fault by the accessor. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xDA</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ACCESS_FLAG_3</spirit:name>
              <spirit:description>   A memory access hit a translation table entry with the ACCESS_FLAG bit set in level 3 of the translation table. This is not treated as a fault by the accessor. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xDB</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ADDRESS_SIZE_FAULT_IN0</spirit:name>
              <spirit:description>   An input address size fault occurred while reading level 0 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ADDRESS_SIZE_FAULT_IN1</spirit:name>
              <spirit:description>   An input address size fault occurred while reading level 1 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE1</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ADDRESS_SIZE_FAULT_IN2</spirit:name>
              <spirit:description>   An input address size fault occurred while reading level 2 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE2</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ADDRESS_SIZE_FAULT_IN3</spirit:name>
              <spirit:description>   An input address size fault occurred while reading level 3 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE3</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ADDRESS_SIZE_FAULT_OUT0</spirit:name>
              <spirit:description>   An output address size fault occurred while reading level 0 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE4</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ADDRESS_SIZE_FAULT_OUT1</spirit:name>
              <spirit:description>   An output address size fault occurred while reading level 1 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE5</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ADDRESS_SIZE_FAULT_OUT2</spirit:name>
              <spirit:description>   An output address size fault occurred while reading level 2 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE6</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ADDRESS_SIZE_FAULT_OUT3</spirit:name>
              <spirit:description>   An output address size fault occurred while reading level 3 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE7</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>MEMORY_ATTRIBUTE_FAULT_0</spirit:name>
              <spirit:description>   A memory access could not be allowed due to an attempt to access a page with its memory attribute set to  FAULT in the MEMATTR register. This fault happened when reading level 0 of the translation tables. The appropriate PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE8</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>MEMORY_ATTRIBUTE_FAULT_1</spirit:name>
              <spirit:description>   A memory access could not be allowed due to an attempt to access a page with its memory attribute set to  FAULT in the MEMATTR register. This fault happened when reading level 1 of the translation tables. The appropriate PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE9</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>MEMORY_ATTRIBUTE_FAULT_2</spirit:name>
              <spirit:description>   A memory access could not be allowed due to an attempt to access a page with its memory attribute set to  FAULT in the MEMATTR register. This fault happened when reading level 2 of the translation tables. The appropriate PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xEA</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>MEMORY_ATTRIBUTE_FAULT_3</spirit:name>
              <spirit:description>   A memory access could not be allowed due to an attempt to access a page with its memory attribute set to  FAULT in the MEMATTR register. This fault happened when reading level 3 of the translation tables. The appropriate PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xEB</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>MEMORY_ATTRIBUTE_NONCACHEABLE_0</spirit:name>
              <spirit:description>   A memory access could not be allowed due to an attempt to access a non-cacheable page from a bus master which does not support non-cacheable accessess. This fault happened when reading level 0 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xEC</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>MEMORY_ATTRIBUTE_NONCACHEABLE_1</spirit:name>
              <spirit:description>   A memory access could not be allowed due to an attempt to access a non-cacheable page from a bus master which does not support non-cacheable accessess. This fault happened when reading level 1 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xED</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>MEMORY_ATTRIBUTE_NONCACHEABLE_2</spirit:name>
              <spirit:description>   A memory access could not be allowed due to an attempt to access a non-cacheable page from a bus master which does not support non-cacheable accessess. This fault happened when reading level 2 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xEE</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>MEMORY_ATTRIBUTE_NONCACHEABLE_3</spirit:name>
              <spirit:description>   A memory access could not be allowed due to an attempt to access a non-cacheable page from a bus master which does not support non-cacheable accessess. This fault happened when reading level 3 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xEF</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>JS2_FLUSH_ID</spirit:name>
        <spirit:displayName>JS2_FLUSH_ID</spirit:displayName>
        <spirit:description>   This register contains the current cache flush ID for this job slot. </spirit:description>
        <spirit:addressOffset>0x30</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>JS2FLUSH_ID</spirit:name>
          <spirit:displayName>JS2FLUSH_ID</spirit:displayName>
          <spirit:description>   When operating in "cache flush reduction" mode, each job chain has an associated ID which is used to identify cache flushes.  This ID is a sequential 32-bit value. When the job manager is asked to perform a flush, it compares the job chain flush ID with the latest flush ID. If the job chain ID is greater than the latest flush, then a flush is performed.  Care must be taken in the overflow case. If the software setting up the ID detects that an overflow may occur, the job chain should be tagged with the maximum value of the  LATEST_FLUSH register. This ensures that flushes are correctly performed, at the possible cost of a few redundant flushes. Added cache flush reduction </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>JS2_EVENT_0</spirit:name>
        <spirit:displayName>JS2_EVENT_0</spirit:displayName>
        <spirit:description>   This register is used to accumulate events for job chains where the job chain disambiguation bit is 0.  Added event registers to job slots. </spirit:description>
        <spirit:addressOffset>0x34</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>JS2EVENT_0</spirit:name>
          <spirit:displayName>JS2EVENT_0</spirit:displayName>
          <spirit:description>JS2EVENT_0</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> No event was received of type  n .</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> At least one event of type  n has been received.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>JS2_EVENT_1</spirit:name>
        <spirit:displayName>JS2_EVENT_1</spirit:displayName>
        <spirit:description>   This register is used to accumulate events for job chains where the job chain disambiguation bit is 1. </spirit:description>
        <spirit:addressOffset>0x38</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>JS2EVENT_1</spirit:name>
          <spirit:displayName>JS2EVENT_1</spirit:displayName>
          <spirit:description>JS2EVENT_1</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> No event was received of type  n .</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> At least one event of type  n has been received.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>JS2_EVENT_MASK</spirit:name>
        <spirit:displayName>JS2_EVENT_MASK</spirit:displayName>
        <spirit:description>   This register is the current event mask. </spirit:description>
        <spirit:addressOffset>0x3c</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>JS2EVENT_MASK</spirit:name>
          <spirit:displayName>JS2EVENT_MASK</spirit:displayName>
          <spirit:description>JS2EVENT_MASK</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> Event  n will not cause an interrupt.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Event  n will cause an interrupt.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>JS2_HEAD_NEXT_LO</spirit:name>
        <spirit:displayName>JS2_HEAD_NEXT_LO</spirit:displayName>
        <spirit:description>   This register contains the value to be transferred into the JS  n _HEAD register when the next job chain starts. See COMMAND_NEXT for details.</spirit:description>
        <spirit:addressOffset>0x40</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>JS2HEAD_NEXT_LO</spirit:name>
          <spirit:displayName>JS2HEAD_NEXT_LO</spirit:displayName>
          <spirit:description>   This register contains the address of the current job descriptor. The address is a virtual address in the address space specified by the ADDRESS_SPACE field in the JS  n _CONFIG register.</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>JS2_HEAD_NEXT_HI</spirit:name>
        <spirit:displayName>JS2_HEAD_NEXT_HI</spirit:displayName>
        <spirit:description>   This register contains the value to be transferred into the JS  n _HEAD register when the next job chain starts. See COMMAND_NEXT for details.</spirit:description>
        <spirit:addressOffset>0x44</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>JS2HEAD_NEXT_HI</spirit:name>
          <spirit:displayName>JS2HEAD_NEXT_HI</spirit:displayName>
          <spirit:description>   This register contains the address of the current job descriptor. The address is a virtual address in the address space specified by the ADDRESS_SPACE field in the JS  n _CONFIG register.</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>JS2_AFFINITY_NEXT_LO</spirit:name>
        <spirit:displayName>JS2_AFFINITY_NEXT_LO</spirit:displayName>
        <spirit:description>   This register contains the value to be transferred into the JS  n _AFFINITY register when the next job chain starts. See COMMAND_NEXT for details.</spirit:description>
        <spirit:addressOffset>0x50</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>JS2AFFINITY_NEXT_LO</spirit:name>
          <spirit:displayName>JS2AFFINITY_NEXT_LO</spirit:displayName>
          <spirit:description>JS2AFFINITY_NEXT_LO</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> This job slot is not allowed to dispatch tasks to shader core  n .</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> This job slot is allowed to dispatch tasks to shader core  n .</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>JS2_AFFINITY_NEXT_HI</spirit:name>
        <spirit:displayName>JS2_AFFINITY_NEXT_HI</spirit:displayName>
        <spirit:description>   This register contains the value to be transferred into the JS  n _AFFINITY register when the next job chain starts. See COMMAND_NEXT for details.</spirit:description>
        <spirit:addressOffset>0x54</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>JS2AFFINITY_NEXT_HI</spirit:name>
          <spirit:displayName>JS2AFFINITY_NEXT_HI</spirit:displayName>
          <spirit:description>JS2AFFINITY_NEXT_HI</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> This job slot is not allowed to dispatch tasks to shader core  n .</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> This job slot is allowed to dispatch tasks to shader core  n .</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>JS2_CONFIG_NEXT</spirit:name>
        <spirit:displayName>JS2_CONFIG_NEXT</spirit:displayName>
        <spirit:description>   This register contains the value to be transferred into the JS  n _CONFIG register when the next job chain starts. See COMMAND_NEXT for details.</spirit:description>
        <spirit:addressOffset>0x58</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>Res95</spirit:name>
          <spirit:displayName>Res95</spirit:displayName>
          <spirit:description>Res95</spirit:description>
          <spirit:bitOffset>4</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>Res96</spirit:name>
          <spirit:displayName>Res96</spirit:displayName>
          <spirit:description>Res96</spirit:description>
          <spirit:bitOffset>20</spirit:bitOffset>
          <spirit:bitWidth>12</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>ADDRESS_SPACE</spirit:name>
          <spirit:displayName>ADDRESS_SPACE</spirit:displayName>
          <spirit:description>   This is the ID of the address space to use for execution of all the jobs in this job chain.
						Address space configuration values are read from the AS  n registers.
						Specifying an address space that is not supported (i.e. the corresponding bit in AS_PRESENT is 0) may result in UNDEFINED behavior.</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>JOB_CHAIN_FLAG</spirit:name>
          <spirit:displayName>JOB_CHAIN_FLAG</spirit:displayName>
          <spirit:description>   The JOB_CHAIN_FLAG is set and read by software, and is used to disambiguate short-running job chains. It has no effect on the execution of a job, but is transferred intact from the JS  n _CONFIG_NEXT register to the JS n _CONFIG register when a job starts.</spirit:description>
          <spirit:bitOffset>11</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>THREAD_PRI</spirit:name>
          <spirit:displayName>THREAD_PRI</spirit:displayName>
          <spirit:description>   The thread priority is ordered so that high values will cause threads to be issued faster. Priority values are relative to the other jobs running  if no other jobs are issuing threads, this job will never be throttled even with low priorities.  How the priority values affect issue rates from different slots is implementation dependent. </spirit:description>
          <spirit:bitOffset>16</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>START_FLUSH</spirit:name>
          <spirit:displayName>START_FLUSH</spirit:displayName>
          <spirit:description>   Before the job chain is started, the selected action is applied to all caches except the tiler cache.  Clarified that cache flush behavior for Mimir deviates from spec.  In this implementation (MIMIR), this behavior is not fully implemented.
								Any non-zero value in this field will cause both a clean  and an invalidate for the read-write caches.
								If the value is 3, then the read-only caches are also invalidated, as specified.
								The flush command goes to all GPU cores enabled in the affinity mask, and the L2 cache.</spirit:description>
          <spirit:bitOffset>8</spirit:bitOffset>
          <spirit:bitWidth>2</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NO_ACTION</spirit:name>
              <spirit:description> No action is performed </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>CLEAN</spirit:name>
              <spirit:description> Cleans the shader core's load/store cache and other read/write L1 caches. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>INVALIDATE</spirit:name>
              <spirit:description> Cleans and invalidates the shader core's load/store cache and other read/write L1 caches, and also invalidates all read-only caches, namely:   All DCDs with a matching JASID. Texture descriptor cache entries matching invalidated DCDs. Sampler descriptor cache entries matching invalidated DCDs. For fragment endpoints only, all vertex loader cache lines with zero reference count.</spirit:description>
              <spirit:value>3</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>END_FLUSH</spirit:name>
          <spirit:displayName>END_FLUSH</spirit:displayName>
          <spirit:description>   After the job chain is finished, the selected action is applied to all caches including the tiler cache. This happens when the job chain ends with a success code, or a fault code other than JOB_CONFIG_FAULT or JOB_POWER_FAULT. In the case of JOB_CONFIG_FAULT and JOB_POWER_FAULT, the job chain could not even start and so no cache flush on end takes place.  Clarified that cache flush behavior for Mimir deviates from spec.  In this implementation (MIMIR), this behavior is not fully implemented.
								The flush command goes only to the L2 cache. The tiler cache is not affected.
								Any non-zero value in this field will cause both a clean  and an invalidate.</spirit:description>
          <spirit:bitOffset>12</spirit:bitOffset>
          <spirit:bitWidth>2</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NO_ACTION</spirit:name>
              <spirit:description> No action is performed </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>CLEAN</spirit:name>
              <spirit:description> Cleans the shader core's load/store cache and other read/write L1 caches. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>INVALIDATE</spirit:name>
              <spirit:description> Cleans and invalidates the shader core's load/store cache and other read/write L1 caches, and also invalidates all read-only caches, namely:   All DCDs with a matching JASID. Texture descriptor cache entries matching invalidated DCDs. Sampler descriptor cache entries matching invalidated DCDs. For fragment endpoints only, all vertex loader cache lines with zero reference count.</spirit:description>
              <spirit:value>3</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>START_MMU</spirit:name>
          <spirit:displayName>START_MMU</spirit:displayName>
          <spirit:description>START_MMU</spirit:description>
          <spirit:bitOffset>10</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> No MMU actions </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Before the job chain is started, the MMU is instructed to update. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ENABLE_FLUSH_REDUCTION</spirit:name>
          <spirit:displayName>ENABLE_FLUSH_REDUCTION</spirit:displayName>
          <spirit:description>   When operating in "cache flush reduction" mode, each job chain has an associated ID which is used to identify cache flushes.  This ID is a sequential 32-bit value. When the job manager is asked to perform a suppressable flush, it compares the job chain flush ID with the latest flush ID. If the job chain ID is greater than the latest flush, then a flush is performed. Otherwise, the flush  may be suppressed. Not all flushes can be suppressed, and not all suppressable flushes may be suppressed in any particular hardware implementation. In particular:    A CLEAN_INVALIDATE operation can replace a CLEAN, but not the other way around.  A CLEAN_INVALIDATE operation can be suppressed at the start of a job chain.  A CLEAN or CLEAN_INVALIDATE operation at the end of a job chain cannot be suppressed in the general case.  If software can guarantee that it will not read the result of a job chain until another job chain has been completed, then this is a case where the CLEAN or CLEAN_INVALIDATE operation at the end of a job chain could be suppressed. It is, however, simpler for software to signal this guarantee by simply not enabling the end-of-chain cache flush at all.  Explicit cache flush jobs are assumed to have been placed into the job chain for a reason, and are therefore not suppressed.  Clarified cache flush reduction  Added cache flush reduction </spirit:description>
          <spirit:bitOffset>14</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> No cache flush reduction is applied. Cache flushes are executed as they are encountered. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Cache flush reduction is enabled. Redundant cache flushes may be eliminated by hardware. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>DISABLE_DESCRIPTOR_WRITEBACK</spirit:name>
          <spirit:displayName>DISABLE_DESCRIPTOR_WRITEBACK</spirit:displayName>
          <spirit:description>   Normally, the status of each job in the job chain is written back as it is completed. This flag allows software to suppress that mechanism in cases where it is not required. Regardless of the setting of this flag, a job slot's  STATUS register is always updated on completion of its job chain. One of the reasons for writing back the status to the job descriptors is to guard against infinite loops in job chains. If this flag is set, then that protection is disabled and additional steps should be taken to detect and mitigate infinite loops.  Added  DISABLE_DESCRIPTOR_WRITEBACK flag to job slot CONFIG register.</spirit:description>
          <spirit:bitOffset>15</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> Status is written to job descriptor upon job completion. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Status is not written to job descriptor upon job completion. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>JS2_XAFFINITY_NEXT</spirit:name>
        <spirit:displayName>JS2_XAFFINITY_NEXT</spirit:displayName>
        <spirit:description>   This register contains the value to be transferred into the JS  n _XAFFINITY register when the next job chain starts. See COMMAND_NEXT for details.</spirit:description>
        <spirit:addressOffset>0x5c</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>Res97</spirit:name>
          <spirit:displayName>Res97</spirit:displayName>
          <spirit:description>Res97</spirit:description>
          <spirit:bitOffset>1</spirit:bitOffset>
          <spirit:bitWidth>7</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>XAFFINITY_ENABLE</spirit:name>
          <spirit:displayName>XAFFINITY_ENABLE</spirit:displayName>
          <spirit:description>XAFFINITY_ENABLE</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> This register is disabled.  Other fields in the register are ignored and treated as all-1s, so that all available resources are enabled. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> This register is enabled. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>TILER_ENABLE</spirit:name>
          <spirit:displayName>TILER_ENABLE</spirit:displayName>
          <spirit:description>   This field selects which tilers receive commands such as cache flushes and tiler jobs. </spirit:description>
          <spirit:bitOffset>8</spirit:bitOffset>
          <spirit:bitWidth>8</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> This job slot is not allowed to dispatch tasks to tiler unit  n .</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> This job slot is allowed to dispatch tasks to tiler unit  n .</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>CACHE_ENABLE</spirit:name>
          <spirit:displayName>CACHE_ENABLE</spirit:displayName>
          <spirit:description>   This field selects which level 2 caches receive commands such as cache flushes and tiler jobs. </spirit:description>
          <spirit:bitOffset>16</spirit:bitOffset>
          <spirit:bitWidth>16</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> This job slot is not allowed to dispatch tasks to L2 cache  n .</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> This job slot is allowed to dispatch tasks to L2 cache  n .</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>JS2_COMMAND_NEXT</spirit:name>
        <spirit:displayName>JS2_COMMAND_NEXT</spirit:displayName>
        <spirit:description>   When the current job chain is completed, if there are no unacknowledged errors from the previous job chain, and this register is not set to NOP,
					then the contents of the *_NEXT registers are transferred to the corresponding current * registers. This allows software to construct job chains one ahead and maintain throughput.  When the values are transferred, the JS  n _COMMAND_NEXT register is cleared, indicating a NOP. The register is then ready to accept a new command. The JS n _HEAD_NEXT register is also cleared at the same time. The state of the current job can be determined using JS n _STATUS. In order to prevent new chains being transferred in a half-completed state, data is transferred only when a START command is present in the JS  n _COMMAND_NEXT register. Therefore, software should initialize the other _NEXT registers first, and only write a START command to the JS n _COMMAND_NEXT register when the data for the next job is complete. If there is no job running in slot n when START is written to JS  n _COMMAND_NEXT, the next data is transferred immediately.
					If the next command value is anything except START, nothing happens. To stop jobs, write STOP commands to the JS  n _COMMAND register instead. If any status is returned from a job in the previous job chain other than DONE, the JOB_FAIL_  n bit for this job chain is set in the JOB_IRQ_RAWSTAT register, and the next job chain is not started. This allows software to retrieve the current register values. Software must indicate that it is ready to proceed by clearing the error interrupt bit, at which point the next job chain may be started.</spirit:description>
        <spirit:addressOffset>0x60</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>JS2COMMAND_NEXT</spirit:name>
          <spirit:displayName>JS2COMMAND_NEXT</spirit:displayName>
          <spirit:description>   Added SUSPEND and RESUME commands to job chain  COMMAND register.</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NOP</spirit:name>
              <spirit:description> No operation, idle. Writing this value is ignored. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>START</spirit:name>
              <spirit:description> Start processing a job chain. Writing this value is ignored. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>SOFT_STOP</spirit:name>
              <spirit:description> Gently stop processing a job chain. Ignored if not running jobs. </spirit:description>
              <spirit:value>2</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>HARD_STOP</spirit:name>
              <spirit:description> Immediately stop processing a job chain. Ignored if not running jobs. </spirit:description>
              <spirit:value>3</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>SOFT_STOP_0</spirit:name>
              <spirit:description> Execute SOFT_STOP if JOB_CHAIN_FLAG is 0. </spirit:description>
              <spirit:value>4</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>HARD_STOP_0</spirit:name>
              <spirit:description> Execute HARD_STOP if JOB_CHAIN_FLAG is 0. </spirit:description>
              <spirit:value>5</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>SOFT_STOP_1</spirit:name>
              <spirit:description> Execute SOFT_STOP if JOB_CHAIN_FLAG is 1. </spirit:description>
              <spirit:value>6</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>HARD_STOP_1</spirit:name>
              <spirit:description> Execute HARD_STOP if JOB_CHAIN_FLAG is 1. </spirit:description>
              <spirit:value>7</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>SUSPEND</spirit:name>
              <spirit:description> Statefully suspend a job chain. Ignored if not running jobs. </spirit:description>
              <spirit:value>8</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>SUSPEND_0</spirit:name>
              <spirit:description> Execute SUSPEND if JOB_CHAIN_FLAG is 0. </spirit:description>
              <spirit:value>9</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>SUSPEND_1</spirit:name>
              <spirit:description> Execute SUSPEND if JOB_CHAIN_FLAG is 1. </spirit:description>
              <spirit:value>10</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>RESUME</spirit:name>
              <spirit:description> Resume a suspended job chain. </spirit:description>
              <spirit:value>11</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>JS2_FLUSH_ID_NEXT</spirit:name>
        <spirit:displayName>JS2_FLUSH_ID_NEXT</spirit:displayName>
        <spirit:description>   This register contains the value to be transferred into the JS  n _FLUSH_ID register when the next job chain starts. See FLUSH_ID for details.</spirit:description>
        <spirit:addressOffset>0x70</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>JS2FLUSH_ID_NEXT</spirit:name>
          <spirit:displayName>JS2FLUSH_ID_NEXT</spirit:displayName>
          <spirit:description>   When operating in "cache flush reduction" mode, each job chain has an associated ID which is used to identify cache flushes.  This ID is a sequential 32-bit value. When the job manager is asked to perform a flush, it compares the job chain flush ID with the latest flush ID. If the job chain ID is greater than the latest flush, then a flush is performed.  Care must be taken in the overflow case. If the software setting up the ID detects that an overflow may occur, the job chain should be tagged with the maximum value of the  LATEST_FLUSH register. This ensures that flushes are correctly performed, at the possible cost of a few redundant flushes. Added cache flush reduction </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>JS2_EVENT_MASK_NEXT</spirit:name>
        <spirit:displayName>JS2_EVENT_MASK_NEXT</spirit:displayName>
        <spirit:description>   This register contains the value to be transferred into the JS  n _EVENT_MASK register when the next job chain starts. See EVENT_MASK for details.</spirit:description>
        <spirit:addressOffset>0x7c</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>JS2EVENT_MASK_NEXT</spirit:name>
          <spirit:displayName>JS2EVENT_MASK_NEXT</spirit:displayName>
          <spirit:description>JS2EVENT_MASK_NEXT</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> Event  n will not cause an interrupt.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Event  n will cause an interrupt.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
    </spirit:addressBlock>
    <spirit:addressBlock>
      <spirit:name>jm_mmu_irq_regs</spirit:name>
      <spirit:baseAddress>8192</spirit:baseAddress>
      <spirit:range>16</spirit:range>
      <spirit:width>32</spirit:width>
      <spirit:usage>register</spirit:usage>
      <spirit:register>
        <spirit:name>ST1MMU_IRQ_RAWSTAT</spirit:name>
        <spirit:displayName>ST1MMU_IRQ_RAWSTAT</spirit:displayName>
        <spirit:description>   This register contains the raw unmasked interrupt sources for MMU status and exception handling.  Writing to this register may force bits on, but will not clear them. 
				The new state for a bit corresponding to an existing address space is the logical OR of the previous state and the written value, except
				that bits corresponding to address spaces which do not exist will ignore writes and consistently read 0.  Writing a zero to a bit will have no effect. Use the IRQ_CLEAR register to clear interrupts.  Clarified that bits in MMU IRQ_RAWSTAT are dependent on existence of address spaces. </spirit:description>
        <spirit:addressOffset>0x0</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>PAGE_FAULT</spirit:name>
          <spirit:displayName>PAGE_FAULT</spirit:displayName>
          <spirit:description>PAGE_FAULT</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>16</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> No page fault from address space  n .</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Page fault from address space  n .</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>BUS_ERROR</spirit:name>
          <spirit:displayName>BUS_ERROR</spirit:displayName>
          <spirit:description>BUS_ERROR</spirit:description>
          <spirit:bitOffset>16</spirit:bitOffset>
          <spirit:bitWidth>16</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> No error from address space  n .</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Address space  n signalled a bus fault when reading page tables.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMU_IRQ_CLEAR</spirit:name>
        <spirit:displayName>ST1MMU_IRQ_CLEAR</spirit:displayName>
        <spirit:description>   This register has the same layout as  IRQ_RAWSTAT . Write a one to a bit in this register to clear the corresponding bit in IRQ_RAWSTAT. As for  IRQ_RAWSTAT , bits corresponding to address spaces which do not exist will ignore writes and consistently read 0.</spirit:description>
        <spirit:addressOffset>0x4</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>PAGE_FAULT</spirit:name>
          <spirit:displayName>PAGE_FAULT</spirit:displayName>
          <spirit:description>PAGE_FAULT</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>16</spirit:bitWidth>
          <spirit:access>write-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> No page fault from address space  n .</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Page fault from address space  n .</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>BUS_ERROR</spirit:name>
          <spirit:displayName>BUS_ERROR</spirit:displayName>
          <spirit:description>BUS_ERROR</spirit:description>
          <spirit:bitOffset>16</spirit:bitOffset>
          <spirit:bitWidth>16</spirit:bitWidth>
          <spirit:access>write-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> No error from address space  n .</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Address space  n signalled a bus fault when reading page tables.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMU_IRQ_MASK</spirit:name>
        <spirit:displayName>ST1MMU_IRQ_MASK</spirit:displayName>
        <spirit:description>   This register has the same layout as  IRQ_RAWSTAT . Set each bit in this to one to enable the corresponding interrupt source, and to zero to disable it. As for  IRQ_RAWSTAT , bits corresponding to address spaces which do not exist will ignore writes and consistently read 0.</spirit:description>
        <spirit:addressOffset>0x8</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>PAGE_FAULT</spirit:name>
          <spirit:displayName>PAGE_FAULT</spirit:displayName>
          <spirit:description>PAGE_FAULT</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>16</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> No page fault from address space  n .</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Page fault from address space  n .</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>BUS_ERROR</spirit:name>
          <spirit:displayName>BUS_ERROR</spirit:displayName>
          <spirit:description>BUS_ERROR</spirit:description>
          <spirit:bitOffset>16</spirit:bitOffset>
          <spirit:bitWidth>16</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> No error from address space  n .</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Address space  n signalled a bus fault when reading page tables.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMU_IRQ_STATUS</spirit:name>
        <spirit:displayName>ST1MMU_IRQ_STATUS</spirit:displayName>
        <spirit:description>   This register has the same layout as  IRQ_RAWSTAT . This register contains the result of anding together IRQ_RAWSTAT and IRQ_MASK. If any bits in this register are set, the external GPU control interrupt line is asserted, signaling an interrupt request to the CPU.</spirit:description>
        <spirit:addressOffset>0xc</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>PAGE_FAULT</spirit:name>
          <spirit:displayName>PAGE_FAULT</spirit:displayName>
          <spirit:description>PAGE_FAULT</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>16</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> No page fault from address space  n .</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Page fault from address space  n .</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>BUS_ERROR</spirit:name>
          <spirit:displayName>BUS_ERROR</spirit:displayName>
          <spirit:description>BUS_ERROR</spirit:description>
          <spirit:bitOffset>16</spirit:bitOffset>
          <spirit:bitWidth>16</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> No error from address space  n .</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Address space  n signalled a bus fault when reading page tables.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
    </spirit:addressBlock>
    <spirit:addressBlock>
      <spirit:name>jm_mmu_as0_regs</spirit:name>
      <spirit:baseAddress>9216</spirit:baseAddress>
      <spirit:range>64</spirit:range>
      <spirit:width>32</spirit:width>
      <spirit:usage>register</spirit:usage>
      <spirit:register>
        <spirit:name>ST1MMUAS0_TRANSTAB_LO</spirit:name>
        <spirit:displayName>ST1MMUAS0_TRANSTAB_LO</spirit:displayName>
        <spirit:description>   This register contains the address of the base level of the translation table, together with some related flags.  Details on the layout of the page tables, and the address translation process, can be found in the section  Memory Management Unit .</spirit:description>
        <spirit:addressOffset>0x0</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>Res98</spirit:name>
          <spirit:displayName>Res98</spirit:displayName>
          <spirit:description>Res98</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>ST1MMUAS0TRANSTAB_LO</spirit:name>
          <spirit:displayName>ST1MMUAS0TRANSTAB_LO</spirit:displayName>
          <spirit:description>   This field contains the address of the top level of a page table structure. This must be 16-byte-aligned, so address bits [3:0] are assumed to be zero.  For a stage 1 page table, this will be an intermediate physical address, and for stage 2 it will be a physical address. The number of actual translated address bits is stored in  OUTA_BITS . The unused high bits must be set to 0. Changed alignment text for TRANSTAB.BASE  TRANSTAB.BASE pointer is a physical (or intermediate) address </spirit:description>
          <spirit:bitOffset>4</spirit:bitOffset>
          <spirit:bitWidth>28</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS0_TRANSTAB_HI</spirit:name>
        <spirit:displayName>ST1MMUAS0_TRANSTAB_HI</spirit:displayName>
        <spirit:description>   This register contains the address of the base level of the translation table, together with some related flags.  Details on the layout of the page tables, and the address translation process, can be found in the section  Memory Management Unit .</spirit:description>
        <spirit:addressOffset>0x4</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>ST1MMUAS0TRANSTAB_HI</spirit:name>
          <spirit:displayName>ST1MMUAS0TRANSTAB_HI</spirit:displayName>
          <spirit:description>   This field contains the address of the top level of a page table structure. This must be 16-byte-aligned, so address bits [3:0] are assumed to be zero.  For a stage 1 page table, this will be an intermediate physical address, and for stage 2 it will be a physical address. The number of actual translated address bits is stored in  OUTA_BITS . The unused high bits must be set to 0. Changed alignment text for TRANSTAB.BASE  TRANSTAB.BASE pointer is a physical (or intermediate) address </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS0_MEMATTR_LO</spirit:name>
        <spirit:displayName>ST1MMUAS0_MEMATTR_LO</spirit:displayName>
        <spirit:description>  </spirit:description>
        <spirit:addressOffset>0x8</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>ATTRIBUTE0</spirit:name>
          <spirit:displayName>ATTRIBUTE0</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 0. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE1</spirit:name>
          <spirit:displayName>ATTRIBUTE1</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 1. </spirit:description>
          <spirit:bitOffset>4</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE2</spirit:name>
          <spirit:displayName>ATTRIBUTE2</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 2. </spirit:description>
          <spirit:bitOffset>8</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE3</spirit:name>
          <spirit:displayName>ATTRIBUTE3</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 3. </spirit:description>
          <spirit:bitOffset>12</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE4</spirit:name>
          <spirit:displayName>ATTRIBUTE4</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 4. </spirit:description>
          <spirit:bitOffset>16</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE5</spirit:name>
          <spirit:displayName>ATTRIBUTE5</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 5. </spirit:description>
          <spirit:bitOffset>20</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE6</spirit:name>
          <spirit:displayName>ATTRIBUTE6</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 6. </spirit:description>
          <spirit:bitOffset>24</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE7</spirit:name>
          <spirit:displayName>ATTRIBUTE7</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 7. </spirit:description>
          <spirit:bitOffset>28</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS0_MEMATTR_HI</spirit:name>
        <spirit:displayName>ST1MMUAS0_MEMATTR_HI</spirit:displayName>
        <spirit:description>  </spirit:description>
        <spirit:addressOffset>0xc</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>ATTRIBUTE8</spirit:name>
          <spirit:displayName>ATTRIBUTE8</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 8. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE9</spirit:name>
          <spirit:displayName>ATTRIBUTE9</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 9. </spirit:description>
          <spirit:bitOffset>4</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE10</spirit:name>
          <spirit:displayName>ATTRIBUTE10</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 10. </spirit:description>
          <spirit:bitOffset>8</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE11</spirit:name>
          <spirit:displayName>ATTRIBUTE11</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 11. </spirit:description>
          <spirit:bitOffset>12</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE12</spirit:name>
          <spirit:displayName>ATTRIBUTE12</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 12. </spirit:description>
          <spirit:bitOffset>16</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE13</spirit:name>
          <spirit:displayName>ATTRIBUTE13</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 13. </spirit:description>
          <spirit:bitOffset>20</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE14</spirit:name>
          <spirit:displayName>ATTRIBUTE14</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 14. </spirit:description>
          <spirit:bitOffset>24</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE15</spirit:name>
          <spirit:displayName>ATTRIBUTE15</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 15. </spirit:description>
          <spirit:bitOffset>28</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS0_LOCKADDR_LO</spirit:name>
        <spirit:displayName>ST1MMUAS0_LOCKADDR_LO</spirit:displayName>
        <spirit:description>   This register tells the MMU to lock a region of virtual memory. All page mappings within this region must be flushed, and no translation requests within this region can complete or fault before the area is unlocked.  Only one region can be locked at a time.  As only 32 bits of the register can be written to at a time, no changes are issued until the LOCK command is written to the COMMAND register. </spirit:description>
        <spirit:addressOffset>0x10</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>Res99</spirit:name>
          <spirit:displayName>Res99</spirit:displayName>
          <spirit:description>Res99</spirit:description>
          <spirit:bitOffset>6</spirit:bitOffset>
          <spirit:bitWidth>6</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>LOCKADDR_SIZE</spirit:name>
          <spirit:displayName>LOCKADDR_SIZE</spirit:displayName>
          <spirit:description>   This field contains the log  2 of the size of the region to lock, minus 1. Only values in the range 11 to 63 are valid values for this field, corresponding to region sizes of 4KB up to the entire address space. Values in the range 0 to 10 result in UNDEFINED behavior and should not be used.</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>6</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>ST1MMUAS0LOCKADDR_LO</spirit:name>
          <spirit:displayName>ST1MMUAS0LOCKADDR_LO</spirit:displayName>
          <spirit:description>   This field contains the lowest address in the region to be locked. The address is a virtual address in this address space.  Only the upper bits of the address are used. The address is aligned to a multiple of the region size, so a variable number of low-order bits are ignored, depending on the selected region size. It is recommended that software ensures that these low bits in the address are cleared, to avoid confusion. </spirit:description>
          <spirit:bitOffset>12</spirit:bitOffset>
          <spirit:bitWidth>20</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS0_LOCKADDR_HI</spirit:name>
        <spirit:displayName>ST1MMUAS0_LOCKADDR_HI</spirit:displayName>
        <spirit:description>   This register tells the MMU to lock a region of virtual memory. All page mappings within this region must be flushed, and no translation requests within this region can complete or fault before the area is unlocked.  Only one region can be locked at a time.  As only 32 bits of the register can be written to at a time, no changes are issued until the LOCK command is written to the COMMAND register. </spirit:description>
        <spirit:addressOffset>0x14</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>ST1MMUAS0LOCKADDR_HI</spirit:name>
          <spirit:displayName>ST1MMUAS0LOCKADDR_HI</spirit:displayName>
          <spirit:description>   This field contains the lowest address in the region to be locked. The address is a virtual address in this address space.  Only the upper bits of the address are used. The address is aligned to a multiple of the region size, so a variable number of low-order bits are ignored, depending on the selected region size. It is recommended that software ensures that these low bits in the address are cleared, to avoid confusion. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS0_COMMAND</spirit:name>
        <spirit:displayName>ST1MMUAS0_COMMAND</spirit:displayName>
        <spirit:description>   MMU commands are issued by writing to this register. Any command written to an address space while the corresponding STATUS.AS_ACTIVE flag is set will be ignored.  In general an MMU command only applies to the address space it is submitted to. However a command that invalidates the MMU cache may invalidate the whole MMU cache rather than only those entries specific to one address space. </spirit:description>
        <spirit:addressOffset>0x18</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>ST1MMUAS0COMMAND</spirit:name>
          <spirit:displayName>ST1MMUAS0COMMAND</spirit:displayName>
          <spirit:description>ST1MMUAS0COMMAND</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>write-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NOP</spirit:name>
              <spirit:description> No operation, nothing happens. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>UPDATE</spirit:name>
              <spirit:description> Broadcasts the values in TRANSTAB and MEMATTR to all MMUs. MMU caches are invalidated. Use this after changing the content of these registers. This will  not clear the effect of a LOCK set in the updated address space.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>LOCK</spirit:name>
              <spirit:description> Issues a lock region command to all MMUs, using the address and size set in the LOCKADDR register. MMU caches are invalidated. Use this before changing an in-memory page table. Any existing lock on this address space is cleared. Locks on other address spaces are not affected. Use a FLUSH or UNLOCK command to unlock a memory region. </spirit:description>
              <spirit:value>2</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>UNLOCK</spirit:name>
              <spirit:description> Issues an unlock region command to all MMUs, using the address and size set in the LOCKADDR register. Any existing lock on this address space is cleared. If no lock was present, the MMU caches are invalidated. Use this when finished changing an in-memory page table, except if the page table can be cached in the L2 cache, in which case, a FLUSH_MEM command must be issued instead. </spirit:description>
              <spirit:value>3</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FLUSH_PT</spirit:name>
              <spirit:description> First cleans and invalidates all L2 caches to force cached page tables to be invalidated, then performs an UNLOCK command. </spirit:description>
              <spirit:value>4</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FLUSH_MEM</spirit:name>
              <spirit:description> First waits until all memory accesses to a region locked by a preceding LOCK command have completed and have reached the nearest cache.
			This will ensure that all reads to a locked memory region have finished, and that any writes to a locked region have either been written out to memory or are present in the L1 or L2 cache as dirty data.
			Then cleans and invalidates the L1 cache in all shader cores, forcing dirty data for locked regions to be pushed out to the L2 cache.
			Then cleans and invalidates all L2 caches forcing all dirty data for locked regions to be written back to memory and page tables to be invalidated.
			Then performs an UNLOCK command on this address space.
			Use this when finished changing or removing entries in an in-memory page table. </spirit:description>
              <spirit:value>5</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS0_FAULTSTATUS</spirit:name>
        <spirit:displayName>ST1MMUAS0_FAULTSTATUS</spirit:displayName>
        <spirit:description>   This register contains extended status information after a fault. If read before a fault occurs, its contents are the reset value, 0, which indicates no fault.
						If multiple faults occur before the first is handled, the subsequent faults are ignored. They may fault again after handling the first one.  If the GPU is in protected mode, this register is not updated, and MMU faults are ignored. 
						They are not fatal but will halt the GPU until the MMU address space is updated. 
						However, no fault information wil be visible in this case.  Changed access type of MMU_FAULTSTATUS register when in protected mode. </spirit:description>
        <spirit:addressOffset>0x1c</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>Res100</spirit:name>
          <spirit:displayName>Res100</spirit:displayName>
          <spirit:description>Res100</spirit:description>
          <spirit:bitOffset>10</spirit:bitOffset>
          <spirit:bitWidth>6</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>SOURCE_ID</spirit:name>
          <spirit:displayName>SOURCE_ID</spirit:displayName>
          <spirit:description>   This field contains an implementation-defined ID that supplies additional data about the source of the fault. For example, it may be the ID of the internal bus master that issued the request that faulted. This makes it possible to distinguish between the job manager, the texture unit and the load/store unit. Another example might be an indication of the type of an invalid data structure. The values in this field are implementation defined. </spirit:description>
          <spirit:bitOffset>16</spirit:bitOffset>
          <spirit:bitWidth>16</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>EXCEPTION_TYPE</spirit:name>
          <spirit:displayName>EXCEPTION_TYPE</spirit:displayName>
          <spirit:description>   This field indicates the type of exception that caused the fault. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>8</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>OK</spirit:name>
              <spirit:description>   This indicates that the GPU has completed its work and is in a state ready to receive new commands. Its precise meaning depends on its usage:    In the job status field, this indicates that the job has not been started. This should be the initial state of a newly created job.  In the job slot status register, this indicates that the job slot is idle.  In the GPU and MMU exception status registers, this indicates that no exception has yet been received.  No additional error information is available (or indeed required). </spirit:description>
              <spirit:value>0x00</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>DONE</spirit:name>
              <spirit:description> The job completed successfully. The fault value is written to the job descriptor.
			The job descriptors fault address field contains the TIMESTAMP value when the job completed.
			If a job is terminated early using the  EUREKA instruction, then that job will be marked with the EUREKA exception status but the job chain status as a whole will still be DONE.</spirit:description>
              <spirit:value>0x01</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>SUSPENDED</spirit:name>
              <spirit:description> The job was interrupted by a SUSPEND command. The fault value is written both to the job slot  STATUS register and the job descriptor.
			The job descriptor contains the partition index of the first task to be interrupted. The fault address field contains the TIMESTAMP value when the job was interrupted.</spirit:description>
              <spirit:value>0x02</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>STOPPED</spirit:name>
              <spirit:description> The job was interrupted by a SOFT_STOP command. The fault value is written both to the job slot  STATUS register and the job descriptor.
			The job descriptor contains the partition index of the first task that was not completed. This will be the index of the first task issued if the job is resumed. The fault address is UNDEFINED .</spirit:description>
              <spirit:value>0x03</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TERMINATED</spirit:name>
              <spirit:description> The job was interrupted by a HARD_STOP command or a  KABOOM instruction from another job. The fault value is written both to the job slot STATUS register and the job descriptor.
			This status is treated in the same way as an error condition. The job descriptor contains the partition index of the first task to be terminated. The fault address field contains the TIMESTAMP value when the job was interrupted.</spirit:description>
              <spirit:value>0x04</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>KABOOM</spirit:name>
              <spirit:description> The job was interrupted by a shader executing a  KABOOM instruction. The fault value is written both to the job slot STATUS register and the job descriptor.
			This status is treated in the same way as an error condition. The job descriptor contains the partition index of the first task to be terminated. The fault address field contains the TIMESTAMP value when the job was interrupted.</spirit:description>
              <spirit:value>0x05</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>EUREKA</spirit:name>
              <spirit:description> The job was interrupted by a shader executing a  EUREKA instruction. The fault value is written only to the job descriptor, and does not affect subsequent jobs in the job chain.
			The job descriptor contains the partition index of the first task to be terminated. The fault address field contains the TIMESTAMP value when the job was interrupted.</spirit:description>
              <spirit:value>0x06</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ACTIVE</spirit:name>
              <spirit:description> In the JSn_STATUS register, this indicates that the job slot is active.
			The JSn_HEAD and JSn_TAIL registers contain the range of job descriptors currently in progress. </spirit:description>
              <spirit:value>0x08</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>JOB_CONFIG_FAULT</spirit:name>
              <spirit:description>   The job configuration specified in the job slot registers is invalid, so it is not possible to read job descriptors.
				For example this includes setting a NULL job descriptor pointer, selecting an address space that isnt present.
				No additional information is available. </spirit:description>
              <spirit:value>0x40</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>JOB_POWER_FAULT</spirit:name>
              <spirit:description>   The job could not be executed because the part of the memory system required to access job descriptors was not powered on.
				No additional information is available. </spirit:description>
              <spirit:value>0x41</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>JOB_READ_FAULT</spirit:name>
              <spirit:description>   Reading a job descriptor into the Job manager failed.
				The JSn_HEAD register contains the virtual address of the job descriptor that could not be read. </spirit:description>
              <spirit:value>0x42</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>JOB_WRITE_FAULT</spirit:name>
              <spirit:description>   Writing a job descriptor from the Job manager failed.
				The JSn_TAIL register contains the virtual address of the job descriptor that could not be written. </spirit:description>
              <spirit:value>0x43</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>JOB_AFFINITY_FAULT</spirit:name>
              <spirit:description>   The job could not be executed because the specified affinity mask does not intersect any available cores.
				No additional information is available. </spirit:description>
              <spirit:value>0x44</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>JOB_BUS_FAULT</spirit:name>
              <spirit:description>   A bus access failed while executing a job.
				The job descriptor contains the virtual address of the failing access, the type of access, and which part of the GPU initiated the access.
				This error code may also be reported if a bus fault occurs while writing the performance counters to memory. In this case, the GPU_FAULT* registers are updated, but the active JASID is not reported. It is possible to distinguish this case from a genuine Job Bus Fault exception by examining the SOURCE_ID field. </spirit:description>
              <spirit:value>0x48</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>INSTR_INVALID_PC</spirit:name>
              <spirit:description>   A shader instruction with an illegal program counter was executed.
				The job descriptors fault address field contains the offending program counter value. </spirit:description>
              <spirit:value>0x50</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>INSTR_INVALID_ENC</spirit:name>
              <spirit:description>   A shader instruction with an illegal encoding was executed.
				The job descriptors fault address field contains the program counter used to reach the offending instruction. </spirit:description>
              <spirit:value>0x51</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>INSTR_BARRIER_FAULT</spirit:name>
              <spirit:description>   A shader instruction was executed that failed to complete an instruction barrier.
				The job descriptors fault address field contains the program counter used to reach the offending instruction. </spirit:description>
              <spirit:value>0x55</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>DATA_INVALID_FAULT</spirit:name>
              <spirit:description>   Any data structure read as part of the job contains invalid combinations of data.
				The job descriptors fault address field contains the virtual address of the invalid data structure. </spirit:description>
              <spirit:value>0x58</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TILE_RANGE_FAULT</spirit:name>
              <spirit:description>   Tile or fragment shading was asked to process a tile that is entirely outside the bounding box of the frame.
				The job descriptors fault address field contains the coordinates of the top left corner of the failing tile, with X in the bits [15:0], and Y in the bits [31:16].  Clarified description of TILE_RANGE_FAULT. </spirit:description>
              <spirit:value>0x59</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ADDR_RANGE_FAULT</spirit:name>
              <spirit:description>   A virtual address has been found that exceeds the virtual address range.
				The job descriptors fault address field contains the virtual address which is out of range. </spirit:description>
              <spirit:value>0x5A</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>IMPRECISE_FAULT</spirit:name>
              <spirit:description>   A fault has been generated without precise fault information.
				This can happen if appropriate source information is not available at the point where the fault happens.
				The job descriptors fault address field may contain a virtual address related to the fault. </spirit:description>
              <spirit:value>0x5B</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>OUT_OF_MEMORY</spirit:name>
              <spirit:description>   The tiler ran out of memory when executing a job.
				The job descriptors fault address field contains the index of the last completed vertex sent through the tiler. </spirit:description>
              <spirit:value>0x60</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>UNKNOWN</spirit:name>
              <spirit:description>   If multiple jobs in a job chain fail, only the first one the reports an error will set and return full error information. Subsequent failing jobs will not update the error status registers, and may write an error status of UNKNOWN.
				Note that the first job to fail may not be the first job in the chain, which may lead to jobs with  UNKNOWN error status being encountered first when traversing the job chain.
				For example, you may see: Done, Done, Unknown, Bus Error, Unknown, New. In this case, the first two jobs ran successfully, the fourth job hit a bus error, and then jobs three and five also failed. The sixth and subsequent jobs had not been started at that point.</spirit:description>
              <spirit:value>0x7F</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>DELAYED_BUS_FAULT</spirit:name>
              <spirit:description>   The GPU received a bus fault for access to physical memory where the original virtual address is no longer available. This is the result of evicting a dirty line from a cache.
				This may also be triggered by a bus fault during a Tiler cache flush operation. In this case, the address reported in  GPU_FAULTADDRESS is a virtual address.</spirit:description>
              <spirit:value>0x80</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>GPU_SHAREABILITY_FAULT</spirit:name>
              <spirit:description>   A cache has detected that the same line has been accessed as both shareable and non-shareable memory from inside the GPU. Coherency after this point can no longer be guaranteed. </spirit:description>
              <spirit:value>0x88</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>SYSTEM_SHAREABILITY_FAULT</spirit:name>
              <spirit:description>   A cache has detected that the same line has been accessed as both shareable and non-shareable memory from outside the GPU. Coherency after this point can no longer be guaranteed. </spirit:description>
              <spirit:value>0x89</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>GPU_CACHEABILITY_FAULT</spirit:name>
              <spirit:description>   A cache has detected that the same line has been accessed as both cacheable and non-cacheable memory from inside the GPU. Non-cacheable memory may have been cached. </spirit:description>
              <spirit:value>0x8A</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TRANSLATION_FAULT_0</spirit:name>
              <spirit:description>   A memory access hit an invalid table entry at level 0 of the translation table. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xC0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TRANSLATION_FAULT_1</spirit:name>
              <spirit:description>   A memory access hit an invalid table entry at level 1 of the translation table. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xC1</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TRANSLATION_FAULT_2</spirit:name>
              <spirit:description>   A memory access hit an invalid table entry at level 2 of the translation table. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xC2</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TRANSLATION_FAULT_3</spirit:name>
              <spirit:description>   A memory access hit an invalid table entry at level 3 of the translation table. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xC3</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TRANSLATION_FAULT_IDENTITY</spirit:name>
              <spirit:description>   In IDENTITY translation mode, the virtual address exceeds the maximum physical address. </spirit:description>
              <spirit:value>0xC7</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>PERMISSION_FAULT_0</spirit:name>
              <spirit:description>   A memory access could not be allowed due to the permission flags set in level 0 of the translation table. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set. Added MMU translation level information to permission fault. </spirit:description>
              <spirit:value>0xC8</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>PERMISSION_FAULT_1</spirit:name>
              <spirit:description>   A memory access could not be allowed due to the permission flags set in level 1 of the translation table. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xC9</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>PERMISSION_FAULT_2</spirit:name>
              <spirit:description>   A memory access could not be allowed due to the permission flags set in level 2 of the translation table. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xCA</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>PERMISSION_FAULT_3</spirit:name>
              <spirit:description>   A memory access could not be allowed due to the permission flags set in level 3 of the translation table. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xCB</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TRANSTAB_BUS_FAULT_0</spirit:name>
              <spirit:description>   A bus fault occurred while reading level 0 of the translation tables. The appropriate  BUS_ERROR flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xD0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TRANSTAB_BUS_FAULT_1</spirit:name>
              <spirit:description>   A bus fault occurred while reading level 1 of the translation tables. The appropriate  BUS_ERROR flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xD1</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TRANSTAB_BUS_FAULT_2</spirit:name>
              <spirit:description>   A bus fault occurred while reading level 2 of the translation tables. The appropriate  BUS_ERROR flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xD2</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TRANSTAB_BUS_FAULT_3</spirit:name>
              <spirit:description>   A bus fault occurred while reading level 3 of the translation tables. The appropriate  BUS_ERROR flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xD3</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ACCESS_FLAG_0</spirit:name>
              <spirit:description>   A memory access hit a translation table entry with the ACCESS_FLAG bit set in level 0 of the translation table. This is not treated as a fault by the accessor. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set. Added MMU translation level information to access flag fault. </spirit:description>
              <spirit:value>0xD8</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ACCESS_FLAG_1</spirit:name>
              <spirit:description>   A memory access hit a translation table entry with the ACCESS_FLAG bit set in level 1 of the translation table. This is not treated as a fault by the accessor. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xD9</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ACCESS_FLAG_2</spirit:name>
              <spirit:description>   A memory access hit a translation table entry with the ACCESS_FLAG bit set in level 2 of the translation table. This is not treated as a fault by the accessor. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xDA</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ACCESS_FLAG_3</spirit:name>
              <spirit:description>   A memory access hit a translation table entry with the ACCESS_FLAG bit set in level 3 of the translation table. This is not treated as a fault by the accessor. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xDB</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ADDRESS_SIZE_FAULT_IN0</spirit:name>
              <spirit:description>   An input address size fault occurred while reading level 0 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ADDRESS_SIZE_FAULT_IN1</spirit:name>
              <spirit:description>   An input address size fault occurred while reading level 1 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE1</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ADDRESS_SIZE_FAULT_IN2</spirit:name>
              <spirit:description>   An input address size fault occurred while reading level 2 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE2</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ADDRESS_SIZE_FAULT_IN3</spirit:name>
              <spirit:description>   An input address size fault occurred while reading level 3 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE3</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ADDRESS_SIZE_FAULT_OUT0</spirit:name>
              <spirit:description>   An output address size fault occurred while reading level 0 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE4</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ADDRESS_SIZE_FAULT_OUT1</spirit:name>
              <spirit:description>   An output address size fault occurred while reading level 1 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE5</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ADDRESS_SIZE_FAULT_OUT2</spirit:name>
              <spirit:description>   An output address size fault occurred while reading level 2 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE6</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ADDRESS_SIZE_FAULT_OUT3</spirit:name>
              <spirit:description>   An output address size fault occurred while reading level 3 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE7</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>MEMORY_ATTRIBUTE_FAULT_0</spirit:name>
              <spirit:description>   A memory access could not be allowed due to an attempt to access a page with its memory attribute set to  FAULT in the MEMATTR register. This fault happened when reading level 0 of the translation tables. The appropriate PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE8</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>MEMORY_ATTRIBUTE_FAULT_1</spirit:name>
              <spirit:description>   A memory access could not be allowed due to an attempt to access a page with its memory attribute set to  FAULT in the MEMATTR register. This fault happened when reading level 1 of the translation tables. The appropriate PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE9</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>MEMORY_ATTRIBUTE_FAULT_2</spirit:name>
              <spirit:description>   A memory access could not be allowed due to an attempt to access a page with its memory attribute set to  FAULT in the MEMATTR register. This fault happened when reading level 2 of the translation tables. The appropriate PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xEA</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>MEMORY_ATTRIBUTE_FAULT_3</spirit:name>
              <spirit:description>   A memory access could not be allowed due to an attempt to access a page with its memory attribute set to  FAULT in the MEMATTR register. This fault happened when reading level 3 of the translation tables. The appropriate PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xEB</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>MEMORY_ATTRIBUTE_NONCACHEABLE_0</spirit:name>
              <spirit:description>   A memory access could not be allowed due to an attempt to access a non-cacheable page from a bus master which does not support non-cacheable accessess. This fault happened when reading level 0 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xEC</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>MEMORY_ATTRIBUTE_NONCACHEABLE_1</spirit:name>
              <spirit:description>   A memory access could not be allowed due to an attempt to access a non-cacheable page from a bus master which does not support non-cacheable accessess. This fault happened when reading level 1 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xED</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>MEMORY_ATTRIBUTE_NONCACHEABLE_2</spirit:name>
              <spirit:description>   A memory access could not be allowed due to an attempt to access a non-cacheable page from a bus master which does not support non-cacheable accessess. This fault happened when reading level 2 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xEE</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>MEMORY_ATTRIBUTE_NONCACHEABLE_3</spirit:name>
              <spirit:description>   A memory access could not be allowed due to an attempt to access a non-cacheable page from a bus master which does not support non-cacheable accessess. This fault happened when reading level 3 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xEF</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ACCESS_TYPE</spirit:name>
          <spirit:displayName>ACCESS_TYPE</spirit:displayName>
          <spirit:description>   This field contains the direction of data transfer that caused the fault, if known.  For the purposes of error reporting, atomic transactions act like a read followed by a write, so denying either permission will result in the atomic transaction failing, and the exceptions ACCESS_TYPE field will be set to "atomic". </spirit:description>
          <spirit:bitOffset>8</spirit:bitOffset>
          <spirit:bitWidth>2</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>atomic</spirit:name>
              <spirit:description> An atomic (read/write) transaction. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>execute</spirit:name>
              <spirit:description> An execute transaction. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>read</spirit:name>
              <spirit:description> A read transaction. </spirit:description>
              <spirit:value>2</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>write</spirit:name>
              <spirit:description> A write transaction. </spirit:description>
              <spirit:value>3</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS0_FAULTADDRESS_LO</spirit:name>
        <spirit:displayName>ST1MMUAS0_FAULTADDRESS_LO</spirit:displayName>
        <spirit:description>   This register contains information about the cause of a page fault or bus error. </spirit:description>
        <spirit:addressOffset>0x20</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>ST1MMUAS0FAULTADDRESS_LO</spirit:name>
          <spirit:displayName>ST1MMUAS0FAULTADDRESS_LO</spirit:displayName>
          <spirit:description>   This field contains the virtual address (in this address space) of the access that caused the fault.  Additional information about the fault is also available in the FAULTSTATUS register.  If multiple faults occur before the first is handled, the subsequent faults are ignored. They may fault again after handling the first one. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS0_FAULTADDRESS_HI</spirit:name>
        <spirit:displayName>ST1MMUAS0_FAULTADDRESS_HI</spirit:displayName>
        <spirit:description>   This register contains information about the cause of a page fault or bus error. </spirit:description>
        <spirit:addressOffset>0x24</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>ST1MMUAS0FAULTADDRESS_HI</spirit:name>
          <spirit:displayName>ST1MMUAS0FAULTADDRESS_HI</spirit:displayName>
          <spirit:description>   This field contains the virtual address (in this address space) of the access that caused the fault.  Additional information about the fault is also available in the FAULTSTATUS register.  If multiple faults occur before the first is handled, the subsequent faults are ignored. They may fault again after handling the first one. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS0_STATUS</spirit:name>
        <spirit:displayName>ST1MMUAS0_STATUS</spirit:displayName>
        <spirit:description>   This register contains dynamic status information about this address space. </spirit:description>
        <spirit:addressOffset>0x28</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>Res101</spirit:name>
          <spirit:displayName>Res101</spirit:displayName>
          <spirit:description>Res101</spirit:description>
          <spirit:bitOffset>1</spirit:bitOffset>
          <spirit:bitWidth>31</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>AS_ACTIVE</spirit:name>
          <spirit:displayName>AS_ACTIVE</spirit:displayName>
          <spirit:description>   This flag is set while a MMU_UPDATE, LOCK, UNLOCK, FLUSH_PT or FLUSH_MEM command is active on this address space. This allows software to safely verify that the address space is in a consistent state after reconfiguring the MMU page tables.  If a new command is written to the corresponding COMMAND register while the AS_ACTIVE bit is set, then the command is ignored. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> Address space command register is inactive. A new command may be written to the COMMAND register. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Address space command register is active. Any new command written to the COMMAND register will be ignored. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS0_TRANSCFG_LO</spirit:name>
        <spirit:displayName>ST1MMUAS0_TRANSCFG_LO</spirit:displayName>
        <spirit:description>ST1MMUAS0_TRANSCFG_LO</spirit:description>
        <spirit:addressOffset>0x30</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>Res102</spirit:name>
          <spirit:displayName>Res102</spirit:displayName>
          <spirit:description>Res102</spirit:description>
          <spirit:bitOffset>4</spirit:bitOffset>
          <spirit:bitWidth>2</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>Res103</spirit:name>
          <spirit:displayName>Res103</spirit:displayName>
          <spirit:description>Res103</spirit:description>
          <spirit:bitOffset>11</spirit:bitOffset>
          <spirit:bitWidth>3</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>Res104</spirit:name>
          <spirit:displayName>Res104</spirit:displayName>
          <spirit:description>Res104</spirit:description>
          <spirit:bitOffset>19</spirit:bitOffset>
          <spirit:bitWidth>3</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>Res105</spirit:name>
          <spirit:displayName>Res105</spirit:displayName>
          <spirit:description>Res105</spirit:description>
          <spirit:bitOffset>23</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>Res106</spirit:name>
          <spirit:displayName>Res106</spirit:displayName>
          <spirit:description>Res106</spirit:description>
          <spirit:bitOffset>26</spirit:bitOffset>
          <spirit:bitWidth>2</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>Res107</spirit:name>
          <spirit:displayName>Res107</spirit:displayName>
          <spirit:description>Res107</spirit:description>
          <spirit:bitOffset>31</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>INA_BITS</spirit:name>
          <spirit:displayName>INA_BITS</spirit:displayName>
          <spirit:description>   This field allows the system software to restrict the range of input addresses accepted by this translation stage. This is used in conjunction with the hardware limits to determine the valid address range as follows:  INA_BITS_VALID = min(HW_INA_BITS, 55-INA_BITS)  If the input address is outside the range (0, 2  INA_BITS_VALID -1), then a TRANSLATION_FAULT error is generated.</spirit:description>
          <spirit:bitOffset>6</spirit:bitOffset>
          <spirit:bitWidth>5</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>OUTA_BITS</spirit:name>
          <spirit:displayName>OUTA_BITS</spirit:displayName>
          <spirit:description>   This field allows the system software to restrict the range of output addresses generated by this translation stage. This is used in conjunction with the hardware limits to determine the valid address range as follows:  OUTA_BITS_VALID = min(HW_OUTA_BITS, 55-OUTA_BITS)  If the translated output address is outside the range (0, 2  OUTA_BITS_VALID -1), then a TRANSLATION_FAULT error is generated.</spirit:description>
          <spirit:bitOffset>14</spirit:bitOffset>
          <spirit:bitWidth>5</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>MODE</spirit:name>
          <spirit:displayName>MODE</spirit:displayName>
          <spirit:description>   This field controls the overall operation of the MMU. There are some differences between stage 1 and stage 2.  Execute permissions for a page are evaluated as follows (PTE.&amp;lt;W|R|X&gt; refers to page table entry permissions resolved for hierarchical permissions (if applicable):  EXECUTE_ALLOWED = !((TRANSCFG.WXN &amp;amp; !PTE.W) | (TRANSCFG.XREADABLE &amp;amp; !PTE.R) | (!TRANSCFG.XREADABLE &amp;amp; !PTE.X)) </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>LEGACY</spirit:name>
              <spirit:description>   The contents of TRANSTAB and MEMATTR are interpreted according to the legacy behaviour, as used in previous Midgard GPUs. The rest of the TRANSCFG bits are ignored.  Input and output address sizes are set according to the hardware configuration.  Stage 1 will follow the legacy behaviour.  Stage 2 will be transparent, will ignore TRANSTAB settings and will not generate any faults.  Note: as the reset value of TRANSCFG is 0, this is a mechanism to ensure backwards-compatibility and alignment between the stages. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>UNMAPPED</spirit:name>
              <spirit:description> The MMU forces all memory access to fail with a decode fault. No actual page table is required. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>IDENTITY</spirit:name>
              <spirit:description>   The MMU behaves as if using an address translation table with all entries valid and giving an identity mapping (output address is the same as the input address) with full read/write/execute access. Addresses outside the configured address ranges cause page faults.  For Stage 1, cacheability and shareability are defined by MEMATTR0. For Stage 2, cacheablity and sharebility are defined so that they dont change whats set by Stage 1 (non-shareable and inner/outer write-back cacheable and master-defined allocation). </spirit:description>
              <spirit:value>2</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>AARCH64_4K</spirit:name>
              <spirit:description> Page tables are interpreted according to the AArch64 4kB granule specification. </spirit:description>
              <spirit:value>6</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>AARCH64_64K</spirit:name>
              <spirit:description> Page tables are interpreted according to the AArch64 64kB granule specification. </spirit:description>
              <spirit:value>8</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>PTW_MEMATTR</spirit:name>
          <spirit:displayName>PTW_MEMATTR</spirit:displayName>
          <spirit:description>   Memory attributes for page table walks. The allowed values are compatible with the values allowed for  MEMORY_TYPE . For outer cache transactions, the desired attributes for the transaction will be decided by the bus master and communicated to the memory system using signals on the bus.  Changed allowed values for TRANSCFG.PTW_MEMATTR. </spirit:description>
          <spirit:bitOffset>24</spirit:bitOffset>
          <spirit:bitWidth>2</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NON_CACHEABLE</spirit:name>
              <spirit:description> Normal memory, inner non-cacheable, outer non-cacheable. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>WRITE_BACK</spirit:name>
              <spirit:description> Normal memory, inner write-back cacheable, outer write-back cacheable. </spirit:description>
              <spirit:value>2</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>PTW_SH</spirit:name>
          <spirit:displayName>PTW_SH</spirit:displayName>
          <spirit:description>   This field specifies the shareability for the page table walks. This is the same encoding as used for ARMv8 page tables. </spirit:description>
          <spirit:bitOffset>28</spirit:bitOffset>
          <spirit:bitWidth>2</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>non_shareable</spirit:name>
              <spirit:description> The memory region is non-shareable, and coherency with other observers will not automatically be maintained. Software will have to ensure that caches are flushed or invalidated at appropriate times. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>outer_shareable</spirit:name>
              <spirit:description> The memory region is marked as outer shareable. Each outer shareability domain contains a set of observers that are data coherent for each member of that set for	data accesses with the outer shareable attribute made by any member of that set. </spirit:description>
              <spirit:value>2</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>inner_shareable</spirit:name>
              <spirit:description> The memory region is marked as inner shareable. Each inner shareability domain contains a set of observers that are data coherent for each member of that set for	data accesses with the inner shareable attribute made by any member of that set. All observers in an inner shareability domain are always members of the same outer shareability domain. This means that an inner shareability domain is a subset of an Outer Shareability domain, although it is not required to be a proper subset. </spirit:description>
              <spirit:value>3</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>R_ALLOCATE</spirit:name>
          <spirit:displayName>R_ALLOCATE</spirit:displayName>
          <spirit:description>   This field sets the inner read allocation hint for the page table walks. This is the same encoding as used for ARMv8 page tables. </spirit:description>
          <spirit:bitOffset>30</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>no_read_allocate</spirit:name>
              <spirit:description> Hints that the cache should not allocate space when reading a page table entry. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>read_allocate</spirit:name>
              <spirit:description> Hints that the cache should allocate space when reading a page table entry. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>SL_CONCAT_EN</spirit:name>
          <spirit:displayName>SL_CONCAT_EN</spirit:displayName>
          <spirit:description>   If set then the page table walk starting level will be increased if possible by concatenating up to 16 tables in the starting level. </spirit:description>
          <spirit:bitOffset>22</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> Page table concatenation is disabled. 	This mode must be used for Stage 1 if sharing page tables with the CPU, otherwise  UNDEFINED behavior results.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Page table concatenation is enabled. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS0_TRANSCFG_HI</spirit:name>
        <spirit:displayName>ST1MMUAS0_TRANSCFG_HI</spirit:displayName>
        <spirit:description>ST1MMUAS0_TRANSCFG_HI</spirit:description>
        <spirit:addressOffset>0x34</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>Res108</spirit:name>
          <spirit:displayName>Res108</spirit:displayName>
          <spirit:description>Res108</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>Res109</spirit:name>
          <spirit:displayName>Res109</spirit:displayName>
          <spirit:description>Res109</spirit:description>
          <spirit:bitOffset>5</spirit:bitOffset>
          <spirit:bitWidth>27</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>DISABLE_HIER_AP</spirit:name>
          <spirit:displayName>DISABLE_HIER_AP</spirit:displayName>
          <spirit:description>   This flag only has an effect on stage 1 of translation. It is ignored for stage 2. Note the inverted logic - the flag must be set to  dis able hierarchical access permissions.</spirit:description>
          <spirit:bitOffset>1</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> Hierarchical access permissions are enabled. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Hierarchical access permissions are disabled. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>DISABLE_AF_FAULT</spirit:name>
          <spirit:displayName>DISABLE_AF_FAULT</spirit:displayName>
          <spirit:description>   This flag can be used to disable access fault checking when in one of AARCH64 modes. </spirit:description>
          <spirit:bitOffset>2</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> Access fault checking is enabled. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Access fault checking is disabled. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>WXN</spirit:name>
          <spirit:displayName>WXN</spirit:displayName>
          <spirit:description>   This flag can be used to disable all writes to executable pages, overriding access permissions specified in the page table. </spirit:description>
          <spirit:bitOffset>3</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> Write access permissions are read as usual from the page table. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Write access to all executable pages is disabled. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>XREADABLE</spirit:name>
          <spirit:displayName>XREADABLE</spirit:displayName>
          <spirit:description>   This flag can be used to enable execution on all readable pages, overriding access permissions specified in the page table. </spirit:description>
          <spirit:bitOffset>4</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> Execute access permissions are read as usual from the page table. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Execute access to all readable pages is enabled. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS0_FAULTEXTRA_LO</spirit:name>
        <spirit:displayName>ST1MMUAS0_FAULTEXTRA_LO</spirit:displayName>
        <spirit:description>   This register contains additional information about the cause of a page fault or bus error. </spirit:description>
        <spirit:addressOffset>0x38</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>ST1MMUAS0FAULTEXTRA_LO</spirit:name>
          <spirit:displayName>ST1MMUAS0FAULTEXTRA_LO</spirit:displayName>
          <spirit:description>   This field contains the virtual address (in this address space) of the access that caused the fault.  Additional information about the fault is also available in the  FAULTSTATUS and FAULTADDRESS registers. If multiple faults occur before the first is handled, the subsequent faults are ignored. They may fault again after handling the first one.  Fixed duplicate state name in FAULT_ADDRESS - exposes previously hidden field S2FS1WALK. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS0_FAULTEXTRA_HI</spirit:name>
        <spirit:displayName>ST1MMUAS0_FAULTEXTRA_HI</spirit:displayName>
        <spirit:description>   This register contains additional information about the cause of a page fault or bus error. </spirit:description>
        <spirit:addressOffset>0x3c</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>Res110</spirit:name>
          <spirit:displayName>Res110</spirit:displayName>
          <spirit:description>Res110</spirit:description>
          <spirit:bitOffset>16</spirit:bitOffset>
          <spirit:bitWidth>15</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>ST1MMUAS0FAULTEXTRA_HI</spirit:name>
          <spirit:displayName>ST1MMUAS0FAULTEXTRA_HI</spirit:displayName>
          <spirit:description>   This field contains the virtual address (in this address space) of the access that caused the fault.  Additional information about the fault is also available in the  FAULTSTATUS and FAULTADDRESS registers. If multiple faults occur before the first is handled, the subsequent faults are ignored. They may fault again after handling the first one.  Fixed duplicate state name in FAULT_ADDRESS - exposes previously hidden field S2FS1WALK. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>16</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>S2FS1WALK</spirit:name>
          <spirit:displayName>S2FS1WALK</spirit:displayName>
          <spirit:description>S2FS1WALK</spirit:description>
          <spirit:bitOffset>31</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>stage2</spirit:name>
              <spirit:description> Fault source is a stage 2 translation. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>stage1</spirit:name>
              <spirit:description> Fault source is a stage 1 page table walk. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
    </spirit:addressBlock>
    <spirit:addressBlock>
      <spirit:name>jm_mmu_as1_regs</spirit:name>
      <spirit:baseAddress>9280</spirit:baseAddress>
      <spirit:range>64</spirit:range>
      <spirit:width>32</spirit:width>
      <spirit:usage>register</spirit:usage>
      <spirit:register>
        <spirit:name>ST1MMUAS1_TRANSTAB_LO</spirit:name>
        <spirit:displayName>ST1MMUAS1_TRANSTAB_LO</spirit:displayName>
        <spirit:description>   This register contains the address of the base level of the translation table, together with some related flags.  Details on the layout of the page tables, and the address translation process, can be found in the section  Memory Management Unit .</spirit:description>
        <spirit:addressOffset>0x0</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>Res111</spirit:name>
          <spirit:displayName>Res111</spirit:displayName>
          <spirit:description>Res111</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>ST1MMUAS1TRANSTAB_LO</spirit:name>
          <spirit:displayName>ST1MMUAS1TRANSTAB_LO</spirit:displayName>
          <spirit:description>   This field contains the address of the top level of a page table structure. This must be 16-byte-aligned, so address bits [3:0] are assumed to be zero.  For a stage 1 page table, this will be an intermediate physical address, and for stage 2 it will be a physical address. The number of actual translated address bits is stored in  OUTA_BITS . The unused high bits must be set to 0. Changed alignment text for TRANSTAB.BASE  TRANSTAB.BASE pointer is a physical (or intermediate) address </spirit:description>
          <spirit:bitOffset>4</spirit:bitOffset>
          <spirit:bitWidth>28</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS1_TRANSTAB_HI</spirit:name>
        <spirit:displayName>ST1MMUAS1_TRANSTAB_HI</spirit:displayName>
        <spirit:description>   This register contains the address of the base level of the translation table, together with some related flags.  Details on the layout of the page tables, and the address translation process, can be found in the section  Memory Management Unit .</spirit:description>
        <spirit:addressOffset>0x4</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>ST1MMUAS1TRANSTAB_HI</spirit:name>
          <spirit:displayName>ST1MMUAS1TRANSTAB_HI</spirit:displayName>
          <spirit:description>   This field contains the address of the top level of a page table structure. This must be 16-byte-aligned, so address bits [3:0] are assumed to be zero.  For a stage 1 page table, this will be an intermediate physical address, and for stage 2 it will be a physical address. The number of actual translated address bits is stored in  OUTA_BITS . The unused high bits must be set to 0. Changed alignment text for TRANSTAB.BASE  TRANSTAB.BASE pointer is a physical (or intermediate) address </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS1_MEMATTR_LO</spirit:name>
        <spirit:displayName>ST1MMUAS1_MEMATTR_LO</spirit:displayName>
        <spirit:description>  </spirit:description>
        <spirit:addressOffset>0x8</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>ATTRIBUTE0</spirit:name>
          <spirit:displayName>ATTRIBUTE0</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 0. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE1</spirit:name>
          <spirit:displayName>ATTRIBUTE1</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 1. </spirit:description>
          <spirit:bitOffset>4</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE2</spirit:name>
          <spirit:displayName>ATTRIBUTE2</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 2. </spirit:description>
          <spirit:bitOffset>8</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE3</spirit:name>
          <spirit:displayName>ATTRIBUTE3</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 3. </spirit:description>
          <spirit:bitOffset>12</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE4</spirit:name>
          <spirit:displayName>ATTRIBUTE4</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 4. </spirit:description>
          <spirit:bitOffset>16</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE5</spirit:name>
          <spirit:displayName>ATTRIBUTE5</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 5. </spirit:description>
          <spirit:bitOffset>20</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE6</spirit:name>
          <spirit:displayName>ATTRIBUTE6</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 6. </spirit:description>
          <spirit:bitOffset>24</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE7</spirit:name>
          <spirit:displayName>ATTRIBUTE7</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 7. </spirit:description>
          <spirit:bitOffset>28</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS1_MEMATTR_HI</spirit:name>
        <spirit:displayName>ST1MMUAS1_MEMATTR_HI</spirit:displayName>
        <spirit:description>  </spirit:description>
        <spirit:addressOffset>0xc</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>ATTRIBUTE8</spirit:name>
          <spirit:displayName>ATTRIBUTE8</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 8. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE9</spirit:name>
          <spirit:displayName>ATTRIBUTE9</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 9. </spirit:description>
          <spirit:bitOffset>4</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE10</spirit:name>
          <spirit:displayName>ATTRIBUTE10</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 10. </spirit:description>
          <spirit:bitOffset>8</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE11</spirit:name>
          <spirit:displayName>ATTRIBUTE11</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 11. </spirit:description>
          <spirit:bitOffset>12</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE12</spirit:name>
          <spirit:displayName>ATTRIBUTE12</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 12. </spirit:description>
          <spirit:bitOffset>16</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE13</spirit:name>
          <spirit:displayName>ATTRIBUTE13</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 13. </spirit:description>
          <spirit:bitOffset>20</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE14</spirit:name>
          <spirit:displayName>ATTRIBUTE14</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 14. </spirit:description>
          <spirit:bitOffset>24</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE15</spirit:name>
          <spirit:displayName>ATTRIBUTE15</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 15. </spirit:description>
          <spirit:bitOffset>28</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS1_LOCKADDR_LO</spirit:name>
        <spirit:displayName>ST1MMUAS1_LOCKADDR_LO</spirit:displayName>
        <spirit:description>   This register tells the MMU to lock a region of virtual memory. All page mappings within this region must be flushed, and no translation requests within this region can complete or fault before the area is unlocked.  Only one region can be locked at a time.  As only 32 bits of the register can be written to at a time, no changes are issued until the LOCK command is written to the COMMAND register. </spirit:description>
        <spirit:addressOffset>0x10</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>Res112</spirit:name>
          <spirit:displayName>Res112</spirit:displayName>
          <spirit:description>Res112</spirit:description>
          <spirit:bitOffset>6</spirit:bitOffset>
          <spirit:bitWidth>6</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>LOCKADDR_SIZE</spirit:name>
          <spirit:displayName>LOCKADDR_SIZE</spirit:displayName>
          <spirit:description>   This field contains the log  2 of the size of the region to lock, minus 1. Only values in the range 11 to 63 are valid values for this field, corresponding to region sizes of 4KB up to the entire address space. Values in the range 0 to 10 result in UNDEFINED behavior and should not be used.</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>6</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>ST1MMUAS1LOCKADDR_LO</spirit:name>
          <spirit:displayName>ST1MMUAS1LOCKADDR_LO</spirit:displayName>
          <spirit:description>   This field contains the lowest address in the region to be locked. The address is a virtual address in this address space.  Only the upper bits of the address are used. The address is aligned to a multiple of the region size, so a variable number of low-order bits are ignored, depending on the selected region size. It is recommended that software ensures that these low bits in the address are cleared, to avoid confusion. </spirit:description>
          <spirit:bitOffset>12</spirit:bitOffset>
          <spirit:bitWidth>20</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS1_LOCKADDR_HI</spirit:name>
        <spirit:displayName>ST1MMUAS1_LOCKADDR_HI</spirit:displayName>
        <spirit:description>   This register tells the MMU to lock a region of virtual memory. All page mappings within this region must be flushed, and no translation requests within this region can complete or fault before the area is unlocked.  Only one region can be locked at a time.  As only 32 bits of the register can be written to at a time, no changes are issued until the LOCK command is written to the COMMAND register. </spirit:description>
        <spirit:addressOffset>0x14</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>ST1MMUAS1LOCKADDR_HI</spirit:name>
          <spirit:displayName>ST1MMUAS1LOCKADDR_HI</spirit:displayName>
          <spirit:description>   This field contains the lowest address in the region to be locked. The address is a virtual address in this address space.  Only the upper bits of the address are used. The address is aligned to a multiple of the region size, so a variable number of low-order bits are ignored, depending on the selected region size. It is recommended that software ensures that these low bits in the address are cleared, to avoid confusion. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS1_COMMAND</spirit:name>
        <spirit:displayName>ST1MMUAS1_COMMAND</spirit:displayName>
        <spirit:description>   MMU commands are issued by writing to this register. Any command written to an address space while the corresponding STATUS.AS_ACTIVE flag is set will be ignored.  In general an MMU command only applies to the address space it is submitted to. However a command that invalidates the MMU cache may invalidate the whole MMU cache rather than only those entries specific to one address space. </spirit:description>
        <spirit:addressOffset>0x18</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>ST1MMUAS1COMMAND</spirit:name>
          <spirit:displayName>ST1MMUAS1COMMAND</spirit:displayName>
          <spirit:description>ST1MMUAS1COMMAND</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>write-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NOP</spirit:name>
              <spirit:description> No operation, nothing happens. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>UPDATE</spirit:name>
              <spirit:description> Broadcasts the values in TRANSTAB and MEMATTR to all MMUs. MMU caches are invalidated. Use this after changing the content of these registers. This will  not clear the effect of a LOCK set in the updated address space.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>LOCK</spirit:name>
              <spirit:description> Issues a lock region command to all MMUs, using the address and size set in the LOCKADDR register. MMU caches are invalidated. Use this before changing an in-memory page table. Any existing lock on this address space is cleared. Locks on other address spaces are not affected. Use a FLUSH or UNLOCK command to unlock a memory region. </spirit:description>
              <spirit:value>2</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>UNLOCK</spirit:name>
              <spirit:description> Issues an unlock region command to all MMUs, using the address and size set in the LOCKADDR register. Any existing lock on this address space is cleared. If no lock was present, the MMU caches are invalidated. Use this when finished changing an in-memory page table, except if the page table can be cached in the L2 cache, in which case, a FLUSH_MEM command must be issued instead. </spirit:description>
              <spirit:value>3</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FLUSH_PT</spirit:name>
              <spirit:description> First cleans and invalidates all L2 caches to force cached page tables to be invalidated, then performs an UNLOCK command. </spirit:description>
              <spirit:value>4</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FLUSH_MEM</spirit:name>
              <spirit:description> First waits until all memory accesses to a region locked by a preceding LOCK command have completed and have reached the nearest cache.
			This will ensure that all reads to a locked memory region have finished, and that any writes to a locked region have either been written out to memory or are present in the L1 or L2 cache as dirty data.
			Then cleans and invalidates the L1 cache in all shader cores, forcing dirty data for locked regions to be pushed out to the L2 cache.
			Then cleans and invalidates all L2 caches forcing all dirty data for locked regions to be written back to memory and page tables to be invalidated.
			Then performs an UNLOCK command on this address space.
			Use this when finished changing or removing entries in an in-memory page table. </spirit:description>
              <spirit:value>5</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS1_FAULTSTATUS</spirit:name>
        <spirit:displayName>ST1MMUAS1_FAULTSTATUS</spirit:displayName>
        <spirit:description>   This register contains extended status information after a fault. If read before a fault occurs, its contents are the reset value, 0, which indicates no fault.
						If multiple faults occur before the first is handled, the subsequent faults are ignored. They may fault again after handling the first one.  If the GPU is in protected mode, this register is not updated, and MMU faults are ignored. 
						They are not fatal but will halt the GPU until the MMU address space is updated. 
						However, no fault information wil be visible in this case.  Changed access type of MMU_FAULTSTATUS register when in protected mode. </spirit:description>
        <spirit:addressOffset>0x1c</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>Res113</spirit:name>
          <spirit:displayName>Res113</spirit:displayName>
          <spirit:description>Res113</spirit:description>
          <spirit:bitOffset>10</spirit:bitOffset>
          <spirit:bitWidth>6</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>SOURCE_ID</spirit:name>
          <spirit:displayName>SOURCE_ID</spirit:displayName>
          <spirit:description>   This field contains an implementation-defined ID that supplies additional data about the source of the fault. For example, it may be the ID of the internal bus master that issued the request that faulted. This makes it possible to distinguish between the job manager, the texture unit and the load/store unit. Another example might be an indication of the type of an invalid data structure. The values in this field are implementation defined. </spirit:description>
          <spirit:bitOffset>16</spirit:bitOffset>
          <spirit:bitWidth>16</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>EXCEPTION_TYPE</spirit:name>
          <spirit:displayName>EXCEPTION_TYPE</spirit:displayName>
          <spirit:description>   This field indicates the type of exception that caused the fault. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>8</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>OK</spirit:name>
              <spirit:description>   This indicates that the GPU has completed its work and is in a state ready to receive new commands. Its precise meaning depends on its usage:    In the job status field, this indicates that the job has not been started. This should be the initial state of a newly created job.  In the job slot status register, this indicates that the job slot is idle.  In the GPU and MMU exception status registers, this indicates that no exception has yet been received.  No additional error information is available (or indeed required). </spirit:description>
              <spirit:value>0x00</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>DONE</spirit:name>
              <spirit:description> The job completed successfully. The fault value is written to the job descriptor.
			The job descriptors fault address field contains the TIMESTAMP value when the job completed.
			If a job is terminated early using the  EUREKA instruction, then that job will be marked with the EUREKA exception status but the job chain status as a whole will still be DONE.</spirit:description>
              <spirit:value>0x01</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>SUSPENDED</spirit:name>
              <spirit:description> The job was interrupted by a SUSPEND command. The fault value is written both to the job slot  STATUS register and the job descriptor.
			The job descriptor contains the partition index of the first task to be interrupted. The fault address field contains the TIMESTAMP value when the job was interrupted.</spirit:description>
              <spirit:value>0x02</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>STOPPED</spirit:name>
              <spirit:description> The job was interrupted by a SOFT_STOP command. The fault value is written both to the job slot  STATUS register and the job descriptor.
			The job descriptor contains the partition index of the first task that was not completed. This will be the index of the first task issued if the job is resumed. The fault address is UNDEFINED .</spirit:description>
              <spirit:value>0x03</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TERMINATED</spirit:name>
              <spirit:description> The job was interrupted by a HARD_STOP command or a  KABOOM instruction from another job. The fault value is written both to the job slot STATUS register and the job descriptor.
			This status is treated in the same way as an error condition. The job descriptor contains the partition index of the first task to be terminated. The fault address field contains the TIMESTAMP value when the job was interrupted.</spirit:description>
              <spirit:value>0x04</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>KABOOM</spirit:name>
              <spirit:description> The job was interrupted by a shader executing a  KABOOM instruction. The fault value is written both to the job slot STATUS register and the job descriptor.
			This status is treated in the same way as an error condition. The job descriptor contains the partition index of the first task to be terminated. The fault address field contains the TIMESTAMP value when the job was interrupted.</spirit:description>
              <spirit:value>0x05</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>EUREKA</spirit:name>
              <spirit:description> The job was interrupted by a shader executing a  EUREKA instruction. The fault value is written only to the job descriptor, and does not affect subsequent jobs in the job chain.
			The job descriptor contains the partition index of the first task to be terminated. The fault address field contains the TIMESTAMP value when the job was interrupted.</spirit:description>
              <spirit:value>0x06</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ACTIVE</spirit:name>
              <spirit:description> In the JSn_STATUS register, this indicates that the job slot is active.
			The JSn_HEAD and JSn_TAIL registers contain the range of job descriptors currently in progress. </spirit:description>
              <spirit:value>0x08</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>JOB_CONFIG_FAULT</spirit:name>
              <spirit:description>   The job configuration specified in the job slot registers is invalid, so it is not possible to read job descriptors.
				For example this includes setting a NULL job descriptor pointer, selecting an address space that isnt present.
				No additional information is available. </spirit:description>
              <spirit:value>0x40</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>JOB_POWER_FAULT</spirit:name>
              <spirit:description>   The job could not be executed because the part of the memory system required to access job descriptors was not powered on.
				No additional information is available. </spirit:description>
              <spirit:value>0x41</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>JOB_READ_FAULT</spirit:name>
              <spirit:description>   Reading a job descriptor into the Job manager failed.
				The JSn_HEAD register contains the virtual address of the job descriptor that could not be read. </spirit:description>
              <spirit:value>0x42</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>JOB_WRITE_FAULT</spirit:name>
              <spirit:description>   Writing a job descriptor from the Job manager failed.
				The JSn_TAIL register contains the virtual address of the job descriptor that could not be written. </spirit:description>
              <spirit:value>0x43</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>JOB_AFFINITY_FAULT</spirit:name>
              <spirit:description>   The job could not be executed because the specified affinity mask does not intersect any available cores.
				No additional information is available. </spirit:description>
              <spirit:value>0x44</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>JOB_BUS_FAULT</spirit:name>
              <spirit:description>   A bus access failed while executing a job.
				The job descriptor contains the virtual address of the failing access, the type of access, and which part of the GPU initiated the access.
				This error code may also be reported if a bus fault occurs while writing the performance counters to memory. In this case, the GPU_FAULT* registers are updated, but the active JASID is not reported. It is possible to distinguish this case from a genuine Job Bus Fault exception by examining the SOURCE_ID field. </spirit:description>
              <spirit:value>0x48</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>INSTR_INVALID_PC</spirit:name>
              <spirit:description>   A shader instruction with an illegal program counter was executed.
				The job descriptors fault address field contains the offending program counter value. </spirit:description>
              <spirit:value>0x50</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>INSTR_INVALID_ENC</spirit:name>
              <spirit:description>   A shader instruction with an illegal encoding was executed.
				The job descriptors fault address field contains the program counter used to reach the offending instruction. </spirit:description>
              <spirit:value>0x51</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>INSTR_BARRIER_FAULT</spirit:name>
              <spirit:description>   A shader instruction was executed that failed to complete an instruction barrier.
				The job descriptors fault address field contains the program counter used to reach the offending instruction. </spirit:description>
              <spirit:value>0x55</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>DATA_INVALID_FAULT</spirit:name>
              <spirit:description>   Any data structure read as part of the job contains invalid combinations of data.
				The job descriptors fault address field contains the virtual address of the invalid data structure. </spirit:description>
              <spirit:value>0x58</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TILE_RANGE_FAULT</spirit:name>
              <spirit:description>   Tile or fragment shading was asked to process a tile that is entirely outside the bounding box of the frame.
				The job descriptors fault address field contains the coordinates of the top left corner of the failing tile, with X in the bits [15:0], and Y in the bits [31:16].  Clarified description of TILE_RANGE_FAULT. </spirit:description>
              <spirit:value>0x59</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ADDR_RANGE_FAULT</spirit:name>
              <spirit:description>   A virtual address has been found that exceeds the virtual address range.
				The job descriptors fault address field contains the virtual address which is out of range. </spirit:description>
              <spirit:value>0x5A</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>IMPRECISE_FAULT</spirit:name>
              <spirit:description>   A fault has been generated without precise fault information.
				This can happen if appropriate source information is not available at the point where the fault happens.
				The job descriptors fault address field may contain a virtual address related to the fault. </spirit:description>
              <spirit:value>0x5B</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>OUT_OF_MEMORY</spirit:name>
              <spirit:description>   The tiler ran out of memory when executing a job.
				The job descriptors fault address field contains the index of the last completed vertex sent through the tiler. </spirit:description>
              <spirit:value>0x60</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>UNKNOWN</spirit:name>
              <spirit:description>   If multiple jobs in a job chain fail, only the first one the reports an error will set and return full error information. Subsequent failing jobs will not update the error status registers, and may write an error status of UNKNOWN.
				Note that the first job to fail may not be the first job in the chain, which may lead to jobs with  UNKNOWN error status being encountered first when traversing the job chain.
				For example, you may see: Done, Done, Unknown, Bus Error, Unknown, New. In this case, the first two jobs ran successfully, the fourth job hit a bus error, and then jobs three and five also failed. The sixth and subsequent jobs had not been started at that point.</spirit:description>
              <spirit:value>0x7F</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>DELAYED_BUS_FAULT</spirit:name>
              <spirit:description>   The GPU received a bus fault for access to physical memory where the original virtual address is no longer available. This is the result of evicting a dirty line from a cache.
				This may also be triggered by a bus fault during a Tiler cache flush operation. In this case, the address reported in  GPU_FAULTADDRESS is a virtual address.</spirit:description>
              <spirit:value>0x80</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>GPU_SHAREABILITY_FAULT</spirit:name>
              <spirit:description>   A cache has detected that the same line has been accessed as both shareable and non-shareable memory from inside the GPU. Coherency after this point can no longer be guaranteed. </spirit:description>
              <spirit:value>0x88</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>SYSTEM_SHAREABILITY_FAULT</spirit:name>
              <spirit:description>   A cache has detected that the same line has been accessed as both shareable and non-shareable memory from outside the GPU. Coherency after this point can no longer be guaranteed. </spirit:description>
              <spirit:value>0x89</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>GPU_CACHEABILITY_FAULT</spirit:name>
              <spirit:description>   A cache has detected that the same line has been accessed as both cacheable and non-cacheable memory from inside the GPU. Non-cacheable memory may have been cached. </spirit:description>
              <spirit:value>0x8A</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TRANSLATION_FAULT_0</spirit:name>
              <spirit:description>   A memory access hit an invalid table entry at level 0 of the translation table. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xC0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TRANSLATION_FAULT_1</spirit:name>
              <spirit:description>   A memory access hit an invalid table entry at level 1 of the translation table. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xC1</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TRANSLATION_FAULT_2</spirit:name>
              <spirit:description>   A memory access hit an invalid table entry at level 2 of the translation table. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xC2</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TRANSLATION_FAULT_3</spirit:name>
              <spirit:description>   A memory access hit an invalid table entry at level 3 of the translation table. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xC3</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TRANSLATION_FAULT_IDENTITY</spirit:name>
              <spirit:description>   In IDENTITY translation mode, the virtual address exceeds the maximum physical address. </spirit:description>
              <spirit:value>0xC7</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>PERMISSION_FAULT_0</spirit:name>
              <spirit:description>   A memory access could not be allowed due to the permission flags set in level 0 of the translation table. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set. Added MMU translation level information to permission fault. </spirit:description>
              <spirit:value>0xC8</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>PERMISSION_FAULT_1</spirit:name>
              <spirit:description>   A memory access could not be allowed due to the permission flags set in level 1 of the translation table. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xC9</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>PERMISSION_FAULT_2</spirit:name>
              <spirit:description>   A memory access could not be allowed due to the permission flags set in level 2 of the translation table. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xCA</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>PERMISSION_FAULT_3</spirit:name>
              <spirit:description>   A memory access could not be allowed due to the permission flags set in level 3 of the translation table. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xCB</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TRANSTAB_BUS_FAULT_0</spirit:name>
              <spirit:description>   A bus fault occurred while reading level 0 of the translation tables. The appropriate  BUS_ERROR flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xD0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TRANSTAB_BUS_FAULT_1</spirit:name>
              <spirit:description>   A bus fault occurred while reading level 1 of the translation tables. The appropriate  BUS_ERROR flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xD1</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TRANSTAB_BUS_FAULT_2</spirit:name>
              <spirit:description>   A bus fault occurred while reading level 2 of the translation tables. The appropriate  BUS_ERROR flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xD2</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TRANSTAB_BUS_FAULT_3</spirit:name>
              <spirit:description>   A bus fault occurred while reading level 3 of the translation tables. The appropriate  BUS_ERROR flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xD3</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ACCESS_FLAG_0</spirit:name>
              <spirit:description>   A memory access hit a translation table entry with the ACCESS_FLAG bit set in level 0 of the translation table. This is not treated as a fault by the accessor. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set. Added MMU translation level information to access flag fault. </spirit:description>
              <spirit:value>0xD8</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ACCESS_FLAG_1</spirit:name>
              <spirit:description>   A memory access hit a translation table entry with the ACCESS_FLAG bit set in level 1 of the translation table. This is not treated as a fault by the accessor. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xD9</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ACCESS_FLAG_2</spirit:name>
              <spirit:description>   A memory access hit a translation table entry with the ACCESS_FLAG bit set in level 2 of the translation table. This is not treated as a fault by the accessor. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xDA</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ACCESS_FLAG_3</spirit:name>
              <spirit:description>   A memory access hit a translation table entry with the ACCESS_FLAG bit set in level 3 of the translation table. This is not treated as a fault by the accessor. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xDB</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ADDRESS_SIZE_FAULT_IN0</spirit:name>
              <spirit:description>   An input address size fault occurred while reading level 0 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ADDRESS_SIZE_FAULT_IN1</spirit:name>
              <spirit:description>   An input address size fault occurred while reading level 1 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE1</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ADDRESS_SIZE_FAULT_IN2</spirit:name>
              <spirit:description>   An input address size fault occurred while reading level 2 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE2</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ADDRESS_SIZE_FAULT_IN3</spirit:name>
              <spirit:description>   An input address size fault occurred while reading level 3 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE3</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ADDRESS_SIZE_FAULT_OUT0</spirit:name>
              <spirit:description>   An output address size fault occurred while reading level 0 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE4</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ADDRESS_SIZE_FAULT_OUT1</spirit:name>
              <spirit:description>   An output address size fault occurred while reading level 1 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE5</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ADDRESS_SIZE_FAULT_OUT2</spirit:name>
              <spirit:description>   An output address size fault occurred while reading level 2 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE6</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ADDRESS_SIZE_FAULT_OUT3</spirit:name>
              <spirit:description>   An output address size fault occurred while reading level 3 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE7</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>MEMORY_ATTRIBUTE_FAULT_0</spirit:name>
              <spirit:description>   A memory access could not be allowed due to an attempt to access a page with its memory attribute set to  FAULT in the MEMATTR register. This fault happened when reading level 0 of the translation tables. The appropriate PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE8</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>MEMORY_ATTRIBUTE_FAULT_1</spirit:name>
              <spirit:description>   A memory access could not be allowed due to an attempt to access a page with its memory attribute set to  FAULT in the MEMATTR register. This fault happened when reading level 1 of the translation tables. The appropriate PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE9</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>MEMORY_ATTRIBUTE_FAULT_2</spirit:name>
              <spirit:description>   A memory access could not be allowed due to an attempt to access a page with its memory attribute set to  FAULT in the MEMATTR register. This fault happened when reading level 2 of the translation tables. The appropriate PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xEA</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>MEMORY_ATTRIBUTE_FAULT_3</spirit:name>
              <spirit:description>   A memory access could not be allowed due to an attempt to access a page with its memory attribute set to  FAULT in the MEMATTR register. This fault happened when reading level 3 of the translation tables. The appropriate PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xEB</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>MEMORY_ATTRIBUTE_NONCACHEABLE_0</spirit:name>
              <spirit:description>   A memory access could not be allowed due to an attempt to access a non-cacheable page from a bus master which does not support non-cacheable accessess. This fault happened when reading level 0 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xEC</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>MEMORY_ATTRIBUTE_NONCACHEABLE_1</spirit:name>
              <spirit:description>   A memory access could not be allowed due to an attempt to access a non-cacheable page from a bus master which does not support non-cacheable accessess. This fault happened when reading level 1 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xED</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>MEMORY_ATTRIBUTE_NONCACHEABLE_2</spirit:name>
              <spirit:description>   A memory access could not be allowed due to an attempt to access a non-cacheable page from a bus master which does not support non-cacheable accessess. This fault happened when reading level 2 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xEE</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>MEMORY_ATTRIBUTE_NONCACHEABLE_3</spirit:name>
              <spirit:description>   A memory access could not be allowed due to an attempt to access a non-cacheable page from a bus master which does not support non-cacheable accessess. This fault happened when reading level 3 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xEF</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ACCESS_TYPE</spirit:name>
          <spirit:displayName>ACCESS_TYPE</spirit:displayName>
          <spirit:description>   This field contains the direction of data transfer that caused the fault, if known.  For the purposes of error reporting, atomic transactions act like a read followed by a write, so denying either permission will result in the atomic transaction failing, and the exceptions ACCESS_TYPE field will be set to "atomic". </spirit:description>
          <spirit:bitOffset>8</spirit:bitOffset>
          <spirit:bitWidth>2</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>atomic</spirit:name>
              <spirit:description> An atomic (read/write) transaction. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>execute</spirit:name>
              <spirit:description> An execute transaction. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>read</spirit:name>
              <spirit:description> A read transaction. </spirit:description>
              <spirit:value>2</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>write</spirit:name>
              <spirit:description> A write transaction. </spirit:description>
              <spirit:value>3</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS1_FAULTADDRESS_LO</spirit:name>
        <spirit:displayName>ST1MMUAS1_FAULTADDRESS_LO</spirit:displayName>
        <spirit:description>   This register contains information about the cause of a page fault or bus error. </spirit:description>
        <spirit:addressOffset>0x20</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>ST1MMUAS1FAULTADDRESS_LO</spirit:name>
          <spirit:displayName>ST1MMUAS1FAULTADDRESS_LO</spirit:displayName>
          <spirit:description>   This field contains the virtual address (in this address space) of the access that caused the fault.  Additional information about the fault is also available in the FAULTSTATUS register.  If multiple faults occur before the first is handled, the subsequent faults are ignored. They may fault again after handling the first one. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS1_FAULTADDRESS_HI</spirit:name>
        <spirit:displayName>ST1MMUAS1_FAULTADDRESS_HI</spirit:displayName>
        <spirit:description>   This register contains information about the cause of a page fault or bus error. </spirit:description>
        <spirit:addressOffset>0x24</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>ST1MMUAS1FAULTADDRESS_HI</spirit:name>
          <spirit:displayName>ST1MMUAS1FAULTADDRESS_HI</spirit:displayName>
          <spirit:description>   This field contains the virtual address (in this address space) of the access that caused the fault.  Additional information about the fault is also available in the FAULTSTATUS register.  If multiple faults occur before the first is handled, the subsequent faults are ignored. They may fault again after handling the first one. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS1_STATUS</spirit:name>
        <spirit:displayName>ST1MMUAS1_STATUS</spirit:displayName>
        <spirit:description>   This register contains dynamic status information about this address space. </spirit:description>
        <spirit:addressOffset>0x28</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>Res114</spirit:name>
          <spirit:displayName>Res114</spirit:displayName>
          <spirit:description>Res114</spirit:description>
          <spirit:bitOffset>1</spirit:bitOffset>
          <spirit:bitWidth>31</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>AS_ACTIVE</spirit:name>
          <spirit:displayName>AS_ACTIVE</spirit:displayName>
          <spirit:description>   This flag is set while a MMU_UPDATE, LOCK, UNLOCK, FLUSH_PT or FLUSH_MEM command is active on this address space. This allows software to safely verify that the address space is in a consistent state after reconfiguring the MMU page tables.  If a new command is written to the corresponding COMMAND register while the AS_ACTIVE bit is set, then the command is ignored. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> Address space command register is inactive. A new command may be written to the COMMAND register. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Address space command register is active. Any new command written to the COMMAND register will be ignored. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS1_TRANSCFG_LO</spirit:name>
        <spirit:displayName>ST1MMUAS1_TRANSCFG_LO</spirit:displayName>
        <spirit:description>ST1MMUAS1_TRANSCFG_LO</spirit:description>
        <spirit:addressOffset>0x30</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>Res115</spirit:name>
          <spirit:displayName>Res115</spirit:displayName>
          <spirit:description>Res115</spirit:description>
          <spirit:bitOffset>4</spirit:bitOffset>
          <spirit:bitWidth>2</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>Res116</spirit:name>
          <spirit:displayName>Res116</spirit:displayName>
          <spirit:description>Res116</spirit:description>
          <spirit:bitOffset>11</spirit:bitOffset>
          <spirit:bitWidth>3</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>Res117</spirit:name>
          <spirit:displayName>Res117</spirit:displayName>
          <spirit:description>Res117</spirit:description>
          <spirit:bitOffset>19</spirit:bitOffset>
          <spirit:bitWidth>3</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>Res118</spirit:name>
          <spirit:displayName>Res118</spirit:displayName>
          <spirit:description>Res118</spirit:description>
          <spirit:bitOffset>23</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>Res119</spirit:name>
          <spirit:displayName>Res119</spirit:displayName>
          <spirit:description>Res119</spirit:description>
          <spirit:bitOffset>26</spirit:bitOffset>
          <spirit:bitWidth>2</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>Res120</spirit:name>
          <spirit:displayName>Res120</spirit:displayName>
          <spirit:description>Res120</spirit:description>
          <spirit:bitOffset>31</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>INA_BITS</spirit:name>
          <spirit:displayName>INA_BITS</spirit:displayName>
          <spirit:description>   This field allows the system software to restrict the range of input addresses accepted by this translation stage. This is used in conjunction with the hardware limits to determine the valid address range as follows:  INA_BITS_VALID = min(HW_INA_BITS, 55-INA_BITS)  If the input address is outside the range (0, 2  INA_BITS_VALID -1), then a TRANSLATION_FAULT error is generated.</spirit:description>
          <spirit:bitOffset>6</spirit:bitOffset>
          <spirit:bitWidth>5</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>OUTA_BITS</spirit:name>
          <spirit:displayName>OUTA_BITS</spirit:displayName>
          <spirit:description>   This field allows the system software to restrict the range of output addresses generated by this translation stage. This is used in conjunction with the hardware limits to determine the valid address range as follows:  OUTA_BITS_VALID = min(HW_OUTA_BITS, 55-OUTA_BITS)  If the translated output address is outside the range (0, 2  OUTA_BITS_VALID -1), then a TRANSLATION_FAULT error is generated.</spirit:description>
          <spirit:bitOffset>14</spirit:bitOffset>
          <spirit:bitWidth>5</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>MODE</spirit:name>
          <spirit:displayName>MODE</spirit:displayName>
          <spirit:description>   This field controls the overall operation of the MMU. There are some differences between stage 1 and stage 2.  Execute permissions for a page are evaluated as follows (PTE.&amp;lt;W|R|X&gt; refers to page table entry permissions resolved for hierarchical permissions (if applicable):  EXECUTE_ALLOWED = !((TRANSCFG.WXN &amp;amp; !PTE.W) | (TRANSCFG.XREADABLE &amp;amp; !PTE.R) | (!TRANSCFG.XREADABLE &amp;amp; !PTE.X)) </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>LEGACY</spirit:name>
              <spirit:description>   The contents of TRANSTAB and MEMATTR are interpreted according to the legacy behaviour, as used in previous Midgard GPUs. The rest of the TRANSCFG bits are ignored.  Input and output address sizes are set according to the hardware configuration.  Stage 1 will follow the legacy behaviour.  Stage 2 will be transparent, will ignore TRANSTAB settings and will not generate any faults.  Note: as the reset value of TRANSCFG is 0, this is a mechanism to ensure backwards-compatibility and alignment between the stages. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>UNMAPPED</spirit:name>
              <spirit:description> The MMU forces all memory access to fail with a decode fault. No actual page table is required. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>IDENTITY</spirit:name>
              <spirit:description>   The MMU behaves as if using an address translation table with all entries valid and giving an identity mapping (output address is the same as the input address) with full read/write/execute access. Addresses outside the configured address ranges cause page faults.  For Stage 1, cacheability and shareability are defined by MEMATTR0. For Stage 2, cacheablity and sharebility are defined so that they dont change whats set by Stage 1 (non-shareable and inner/outer write-back cacheable and master-defined allocation). </spirit:description>
              <spirit:value>2</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>AARCH64_4K</spirit:name>
              <spirit:description> Page tables are interpreted according to the AArch64 4kB granule specification. </spirit:description>
              <spirit:value>6</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>AARCH64_64K</spirit:name>
              <spirit:description> Page tables are interpreted according to the AArch64 64kB granule specification. </spirit:description>
              <spirit:value>8</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>PTW_MEMATTR</spirit:name>
          <spirit:displayName>PTW_MEMATTR</spirit:displayName>
          <spirit:description>   Memory attributes for page table walks. The allowed values are compatible with the values allowed for  MEMORY_TYPE . For outer cache transactions, the desired attributes for the transaction will be decided by the bus master and communicated to the memory system using signals on the bus.  Changed allowed values for TRANSCFG.PTW_MEMATTR. </spirit:description>
          <spirit:bitOffset>24</spirit:bitOffset>
          <spirit:bitWidth>2</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NON_CACHEABLE</spirit:name>
              <spirit:description> Normal memory, inner non-cacheable, outer non-cacheable. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>WRITE_BACK</spirit:name>
              <spirit:description> Normal memory, inner write-back cacheable, outer write-back cacheable. </spirit:description>
              <spirit:value>2</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>PTW_SH</spirit:name>
          <spirit:displayName>PTW_SH</spirit:displayName>
          <spirit:description>   This field specifies the shareability for the page table walks. This is the same encoding as used for ARMv8 page tables. </spirit:description>
          <spirit:bitOffset>28</spirit:bitOffset>
          <spirit:bitWidth>2</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>non_shareable</spirit:name>
              <spirit:description> The memory region is non-shareable, and coherency with other observers will not automatically be maintained. Software will have to ensure that caches are flushed or invalidated at appropriate times. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>outer_shareable</spirit:name>
              <spirit:description> The memory region is marked as outer shareable. Each outer shareability domain contains a set of observers that are data coherent for each member of that set for	data accesses with the outer shareable attribute made by any member of that set. </spirit:description>
              <spirit:value>2</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>inner_shareable</spirit:name>
              <spirit:description> The memory region is marked as inner shareable. Each inner shareability domain contains a set of observers that are data coherent for each member of that set for	data accesses with the inner shareable attribute made by any member of that set. All observers in an inner shareability domain are always members of the same outer shareability domain. This means that an inner shareability domain is a subset of an Outer Shareability domain, although it is not required to be a proper subset. </spirit:description>
              <spirit:value>3</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>R_ALLOCATE</spirit:name>
          <spirit:displayName>R_ALLOCATE</spirit:displayName>
          <spirit:description>   This field sets the inner read allocation hint for the page table walks. This is the same encoding as used for ARMv8 page tables. </spirit:description>
          <spirit:bitOffset>30</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>no_read_allocate</spirit:name>
              <spirit:description> Hints that the cache should not allocate space when reading a page table entry. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>read_allocate</spirit:name>
              <spirit:description> Hints that the cache should allocate space when reading a page table entry. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>SL_CONCAT_EN</spirit:name>
          <spirit:displayName>SL_CONCAT_EN</spirit:displayName>
          <spirit:description>   If set then the page table walk starting level will be increased if possible by concatenating up to 16 tables in the starting level. </spirit:description>
          <spirit:bitOffset>22</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> Page table concatenation is disabled. 	This mode must be used for Stage 1 if sharing page tables with the CPU, otherwise  UNDEFINED behavior results.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Page table concatenation is enabled. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS1_TRANSCFG_HI</spirit:name>
        <spirit:displayName>ST1MMUAS1_TRANSCFG_HI</spirit:displayName>
        <spirit:description>ST1MMUAS1_TRANSCFG_HI</spirit:description>
        <spirit:addressOffset>0x34</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>Res121</spirit:name>
          <spirit:displayName>Res121</spirit:displayName>
          <spirit:description>Res121</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>Res122</spirit:name>
          <spirit:displayName>Res122</spirit:displayName>
          <spirit:description>Res122</spirit:description>
          <spirit:bitOffset>5</spirit:bitOffset>
          <spirit:bitWidth>27</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>DISABLE_HIER_AP</spirit:name>
          <spirit:displayName>DISABLE_HIER_AP</spirit:displayName>
          <spirit:description>   This flag only has an effect on stage 1 of translation. It is ignored for stage 2. Note the inverted logic - the flag must be set to  dis able hierarchical access permissions.</spirit:description>
          <spirit:bitOffset>1</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> Hierarchical access permissions are enabled. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Hierarchical access permissions are disabled. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>DISABLE_AF_FAULT</spirit:name>
          <spirit:displayName>DISABLE_AF_FAULT</spirit:displayName>
          <spirit:description>   This flag can be used to disable access fault checking when in one of AARCH64 modes. </spirit:description>
          <spirit:bitOffset>2</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> Access fault checking is enabled. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Access fault checking is disabled. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>WXN</spirit:name>
          <spirit:displayName>WXN</spirit:displayName>
          <spirit:description>   This flag can be used to disable all writes to executable pages, overriding access permissions specified in the page table. </spirit:description>
          <spirit:bitOffset>3</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> Write access permissions are read as usual from the page table. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Write access to all executable pages is disabled. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>XREADABLE</spirit:name>
          <spirit:displayName>XREADABLE</spirit:displayName>
          <spirit:description>   This flag can be used to enable execution on all readable pages, overriding access permissions specified in the page table. </spirit:description>
          <spirit:bitOffset>4</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> Execute access permissions are read as usual from the page table. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Execute access to all readable pages is enabled. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS1_FAULTEXTRA_LO</spirit:name>
        <spirit:displayName>ST1MMUAS1_FAULTEXTRA_LO</spirit:displayName>
        <spirit:description>   This register contains additional information about the cause of a page fault or bus error. </spirit:description>
        <spirit:addressOffset>0x38</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>ST1MMUAS1FAULTEXTRA_LO</spirit:name>
          <spirit:displayName>ST1MMUAS1FAULTEXTRA_LO</spirit:displayName>
          <spirit:description>   This field contains the virtual address (in this address space) of the access that caused the fault.  Additional information about the fault is also available in the  FAULTSTATUS and FAULTADDRESS registers. If multiple faults occur before the first is handled, the subsequent faults are ignored. They may fault again after handling the first one.  Fixed duplicate state name in FAULT_ADDRESS - exposes previously hidden field S2FS1WALK. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS1_FAULTEXTRA_HI</spirit:name>
        <spirit:displayName>ST1MMUAS1_FAULTEXTRA_HI</spirit:displayName>
        <spirit:description>   This register contains additional information about the cause of a page fault or bus error. </spirit:description>
        <spirit:addressOffset>0x3c</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>Res123</spirit:name>
          <spirit:displayName>Res123</spirit:displayName>
          <spirit:description>Res123</spirit:description>
          <spirit:bitOffset>16</spirit:bitOffset>
          <spirit:bitWidth>15</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>ST1MMUAS1FAULTEXTRA_HI</spirit:name>
          <spirit:displayName>ST1MMUAS1FAULTEXTRA_HI</spirit:displayName>
          <spirit:description>   This field contains the virtual address (in this address space) of the access that caused the fault.  Additional information about the fault is also available in the  FAULTSTATUS and FAULTADDRESS registers. If multiple faults occur before the first is handled, the subsequent faults are ignored. They may fault again after handling the first one.  Fixed duplicate state name in FAULT_ADDRESS - exposes previously hidden field S2FS1WALK. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>16</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>S2FS1WALK</spirit:name>
          <spirit:displayName>S2FS1WALK</spirit:displayName>
          <spirit:description>S2FS1WALK</spirit:description>
          <spirit:bitOffset>31</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>stage2</spirit:name>
              <spirit:description> Fault source is a stage 2 translation. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>stage1</spirit:name>
              <spirit:description> Fault source is a stage 1 page table walk. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
    </spirit:addressBlock>
    <spirit:addressBlock>
      <spirit:name>jm_mmu_as2_regs</spirit:name>
      <spirit:baseAddress>9344</spirit:baseAddress>
      <spirit:range>64</spirit:range>
      <spirit:width>32</spirit:width>
      <spirit:usage>register</spirit:usage>
      <spirit:register>
        <spirit:name>ST1MMUAS2_TRANSTAB_LO</spirit:name>
        <spirit:displayName>ST1MMUAS2_TRANSTAB_LO</spirit:displayName>
        <spirit:description>   This register contains the address of the base level of the translation table, together with some related flags.  Details on the layout of the page tables, and the address translation process, can be found in the section  Memory Management Unit .</spirit:description>
        <spirit:addressOffset>0x0</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>Res124</spirit:name>
          <spirit:displayName>Res124</spirit:displayName>
          <spirit:description>Res124</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>ST1MMUAS2TRANSTAB_LO</spirit:name>
          <spirit:displayName>ST1MMUAS2TRANSTAB_LO</spirit:displayName>
          <spirit:description>   This field contains the address of the top level of a page table structure. This must be 16-byte-aligned, so address bits [3:0] are assumed to be zero.  For a stage 1 page table, this will be an intermediate physical address, and for stage 2 it will be a physical address. The number of actual translated address bits is stored in  OUTA_BITS . The unused high bits must be set to 0. Changed alignment text for TRANSTAB.BASE  TRANSTAB.BASE pointer is a physical (or intermediate) address </spirit:description>
          <spirit:bitOffset>4</spirit:bitOffset>
          <spirit:bitWidth>28</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS2_TRANSTAB_HI</spirit:name>
        <spirit:displayName>ST1MMUAS2_TRANSTAB_HI</spirit:displayName>
        <spirit:description>   This register contains the address of the base level of the translation table, together with some related flags.  Details on the layout of the page tables, and the address translation process, can be found in the section  Memory Management Unit .</spirit:description>
        <spirit:addressOffset>0x4</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>ST1MMUAS2TRANSTAB_HI</spirit:name>
          <spirit:displayName>ST1MMUAS2TRANSTAB_HI</spirit:displayName>
          <spirit:description>   This field contains the address of the top level of a page table structure. This must be 16-byte-aligned, so address bits [3:0] are assumed to be zero.  For a stage 1 page table, this will be an intermediate physical address, and for stage 2 it will be a physical address. The number of actual translated address bits is stored in  OUTA_BITS . The unused high bits must be set to 0. Changed alignment text for TRANSTAB.BASE  TRANSTAB.BASE pointer is a physical (or intermediate) address </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS2_MEMATTR_LO</spirit:name>
        <spirit:displayName>ST1MMUAS2_MEMATTR_LO</spirit:displayName>
        <spirit:description>  </spirit:description>
        <spirit:addressOffset>0x8</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>ATTRIBUTE0</spirit:name>
          <spirit:displayName>ATTRIBUTE0</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 0. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE1</spirit:name>
          <spirit:displayName>ATTRIBUTE1</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 1. </spirit:description>
          <spirit:bitOffset>4</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE2</spirit:name>
          <spirit:displayName>ATTRIBUTE2</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 2. </spirit:description>
          <spirit:bitOffset>8</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE3</spirit:name>
          <spirit:displayName>ATTRIBUTE3</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 3. </spirit:description>
          <spirit:bitOffset>12</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE4</spirit:name>
          <spirit:displayName>ATTRIBUTE4</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 4. </spirit:description>
          <spirit:bitOffset>16</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE5</spirit:name>
          <spirit:displayName>ATTRIBUTE5</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 5. </spirit:description>
          <spirit:bitOffset>20</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE6</spirit:name>
          <spirit:displayName>ATTRIBUTE6</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 6. </spirit:description>
          <spirit:bitOffset>24</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE7</spirit:name>
          <spirit:displayName>ATTRIBUTE7</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 7. </spirit:description>
          <spirit:bitOffset>28</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS2_MEMATTR_HI</spirit:name>
        <spirit:displayName>ST1MMUAS2_MEMATTR_HI</spirit:displayName>
        <spirit:description>  </spirit:description>
        <spirit:addressOffset>0xc</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>ATTRIBUTE8</spirit:name>
          <spirit:displayName>ATTRIBUTE8</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 8. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE9</spirit:name>
          <spirit:displayName>ATTRIBUTE9</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 9. </spirit:description>
          <spirit:bitOffset>4</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE10</spirit:name>
          <spirit:displayName>ATTRIBUTE10</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 10. </spirit:description>
          <spirit:bitOffset>8</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE11</spirit:name>
          <spirit:displayName>ATTRIBUTE11</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 11. </spirit:description>
          <spirit:bitOffset>12</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE12</spirit:name>
          <spirit:displayName>ATTRIBUTE12</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 12. </spirit:description>
          <spirit:bitOffset>16</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE13</spirit:name>
          <spirit:displayName>ATTRIBUTE13</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 13. </spirit:description>
          <spirit:bitOffset>20</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE14</spirit:name>
          <spirit:displayName>ATTRIBUTE14</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 14. </spirit:description>
          <spirit:bitOffset>24</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE15</spirit:name>
          <spirit:displayName>ATTRIBUTE15</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 15. </spirit:description>
          <spirit:bitOffset>28</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS2_LOCKADDR_LO</spirit:name>
        <spirit:displayName>ST1MMUAS2_LOCKADDR_LO</spirit:displayName>
        <spirit:description>   This register tells the MMU to lock a region of virtual memory. All page mappings within this region must be flushed, and no translation requests within this region can complete or fault before the area is unlocked.  Only one region can be locked at a time.  As only 32 bits of the register can be written to at a time, no changes are issued until the LOCK command is written to the COMMAND register. </spirit:description>
        <spirit:addressOffset>0x10</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>Res125</spirit:name>
          <spirit:displayName>Res125</spirit:displayName>
          <spirit:description>Res125</spirit:description>
          <spirit:bitOffset>6</spirit:bitOffset>
          <spirit:bitWidth>6</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>LOCKADDR_SIZE</spirit:name>
          <spirit:displayName>LOCKADDR_SIZE</spirit:displayName>
          <spirit:description>   This field contains the log  2 of the size of the region to lock, minus 1. Only values in the range 11 to 63 are valid values for this field, corresponding to region sizes of 4KB up to the entire address space. Values in the range 0 to 10 result in UNDEFINED behavior and should not be used.</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>6</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>ST1MMUAS2LOCKADDR_LO</spirit:name>
          <spirit:displayName>ST1MMUAS2LOCKADDR_LO</spirit:displayName>
          <spirit:description>   This field contains the lowest address in the region to be locked. The address is a virtual address in this address space.  Only the upper bits of the address are used. The address is aligned to a multiple of the region size, so a variable number of low-order bits are ignored, depending on the selected region size. It is recommended that software ensures that these low bits in the address are cleared, to avoid confusion. </spirit:description>
          <spirit:bitOffset>12</spirit:bitOffset>
          <spirit:bitWidth>20</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS2_LOCKADDR_HI</spirit:name>
        <spirit:displayName>ST1MMUAS2_LOCKADDR_HI</spirit:displayName>
        <spirit:description>   This register tells the MMU to lock a region of virtual memory. All page mappings within this region must be flushed, and no translation requests within this region can complete or fault before the area is unlocked.  Only one region can be locked at a time.  As only 32 bits of the register can be written to at a time, no changes are issued until the LOCK command is written to the COMMAND register. </spirit:description>
        <spirit:addressOffset>0x14</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>ST1MMUAS2LOCKADDR_HI</spirit:name>
          <spirit:displayName>ST1MMUAS2LOCKADDR_HI</spirit:displayName>
          <spirit:description>   This field contains the lowest address in the region to be locked. The address is a virtual address in this address space.  Only the upper bits of the address are used. The address is aligned to a multiple of the region size, so a variable number of low-order bits are ignored, depending on the selected region size. It is recommended that software ensures that these low bits in the address are cleared, to avoid confusion. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS2_COMMAND</spirit:name>
        <spirit:displayName>ST1MMUAS2_COMMAND</spirit:displayName>
        <spirit:description>   MMU commands are issued by writing to this register. Any command written to an address space while the corresponding STATUS.AS_ACTIVE flag is set will be ignored.  In general an MMU command only applies to the address space it is submitted to. However a command that invalidates the MMU cache may invalidate the whole MMU cache rather than only those entries specific to one address space. </spirit:description>
        <spirit:addressOffset>0x18</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>ST1MMUAS2COMMAND</spirit:name>
          <spirit:displayName>ST1MMUAS2COMMAND</spirit:displayName>
          <spirit:description>ST1MMUAS2COMMAND</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>write-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NOP</spirit:name>
              <spirit:description> No operation, nothing happens. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>UPDATE</spirit:name>
              <spirit:description> Broadcasts the values in TRANSTAB and MEMATTR to all MMUs. MMU caches are invalidated. Use this after changing the content of these registers. This will  not clear the effect of a LOCK set in the updated address space.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>LOCK</spirit:name>
              <spirit:description> Issues a lock region command to all MMUs, using the address and size set in the LOCKADDR register. MMU caches are invalidated. Use this before changing an in-memory page table. Any existing lock on this address space is cleared. Locks on other address spaces are not affected. Use a FLUSH or UNLOCK command to unlock a memory region. </spirit:description>
              <spirit:value>2</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>UNLOCK</spirit:name>
              <spirit:description> Issues an unlock region command to all MMUs, using the address and size set in the LOCKADDR register. Any existing lock on this address space is cleared. If no lock was present, the MMU caches are invalidated. Use this when finished changing an in-memory page table, except if the page table can be cached in the L2 cache, in which case, a FLUSH_MEM command must be issued instead. </spirit:description>
              <spirit:value>3</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FLUSH_PT</spirit:name>
              <spirit:description> First cleans and invalidates all L2 caches to force cached page tables to be invalidated, then performs an UNLOCK command. </spirit:description>
              <spirit:value>4</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FLUSH_MEM</spirit:name>
              <spirit:description> First waits until all memory accesses to a region locked by a preceding LOCK command have completed and have reached the nearest cache.
			This will ensure that all reads to a locked memory region have finished, and that any writes to a locked region have either been written out to memory or are present in the L1 or L2 cache as dirty data.
			Then cleans and invalidates the L1 cache in all shader cores, forcing dirty data for locked regions to be pushed out to the L2 cache.
			Then cleans and invalidates all L2 caches forcing all dirty data for locked regions to be written back to memory and page tables to be invalidated.
			Then performs an UNLOCK command on this address space.
			Use this when finished changing or removing entries in an in-memory page table. </spirit:description>
              <spirit:value>5</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS2_FAULTSTATUS</spirit:name>
        <spirit:displayName>ST1MMUAS2_FAULTSTATUS</spirit:displayName>
        <spirit:description>   This register contains extended status information after a fault. If read before a fault occurs, its contents are the reset value, 0, which indicates no fault.
						If multiple faults occur before the first is handled, the subsequent faults are ignored. They may fault again after handling the first one.  If the GPU is in protected mode, this register is not updated, and MMU faults are ignored. 
						They are not fatal but will halt the GPU until the MMU address space is updated. 
						However, no fault information wil be visible in this case.  Changed access type of MMU_FAULTSTATUS register when in protected mode. </spirit:description>
        <spirit:addressOffset>0x1c</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>Res126</spirit:name>
          <spirit:displayName>Res126</spirit:displayName>
          <spirit:description>Res126</spirit:description>
          <spirit:bitOffset>10</spirit:bitOffset>
          <spirit:bitWidth>6</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>SOURCE_ID</spirit:name>
          <spirit:displayName>SOURCE_ID</spirit:displayName>
          <spirit:description>   This field contains an implementation-defined ID that supplies additional data about the source of the fault. For example, it may be the ID of the internal bus master that issued the request that faulted. This makes it possible to distinguish between the job manager, the texture unit and the load/store unit. Another example might be an indication of the type of an invalid data structure. The values in this field are implementation defined. </spirit:description>
          <spirit:bitOffset>16</spirit:bitOffset>
          <spirit:bitWidth>16</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>EXCEPTION_TYPE</spirit:name>
          <spirit:displayName>EXCEPTION_TYPE</spirit:displayName>
          <spirit:description>   This field indicates the type of exception that caused the fault. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>8</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>OK</spirit:name>
              <spirit:description>   This indicates that the GPU has completed its work and is in a state ready to receive new commands. Its precise meaning depends on its usage:    In the job status field, this indicates that the job has not been started. This should be the initial state of a newly created job.  In the job slot status register, this indicates that the job slot is idle.  In the GPU and MMU exception status registers, this indicates that no exception has yet been received.  No additional error information is available (or indeed required). </spirit:description>
              <spirit:value>0x00</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>DONE</spirit:name>
              <spirit:description> The job completed successfully. The fault value is written to the job descriptor.
			The job descriptors fault address field contains the TIMESTAMP value when the job completed.
			If a job is terminated early using the  EUREKA instruction, then that job will be marked with the EUREKA exception status but the job chain status as a whole will still be DONE.</spirit:description>
              <spirit:value>0x01</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>SUSPENDED</spirit:name>
              <spirit:description> The job was interrupted by a SUSPEND command. The fault value is written both to the job slot  STATUS register and the job descriptor.
			The job descriptor contains the partition index of the first task to be interrupted. The fault address field contains the TIMESTAMP value when the job was interrupted.</spirit:description>
              <spirit:value>0x02</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>STOPPED</spirit:name>
              <spirit:description> The job was interrupted by a SOFT_STOP command. The fault value is written both to the job slot  STATUS register and the job descriptor.
			The job descriptor contains the partition index of the first task that was not completed. This will be the index of the first task issued if the job is resumed. The fault address is UNDEFINED .</spirit:description>
              <spirit:value>0x03</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TERMINATED</spirit:name>
              <spirit:description> The job was interrupted by a HARD_STOP command or a  KABOOM instruction from another job. The fault value is written both to the job slot STATUS register and the job descriptor.
			This status is treated in the same way as an error condition. The job descriptor contains the partition index of the first task to be terminated. The fault address field contains the TIMESTAMP value when the job was interrupted.</spirit:description>
              <spirit:value>0x04</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>KABOOM</spirit:name>
              <spirit:description> The job was interrupted by a shader executing a  KABOOM instruction. The fault value is written both to the job slot STATUS register and the job descriptor.
			This status is treated in the same way as an error condition. The job descriptor contains the partition index of the first task to be terminated. The fault address field contains the TIMESTAMP value when the job was interrupted.</spirit:description>
              <spirit:value>0x05</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>EUREKA</spirit:name>
              <spirit:description> The job was interrupted by a shader executing a  EUREKA instruction. The fault value is written only to the job descriptor, and does not affect subsequent jobs in the job chain.
			The job descriptor contains the partition index of the first task to be terminated. The fault address field contains the TIMESTAMP value when the job was interrupted.</spirit:description>
              <spirit:value>0x06</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ACTIVE</spirit:name>
              <spirit:description> In the JSn_STATUS register, this indicates that the job slot is active.
			The JSn_HEAD and JSn_TAIL registers contain the range of job descriptors currently in progress. </spirit:description>
              <spirit:value>0x08</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>JOB_CONFIG_FAULT</spirit:name>
              <spirit:description>   The job configuration specified in the job slot registers is invalid, so it is not possible to read job descriptors.
				For example this includes setting a NULL job descriptor pointer, selecting an address space that isnt present.
				No additional information is available. </spirit:description>
              <spirit:value>0x40</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>JOB_POWER_FAULT</spirit:name>
              <spirit:description>   The job could not be executed because the part of the memory system required to access job descriptors was not powered on.
				No additional information is available. </spirit:description>
              <spirit:value>0x41</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>JOB_READ_FAULT</spirit:name>
              <spirit:description>   Reading a job descriptor into the Job manager failed.
				The JSn_HEAD register contains the virtual address of the job descriptor that could not be read. </spirit:description>
              <spirit:value>0x42</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>JOB_WRITE_FAULT</spirit:name>
              <spirit:description>   Writing a job descriptor from the Job manager failed.
				The JSn_TAIL register contains the virtual address of the job descriptor that could not be written. </spirit:description>
              <spirit:value>0x43</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>JOB_AFFINITY_FAULT</spirit:name>
              <spirit:description>   The job could not be executed because the specified affinity mask does not intersect any available cores.
				No additional information is available. </spirit:description>
              <spirit:value>0x44</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>JOB_BUS_FAULT</spirit:name>
              <spirit:description>   A bus access failed while executing a job.
				The job descriptor contains the virtual address of the failing access, the type of access, and which part of the GPU initiated the access.
				This error code may also be reported if a bus fault occurs while writing the performance counters to memory. In this case, the GPU_FAULT* registers are updated, but the active JASID is not reported. It is possible to distinguish this case from a genuine Job Bus Fault exception by examining the SOURCE_ID field. </spirit:description>
              <spirit:value>0x48</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>INSTR_INVALID_PC</spirit:name>
              <spirit:description>   A shader instruction with an illegal program counter was executed.
				The job descriptors fault address field contains the offending program counter value. </spirit:description>
              <spirit:value>0x50</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>INSTR_INVALID_ENC</spirit:name>
              <spirit:description>   A shader instruction with an illegal encoding was executed.
				The job descriptors fault address field contains the program counter used to reach the offending instruction. </spirit:description>
              <spirit:value>0x51</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>INSTR_BARRIER_FAULT</spirit:name>
              <spirit:description>   A shader instruction was executed that failed to complete an instruction barrier.
				The job descriptors fault address field contains the program counter used to reach the offending instruction. </spirit:description>
              <spirit:value>0x55</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>DATA_INVALID_FAULT</spirit:name>
              <spirit:description>   Any data structure read as part of the job contains invalid combinations of data.
				The job descriptors fault address field contains the virtual address of the invalid data structure. </spirit:description>
              <spirit:value>0x58</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TILE_RANGE_FAULT</spirit:name>
              <spirit:description>   Tile or fragment shading was asked to process a tile that is entirely outside the bounding box of the frame.
				The job descriptors fault address field contains the coordinates of the top left corner of the failing tile, with X in the bits [15:0], and Y in the bits [31:16].  Clarified description of TILE_RANGE_FAULT. </spirit:description>
              <spirit:value>0x59</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ADDR_RANGE_FAULT</spirit:name>
              <spirit:description>   A virtual address has been found that exceeds the virtual address range.
				The job descriptors fault address field contains the virtual address which is out of range. </spirit:description>
              <spirit:value>0x5A</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>IMPRECISE_FAULT</spirit:name>
              <spirit:description>   A fault has been generated without precise fault information.
				This can happen if appropriate source information is not available at the point where the fault happens.
				The job descriptors fault address field may contain a virtual address related to the fault. </spirit:description>
              <spirit:value>0x5B</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>OUT_OF_MEMORY</spirit:name>
              <spirit:description>   The tiler ran out of memory when executing a job.
				The job descriptors fault address field contains the index of the last completed vertex sent through the tiler. </spirit:description>
              <spirit:value>0x60</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>UNKNOWN</spirit:name>
              <spirit:description>   If multiple jobs in a job chain fail, only the first one the reports an error will set and return full error information. Subsequent failing jobs will not update the error status registers, and may write an error status of UNKNOWN.
				Note that the first job to fail may not be the first job in the chain, which may lead to jobs with  UNKNOWN error status being encountered first when traversing the job chain.
				For example, you may see: Done, Done, Unknown, Bus Error, Unknown, New. In this case, the first two jobs ran successfully, the fourth job hit a bus error, and then jobs three and five also failed. The sixth and subsequent jobs had not been started at that point.</spirit:description>
              <spirit:value>0x7F</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>DELAYED_BUS_FAULT</spirit:name>
              <spirit:description>   The GPU received a bus fault for access to physical memory where the original virtual address is no longer available. This is the result of evicting a dirty line from a cache.
				This may also be triggered by a bus fault during a Tiler cache flush operation. In this case, the address reported in  GPU_FAULTADDRESS is a virtual address.</spirit:description>
              <spirit:value>0x80</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>GPU_SHAREABILITY_FAULT</spirit:name>
              <spirit:description>   A cache has detected that the same line has been accessed as both shareable and non-shareable memory from inside the GPU. Coherency after this point can no longer be guaranteed. </spirit:description>
              <spirit:value>0x88</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>SYSTEM_SHAREABILITY_FAULT</spirit:name>
              <spirit:description>   A cache has detected that the same line has been accessed as both shareable and non-shareable memory from outside the GPU. Coherency after this point can no longer be guaranteed. </spirit:description>
              <spirit:value>0x89</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>GPU_CACHEABILITY_FAULT</spirit:name>
              <spirit:description>   A cache has detected that the same line has been accessed as both cacheable and non-cacheable memory from inside the GPU. Non-cacheable memory may have been cached. </spirit:description>
              <spirit:value>0x8A</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TRANSLATION_FAULT_0</spirit:name>
              <spirit:description>   A memory access hit an invalid table entry at level 0 of the translation table. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xC0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TRANSLATION_FAULT_1</spirit:name>
              <spirit:description>   A memory access hit an invalid table entry at level 1 of the translation table. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xC1</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TRANSLATION_FAULT_2</spirit:name>
              <spirit:description>   A memory access hit an invalid table entry at level 2 of the translation table. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xC2</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TRANSLATION_FAULT_3</spirit:name>
              <spirit:description>   A memory access hit an invalid table entry at level 3 of the translation table. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xC3</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TRANSLATION_FAULT_IDENTITY</spirit:name>
              <spirit:description>   In IDENTITY translation mode, the virtual address exceeds the maximum physical address. </spirit:description>
              <spirit:value>0xC7</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>PERMISSION_FAULT_0</spirit:name>
              <spirit:description>   A memory access could not be allowed due to the permission flags set in level 0 of the translation table. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set. Added MMU translation level information to permission fault. </spirit:description>
              <spirit:value>0xC8</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>PERMISSION_FAULT_1</spirit:name>
              <spirit:description>   A memory access could not be allowed due to the permission flags set in level 1 of the translation table. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xC9</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>PERMISSION_FAULT_2</spirit:name>
              <spirit:description>   A memory access could not be allowed due to the permission flags set in level 2 of the translation table. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xCA</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>PERMISSION_FAULT_3</spirit:name>
              <spirit:description>   A memory access could not be allowed due to the permission flags set in level 3 of the translation table. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xCB</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TRANSTAB_BUS_FAULT_0</spirit:name>
              <spirit:description>   A bus fault occurred while reading level 0 of the translation tables. The appropriate  BUS_ERROR flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xD0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TRANSTAB_BUS_FAULT_1</spirit:name>
              <spirit:description>   A bus fault occurred while reading level 1 of the translation tables. The appropriate  BUS_ERROR flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xD1</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TRANSTAB_BUS_FAULT_2</spirit:name>
              <spirit:description>   A bus fault occurred while reading level 2 of the translation tables. The appropriate  BUS_ERROR flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xD2</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TRANSTAB_BUS_FAULT_3</spirit:name>
              <spirit:description>   A bus fault occurred while reading level 3 of the translation tables. The appropriate  BUS_ERROR flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xD3</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ACCESS_FLAG_0</spirit:name>
              <spirit:description>   A memory access hit a translation table entry with the ACCESS_FLAG bit set in level 0 of the translation table. This is not treated as a fault by the accessor. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set. Added MMU translation level information to access flag fault. </spirit:description>
              <spirit:value>0xD8</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ACCESS_FLAG_1</spirit:name>
              <spirit:description>   A memory access hit a translation table entry with the ACCESS_FLAG bit set in level 1 of the translation table. This is not treated as a fault by the accessor. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xD9</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ACCESS_FLAG_2</spirit:name>
              <spirit:description>   A memory access hit a translation table entry with the ACCESS_FLAG bit set in level 2 of the translation table. This is not treated as a fault by the accessor. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xDA</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ACCESS_FLAG_3</spirit:name>
              <spirit:description>   A memory access hit a translation table entry with the ACCESS_FLAG bit set in level 3 of the translation table. This is not treated as a fault by the accessor. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xDB</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ADDRESS_SIZE_FAULT_IN0</spirit:name>
              <spirit:description>   An input address size fault occurred while reading level 0 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ADDRESS_SIZE_FAULT_IN1</spirit:name>
              <spirit:description>   An input address size fault occurred while reading level 1 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE1</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ADDRESS_SIZE_FAULT_IN2</spirit:name>
              <spirit:description>   An input address size fault occurred while reading level 2 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE2</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ADDRESS_SIZE_FAULT_IN3</spirit:name>
              <spirit:description>   An input address size fault occurred while reading level 3 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE3</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ADDRESS_SIZE_FAULT_OUT0</spirit:name>
              <spirit:description>   An output address size fault occurred while reading level 0 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE4</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ADDRESS_SIZE_FAULT_OUT1</spirit:name>
              <spirit:description>   An output address size fault occurred while reading level 1 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE5</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ADDRESS_SIZE_FAULT_OUT2</spirit:name>
              <spirit:description>   An output address size fault occurred while reading level 2 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE6</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ADDRESS_SIZE_FAULT_OUT3</spirit:name>
              <spirit:description>   An output address size fault occurred while reading level 3 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE7</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>MEMORY_ATTRIBUTE_FAULT_0</spirit:name>
              <spirit:description>   A memory access could not be allowed due to an attempt to access a page with its memory attribute set to  FAULT in the MEMATTR register. This fault happened when reading level 0 of the translation tables. The appropriate PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE8</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>MEMORY_ATTRIBUTE_FAULT_1</spirit:name>
              <spirit:description>   A memory access could not be allowed due to an attempt to access a page with its memory attribute set to  FAULT in the MEMATTR register. This fault happened when reading level 1 of the translation tables. The appropriate PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE9</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>MEMORY_ATTRIBUTE_FAULT_2</spirit:name>
              <spirit:description>   A memory access could not be allowed due to an attempt to access a page with its memory attribute set to  FAULT in the MEMATTR register. This fault happened when reading level 2 of the translation tables. The appropriate PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xEA</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>MEMORY_ATTRIBUTE_FAULT_3</spirit:name>
              <spirit:description>   A memory access could not be allowed due to an attempt to access a page with its memory attribute set to  FAULT in the MEMATTR register. This fault happened when reading level 3 of the translation tables. The appropriate PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xEB</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>MEMORY_ATTRIBUTE_NONCACHEABLE_0</spirit:name>
              <spirit:description>   A memory access could not be allowed due to an attempt to access a non-cacheable page from a bus master which does not support non-cacheable accessess. This fault happened when reading level 0 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xEC</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>MEMORY_ATTRIBUTE_NONCACHEABLE_1</spirit:name>
              <spirit:description>   A memory access could not be allowed due to an attempt to access a non-cacheable page from a bus master which does not support non-cacheable accessess. This fault happened when reading level 1 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xED</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>MEMORY_ATTRIBUTE_NONCACHEABLE_2</spirit:name>
              <spirit:description>   A memory access could not be allowed due to an attempt to access a non-cacheable page from a bus master which does not support non-cacheable accessess. This fault happened when reading level 2 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xEE</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>MEMORY_ATTRIBUTE_NONCACHEABLE_3</spirit:name>
              <spirit:description>   A memory access could not be allowed due to an attempt to access a non-cacheable page from a bus master which does not support non-cacheable accessess. This fault happened when reading level 3 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xEF</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ACCESS_TYPE</spirit:name>
          <spirit:displayName>ACCESS_TYPE</spirit:displayName>
          <spirit:description>   This field contains the direction of data transfer that caused the fault, if known.  For the purposes of error reporting, atomic transactions act like a read followed by a write, so denying either permission will result in the atomic transaction failing, and the exceptions ACCESS_TYPE field will be set to "atomic". </spirit:description>
          <spirit:bitOffset>8</spirit:bitOffset>
          <spirit:bitWidth>2</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>atomic</spirit:name>
              <spirit:description> An atomic (read/write) transaction. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>execute</spirit:name>
              <spirit:description> An execute transaction. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>read</spirit:name>
              <spirit:description> A read transaction. </spirit:description>
              <spirit:value>2</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>write</spirit:name>
              <spirit:description> A write transaction. </spirit:description>
              <spirit:value>3</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS2_FAULTADDRESS_LO</spirit:name>
        <spirit:displayName>ST1MMUAS2_FAULTADDRESS_LO</spirit:displayName>
        <spirit:description>   This register contains information about the cause of a page fault or bus error. </spirit:description>
        <spirit:addressOffset>0x20</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>ST1MMUAS2FAULTADDRESS_LO</spirit:name>
          <spirit:displayName>ST1MMUAS2FAULTADDRESS_LO</spirit:displayName>
          <spirit:description>   This field contains the virtual address (in this address space) of the access that caused the fault.  Additional information about the fault is also available in the FAULTSTATUS register.  If multiple faults occur before the first is handled, the subsequent faults are ignored. They may fault again after handling the first one. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS2_FAULTADDRESS_HI</spirit:name>
        <spirit:displayName>ST1MMUAS2_FAULTADDRESS_HI</spirit:displayName>
        <spirit:description>   This register contains information about the cause of a page fault or bus error. </spirit:description>
        <spirit:addressOffset>0x24</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>ST1MMUAS2FAULTADDRESS_HI</spirit:name>
          <spirit:displayName>ST1MMUAS2FAULTADDRESS_HI</spirit:displayName>
          <spirit:description>   This field contains the virtual address (in this address space) of the access that caused the fault.  Additional information about the fault is also available in the FAULTSTATUS register.  If multiple faults occur before the first is handled, the subsequent faults are ignored. They may fault again after handling the first one. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS2_STATUS</spirit:name>
        <spirit:displayName>ST1MMUAS2_STATUS</spirit:displayName>
        <spirit:description>   This register contains dynamic status information about this address space. </spirit:description>
        <spirit:addressOffset>0x28</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>Res127</spirit:name>
          <spirit:displayName>Res127</spirit:displayName>
          <spirit:description>Res127</spirit:description>
          <spirit:bitOffset>1</spirit:bitOffset>
          <spirit:bitWidth>31</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>AS_ACTIVE</spirit:name>
          <spirit:displayName>AS_ACTIVE</spirit:displayName>
          <spirit:description>   This flag is set while a MMU_UPDATE, LOCK, UNLOCK, FLUSH_PT or FLUSH_MEM command is active on this address space. This allows software to safely verify that the address space is in a consistent state after reconfiguring the MMU page tables.  If a new command is written to the corresponding COMMAND register while the AS_ACTIVE bit is set, then the command is ignored. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> Address space command register is inactive. A new command may be written to the COMMAND register. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Address space command register is active. Any new command written to the COMMAND register will be ignored. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS2_TRANSCFG_LO</spirit:name>
        <spirit:displayName>ST1MMUAS2_TRANSCFG_LO</spirit:displayName>
        <spirit:description>ST1MMUAS2_TRANSCFG_LO</spirit:description>
        <spirit:addressOffset>0x30</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>Res128</spirit:name>
          <spirit:displayName>Res128</spirit:displayName>
          <spirit:description>Res128</spirit:description>
          <spirit:bitOffset>4</spirit:bitOffset>
          <spirit:bitWidth>2</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>Res129</spirit:name>
          <spirit:displayName>Res129</spirit:displayName>
          <spirit:description>Res129</spirit:description>
          <spirit:bitOffset>11</spirit:bitOffset>
          <spirit:bitWidth>3</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>Res130</spirit:name>
          <spirit:displayName>Res130</spirit:displayName>
          <spirit:description>Res130</spirit:description>
          <spirit:bitOffset>19</spirit:bitOffset>
          <spirit:bitWidth>3</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>Res131</spirit:name>
          <spirit:displayName>Res131</spirit:displayName>
          <spirit:description>Res131</spirit:description>
          <spirit:bitOffset>23</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>Res132</spirit:name>
          <spirit:displayName>Res132</spirit:displayName>
          <spirit:description>Res132</spirit:description>
          <spirit:bitOffset>26</spirit:bitOffset>
          <spirit:bitWidth>2</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>Res133</spirit:name>
          <spirit:displayName>Res133</spirit:displayName>
          <spirit:description>Res133</spirit:description>
          <spirit:bitOffset>31</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>INA_BITS</spirit:name>
          <spirit:displayName>INA_BITS</spirit:displayName>
          <spirit:description>   This field allows the system software to restrict the range of input addresses accepted by this translation stage. This is used in conjunction with the hardware limits to determine the valid address range as follows:  INA_BITS_VALID = min(HW_INA_BITS, 55-INA_BITS)  If the input address is outside the range (0, 2  INA_BITS_VALID -1), then a TRANSLATION_FAULT error is generated.</spirit:description>
          <spirit:bitOffset>6</spirit:bitOffset>
          <spirit:bitWidth>5</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>OUTA_BITS</spirit:name>
          <spirit:displayName>OUTA_BITS</spirit:displayName>
          <spirit:description>   This field allows the system software to restrict the range of output addresses generated by this translation stage. This is used in conjunction with the hardware limits to determine the valid address range as follows:  OUTA_BITS_VALID = min(HW_OUTA_BITS, 55-OUTA_BITS)  If the translated output address is outside the range (0, 2  OUTA_BITS_VALID -1), then a TRANSLATION_FAULT error is generated.</spirit:description>
          <spirit:bitOffset>14</spirit:bitOffset>
          <spirit:bitWidth>5</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>MODE</spirit:name>
          <spirit:displayName>MODE</spirit:displayName>
          <spirit:description>   This field controls the overall operation of the MMU. There are some differences between stage 1 and stage 2.  Execute permissions for a page are evaluated as follows (PTE.&amp;lt;W|R|X&gt; refers to page table entry permissions resolved for hierarchical permissions (if applicable):  EXECUTE_ALLOWED = !((TRANSCFG.WXN &amp;amp; !PTE.W) | (TRANSCFG.XREADABLE &amp;amp; !PTE.R) | (!TRANSCFG.XREADABLE &amp;amp; !PTE.X)) </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>LEGACY</spirit:name>
              <spirit:description>   The contents of TRANSTAB and MEMATTR are interpreted according to the legacy behaviour, as used in previous Midgard GPUs. The rest of the TRANSCFG bits are ignored.  Input and output address sizes are set according to the hardware configuration.  Stage 1 will follow the legacy behaviour.  Stage 2 will be transparent, will ignore TRANSTAB settings and will not generate any faults.  Note: as the reset value of TRANSCFG is 0, this is a mechanism to ensure backwards-compatibility and alignment between the stages. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>UNMAPPED</spirit:name>
              <spirit:description> The MMU forces all memory access to fail with a decode fault. No actual page table is required. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>IDENTITY</spirit:name>
              <spirit:description>   The MMU behaves as if using an address translation table with all entries valid and giving an identity mapping (output address is the same as the input address) with full read/write/execute access. Addresses outside the configured address ranges cause page faults.  For Stage 1, cacheability and shareability are defined by MEMATTR0. For Stage 2, cacheablity and sharebility are defined so that they dont change whats set by Stage 1 (non-shareable and inner/outer write-back cacheable and master-defined allocation). </spirit:description>
              <spirit:value>2</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>AARCH64_4K</spirit:name>
              <spirit:description> Page tables are interpreted according to the AArch64 4kB granule specification. </spirit:description>
              <spirit:value>6</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>AARCH64_64K</spirit:name>
              <spirit:description> Page tables are interpreted according to the AArch64 64kB granule specification. </spirit:description>
              <spirit:value>8</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>PTW_MEMATTR</spirit:name>
          <spirit:displayName>PTW_MEMATTR</spirit:displayName>
          <spirit:description>   Memory attributes for page table walks. The allowed values are compatible with the values allowed for  MEMORY_TYPE . For outer cache transactions, the desired attributes for the transaction will be decided by the bus master and communicated to the memory system using signals on the bus.  Changed allowed values for TRANSCFG.PTW_MEMATTR. </spirit:description>
          <spirit:bitOffset>24</spirit:bitOffset>
          <spirit:bitWidth>2</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NON_CACHEABLE</spirit:name>
              <spirit:description> Normal memory, inner non-cacheable, outer non-cacheable. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>WRITE_BACK</spirit:name>
              <spirit:description> Normal memory, inner write-back cacheable, outer write-back cacheable. </spirit:description>
              <spirit:value>2</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>PTW_SH</spirit:name>
          <spirit:displayName>PTW_SH</spirit:displayName>
          <spirit:description>   This field specifies the shareability for the page table walks. This is the same encoding as used for ARMv8 page tables. </spirit:description>
          <spirit:bitOffset>28</spirit:bitOffset>
          <spirit:bitWidth>2</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>non_shareable</spirit:name>
              <spirit:description> The memory region is non-shareable, and coherency with other observers will not automatically be maintained. Software will have to ensure that caches are flushed or invalidated at appropriate times. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>outer_shareable</spirit:name>
              <spirit:description> The memory region is marked as outer shareable. Each outer shareability domain contains a set of observers that are data coherent for each member of that set for	data accesses with the outer shareable attribute made by any member of that set. </spirit:description>
              <spirit:value>2</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>inner_shareable</spirit:name>
              <spirit:description> The memory region is marked as inner shareable. Each inner shareability domain contains a set of observers that are data coherent for each member of that set for	data accesses with the inner shareable attribute made by any member of that set. All observers in an inner shareability domain are always members of the same outer shareability domain. This means that an inner shareability domain is a subset of an Outer Shareability domain, although it is not required to be a proper subset. </spirit:description>
              <spirit:value>3</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>R_ALLOCATE</spirit:name>
          <spirit:displayName>R_ALLOCATE</spirit:displayName>
          <spirit:description>   This field sets the inner read allocation hint for the page table walks. This is the same encoding as used for ARMv8 page tables. </spirit:description>
          <spirit:bitOffset>30</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>no_read_allocate</spirit:name>
              <spirit:description> Hints that the cache should not allocate space when reading a page table entry. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>read_allocate</spirit:name>
              <spirit:description> Hints that the cache should allocate space when reading a page table entry. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>SL_CONCAT_EN</spirit:name>
          <spirit:displayName>SL_CONCAT_EN</spirit:displayName>
          <spirit:description>   If set then the page table walk starting level will be increased if possible by concatenating up to 16 tables in the starting level. </spirit:description>
          <spirit:bitOffset>22</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> Page table concatenation is disabled. 	This mode must be used for Stage 1 if sharing page tables with the CPU, otherwise  UNDEFINED behavior results.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Page table concatenation is enabled. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS2_TRANSCFG_HI</spirit:name>
        <spirit:displayName>ST1MMUAS2_TRANSCFG_HI</spirit:displayName>
        <spirit:description>ST1MMUAS2_TRANSCFG_HI</spirit:description>
        <spirit:addressOffset>0x34</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>Res134</spirit:name>
          <spirit:displayName>Res134</spirit:displayName>
          <spirit:description>Res134</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>Res135</spirit:name>
          <spirit:displayName>Res135</spirit:displayName>
          <spirit:description>Res135</spirit:description>
          <spirit:bitOffset>5</spirit:bitOffset>
          <spirit:bitWidth>27</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>DISABLE_HIER_AP</spirit:name>
          <spirit:displayName>DISABLE_HIER_AP</spirit:displayName>
          <spirit:description>   This flag only has an effect on stage 1 of translation. It is ignored for stage 2. Note the inverted logic - the flag must be set to  dis able hierarchical access permissions.</spirit:description>
          <spirit:bitOffset>1</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> Hierarchical access permissions are enabled. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Hierarchical access permissions are disabled. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>DISABLE_AF_FAULT</spirit:name>
          <spirit:displayName>DISABLE_AF_FAULT</spirit:displayName>
          <spirit:description>   This flag can be used to disable access fault checking when in one of AARCH64 modes. </spirit:description>
          <spirit:bitOffset>2</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> Access fault checking is enabled. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Access fault checking is disabled. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>WXN</spirit:name>
          <spirit:displayName>WXN</spirit:displayName>
          <spirit:description>   This flag can be used to disable all writes to executable pages, overriding access permissions specified in the page table. </spirit:description>
          <spirit:bitOffset>3</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> Write access permissions are read as usual from the page table. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Write access to all executable pages is disabled. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>XREADABLE</spirit:name>
          <spirit:displayName>XREADABLE</spirit:displayName>
          <spirit:description>   This flag can be used to enable execution on all readable pages, overriding access permissions specified in the page table. </spirit:description>
          <spirit:bitOffset>4</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> Execute access permissions are read as usual from the page table. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Execute access to all readable pages is enabled. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS2_FAULTEXTRA_LO</spirit:name>
        <spirit:displayName>ST1MMUAS2_FAULTEXTRA_LO</spirit:displayName>
        <spirit:description>   This register contains additional information about the cause of a page fault or bus error. </spirit:description>
        <spirit:addressOffset>0x38</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>ST1MMUAS2FAULTEXTRA_LO</spirit:name>
          <spirit:displayName>ST1MMUAS2FAULTEXTRA_LO</spirit:displayName>
          <spirit:description>   This field contains the virtual address (in this address space) of the access that caused the fault.  Additional information about the fault is also available in the  FAULTSTATUS and FAULTADDRESS registers. If multiple faults occur before the first is handled, the subsequent faults are ignored. They may fault again after handling the first one.  Fixed duplicate state name in FAULT_ADDRESS - exposes previously hidden field S2FS1WALK. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS2_FAULTEXTRA_HI</spirit:name>
        <spirit:displayName>ST1MMUAS2_FAULTEXTRA_HI</spirit:displayName>
        <spirit:description>   This register contains additional information about the cause of a page fault or bus error. </spirit:description>
        <spirit:addressOffset>0x3c</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>Res136</spirit:name>
          <spirit:displayName>Res136</spirit:displayName>
          <spirit:description>Res136</spirit:description>
          <spirit:bitOffset>16</spirit:bitOffset>
          <spirit:bitWidth>15</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>ST1MMUAS2FAULTEXTRA_HI</spirit:name>
          <spirit:displayName>ST1MMUAS2FAULTEXTRA_HI</spirit:displayName>
          <spirit:description>   This field contains the virtual address (in this address space) of the access that caused the fault.  Additional information about the fault is also available in the  FAULTSTATUS and FAULTADDRESS registers. If multiple faults occur before the first is handled, the subsequent faults are ignored. They may fault again after handling the first one.  Fixed duplicate state name in FAULT_ADDRESS - exposes previously hidden field S2FS1WALK. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>16</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>S2FS1WALK</spirit:name>
          <spirit:displayName>S2FS1WALK</spirit:displayName>
          <spirit:description>S2FS1WALK</spirit:description>
          <spirit:bitOffset>31</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>stage2</spirit:name>
              <spirit:description> Fault source is a stage 2 translation. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>stage1</spirit:name>
              <spirit:description> Fault source is a stage 1 page table walk. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
    </spirit:addressBlock>
    <spirit:addressBlock>
      <spirit:name>jm_mmu_as3_regs</spirit:name>
      <spirit:baseAddress>9408</spirit:baseAddress>
      <spirit:range>64</spirit:range>
      <spirit:width>32</spirit:width>
      <spirit:usage>register</spirit:usage>
      <spirit:register>
        <spirit:name>ST1MMUAS3_TRANSTAB_LO</spirit:name>
        <spirit:displayName>ST1MMUAS3_TRANSTAB_LO</spirit:displayName>
        <spirit:description>   This register contains the address of the base level of the translation table, together with some related flags.  Details on the layout of the page tables, and the address translation process, can be found in the section  Memory Management Unit .</spirit:description>
        <spirit:addressOffset>0x0</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>Res137</spirit:name>
          <spirit:displayName>Res137</spirit:displayName>
          <spirit:description>Res137</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>ST1MMUAS3TRANSTAB_LO</spirit:name>
          <spirit:displayName>ST1MMUAS3TRANSTAB_LO</spirit:displayName>
          <spirit:description>   This field contains the address of the top level of a page table structure. This must be 16-byte-aligned, so address bits [3:0] are assumed to be zero.  For a stage 1 page table, this will be an intermediate physical address, and for stage 2 it will be a physical address. The number of actual translated address bits is stored in  OUTA_BITS . The unused high bits must be set to 0. Changed alignment text for TRANSTAB.BASE  TRANSTAB.BASE pointer is a physical (or intermediate) address </spirit:description>
          <spirit:bitOffset>4</spirit:bitOffset>
          <spirit:bitWidth>28</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS3_TRANSTAB_HI</spirit:name>
        <spirit:displayName>ST1MMUAS3_TRANSTAB_HI</spirit:displayName>
        <spirit:description>   This register contains the address of the base level of the translation table, together with some related flags.  Details on the layout of the page tables, and the address translation process, can be found in the section  Memory Management Unit .</spirit:description>
        <spirit:addressOffset>0x4</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>ST1MMUAS3TRANSTAB_HI</spirit:name>
          <spirit:displayName>ST1MMUAS3TRANSTAB_HI</spirit:displayName>
          <spirit:description>   This field contains the address of the top level of a page table structure. This must be 16-byte-aligned, so address bits [3:0] are assumed to be zero.  For a stage 1 page table, this will be an intermediate physical address, and for stage 2 it will be a physical address. The number of actual translated address bits is stored in  OUTA_BITS . The unused high bits must be set to 0. Changed alignment text for TRANSTAB.BASE  TRANSTAB.BASE pointer is a physical (or intermediate) address </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS3_MEMATTR_LO</spirit:name>
        <spirit:displayName>ST1MMUAS3_MEMATTR_LO</spirit:displayName>
        <spirit:description>  </spirit:description>
        <spirit:addressOffset>0x8</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>ATTRIBUTE0</spirit:name>
          <spirit:displayName>ATTRIBUTE0</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 0. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE1</spirit:name>
          <spirit:displayName>ATTRIBUTE1</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 1. </spirit:description>
          <spirit:bitOffset>4</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE2</spirit:name>
          <spirit:displayName>ATTRIBUTE2</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 2. </spirit:description>
          <spirit:bitOffset>8</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE3</spirit:name>
          <spirit:displayName>ATTRIBUTE3</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 3. </spirit:description>
          <spirit:bitOffset>12</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE4</spirit:name>
          <spirit:displayName>ATTRIBUTE4</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 4. </spirit:description>
          <spirit:bitOffset>16</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE5</spirit:name>
          <spirit:displayName>ATTRIBUTE5</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 5. </spirit:description>
          <spirit:bitOffset>20</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE6</spirit:name>
          <spirit:displayName>ATTRIBUTE6</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 6. </spirit:description>
          <spirit:bitOffset>24</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE7</spirit:name>
          <spirit:displayName>ATTRIBUTE7</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 7. </spirit:description>
          <spirit:bitOffset>28</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS3_MEMATTR_HI</spirit:name>
        <spirit:displayName>ST1MMUAS3_MEMATTR_HI</spirit:displayName>
        <spirit:description>  </spirit:description>
        <spirit:addressOffset>0xc</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>ATTRIBUTE8</spirit:name>
          <spirit:displayName>ATTRIBUTE8</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 8. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE9</spirit:name>
          <spirit:displayName>ATTRIBUTE9</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 9. </spirit:description>
          <spirit:bitOffset>4</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE10</spirit:name>
          <spirit:displayName>ATTRIBUTE10</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 10. </spirit:description>
          <spirit:bitOffset>8</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE11</spirit:name>
          <spirit:displayName>ATTRIBUTE11</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 11. </spirit:description>
          <spirit:bitOffset>12</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE12</spirit:name>
          <spirit:displayName>ATTRIBUTE12</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 12. </spirit:description>
          <spirit:bitOffset>16</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE13</spirit:name>
          <spirit:displayName>ATTRIBUTE13</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 13. </spirit:description>
          <spirit:bitOffset>20</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE14</spirit:name>
          <spirit:displayName>ATTRIBUTE14</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 14. </spirit:description>
          <spirit:bitOffset>24</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE15</spirit:name>
          <spirit:displayName>ATTRIBUTE15</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 15. </spirit:description>
          <spirit:bitOffset>28</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS3_LOCKADDR_LO</spirit:name>
        <spirit:displayName>ST1MMUAS3_LOCKADDR_LO</spirit:displayName>
        <spirit:description>   This register tells the MMU to lock a region of virtual memory. All page mappings within this region must be flushed, and no translation requests within this region can complete or fault before the area is unlocked.  Only one region can be locked at a time.  As only 32 bits of the register can be written to at a time, no changes are issued until the LOCK command is written to the COMMAND register. </spirit:description>
        <spirit:addressOffset>0x10</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>Res138</spirit:name>
          <spirit:displayName>Res138</spirit:displayName>
          <spirit:description>Res138</spirit:description>
          <spirit:bitOffset>6</spirit:bitOffset>
          <spirit:bitWidth>6</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>LOCKADDR_SIZE</spirit:name>
          <spirit:displayName>LOCKADDR_SIZE</spirit:displayName>
          <spirit:description>   This field contains the log  2 of the size of the region to lock, minus 1. Only values in the range 11 to 63 are valid values for this field, corresponding to region sizes of 4KB up to the entire address space. Values in the range 0 to 10 result in UNDEFINED behavior and should not be used.</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>6</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>ST1MMUAS3LOCKADDR_LO</spirit:name>
          <spirit:displayName>ST1MMUAS3LOCKADDR_LO</spirit:displayName>
          <spirit:description>   This field contains the lowest address in the region to be locked. The address is a virtual address in this address space.  Only the upper bits of the address are used. The address is aligned to a multiple of the region size, so a variable number of low-order bits are ignored, depending on the selected region size. It is recommended that software ensures that these low bits in the address are cleared, to avoid confusion. </spirit:description>
          <spirit:bitOffset>12</spirit:bitOffset>
          <spirit:bitWidth>20</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS3_LOCKADDR_HI</spirit:name>
        <spirit:displayName>ST1MMUAS3_LOCKADDR_HI</spirit:displayName>
        <spirit:description>   This register tells the MMU to lock a region of virtual memory. All page mappings within this region must be flushed, and no translation requests within this region can complete or fault before the area is unlocked.  Only one region can be locked at a time.  As only 32 bits of the register can be written to at a time, no changes are issued until the LOCK command is written to the COMMAND register. </spirit:description>
        <spirit:addressOffset>0x14</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>ST1MMUAS3LOCKADDR_HI</spirit:name>
          <spirit:displayName>ST1MMUAS3LOCKADDR_HI</spirit:displayName>
          <spirit:description>   This field contains the lowest address in the region to be locked. The address is a virtual address in this address space.  Only the upper bits of the address are used. The address is aligned to a multiple of the region size, so a variable number of low-order bits are ignored, depending on the selected region size. It is recommended that software ensures that these low bits in the address are cleared, to avoid confusion. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS3_COMMAND</spirit:name>
        <spirit:displayName>ST1MMUAS3_COMMAND</spirit:displayName>
        <spirit:description>   MMU commands are issued by writing to this register. Any command written to an address space while the corresponding STATUS.AS_ACTIVE flag is set will be ignored.  In general an MMU command only applies to the address space it is submitted to. However a command that invalidates the MMU cache may invalidate the whole MMU cache rather than only those entries specific to one address space. </spirit:description>
        <spirit:addressOffset>0x18</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>ST1MMUAS3COMMAND</spirit:name>
          <spirit:displayName>ST1MMUAS3COMMAND</spirit:displayName>
          <spirit:description>ST1MMUAS3COMMAND</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>write-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NOP</spirit:name>
              <spirit:description> No operation, nothing happens. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>UPDATE</spirit:name>
              <spirit:description> Broadcasts the values in TRANSTAB and MEMATTR to all MMUs. MMU caches are invalidated. Use this after changing the content of these registers. This will  not clear the effect of a LOCK set in the updated address space.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>LOCK</spirit:name>
              <spirit:description> Issues a lock region command to all MMUs, using the address and size set in the LOCKADDR register. MMU caches are invalidated. Use this before changing an in-memory page table. Any existing lock on this address space is cleared. Locks on other address spaces are not affected. Use a FLUSH or UNLOCK command to unlock a memory region. </spirit:description>
              <spirit:value>2</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>UNLOCK</spirit:name>
              <spirit:description> Issues an unlock region command to all MMUs, using the address and size set in the LOCKADDR register. Any existing lock on this address space is cleared. If no lock was present, the MMU caches are invalidated. Use this when finished changing an in-memory page table, except if the page table can be cached in the L2 cache, in which case, a FLUSH_MEM command must be issued instead. </spirit:description>
              <spirit:value>3</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FLUSH_PT</spirit:name>
              <spirit:description> First cleans and invalidates all L2 caches to force cached page tables to be invalidated, then performs an UNLOCK command. </spirit:description>
              <spirit:value>4</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FLUSH_MEM</spirit:name>
              <spirit:description> First waits until all memory accesses to a region locked by a preceding LOCK command have completed and have reached the nearest cache.
			This will ensure that all reads to a locked memory region have finished, and that any writes to a locked region have either been written out to memory or are present in the L1 or L2 cache as dirty data.
			Then cleans and invalidates the L1 cache in all shader cores, forcing dirty data for locked regions to be pushed out to the L2 cache.
			Then cleans and invalidates all L2 caches forcing all dirty data for locked regions to be written back to memory and page tables to be invalidated.
			Then performs an UNLOCK command on this address space.
			Use this when finished changing or removing entries in an in-memory page table. </spirit:description>
              <spirit:value>5</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS3_FAULTSTATUS</spirit:name>
        <spirit:displayName>ST1MMUAS3_FAULTSTATUS</spirit:displayName>
        <spirit:description>   This register contains extended status information after a fault. If read before a fault occurs, its contents are the reset value, 0, which indicates no fault.
						If multiple faults occur before the first is handled, the subsequent faults are ignored. They may fault again after handling the first one.  If the GPU is in protected mode, this register is not updated, and MMU faults are ignored. 
						They are not fatal but will halt the GPU until the MMU address space is updated. 
						However, no fault information wil be visible in this case.  Changed access type of MMU_FAULTSTATUS register when in protected mode. </spirit:description>
        <spirit:addressOffset>0x1c</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>Res139</spirit:name>
          <spirit:displayName>Res139</spirit:displayName>
          <spirit:description>Res139</spirit:description>
          <spirit:bitOffset>10</spirit:bitOffset>
          <spirit:bitWidth>6</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>SOURCE_ID</spirit:name>
          <spirit:displayName>SOURCE_ID</spirit:displayName>
          <spirit:description>   This field contains an implementation-defined ID that supplies additional data about the source of the fault. For example, it may be the ID of the internal bus master that issued the request that faulted. This makes it possible to distinguish between the job manager, the texture unit and the load/store unit. Another example might be an indication of the type of an invalid data structure. The values in this field are implementation defined. </spirit:description>
          <spirit:bitOffset>16</spirit:bitOffset>
          <spirit:bitWidth>16</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>EXCEPTION_TYPE</spirit:name>
          <spirit:displayName>EXCEPTION_TYPE</spirit:displayName>
          <spirit:description>   This field indicates the type of exception that caused the fault. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>8</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>OK</spirit:name>
              <spirit:description>   This indicates that the GPU has completed its work and is in a state ready to receive new commands. Its precise meaning depends on its usage:    In the job status field, this indicates that the job has not been started. This should be the initial state of a newly created job.  In the job slot status register, this indicates that the job slot is idle.  In the GPU and MMU exception status registers, this indicates that no exception has yet been received.  No additional error information is available (or indeed required). </spirit:description>
              <spirit:value>0x00</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>DONE</spirit:name>
              <spirit:description> The job completed successfully. The fault value is written to the job descriptor.
			The job descriptors fault address field contains the TIMESTAMP value when the job completed.
			If a job is terminated early using the  EUREKA instruction, then that job will be marked with the EUREKA exception status but the job chain status as a whole will still be DONE.</spirit:description>
              <spirit:value>0x01</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>SUSPENDED</spirit:name>
              <spirit:description> The job was interrupted by a SUSPEND command. The fault value is written both to the job slot  STATUS register and the job descriptor.
			The job descriptor contains the partition index of the first task to be interrupted. The fault address field contains the TIMESTAMP value when the job was interrupted.</spirit:description>
              <spirit:value>0x02</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>STOPPED</spirit:name>
              <spirit:description> The job was interrupted by a SOFT_STOP command. The fault value is written both to the job slot  STATUS register and the job descriptor.
			The job descriptor contains the partition index of the first task that was not completed. This will be the index of the first task issued if the job is resumed. The fault address is UNDEFINED .</spirit:description>
              <spirit:value>0x03</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TERMINATED</spirit:name>
              <spirit:description> The job was interrupted by a HARD_STOP command or a  KABOOM instruction from another job. The fault value is written both to the job slot STATUS register and the job descriptor.
			This status is treated in the same way as an error condition. The job descriptor contains the partition index of the first task to be terminated. The fault address field contains the TIMESTAMP value when the job was interrupted.</spirit:description>
              <spirit:value>0x04</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>KABOOM</spirit:name>
              <spirit:description> The job was interrupted by a shader executing a  KABOOM instruction. The fault value is written both to the job slot STATUS register and the job descriptor.
			This status is treated in the same way as an error condition. The job descriptor contains the partition index of the first task to be terminated. The fault address field contains the TIMESTAMP value when the job was interrupted.</spirit:description>
              <spirit:value>0x05</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>EUREKA</spirit:name>
              <spirit:description> The job was interrupted by a shader executing a  EUREKA instruction. The fault value is written only to the job descriptor, and does not affect subsequent jobs in the job chain.
			The job descriptor contains the partition index of the first task to be terminated. The fault address field contains the TIMESTAMP value when the job was interrupted.</spirit:description>
              <spirit:value>0x06</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ACTIVE</spirit:name>
              <spirit:description> In the JSn_STATUS register, this indicates that the job slot is active.
			The JSn_HEAD and JSn_TAIL registers contain the range of job descriptors currently in progress. </spirit:description>
              <spirit:value>0x08</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>JOB_CONFIG_FAULT</spirit:name>
              <spirit:description>   The job configuration specified in the job slot registers is invalid, so it is not possible to read job descriptors.
				For example this includes setting a NULL job descriptor pointer, selecting an address space that isnt present.
				No additional information is available. </spirit:description>
              <spirit:value>0x40</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>JOB_POWER_FAULT</spirit:name>
              <spirit:description>   The job could not be executed because the part of the memory system required to access job descriptors was not powered on.
				No additional information is available. </spirit:description>
              <spirit:value>0x41</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>JOB_READ_FAULT</spirit:name>
              <spirit:description>   Reading a job descriptor into the Job manager failed.
				The JSn_HEAD register contains the virtual address of the job descriptor that could not be read. </spirit:description>
              <spirit:value>0x42</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>JOB_WRITE_FAULT</spirit:name>
              <spirit:description>   Writing a job descriptor from the Job manager failed.
				The JSn_TAIL register contains the virtual address of the job descriptor that could not be written. </spirit:description>
              <spirit:value>0x43</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>JOB_AFFINITY_FAULT</spirit:name>
              <spirit:description>   The job could not be executed because the specified affinity mask does not intersect any available cores.
				No additional information is available. </spirit:description>
              <spirit:value>0x44</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>JOB_BUS_FAULT</spirit:name>
              <spirit:description>   A bus access failed while executing a job.
				The job descriptor contains the virtual address of the failing access, the type of access, and which part of the GPU initiated the access.
				This error code may also be reported if a bus fault occurs while writing the performance counters to memory. In this case, the GPU_FAULT* registers are updated, but the active JASID is not reported. It is possible to distinguish this case from a genuine Job Bus Fault exception by examining the SOURCE_ID field. </spirit:description>
              <spirit:value>0x48</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>INSTR_INVALID_PC</spirit:name>
              <spirit:description>   A shader instruction with an illegal program counter was executed.
				The job descriptors fault address field contains the offending program counter value. </spirit:description>
              <spirit:value>0x50</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>INSTR_INVALID_ENC</spirit:name>
              <spirit:description>   A shader instruction with an illegal encoding was executed.
				The job descriptors fault address field contains the program counter used to reach the offending instruction. </spirit:description>
              <spirit:value>0x51</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>INSTR_BARRIER_FAULT</spirit:name>
              <spirit:description>   A shader instruction was executed that failed to complete an instruction barrier.
				The job descriptors fault address field contains the program counter used to reach the offending instruction. </spirit:description>
              <spirit:value>0x55</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>DATA_INVALID_FAULT</spirit:name>
              <spirit:description>   Any data structure read as part of the job contains invalid combinations of data.
				The job descriptors fault address field contains the virtual address of the invalid data structure. </spirit:description>
              <spirit:value>0x58</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TILE_RANGE_FAULT</spirit:name>
              <spirit:description>   Tile or fragment shading was asked to process a tile that is entirely outside the bounding box of the frame.
				The job descriptors fault address field contains the coordinates of the top left corner of the failing tile, with X in the bits [15:0], and Y in the bits [31:16].  Clarified description of TILE_RANGE_FAULT. </spirit:description>
              <spirit:value>0x59</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ADDR_RANGE_FAULT</spirit:name>
              <spirit:description>   A virtual address has been found that exceeds the virtual address range.
				The job descriptors fault address field contains the virtual address which is out of range. </spirit:description>
              <spirit:value>0x5A</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>IMPRECISE_FAULT</spirit:name>
              <spirit:description>   A fault has been generated without precise fault information.
				This can happen if appropriate source information is not available at the point where the fault happens.
				The job descriptors fault address field may contain a virtual address related to the fault. </spirit:description>
              <spirit:value>0x5B</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>OUT_OF_MEMORY</spirit:name>
              <spirit:description>   The tiler ran out of memory when executing a job.
				The job descriptors fault address field contains the index of the last completed vertex sent through the tiler. </spirit:description>
              <spirit:value>0x60</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>UNKNOWN</spirit:name>
              <spirit:description>   If multiple jobs in a job chain fail, only the first one the reports an error will set and return full error information. Subsequent failing jobs will not update the error status registers, and may write an error status of UNKNOWN.
				Note that the first job to fail may not be the first job in the chain, which may lead to jobs with  UNKNOWN error status being encountered first when traversing the job chain.
				For example, you may see: Done, Done, Unknown, Bus Error, Unknown, New. In this case, the first two jobs ran successfully, the fourth job hit a bus error, and then jobs three and five also failed. The sixth and subsequent jobs had not been started at that point.</spirit:description>
              <spirit:value>0x7F</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>DELAYED_BUS_FAULT</spirit:name>
              <spirit:description>   The GPU received a bus fault for access to physical memory where the original virtual address is no longer available. This is the result of evicting a dirty line from a cache.
				This may also be triggered by a bus fault during a Tiler cache flush operation. In this case, the address reported in  GPU_FAULTADDRESS is a virtual address.</spirit:description>
              <spirit:value>0x80</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>GPU_SHAREABILITY_FAULT</spirit:name>
              <spirit:description>   A cache has detected that the same line has been accessed as both shareable and non-shareable memory from inside the GPU. Coherency after this point can no longer be guaranteed. </spirit:description>
              <spirit:value>0x88</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>SYSTEM_SHAREABILITY_FAULT</spirit:name>
              <spirit:description>   A cache has detected that the same line has been accessed as both shareable and non-shareable memory from outside the GPU. Coherency after this point can no longer be guaranteed. </spirit:description>
              <spirit:value>0x89</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>GPU_CACHEABILITY_FAULT</spirit:name>
              <spirit:description>   A cache has detected that the same line has been accessed as both cacheable and non-cacheable memory from inside the GPU. Non-cacheable memory may have been cached. </spirit:description>
              <spirit:value>0x8A</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TRANSLATION_FAULT_0</spirit:name>
              <spirit:description>   A memory access hit an invalid table entry at level 0 of the translation table. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xC0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TRANSLATION_FAULT_1</spirit:name>
              <spirit:description>   A memory access hit an invalid table entry at level 1 of the translation table. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xC1</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TRANSLATION_FAULT_2</spirit:name>
              <spirit:description>   A memory access hit an invalid table entry at level 2 of the translation table. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xC2</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TRANSLATION_FAULT_3</spirit:name>
              <spirit:description>   A memory access hit an invalid table entry at level 3 of the translation table. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xC3</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TRANSLATION_FAULT_IDENTITY</spirit:name>
              <spirit:description>   In IDENTITY translation mode, the virtual address exceeds the maximum physical address. </spirit:description>
              <spirit:value>0xC7</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>PERMISSION_FAULT_0</spirit:name>
              <spirit:description>   A memory access could not be allowed due to the permission flags set in level 0 of the translation table. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set. Added MMU translation level information to permission fault. </spirit:description>
              <spirit:value>0xC8</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>PERMISSION_FAULT_1</spirit:name>
              <spirit:description>   A memory access could not be allowed due to the permission flags set in level 1 of the translation table. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xC9</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>PERMISSION_FAULT_2</spirit:name>
              <spirit:description>   A memory access could not be allowed due to the permission flags set in level 2 of the translation table. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xCA</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>PERMISSION_FAULT_3</spirit:name>
              <spirit:description>   A memory access could not be allowed due to the permission flags set in level 3 of the translation table. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xCB</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TRANSTAB_BUS_FAULT_0</spirit:name>
              <spirit:description>   A bus fault occurred while reading level 0 of the translation tables. The appropriate  BUS_ERROR flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xD0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TRANSTAB_BUS_FAULT_1</spirit:name>
              <spirit:description>   A bus fault occurred while reading level 1 of the translation tables. The appropriate  BUS_ERROR flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xD1</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TRANSTAB_BUS_FAULT_2</spirit:name>
              <spirit:description>   A bus fault occurred while reading level 2 of the translation tables. The appropriate  BUS_ERROR flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xD2</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TRANSTAB_BUS_FAULT_3</spirit:name>
              <spirit:description>   A bus fault occurred while reading level 3 of the translation tables. The appropriate  BUS_ERROR flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xD3</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ACCESS_FLAG_0</spirit:name>
              <spirit:description>   A memory access hit a translation table entry with the ACCESS_FLAG bit set in level 0 of the translation table. This is not treated as a fault by the accessor. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set. Added MMU translation level information to access flag fault. </spirit:description>
              <spirit:value>0xD8</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ACCESS_FLAG_1</spirit:name>
              <spirit:description>   A memory access hit a translation table entry with the ACCESS_FLAG bit set in level 1 of the translation table. This is not treated as a fault by the accessor. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xD9</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ACCESS_FLAG_2</spirit:name>
              <spirit:description>   A memory access hit a translation table entry with the ACCESS_FLAG bit set in level 2 of the translation table. This is not treated as a fault by the accessor. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xDA</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ACCESS_FLAG_3</spirit:name>
              <spirit:description>   A memory access hit a translation table entry with the ACCESS_FLAG bit set in level 3 of the translation table. This is not treated as a fault by the accessor. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xDB</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ADDRESS_SIZE_FAULT_IN0</spirit:name>
              <spirit:description>   An input address size fault occurred while reading level 0 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ADDRESS_SIZE_FAULT_IN1</spirit:name>
              <spirit:description>   An input address size fault occurred while reading level 1 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE1</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ADDRESS_SIZE_FAULT_IN2</spirit:name>
              <spirit:description>   An input address size fault occurred while reading level 2 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE2</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ADDRESS_SIZE_FAULT_IN3</spirit:name>
              <spirit:description>   An input address size fault occurred while reading level 3 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE3</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ADDRESS_SIZE_FAULT_OUT0</spirit:name>
              <spirit:description>   An output address size fault occurred while reading level 0 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE4</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ADDRESS_SIZE_FAULT_OUT1</spirit:name>
              <spirit:description>   An output address size fault occurred while reading level 1 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE5</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ADDRESS_SIZE_FAULT_OUT2</spirit:name>
              <spirit:description>   An output address size fault occurred while reading level 2 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE6</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ADDRESS_SIZE_FAULT_OUT3</spirit:name>
              <spirit:description>   An output address size fault occurred while reading level 3 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE7</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>MEMORY_ATTRIBUTE_FAULT_0</spirit:name>
              <spirit:description>   A memory access could not be allowed due to an attempt to access a page with its memory attribute set to  FAULT in the MEMATTR register. This fault happened when reading level 0 of the translation tables. The appropriate PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE8</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>MEMORY_ATTRIBUTE_FAULT_1</spirit:name>
              <spirit:description>   A memory access could not be allowed due to an attempt to access a page with its memory attribute set to  FAULT in the MEMATTR register. This fault happened when reading level 1 of the translation tables. The appropriate PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE9</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>MEMORY_ATTRIBUTE_FAULT_2</spirit:name>
              <spirit:description>   A memory access could not be allowed due to an attempt to access a page with its memory attribute set to  FAULT in the MEMATTR register. This fault happened when reading level 2 of the translation tables. The appropriate PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xEA</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>MEMORY_ATTRIBUTE_FAULT_3</spirit:name>
              <spirit:description>   A memory access could not be allowed due to an attempt to access a page with its memory attribute set to  FAULT in the MEMATTR register. This fault happened when reading level 3 of the translation tables. The appropriate PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xEB</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>MEMORY_ATTRIBUTE_NONCACHEABLE_0</spirit:name>
              <spirit:description>   A memory access could not be allowed due to an attempt to access a non-cacheable page from a bus master which does not support non-cacheable accessess. This fault happened when reading level 0 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xEC</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>MEMORY_ATTRIBUTE_NONCACHEABLE_1</spirit:name>
              <spirit:description>   A memory access could not be allowed due to an attempt to access a non-cacheable page from a bus master which does not support non-cacheable accessess. This fault happened when reading level 1 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xED</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>MEMORY_ATTRIBUTE_NONCACHEABLE_2</spirit:name>
              <spirit:description>   A memory access could not be allowed due to an attempt to access a non-cacheable page from a bus master which does not support non-cacheable accessess. This fault happened when reading level 2 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xEE</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>MEMORY_ATTRIBUTE_NONCACHEABLE_3</spirit:name>
              <spirit:description>   A memory access could not be allowed due to an attempt to access a non-cacheable page from a bus master which does not support non-cacheable accessess. This fault happened when reading level 3 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xEF</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ACCESS_TYPE</spirit:name>
          <spirit:displayName>ACCESS_TYPE</spirit:displayName>
          <spirit:description>   This field contains the direction of data transfer that caused the fault, if known.  For the purposes of error reporting, atomic transactions act like a read followed by a write, so denying either permission will result in the atomic transaction failing, and the exceptions ACCESS_TYPE field will be set to "atomic". </spirit:description>
          <spirit:bitOffset>8</spirit:bitOffset>
          <spirit:bitWidth>2</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>atomic</spirit:name>
              <spirit:description> An atomic (read/write) transaction. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>execute</spirit:name>
              <spirit:description> An execute transaction. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>read</spirit:name>
              <spirit:description> A read transaction. </spirit:description>
              <spirit:value>2</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>write</spirit:name>
              <spirit:description> A write transaction. </spirit:description>
              <spirit:value>3</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS3_FAULTADDRESS_LO</spirit:name>
        <spirit:displayName>ST1MMUAS3_FAULTADDRESS_LO</spirit:displayName>
        <spirit:description>   This register contains information about the cause of a page fault or bus error. </spirit:description>
        <spirit:addressOffset>0x20</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>ST1MMUAS3FAULTADDRESS_LO</spirit:name>
          <spirit:displayName>ST1MMUAS3FAULTADDRESS_LO</spirit:displayName>
          <spirit:description>   This field contains the virtual address (in this address space) of the access that caused the fault.  Additional information about the fault is also available in the FAULTSTATUS register.  If multiple faults occur before the first is handled, the subsequent faults are ignored. They may fault again after handling the first one. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS3_FAULTADDRESS_HI</spirit:name>
        <spirit:displayName>ST1MMUAS3_FAULTADDRESS_HI</spirit:displayName>
        <spirit:description>   This register contains information about the cause of a page fault or bus error. </spirit:description>
        <spirit:addressOffset>0x24</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>ST1MMUAS3FAULTADDRESS_HI</spirit:name>
          <spirit:displayName>ST1MMUAS3FAULTADDRESS_HI</spirit:displayName>
          <spirit:description>   This field contains the virtual address (in this address space) of the access that caused the fault.  Additional information about the fault is also available in the FAULTSTATUS register.  If multiple faults occur before the first is handled, the subsequent faults are ignored. They may fault again after handling the first one. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS3_STATUS</spirit:name>
        <spirit:displayName>ST1MMUAS3_STATUS</spirit:displayName>
        <spirit:description>   This register contains dynamic status information about this address space. </spirit:description>
        <spirit:addressOffset>0x28</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>Res140</spirit:name>
          <spirit:displayName>Res140</spirit:displayName>
          <spirit:description>Res140</spirit:description>
          <spirit:bitOffset>1</spirit:bitOffset>
          <spirit:bitWidth>31</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>AS_ACTIVE</spirit:name>
          <spirit:displayName>AS_ACTIVE</spirit:displayName>
          <spirit:description>   This flag is set while a MMU_UPDATE, LOCK, UNLOCK, FLUSH_PT or FLUSH_MEM command is active on this address space. This allows software to safely verify that the address space is in a consistent state after reconfiguring the MMU page tables.  If a new command is written to the corresponding COMMAND register while the AS_ACTIVE bit is set, then the command is ignored. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> Address space command register is inactive. A new command may be written to the COMMAND register. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Address space command register is active. Any new command written to the COMMAND register will be ignored. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS3_TRANSCFG_LO</spirit:name>
        <spirit:displayName>ST1MMUAS3_TRANSCFG_LO</spirit:displayName>
        <spirit:description>ST1MMUAS3_TRANSCFG_LO</spirit:description>
        <spirit:addressOffset>0x30</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>Res141</spirit:name>
          <spirit:displayName>Res141</spirit:displayName>
          <spirit:description>Res141</spirit:description>
          <spirit:bitOffset>4</spirit:bitOffset>
          <spirit:bitWidth>2</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>Res142</spirit:name>
          <spirit:displayName>Res142</spirit:displayName>
          <spirit:description>Res142</spirit:description>
          <spirit:bitOffset>11</spirit:bitOffset>
          <spirit:bitWidth>3</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>Res143</spirit:name>
          <spirit:displayName>Res143</spirit:displayName>
          <spirit:description>Res143</spirit:description>
          <spirit:bitOffset>19</spirit:bitOffset>
          <spirit:bitWidth>3</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>Res144</spirit:name>
          <spirit:displayName>Res144</spirit:displayName>
          <spirit:description>Res144</spirit:description>
          <spirit:bitOffset>23</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>Res145</spirit:name>
          <spirit:displayName>Res145</spirit:displayName>
          <spirit:description>Res145</spirit:description>
          <spirit:bitOffset>26</spirit:bitOffset>
          <spirit:bitWidth>2</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>Res146</spirit:name>
          <spirit:displayName>Res146</spirit:displayName>
          <spirit:description>Res146</spirit:description>
          <spirit:bitOffset>31</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>INA_BITS</spirit:name>
          <spirit:displayName>INA_BITS</spirit:displayName>
          <spirit:description>   This field allows the system software to restrict the range of input addresses accepted by this translation stage. This is used in conjunction with the hardware limits to determine the valid address range as follows:  INA_BITS_VALID = min(HW_INA_BITS, 55-INA_BITS)  If the input address is outside the range (0, 2  INA_BITS_VALID -1), then a TRANSLATION_FAULT error is generated.</spirit:description>
          <spirit:bitOffset>6</spirit:bitOffset>
          <spirit:bitWidth>5</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>OUTA_BITS</spirit:name>
          <spirit:displayName>OUTA_BITS</spirit:displayName>
          <spirit:description>   This field allows the system software to restrict the range of output addresses generated by this translation stage. This is used in conjunction with the hardware limits to determine the valid address range as follows:  OUTA_BITS_VALID = min(HW_OUTA_BITS, 55-OUTA_BITS)  If the translated output address is outside the range (0, 2  OUTA_BITS_VALID -1), then a TRANSLATION_FAULT error is generated.</spirit:description>
          <spirit:bitOffset>14</spirit:bitOffset>
          <spirit:bitWidth>5</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>MODE</spirit:name>
          <spirit:displayName>MODE</spirit:displayName>
          <spirit:description>   This field controls the overall operation of the MMU. There are some differences between stage 1 and stage 2.  Execute permissions for a page are evaluated as follows (PTE.&amp;lt;W|R|X&gt; refers to page table entry permissions resolved for hierarchical permissions (if applicable):  EXECUTE_ALLOWED = !((TRANSCFG.WXN &amp;amp; !PTE.W) | (TRANSCFG.XREADABLE &amp;amp; !PTE.R) | (!TRANSCFG.XREADABLE &amp;amp; !PTE.X)) </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>LEGACY</spirit:name>
              <spirit:description>   The contents of TRANSTAB and MEMATTR are interpreted according to the legacy behaviour, as used in previous Midgard GPUs. The rest of the TRANSCFG bits are ignored.  Input and output address sizes are set according to the hardware configuration.  Stage 1 will follow the legacy behaviour.  Stage 2 will be transparent, will ignore TRANSTAB settings and will not generate any faults.  Note: as the reset value of TRANSCFG is 0, this is a mechanism to ensure backwards-compatibility and alignment between the stages. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>UNMAPPED</spirit:name>
              <spirit:description> The MMU forces all memory access to fail with a decode fault. No actual page table is required. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>IDENTITY</spirit:name>
              <spirit:description>   The MMU behaves as if using an address translation table with all entries valid and giving an identity mapping (output address is the same as the input address) with full read/write/execute access. Addresses outside the configured address ranges cause page faults.  For Stage 1, cacheability and shareability are defined by MEMATTR0. For Stage 2, cacheablity and sharebility are defined so that they dont change whats set by Stage 1 (non-shareable and inner/outer write-back cacheable and master-defined allocation). </spirit:description>
              <spirit:value>2</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>AARCH64_4K</spirit:name>
              <spirit:description> Page tables are interpreted according to the AArch64 4kB granule specification. </spirit:description>
              <spirit:value>6</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>AARCH64_64K</spirit:name>
              <spirit:description> Page tables are interpreted according to the AArch64 64kB granule specification. </spirit:description>
              <spirit:value>8</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>PTW_MEMATTR</spirit:name>
          <spirit:displayName>PTW_MEMATTR</spirit:displayName>
          <spirit:description>   Memory attributes for page table walks. The allowed values are compatible with the values allowed for  MEMORY_TYPE . For outer cache transactions, the desired attributes for the transaction will be decided by the bus master and communicated to the memory system using signals on the bus.  Changed allowed values for TRANSCFG.PTW_MEMATTR. </spirit:description>
          <spirit:bitOffset>24</spirit:bitOffset>
          <spirit:bitWidth>2</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NON_CACHEABLE</spirit:name>
              <spirit:description> Normal memory, inner non-cacheable, outer non-cacheable. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>WRITE_BACK</spirit:name>
              <spirit:description> Normal memory, inner write-back cacheable, outer write-back cacheable. </spirit:description>
              <spirit:value>2</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>PTW_SH</spirit:name>
          <spirit:displayName>PTW_SH</spirit:displayName>
          <spirit:description>   This field specifies the shareability for the page table walks. This is the same encoding as used for ARMv8 page tables. </spirit:description>
          <spirit:bitOffset>28</spirit:bitOffset>
          <spirit:bitWidth>2</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>non_shareable</spirit:name>
              <spirit:description> The memory region is non-shareable, and coherency with other observers will not automatically be maintained. Software will have to ensure that caches are flushed or invalidated at appropriate times. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>outer_shareable</spirit:name>
              <spirit:description> The memory region is marked as outer shareable. Each outer shareability domain contains a set of observers that are data coherent for each member of that set for	data accesses with the outer shareable attribute made by any member of that set. </spirit:description>
              <spirit:value>2</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>inner_shareable</spirit:name>
              <spirit:description> The memory region is marked as inner shareable. Each inner shareability domain contains a set of observers that are data coherent for each member of that set for	data accesses with the inner shareable attribute made by any member of that set. All observers in an inner shareability domain are always members of the same outer shareability domain. This means that an inner shareability domain is a subset of an Outer Shareability domain, although it is not required to be a proper subset. </spirit:description>
              <spirit:value>3</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>R_ALLOCATE</spirit:name>
          <spirit:displayName>R_ALLOCATE</spirit:displayName>
          <spirit:description>   This field sets the inner read allocation hint for the page table walks. This is the same encoding as used for ARMv8 page tables. </spirit:description>
          <spirit:bitOffset>30</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>no_read_allocate</spirit:name>
              <spirit:description> Hints that the cache should not allocate space when reading a page table entry. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>read_allocate</spirit:name>
              <spirit:description> Hints that the cache should allocate space when reading a page table entry. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>SL_CONCAT_EN</spirit:name>
          <spirit:displayName>SL_CONCAT_EN</spirit:displayName>
          <spirit:description>   If set then the page table walk starting level will be increased if possible by concatenating up to 16 tables in the starting level. </spirit:description>
          <spirit:bitOffset>22</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> Page table concatenation is disabled. 	This mode must be used for Stage 1 if sharing page tables with the CPU, otherwise  UNDEFINED behavior results.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Page table concatenation is enabled. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS3_TRANSCFG_HI</spirit:name>
        <spirit:displayName>ST1MMUAS3_TRANSCFG_HI</spirit:displayName>
        <spirit:description>ST1MMUAS3_TRANSCFG_HI</spirit:description>
        <spirit:addressOffset>0x34</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>Res147</spirit:name>
          <spirit:displayName>Res147</spirit:displayName>
          <spirit:description>Res147</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>Res148</spirit:name>
          <spirit:displayName>Res148</spirit:displayName>
          <spirit:description>Res148</spirit:description>
          <spirit:bitOffset>5</spirit:bitOffset>
          <spirit:bitWidth>27</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>DISABLE_HIER_AP</spirit:name>
          <spirit:displayName>DISABLE_HIER_AP</spirit:displayName>
          <spirit:description>   This flag only has an effect on stage 1 of translation. It is ignored for stage 2. Note the inverted logic - the flag must be set to  dis able hierarchical access permissions.</spirit:description>
          <spirit:bitOffset>1</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> Hierarchical access permissions are enabled. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Hierarchical access permissions are disabled. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>DISABLE_AF_FAULT</spirit:name>
          <spirit:displayName>DISABLE_AF_FAULT</spirit:displayName>
          <spirit:description>   This flag can be used to disable access fault checking when in one of AARCH64 modes. </spirit:description>
          <spirit:bitOffset>2</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> Access fault checking is enabled. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Access fault checking is disabled. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>WXN</spirit:name>
          <spirit:displayName>WXN</spirit:displayName>
          <spirit:description>   This flag can be used to disable all writes to executable pages, overriding access permissions specified in the page table. </spirit:description>
          <spirit:bitOffset>3</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> Write access permissions are read as usual from the page table. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Write access to all executable pages is disabled. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>XREADABLE</spirit:name>
          <spirit:displayName>XREADABLE</spirit:displayName>
          <spirit:description>   This flag can be used to enable execution on all readable pages, overriding access permissions specified in the page table. </spirit:description>
          <spirit:bitOffset>4</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> Execute access permissions are read as usual from the page table. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Execute access to all readable pages is enabled. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS3_FAULTEXTRA_LO</spirit:name>
        <spirit:displayName>ST1MMUAS3_FAULTEXTRA_LO</spirit:displayName>
        <spirit:description>   This register contains additional information about the cause of a page fault or bus error. </spirit:description>
        <spirit:addressOffset>0x38</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>ST1MMUAS3FAULTEXTRA_LO</spirit:name>
          <spirit:displayName>ST1MMUAS3FAULTEXTRA_LO</spirit:displayName>
          <spirit:description>   This field contains the virtual address (in this address space) of the access that caused the fault.  Additional information about the fault is also available in the  FAULTSTATUS and FAULTADDRESS registers. If multiple faults occur before the first is handled, the subsequent faults are ignored. They may fault again after handling the first one.  Fixed duplicate state name in FAULT_ADDRESS - exposes previously hidden field S2FS1WALK. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS3_FAULTEXTRA_HI</spirit:name>
        <spirit:displayName>ST1MMUAS3_FAULTEXTRA_HI</spirit:displayName>
        <spirit:description>   This register contains additional information about the cause of a page fault or bus error. </spirit:description>
        <spirit:addressOffset>0x3c</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>Res149</spirit:name>
          <spirit:displayName>Res149</spirit:displayName>
          <spirit:description>Res149</spirit:description>
          <spirit:bitOffset>16</spirit:bitOffset>
          <spirit:bitWidth>15</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>ST1MMUAS3FAULTEXTRA_HI</spirit:name>
          <spirit:displayName>ST1MMUAS3FAULTEXTRA_HI</spirit:displayName>
          <spirit:description>   This field contains the virtual address (in this address space) of the access that caused the fault.  Additional information about the fault is also available in the  FAULTSTATUS and FAULTADDRESS registers. If multiple faults occur before the first is handled, the subsequent faults are ignored. They may fault again after handling the first one.  Fixed duplicate state name in FAULT_ADDRESS - exposes previously hidden field S2FS1WALK. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>16</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>S2FS1WALK</spirit:name>
          <spirit:displayName>S2FS1WALK</spirit:displayName>
          <spirit:description>S2FS1WALK</spirit:description>
          <spirit:bitOffset>31</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>stage2</spirit:name>
              <spirit:description> Fault source is a stage 2 translation. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>stage1</spirit:name>
              <spirit:description> Fault source is a stage 1 page table walk. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
    </spirit:addressBlock>
    <spirit:addressBlock>
      <spirit:name>jm_mmu_as4_regs</spirit:name>
      <spirit:baseAddress>9472</spirit:baseAddress>
      <spirit:range>64</spirit:range>
      <spirit:width>32</spirit:width>
      <spirit:usage>register</spirit:usage>
      <spirit:register>
        <spirit:name>ST1MMUAS4_TRANSTAB_LO</spirit:name>
        <spirit:displayName>ST1MMUAS4_TRANSTAB_LO</spirit:displayName>
        <spirit:description>   This register contains the address of the base level of the translation table, together with some related flags.  Details on the layout of the page tables, and the address translation process, can be found in the section  Memory Management Unit .</spirit:description>
        <spirit:addressOffset>0x0</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>Res150</spirit:name>
          <spirit:displayName>Res150</spirit:displayName>
          <spirit:description>Res150</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>ST1MMUAS4TRANSTAB_LO</spirit:name>
          <spirit:displayName>ST1MMUAS4TRANSTAB_LO</spirit:displayName>
          <spirit:description>   This field contains the address of the top level of a page table structure. This must be 16-byte-aligned, so address bits [3:0] are assumed to be zero.  For a stage 1 page table, this will be an intermediate physical address, and for stage 2 it will be a physical address. The number of actual translated address bits is stored in  OUTA_BITS . The unused high bits must be set to 0. Changed alignment text for TRANSTAB.BASE  TRANSTAB.BASE pointer is a physical (or intermediate) address </spirit:description>
          <spirit:bitOffset>4</spirit:bitOffset>
          <spirit:bitWidth>28</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS4_TRANSTAB_HI</spirit:name>
        <spirit:displayName>ST1MMUAS4_TRANSTAB_HI</spirit:displayName>
        <spirit:description>   This register contains the address of the base level of the translation table, together with some related flags.  Details on the layout of the page tables, and the address translation process, can be found in the section  Memory Management Unit .</spirit:description>
        <spirit:addressOffset>0x4</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>ST1MMUAS4TRANSTAB_HI</spirit:name>
          <spirit:displayName>ST1MMUAS4TRANSTAB_HI</spirit:displayName>
          <spirit:description>   This field contains the address of the top level of a page table structure. This must be 16-byte-aligned, so address bits [3:0] are assumed to be zero.  For a stage 1 page table, this will be an intermediate physical address, and for stage 2 it will be a physical address. The number of actual translated address bits is stored in  OUTA_BITS . The unused high bits must be set to 0. Changed alignment text for TRANSTAB.BASE  TRANSTAB.BASE pointer is a physical (or intermediate) address </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS4_MEMATTR_LO</spirit:name>
        <spirit:displayName>ST1MMUAS4_MEMATTR_LO</spirit:displayName>
        <spirit:description>  </spirit:description>
        <spirit:addressOffset>0x8</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>ATTRIBUTE0</spirit:name>
          <spirit:displayName>ATTRIBUTE0</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 0. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE1</spirit:name>
          <spirit:displayName>ATTRIBUTE1</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 1. </spirit:description>
          <spirit:bitOffset>4</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE2</spirit:name>
          <spirit:displayName>ATTRIBUTE2</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 2. </spirit:description>
          <spirit:bitOffset>8</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE3</spirit:name>
          <spirit:displayName>ATTRIBUTE3</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 3. </spirit:description>
          <spirit:bitOffset>12</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE4</spirit:name>
          <spirit:displayName>ATTRIBUTE4</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 4. </spirit:description>
          <spirit:bitOffset>16</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE5</spirit:name>
          <spirit:displayName>ATTRIBUTE5</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 5. </spirit:description>
          <spirit:bitOffset>20</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE6</spirit:name>
          <spirit:displayName>ATTRIBUTE6</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 6. </spirit:description>
          <spirit:bitOffset>24</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE7</spirit:name>
          <spirit:displayName>ATTRIBUTE7</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 7. </spirit:description>
          <spirit:bitOffset>28</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS4_MEMATTR_HI</spirit:name>
        <spirit:displayName>ST1MMUAS4_MEMATTR_HI</spirit:displayName>
        <spirit:description>  </spirit:description>
        <spirit:addressOffset>0xc</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>ATTRIBUTE8</spirit:name>
          <spirit:displayName>ATTRIBUTE8</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 8. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE9</spirit:name>
          <spirit:displayName>ATTRIBUTE9</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 9. </spirit:description>
          <spirit:bitOffset>4</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE10</spirit:name>
          <spirit:displayName>ATTRIBUTE10</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 10. </spirit:description>
          <spirit:bitOffset>8</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE11</spirit:name>
          <spirit:displayName>ATTRIBUTE11</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 11. </spirit:description>
          <spirit:bitOffset>12</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE12</spirit:name>
          <spirit:displayName>ATTRIBUTE12</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 12. </spirit:description>
          <spirit:bitOffset>16</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE13</spirit:name>
          <spirit:displayName>ATTRIBUTE13</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 13. </spirit:description>
          <spirit:bitOffset>20</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE14</spirit:name>
          <spirit:displayName>ATTRIBUTE14</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 14. </spirit:description>
          <spirit:bitOffset>24</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE15</spirit:name>
          <spirit:displayName>ATTRIBUTE15</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 15. </spirit:description>
          <spirit:bitOffset>28</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS4_LOCKADDR_LO</spirit:name>
        <spirit:displayName>ST1MMUAS4_LOCKADDR_LO</spirit:displayName>
        <spirit:description>   This register tells the MMU to lock a region of virtual memory. All page mappings within this region must be flushed, and no translation requests within this region can complete or fault before the area is unlocked.  Only one region can be locked at a time.  As only 32 bits of the register can be written to at a time, no changes are issued until the LOCK command is written to the COMMAND register. </spirit:description>
        <spirit:addressOffset>0x10</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>Res151</spirit:name>
          <spirit:displayName>Res151</spirit:displayName>
          <spirit:description>Res151</spirit:description>
          <spirit:bitOffset>6</spirit:bitOffset>
          <spirit:bitWidth>6</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>LOCKADDR_SIZE</spirit:name>
          <spirit:displayName>LOCKADDR_SIZE</spirit:displayName>
          <spirit:description>   This field contains the log  2 of the size of the region to lock, minus 1. Only values in the range 11 to 63 are valid values for this field, corresponding to region sizes of 4KB up to the entire address space. Values in the range 0 to 10 result in UNDEFINED behavior and should not be used.</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>6</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>ST1MMUAS4LOCKADDR_LO</spirit:name>
          <spirit:displayName>ST1MMUAS4LOCKADDR_LO</spirit:displayName>
          <spirit:description>   This field contains the lowest address in the region to be locked. The address is a virtual address in this address space.  Only the upper bits of the address are used. The address is aligned to a multiple of the region size, so a variable number of low-order bits are ignored, depending on the selected region size. It is recommended that software ensures that these low bits in the address are cleared, to avoid confusion. </spirit:description>
          <spirit:bitOffset>12</spirit:bitOffset>
          <spirit:bitWidth>20</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS4_LOCKADDR_HI</spirit:name>
        <spirit:displayName>ST1MMUAS4_LOCKADDR_HI</spirit:displayName>
        <spirit:description>   This register tells the MMU to lock a region of virtual memory. All page mappings within this region must be flushed, and no translation requests within this region can complete or fault before the area is unlocked.  Only one region can be locked at a time.  As only 32 bits of the register can be written to at a time, no changes are issued until the LOCK command is written to the COMMAND register. </spirit:description>
        <spirit:addressOffset>0x14</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>ST1MMUAS4LOCKADDR_HI</spirit:name>
          <spirit:displayName>ST1MMUAS4LOCKADDR_HI</spirit:displayName>
          <spirit:description>   This field contains the lowest address in the region to be locked. The address is a virtual address in this address space.  Only the upper bits of the address are used. The address is aligned to a multiple of the region size, so a variable number of low-order bits are ignored, depending on the selected region size. It is recommended that software ensures that these low bits in the address are cleared, to avoid confusion. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS4_COMMAND</spirit:name>
        <spirit:displayName>ST1MMUAS4_COMMAND</spirit:displayName>
        <spirit:description>   MMU commands are issued by writing to this register. Any command written to an address space while the corresponding STATUS.AS_ACTIVE flag is set will be ignored.  In general an MMU command only applies to the address space it is submitted to. However a command that invalidates the MMU cache may invalidate the whole MMU cache rather than only those entries specific to one address space. </spirit:description>
        <spirit:addressOffset>0x18</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>ST1MMUAS4COMMAND</spirit:name>
          <spirit:displayName>ST1MMUAS4COMMAND</spirit:displayName>
          <spirit:description>ST1MMUAS4COMMAND</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>write-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NOP</spirit:name>
              <spirit:description> No operation, nothing happens. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>UPDATE</spirit:name>
              <spirit:description> Broadcasts the values in TRANSTAB and MEMATTR to all MMUs. MMU caches are invalidated. Use this after changing the content of these registers. This will  not clear the effect of a LOCK set in the updated address space.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>LOCK</spirit:name>
              <spirit:description> Issues a lock region command to all MMUs, using the address and size set in the LOCKADDR register. MMU caches are invalidated. Use this before changing an in-memory page table. Any existing lock on this address space is cleared. Locks on other address spaces are not affected. Use a FLUSH or UNLOCK command to unlock a memory region. </spirit:description>
              <spirit:value>2</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>UNLOCK</spirit:name>
              <spirit:description> Issues an unlock region command to all MMUs, using the address and size set in the LOCKADDR register. Any existing lock on this address space is cleared. If no lock was present, the MMU caches are invalidated. Use this when finished changing an in-memory page table, except if the page table can be cached in the L2 cache, in which case, a FLUSH_MEM command must be issued instead. </spirit:description>
              <spirit:value>3</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FLUSH_PT</spirit:name>
              <spirit:description> First cleans and invalidates all L2 caches to force cached page tables to be invalidated, then performs an UNLOCK command. </spirit:description>
              <spirit:value>4</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FLUSH_MEM</spirit:name>
              <spirit:description> First waits until all memory accesses to a region locked by a preceding LOCK command have completed and have reached the nearest cache.
			This will ensure that all reads to a locked memory region have finished, and that any writes to a locked region have either been written out to memory or are present in the L1 or L2 cache as dirty data.
			Then cleans and invalidates the L1 cache in all shader cores, forcing dirty data for locked regions to be pushed out to the L2 cache.
			Then cleans and invalidates all L2 caches forcing all dirty data for locked regions to be written back to memory and page tables to be invalidated.
			Then performs an UNLOCK command on this address space.
			Use this when finished changing or removing entries in an in-memory page table. </spirit:description>
              <spirit:value>5</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS4_FAULTSTATUS</spirit:name>
        <spirit:displayName>ST1MMUAS4_FAULTSTATUS</spirit:displayName>
        <spirit:description>   This register contains extended status information after a fault. If read before a fault occurs, its contents are the reset value, 0, which indicates no fault.
						If multiple faults occur before the first is handled, the subsequent faults are ignored. They may fault again after handling the first one.  If the GPU is in protected mode, this register is not updated, and MMU faults are ignored. 
						They are not fatal but will halt the GPU until the MMU address space is updated. 
						However, no fault information wil be visible in this case.  Changed access type of MMU_FAULTSTATUS register when in protected mode. </spirit:description>
        <spirit:addressOffset>0x1c</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>Res152</spirit:name>
          <spirit:displayName>Res152</spirit:displayName>
          <spirit:description>Res152</spirit:description>
          <spirit:bitOffset>10</spirit:bitOffset>
          <spirit:bitWidth>6</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>SOURCE_ID</spirit:name>
          <spirit:displayName>SOURCE_ID</spirit:displayName>
          <spirit:description>   This field contains an implementation-defined ID that supplies additional data about the source of the fault. For example, it may be the ID of the internal bus master that issued the request that faulted. This makes it possible to distinguish between the job manager, the texture unit and the load/store unit. Another example might be an indication of the type of an invalid data structure. The values in this field are implementation defined. </spirit:description>
          <spirit:bitOffset>16</spirit:bitOffset>
          <spirit:bitWidth>16</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>EXCEPTION_TYPE</spirit:name>
          <spirit:displayName>EXCEPTION_TYPE</spirit:displayName>
          <spirit:description>   This field indicates the type of exception that caused the fault. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>8</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>OK</spirit:name>
              <spirit:description>   This indicates that the GPU has completed its work and is in a state ready to receive new commands. Its precise meaning depends on its usage:    In the job status field, this indicates that the job has not been started. This should be the initial state of a newly created job.  In the job slot status register, this indicates that the job slot is idle.  In the GPU and MMU exception status registers, this indicates that no exception has yet been received.  No additional error information is available (or indeed required). </spirit:description>
              <spirit:value>0x00</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>DONE</spirit:name>
              <spirit:description> The job completed successfully. The fault value is written to the job descriptor.
			The job descriptors fault address field contains the TIMESTAMP value when the job completed.
			If a job is terminated early using the  EUREKA instruction, then that job will be marked with the EUREKA exception status but the job chain status as a whole will still be DONE.</spirit:description>
              <spirit:value>0x01</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>SUSPENDED</spirit:name>
              <spirit:description> The job was interrupted by a SUSPEND command. The fault value is written both to the job slot  STATUS register and the job descriptor.
			The job descriptor contains the partition index of the first task to be interrupted. The fault address field contains the TIMESTAMP value when the job was interrupted.</spirit:description>
              <spirit:value>0x02</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>STOPPED</spirit:name>
              <spirit:description> The job was interrupted by a SOFT_STOP command. The fault value is written both to the job slot  STATUS register and the job descriptor.
			The job descriptor contains the partition index of the first task that was not completed. This will be the index of the first task issued if the job is resumed. The fault address is UNDEFINED .</spirit:description>
              <spirit:value>0x03</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TERMINATED</spirit:name>
              <spirit:description> The job was interrupted by a HARD_STOP command or a  KABOOM instruction from another job. The fault value is written both to the job slot STATUS register and the job descriptor.
			This status is treated in the same way as an error condition. The job descriptor contains the partition index of the first task to be terminated. The fault address field contains the TIMESTAMP value when the job was interrupted.</spirit:description>
              <spirit:value>0x04</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>KABOOM</spirit:name>
              <spirit:description> The job was interrupted by a shader executing a  KABOOM instruction. The fault value is written both to the job slot STATUS register and the job descriptor.
			This status is treated in the same way as an error condition. The job descriptor contains the partition index of the first task to be terminated. The fault address field contains the TIMESTAMP value when the job was interrupted.</spirit:description>
              <spirit:value>0x05</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>EUREKA</spirit:name>
              <spirit:description> The job was interrupted by a shader executing a  EUREKA instruction. The fault value is written only to the job descriptor, and does not affect subsequent jobs in the job chain.
			The job descriptor contains the partition index of the first task to be terminated. The fault address field contains the TIMESTAMP value when the job was interrupted.</spirit:description>
              <spirit:value>0x06</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ACTIVE</spirit:name>
              <spirit:description> In the JSn_STATUS register, this indicates that the job slot is active.
			The JSn_HEAD and JSn_TAIL registers contain the range of job descriptors currently in progress. </spirit:description>
              <spirit:value>0x08</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>JOB_CONFIG_FAULT</spirit:name>
              <spirit:description>   The job configuration specified in the job slot registers is invalid, so it is not possible to read job descriptors.
				For example this includes setting a NULL job descriptor pointer, selecting an address space that isnt present.
				No additional information is available. </spirit:description>
              <spirit:value>0x40</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>JOB_POWER_FAULT</spirit:name>
              <spirit:description>   The job could not be executed because the part of the memory system required to access job descriptors was not powered on.
				No additional information is available. </spirit:description>
              <spirit:value>0x41</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>JOB_READ_FAULT</spirit:name>
              <spirit:description>   Reading a job descriptor into the Job manager failed.
				The JSn_HEAD register contains the virtual address of the job descriptor that could not be read. </spirit:description>
              <spirit:value>0x42</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>JOB_WRITE_FAULT</spirit:name>
              <spirit:description>   Writing a job descriptor from the Job manager failed.
				The JSn_TAIL register contains the virtual address of the job descriptor that could not be written. </spirit:description>
              <spirit:value>0x43</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>JOB_AFFINITY_FAULT</spirit:name>
              <spirit:description>   The job could not be executed because the specified affinity mask does not intersect any available cores.
				No additional information is available. </spirit:description>
              <spirit:value>0x44</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>JOB_BUS_FAULT</spirit:name>
              <spirit:description>   A bus access failed while executing a job.
				The job descriptor contains the virtual address of the failing access, the type of access, and which part of the GPU initiated the access.
				This error code may also be reported if a bus fault occurs while writing the performance counters to memory. In this case, the GPU_FAULT* registers are updated, but the active JASID is not reported. It is possible to distinguish this case from a genuine Job Bus Fault exception by examining the SOURCE_ID field. </spirit:description>
              <spirit:value>0x48</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>INSTR_INVALID_PC</spirit:name>
              <spirit:description>   A shader instruction with an illegal program counter was executed.
				The job descriptors fault address field contains the offending program counter value. </spirit:description>
              <spirit:value>0x50</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>INSTR_INVALID_ENC</spirit:name>
              <spirit:description>   A shader instruction with an illegal encoding was executed.
				The job descriptors fault address field contains the program counter used to reach the offending instruction. </spirit:description>
              <spirit:value>0x51</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>INSTR_BARRIER_FAULT</spirit:name>
              <spirit:description>   A shader instruction was executed that failed to complete an instruction barrier.
				The job descriptors fault address field contains the program counter used to reach the offending instruction. </spirit:description>
              <spirit:value>0x55</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>DATA_INVALID_FAULT</spirit:name>
              <spirit:description>   Any data structure read as part of the job contains invalid combinations of data.
				The job descriptors fault address field contains the virtual address of the invalid data structure. </spirit:description>
              <spirit:value>0x58</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TILE_RANGE_FAULT</spirit:name>
              <spirit:description>   Tile or fragment shading was asked to process a tile that is entirely outside the bounding box of the frame.
				The job descriptors fault address field contains the coordinates of the top left corner of the failing tile, with X in the bits [15:0], and Y in the bits [31:16].  Clarified description of TILE_RANGE_FAULT. </spirit:description>
              <spirit:value>0x59</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ADDR_RANGE_FAULT</spirit:name>
              <spirit:description>   A virtual address has been found that exceeds the virtual address range.
				The job descriptors fault address field contains the virtual address which is out of range. </spirit:description>
              <spirit:value>0x5A</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>IMPRECISE_FAULT</spirit:name>
              <spirit:description>   A fault has been generated without precise fault information.
				This can happen if appropriate source information is not available at the point where the fault happens.
				The job descriptors fault address field may contain a virtual address related to the fault. </spirit:description>
              <spirit:value>0x5B</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>OUT_OF_MEMORY</spirit:name>
              <spirit:description>   The tiler ran out of memory when executing a job.
				The job descriptors fault address field contains the index of the last completed vertex sent through the tiler. </spirit:description>
              <spirit:value>0x60</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>UNKNOWN</spirit:name>
              <spirit:description>   If multiple jobs in a job chain fail, only the first one the reports an error will set and return full error information. Subsequent failing jobs will not update the error status registers, and may write an error status of UNKNOWN.
				Note that the first job to fail may not be the first job in the chain, which may lead to jobs with  UNKNOWN error status being encountered first when traversing the job chain.
				For example, you may see: Done, Done, Unknown, Bus Error, Unknown, New. In this case, the first two jobs ran successfully, the fourth job hit a bus error, and then jobs three and five also failed. The sixth and subsequent jobs had not been started at that point.</spirit:description>
              <spirit:value>0x7F</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>DELAYED_BUS_FAULT</spirit:name>
              <spirit:description>   The GPU received a bus fault for access to physical memory where the original virtual address is no longer available. This is the result of evicting a dirty line from a cache.
				This may also be triggered by a bus fault during a Tiler cache flush operation. In this case, the address reported in  GPU_FAULTADDRESS is a virtual address.</spirit:description>
              <spirit:value>0x80</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>GPU_SHAREABILITY_FAULT</spirit:name>
              <spirit:description>   A cache has detected that the same line has been accessed as both shareable and non-shareable memory from inside the GPU. Coherency after this point can no longer be guaranteed. </spirit:description>
              <spirit:value>0x88</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>SYSTEM_SHAREABILITY_FAULT</spirit:name>
              <spirit:description>   A cache has detected that the same line has been accessed as both shareable and non-shareable memory from outside the GPU. Coherency after this point can no longer be guaranteed. </spirit:description>
              <spirit:value>0x89</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>GPU_CACHEABILITY_FAULT</spirit:name>
              <spirit:description>   A cache has detected that the same line has been accessed as both cacheable and non-cacheable memory from inside the GPU. Non-cacheable memory may have been cached. </spirit:description>
              <spirit:value>0x8A</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TRANSLATION_FAULT_0</spirit:name>
              <spirit:description>   A memory access hit an invalid table entry at level 0 of the translation table. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xC0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TRANSLATION_FAULT_1</spirit:name>
              <spirit:description>   A memory access hit an invalid table entry at level 1 of the translation table. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xC1</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TRANSLATION_FAULT_2</spirit:name>
              <spirit:description>   A memory access hit an invalid table entry at level 2 of the translation table. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xC2</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TRANSLATION_FAULT_3</spirit:name>
              <spirit:description>   A memory access hit an invalid table entry at level 3 of the translation table. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xC3</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TRANSLATION_FAULT_IDENTITY</spirit:name>
              <spirit:description>   In IDENTITY translation mode, the virtual address exceeds the maximum physical address. </spirit:description>
              <spirit:value>0xC7</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>PERMISSION_FAULT_0</spirit:name>
              <spirit:description>   A memory access could not be allowed due to the permission flags set in level 0 of the translation table. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set. Added MMU translation level information to permission fault. </spirit:description>
              <spirit:value>0xC8</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>PERMISSION_FAULT_1</spirit:name>
              <spirit:description>   A memory access could not be allowed due to the permission flags set in level 1 of the translation table. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xC9</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>PERMISSION_FAULT_2</spirit:name>
              <spirit:description>   A memory access could not be allowed due to the permission flags set in level 2 of the translation table. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xCA</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>PERMISSION_FAULT_3</spirit:name>
              <spirit:description>   A memory access could not be allowed due to the permission flags set in level 3 of the translation table. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xCB</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TRANSTAB_BUS_FAULT_0</spirit:name>
              <spirit:description>   A bus fault occurred while reading level 0 of the translation tables. The appropriate  BUS_ERROR flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xD0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TRANSTAB_BUS_FAULT_1</spirit:name>
              <spirit:description>   A bus fault occurred while reading level 1 of the translation tables. The appropriate  BUS_ERROR flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xD1</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TRANSTAB_BUS_FAULT_2</spirit:name>
              <spirit:description>   A bus fault occurred while reading level 2 of the translation tables. The appropriate  BUS_ERROR flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xD2</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TRANSTAB_BUS_FAULT_3</spirit:name>
              <spirit:description>   A bus fault occurred while reading level 3 of the translation tables. The appropriate  BUS_ERROR flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xD3</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ACCESS_FLAG_0</spirit:name>
              <spirit:description>   A memory access hit a translation table entry with the ACCESS_FLAG bit set in level 0 of the translation table. This is not treated as a fault by the accessor. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set. Added MMU translation level information to access flag fault. </spirit:description>
              <spirit:value>0xD8</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ACCESS_FLAG_1</spirit:name>
              <spirit:description>   A memory access hit a translation table entry with the ACCESS_FLAG bit set in level 1 of the translation table. This is not treated as a fault by the accessor. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xD9</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ACCESS_FLAG_2</spirit:name>
              <spirit:description>   A memory access hit a translation table entry with the ACCESS_FLAG bit set in level 2 of the translation table. This is not treated as a fault by the accessor. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xDA</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ACCESS_FLAG_3</spirit:name>
              <spirit:description>   A memory access hit a translation table entry with the ACCESS_FLAG bit set in level 3 of the translation table. This is not treated as a fault by the accessor. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xDB</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ADDRESS_SIZE_FAULT_IN0</spirit:name>
              <spirit:description>   An input address size fault occurred while reading level 0 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ADDRESS_SIZE_FAULT_IN1</spirit:name>
              <spirit:description>   An input address size fault occurred while reading level 1 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE1</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ADDRESS_SIZE_FAULT_IN2</spirit:name>
              <spirit:description>   An input address size fault occurred while reading level 2 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE2</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ADDRESS_SIZE_FAULT_IN3</spirit:name>
              <spirit:description>   An input address size fault occurred while reading level 3 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE3</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ADDRESS_SIZE_FAULT_OUT0</spirit:name>
              <spirit:description>   An output address size fault occurred while reading level 0 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE4</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ADDRESS_SIZE_FAULT_OUT1</spirit:name>
              <spirit:description>   An output address size fault occurred while reading level 1 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE5</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ADDRESS_SIZE_FAULT_OUT2</spirit:name>
              <spirit:description>   An output address size fault occurred while reading level 2 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE6</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ADDRESS_SIZE_FAULT_OUT3</spirit:name>
              <spirit:description>   An output address size fault occurred while reading level 3 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE7</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>MEMORY_ATTRIBUTE_FAULT_0</spirit:name>
              <spirit:description>   A memory access could not be allowed due to an attempt to access a page with its memory attribute set to  FAULT in the MEMATTR register. This fault happened when reading level 0 of the translation tables. The appropriate PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE8</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>MEMORY_ATTRIBUTE_FAULT_1</spirit:name>
              <spirit:description>   A memory access could not be allowed due to an attempt to access a page with its memory attribute set to  FAULT in the MEMATTR register. This fault happened when reading level 1 of the translation tables. The appropriate PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE9</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>MEMORY_ATTRIBUTE_FAULT_2</spirit:name>
              <spirit:description>   A memory access could not be allowed due to an attempt to access a page with its memory attribute set to  FAULT in the MEMATTR register. This fault happened when reading level 2 of the translation tables. The appropriate PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xEA</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>MEMORY_ATTRIBUTE_FAULT_3</spirit:name>
              <spirit:description>   A memory access could not be allowed due to an attempt to access a page with its memory attribute set to  FAULT in the MEMATTR register. This fault happened when reading level 3 of the translation tables. The appropriate PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xEB</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>MEMORY_ATTRIBUTE_NONCACHEABLE_0</spirit:name>
              <spirit:description>   A memory access could not be allowed due to an attempt to access a non-cacheable page from a bus master which does not support non-cacheable accessess. This fault happened when reading level 0 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xEC</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>MEMORY_ATTRIBUTE_NONCACHEABLE_1</spirit:name>
              <spirit:description>   A memory access could not be allowed due to an attempt to access a non-cacheable page from a bus master which does not support non-cacheable accessess. This fault happened when reading level 1 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xED</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>MEMORY_ATTRIBUTE_NONCACHEABLE_2</spirit:name>
              <spirit:description>   A memory access could not be allowed due to an attempt to access a non-cacheable page from a bus master which does not support non-cacheable accessess. This fault happened when reading level 2 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xEE</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>MEMORY_ATTRIBUTE_NONCACHEABLE_3</spirit:name>
              <spirit:description>   A memory access could not be allowed due to an attempt to access a non-cacheable page from a bus master which does not support non-cacheable accessess. This fault happened when reading level 3 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xEF</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ACCESS_TYPE</spirit:name>
          <spirit:displayName>ACCESS_TYPE</spirit:displayName>
          <spirit:description>   This field contains the direction of data transfer that caused the fault, if known.  For the purposes of error reporting, atomic transactions act like a read followed by a write, so denying either permission will result in the atomic transaction failing, and the exceptions ACCESS_TYPE field will be set to "atomic". </spirit:description>
          <spirit:bitOffset>8</spirit:bitOffset>
          <spirit:bitWidth>2</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>atomic</spirit:name>
              <spirit:description> An atomic (read/write) transaction. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>execute</spirit:name>
              <spirit:description> An execute transaction. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>read</spirit:name>
              <spirit:description> A read transaction. </spirit:description>
              <spirit:value>2</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>write</spirit:name>
              <spirit:description> A write transaction. </spirit:description>
              <spirit:value>3</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS4_FAULTADDRESS_LO</spirit:name>
        <spirit:displayName>ST1MMUAS4_FAULTADDRESS_LO</spirit:displayName>
        <spirit:description>   This register contains information about the cause of a page fault or bus error. </spirit:description>
        <spirit:addressOffset>0x20</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>ST1MMUAS4FAULTADDRESS_LO</spirit:name>
          <spirit:displayName>ST1MMUAS4FAULTADDRESS_LO</spirit:displayName>
          <spirit:description>   This field contains the virtual address (in this address space) of the access that caused the fault.  Additional information about the fault is also available in the FAULTSTATUS register.  If multiple faults occur before the first is handled, the subsequent faults are ignored. They may fault again after handling the first one. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS4_FAULTADDRESS_HI</spirit:name>
        <spirit:displayName>ST1MMUAS4_FAULTADDRESS_HI</spirit:displayName>
        <spirit:description>   This register contains information about the cause of a page fault or bus error. </spirit:description>
        <spirit:addressOffset>0x24</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>ST1MMUAS4FAULTADDRESS_HI</spirit:name>
          <spirit:displayName>ST1MMUAS4FAULTADDRESS_HI</spirit:displayName>
          <spirit:description>   This field contains the virtual address (in this address space) of the access that caused the fault.  Additional information about the fault is also available in the FAULTSTATUS register.  If multiple faults occur before the first is handled, the subsequent faults are ignored. They may fault again after handling the first one. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS4_STATUS</spirit:name>
        <spirit:displayName>ST1MMUAS4_STATUS</spirit:displayName>
        <spirit:description>   This register contains dynamic status information about this address space. </spirit:description>
        <spirit:addressOffset>0x28</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>Res153</spirit:name>
          <spirit:displayName>Res153</spirit:displayName>
          <spirit:description>Res153</spirit:description>
          <spirit:bitOffset>1</spirit:bitOffset>
          <spirit:bitWidth>31</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>AS_ACTIVE</spirit:name>
          <spirit:displayName>AS_ACTIVE</spirit:displayName>
          <spirit:description>   This flag is set while a MMU_UPDATE, LOCK, UNLOCK, FLUSH_PT or FLUSH_MEM command is active on this address space. This allows software to safely verify that the address space is in a consistent state after reconfiguring the MMU page tables.  If a new command is written to the corresponding COMMAND register while the AS_ACTIVE bit is set, then the command is ignored. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> Address space command register is inactive. A new command may be written to the COMMAND register. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Address space command register is active. Any new command written to the COMMAND register will be ignored. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS4_TRANSCFG_LO</spirit:name>
        <spirit:displayName>ST1MMUAS4_TRANSCFG_LO</spirit:displayName>
        <spirit:description>ST1MMUAS4_TRANSCFG_LO</spirit:description>
        <spirit:addressOffset>0x30</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>Res154</spirit:name>
          <spirit:displayName>Res154</spirit:displayName>
          <spirit:description>Res154</spirit:description>
          <spirit:bitOffset>4</spirit:bitOffset>
          <spirit:bitWidth>2</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>Res155</spirit:name>
          <spirit:displayName>Res155</spirit:displayName>
          <spirit:description>Res155</spirit:description>
          <spirit:bitOffset>11</spirit:bitOffset>
          <spirit:bitWidth>3</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>Res156</spirit:name>
          <spirit:displayName>Res156</spirit:displayName>
          <spirit:description>Res156</spirit:description>
          <spirit:bitOffset>19</spirit:bitOffset>
          <spirit:bitWidth>3</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>Res157</spirit:name>
          <spirit:displayName>Res157</spirit:displayName>
          <spirit:description>Res157</spirit:description>
          <spirit:bitOffset>23</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>Res158</spirit:name>
          <spirit:displayName>Res158</spirit:displayName>
          <spirit:description>Res158</spirit:description>
          <spirit:bitOffset>26</spirit:bitOffset>
          <spirit:bitWidth>2</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>Res159</spirit:name>
          <spirit:displayName>Res159</spirit:displayName>
          <spirit:description>Res159</spirit:description>
          <spirit:bitOffset>31</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>INA_BITS</spirit:name>
          <spirit:displayName>INA_BITS</spirit:displayName>
          <spirit:description>   This field allows the system software to restrict the range of input addresses accepted by this translation stage. This is used in conjunction with the hardware limits to determine the valid address range as follows:  INA_BITS_VALID = min(HW_INA_BITS, 55-INA_BITS)  If the input address is outside the range (0, 2  INA_BITS_VALID -1), then a TRANSLATION_FAULT error is generated.</spirit:description>
          <spirit:bitOffset>6</spirit:bitOffset>
          <spirit:bitWidth>5</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>OUTA_BITS</spirit:name>
          <spirit:displayName>OUTA_BITS</spirit:displayName>
          <spirit:description>   This field allows the system software to restrict the range of output addresses generated by this translation stage. This is used in conjunction with the hardware limits to determine the valid address range as follows:  OUTA_BITS_VALID = min(HW_OUTA_BITS, 55-OUTA_BITS)  If the translated output address is outside the range (0, 2  OUTA_BITS_VALID -1), then a TRANSLATION_FAULT error is generated.</spirit:description>
          <spirit:bitOffset>14</spirit:bitOffset>
          <spirit:bitWidth>5</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>MODE</spirit:name>
          <spirit:displayName>MODE</spirit:displayName>
          <spirit:description>   This field controls the overall operation of the MMU. There are some differences between stage 1 and stage 2.  Execute permissions for a page are evaluated as follows (PTE.&amp;lt;W|R|X&gt; refers to page table entry permissions resolved for hierarchical permissions (if applicable):  EXECUTE_ALLOWED = !((TRANSCFG.WXN &amp;amp; !PTE.W) | (TRANSCFG.XREADABLE &amp;amp; !PTE.R) | (!TRANSCFG.XREADABLE &amp;amp; !PTE.X)) </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>LEGACY</spirit:name>
              <spirit:description>   The contents of TRANSTAB and MEMATTR are interpreted according to the legacy behaviour, as used in previous Midgard GPUs. The rest of the TRANSCFG bits are ignored.  Input and output address sizes are set according to the hardware configuration.  Stage 1 will follow the legacy behaviour.  Stage 2 will be transparent, will ignore TRANSTAB settings and will not generate any faults.  Note: as the reset value of TRANSCFG is 0, this is a mechanism to ensure backwards-compatibility and alignment between the stages. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>UNMAPPED</spirit:name>
              <spirit:description> The MMU forces all memory access to fail with a decode fault. No actual page table is required. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>IDENTITY</spirit:name>
              <spirit:description>   The MMU behaves as if using an address translation table with all entries valid and giving an identity mapping (output address is the same as the input address) with full read/write/execute access. Addresses outside the configured address ranges cause page faults.  For Stage 1, cacheability and shareability are defined by MEMATTR0. For Stage 2, cacheablity and sharebility are defined so that they dont change whats set by Stage 1 (non-shareable and inner/outer write-back cacheable and master-defined allocation). </spirit:description>
              <spirit:value>2</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>AARCH64_4K</spirit:name>
              <spirit:description> Page tables are interpreted according to the AArch64 4kB granule specification. </spirit:description>
              <spirit:value>6</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>AARCH64_64K</spirit:name>
              <spirit:description> Page tables are interpreted according to the AArch64 64kB granule specification. </spirit:description>
              <spirit:value>8</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>PTW_MEMATTR</spirit:name>
          <spirit:displayName>PTW_MEMATTR</spirit:displayName>
          <spirit:description>   Memory attributes for page table walks. The allowed values are compatible with the values allowed for  MEMORY_TYPE . For outer cache transactions, the desired attributes for the transaction will be decided by the bus master and communicated to the memory system using signals on the bus.  Changed allowed values for TRANSCFG.PTW_MEMATTR. </spirit:description>
          <spirit:bitOffset>24</spirit:bitOffset>
          <spirit:bitWidth>2</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NON_CACHEABLE</spirit:name>
              <spirit:description> Normal memory, inner non-cacheable, outer non-cacheable. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>WRITE_BACK</spirit:name>
              <spirit:description> Normal memory, inner write-back cacheable, outer write-back cacheable. </spirit:description>
              <spirit:value>2</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>PTW_SH</spirit:name>
          <spirit:displayName>PTW_SH</spirit:displayName>
          <spirit:description>   This field specifies the shareability for the page table walks. This is the same encoding as used for ARMv8 page tables. </spirit:description>
          <spirit:bitOffset>28</spirit:bitOffset>
          <spirit:bitWidth>2</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>non_shareable</spirit:name>
              <spirit:description> The memory region is non-shareable, and coherency with other observers will not automatically be maintained. Software will have to ensure that caches are flushed or invalidated at appropriate times. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>outer_shareable</spirit:name>
              <spirit:description> The memory region is marked as outer shareable. Each outer shareability domain contains a set of observers that are data coherent for each member of that set for	data accesses with the outer shareable attribute made by any member of that set. </spirit:description>
              <spirit:value>2</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>inner_shareable</spirit:name>
              <spirit:description> The memory region is marked as inner shareable. Each inner shareability domain contains a set of observers that are data coherent for each member of that set for	data accesses with the inner shareable attribute made by any member of that set. All observers in an inner shareability domain are always members of the same outer shareability domain. This means that an inner shareability domain is a subset of an Outer Shareability domain, although it is not required to be a proper subset. </spirit:description>
              <spirit:value>3</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>R_ALLOCATE</spirit:name>
          <spirit:displayName>R_ALLOCATE</spirit:displayName>
          <spirit:description>   This field sets the inner read allocation hint for the page table walks. This is the same encoding as used for ARMv8 page tables. </spirit:description>
          <spirit:bitOffset>30</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>no_read_allocate</spirit:name>
              <spirit:description> Hints that the cache should not allocate space when reading a page table entry. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>read_allocate</spirit:name>
              <spirit:description> Hints that the cache should allocate space when reading a page table entry. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>SL_CONCAT_EN</spirit:name>
          <spirit:displayName>SL_CONCAT_EN</spirit:displayName>
          <spirit:description>   If set then the page table walk starting level will be increased if possible by concatenating up to 16 tables in the starting level. </spirit:description>
          <spirit:bitOffset>22</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> Page table concatenation is disabled. 	This mode must be used for Stage 1 if sharing page tables with the CPU, otherwise  UNDEFINED behavior results.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Page table concatenation is enabled. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS4_TRANSCFG_HI</spirit:name>
        <spirit:displayName>ST1MMUAS4_TRANSCFG_HI</spirit:displayName>
        <spirit:description>ST1MMUAS4_TRANSCFG_HI</spirit:description>
        <spirit:addressOffset>0x34</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>Res160</spirit:name>
          <spirit:displayName>Res160</spirit:displayName>
          <spirit:description>Res160</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>Res161</spirit:name>
          <spirit:displayName>Res161</spirit:displayName>
          <spirit:description>Res161</spirit:description>
          <spirit:bitOffset>5</spirit:bitOffset>
          <spirit:bitWidth>27</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>DISABLE_HIER_AP</spirit:name>
          <spirit:displayName>DISABLE_HIER_AP</spirit:displayName>
          <spirit:description>   This flag only has an effect on stage 1 of translation. It is ignored for stage 2. Note the inverted logic - the flag must be set to  dis able hierarchical access permissions.</spirit:description>
          <spirit:bitOffset>1</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> Hierarchical access permissions are enabled. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Hierarchical access permissions are disabled. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>DISABLE_AF_FAULT</spirit:name>
          <spirit:displayName>DISABLE_AF_FAULT</spirit:displayName>
          <spirit:description>   This flag can be used to disable access fault checking when in one of AARCH64 modes. </spirit:description>
          <spirit:bitOffset>2</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> Access fault checking is enabled. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Access fault checking is disabled. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>WXN</spirit:name>
          <spirit:displayName>WXN</spirit:displayName>
          <spirit:description>   This flag can be used to disable all writes to executable pages, overriding access permissions specified in the page table. </spirit:description>
          <spirit:bitOffset>3</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> Write access permissions are read as usual from the page table. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Write access to all executable pages is disabled. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>XREADABLE</spirit:name>
          <spirit:displayName>XREADABLE</spirit:displayName>
          <spirit:description>   This flag can be used to enable execution on all readable pages, overriding access permissions specified in the page table. </spirit:description>
          <spirit:bitOffset>4</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> Execute access permissions are read as usual from the page table. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Execute access to all readable pages is enabled. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS4_FAULTEXTRA_LO</spirit:name>
        <spirit:displayName>ST1MMUAS4_FAULTEXTRA_LO</spirit:displayName>
        <spirit:description>   This register contains additional information about the cause of a page fault or bus error. </spirit:description>
        <spirit:addressOffset>0x38</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>ST1MMUAS4FAULTEXTRA_LO</spirit:name>
          <spirit:displayName>ST1MMUAS4FAULTEXTRA_LO</spirit:displayName>
          <spirit:description>   This field contains the virtual address (in this address space) of the access that caused the fault.  Additional information about the fault is also available in the  FAULTSTATUS and FAULTADDRESS registers. If multiple faults occur before the first is handled, the subsequent faults are ignored. They may fault again after handling the first one.  Fixed duplicate state name in FAULT_ADDRESS - exposes previously hidden field S2FS1WALK. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS4_FAULTEXTRA_HI</spirit:name>
        <spirit:displayName>ST1MMUAS4_FAULTEXTRA_HI</spirit:displayName>
        <spirit:description>   This register contains additional information about the cause of a page fault or bus error. </spirit:description>
        <spirit:addressOffset>0x3c</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>Res162</spirit:name>
          <spirit:displayName>Res162</spirit:displayName>
          <spirit:description>Res162</spirit:description>
          <spirit:bitOffset>16</spirit:bitOffset>
          <spirit:bitWidth>15</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>ST1MMUAS4FAULTEXTRA_HI</spirit:name>
          <spirit:displayName>ST1MMUAS4FAULTEXTRA_HI</spirit:displayName>
          <spirit:description>   This field contains the virtual address (in this address space) of the access that caused the fault.  Additional information about the fault is also available in the  FAULTSTATUS and FAULTADDRESS registers. If multiple faults occur before the first is handled, the subsequent faults are ignored. They may fault again after handling the first one.  Fixed duplicate state name in FAULT_ADDRESS - exposes previously hidden field S2FS1WALK. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>16</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>S2FS1WALK</spirit:name>
          <spirit:displayName>S2FS1WALK</spirit:displayName>
          <spirit:description>S2FS1WALK</spirit:description>
          <spirit:bitOffset>31</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>stage2</spirit:name>
              <spirit:description> Fault source is a stage 2 translation. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>stage1</spirit:name>
              <spirit:description> Fault source is a stage 1 page table walk. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
    </spirit:addressBlock>
    <spirit:addressBlock>
      <spirit:name>jm_mmu_as5_regs</spirit:name>
      <spirit:baseAddress>9536</spirit:baseAddress>
      <spirit:range>64</spirit:range>
      <spirit:width>32</spirit:width>
      <spirit:usage>register</spirit:usage>
      <spirit:register>
        <spirit:name>ST1MMUAS5_TRANSTAB_LO</spirit:name>
        <spirit:displayName>ST1MMUAS5_TRANSTAB_LO</spirit:displayName>
        <spirit:description>   This register contains the address of the base level of the translation table, together with some related flags.  Details on the layout of the page tables, and the address translation process, can be found in the section  Memory Management Unit .</spirit:description>
        <spirit:addressOffset>0x0</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>Res163</spirit:name>
          <spirit:displayName>Res163</spirit:displayName>
          <spirit:description>Res163</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>ST1MMUAS5TRANSTAB_LO</spirit:name>
          <spirit:displayName>ST1MMUAS5TRANSTAB_LO</spirit:displayName>
          <spirit:description>   This field contains the address of the top level of a page table structure. This must be 16-byte-aligned, so address bits [3:0] are assumed to be zero.  For a stage 1 page table, this will be an intermediate physical address, and for stage 2 it will be a physical address. The number of actual translated address bits is stored in  OUTA_BITS . The unused high bits must be set to 0. Changed alignment text for TRANSTAB.BASE  TRANSTAB.BASE pointer is a physical (or intermediate) address </spirit:description>
          <spirit:bitOffset>4</spirit:bitOffset>
          <spirit:bitWidth>28</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS5_TRANSTAB_HI</spirit:name>
        <spirit:displayName>ST1MMUAS5_TRANSTAB_HI</spirit:displayName>
        <spirit:description>   This register contains the address of the base level of the translation table, together with some related flags.  Details on the layout of the page tables, and the address translation process, can be found in the section  Memory Management Unit .</spirit:description>
        <spirit:addressOffset>0x4</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>ST1MMUAS5TRANSTAB_HI</spirit:name>
          <spirit:displayName>ST1MMUAS5TRANSTAB_HI</spirit:displayName>
          <spirit:description>   This field contains the address of the top level of a page table structure. This must be 16-byte-aligned, so address bits [3:0] are assumed to be zero.  For a stage 1 page table, this will be an intermediate physical address, and for stage 2 it will be a physical address. The number of actual translated address bits is stored in  OUTA_BITS . The unused high bits must be set to 0. Changed alignment text for TRANSTAB.BASE  TRANSTAB.BASE pointer is a physical (or intermediate) address </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS5_MEMATTR_LO</spirit:name>
        <spirit:displayName>ST1MMUAS5_MEMATTR_LO</spirit:displayName>
        <spirit:description>  </spirit:description>
        <spirit:addressOffset>0x8</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>ATTRIBUTE0</spirit:name>
          <spirit:displayName>ATTRIBUTE0</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 0. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE1</spirit:name>
          <spirit:displayName>ATTRIBUTE1</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 1. </spirit:description>
          <spirit:bitOffset>4</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE2</spirit:name>
          <spirit:displayName>ATTRIBUTE2</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 2. </spirit:description>
          <spirit:bitOffset>8</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE3</spirit:name>
          <spirit:displayName>ATTRIBUTE3</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 3. </spirit:description>
          <spirit:bitOffset>12</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE4</spirit:name>
          <spirit:displayName>ATTRIBUTE4</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 4. </spirit:description>
          <spirit:bitOffset>16</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE5</spirit:name>
          <spirit:displayName>ATTRIBUTE5</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 5. </spirit:description>
          <spirit:bitOffset>20</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE6</spirit:name>
          <spirit:displayName>ATTRIBUTE6</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 6. </spirit:description>
          <spirit:bitOffset>24</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE7</spirit:name>
          <spirit:displayName>ATTRIBUTE7</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 7. </spirit:description>
          <spirit:bitOffset>28</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS5_MEMATTR_HI</spirit:name>
        <spirit:displayName>ST1MMUAS5_MEMATTR_HI</spirit:displayName>
        <spirit:description>  </spirit:description>
        <spirit:addressOffset>0xc</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>ATTRIBUTE8</spirit:name>
          <spirit:displayName>ATTRIBUTE8</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 8. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE9</spirit:name>
          <spirit:displayName>ATTRIBUTE9</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 9. </spirit:description>
          <spirit:bitOffset>4</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE10</spirit:name>
          <spirit:displayName>ATTRIBUTE10</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 10. </spirit:description>
          <spirit:bitOffset>8</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE11</spirit:name>
          <spirit:displayName>ATTRIBUTE11</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 11. </spirit:description>
          <spirit:bitOffset>12</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE12</spirit:name>
          <spirit:displayName>ATTRIBUTE12</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 12. </spirit:description>
          <spirit:bitOffset>16</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE13</spirit:name>
          <spirit:displayName>ATTRIBUTE13</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 13. </spirit:description>
          <spirit:bitOffset>20</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE14</spirit:name>
          <spirit:displayName>ATTRIBUTE14</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 14. </spirit:description>
          <spirit:bitOffset>24</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE15</spirit:name>
          <spirit:displayName>ATTRIBUTE15</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 15. </spirit:description>
          <spirit:bitOffset>28</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS5_LOCKADDR_LO</spirit:name>
        <spirit:displayName>ST1MMUAS5_LOCKADDR_LO</spirit:displayName>
        <spirit:description>   This register tells the MMU to lock a region of virtual memory. All page mappings within this region must be flushed, and no translation requests within this region can complete or fault before the area is unlocked.  Only one region can be locked at a time.  As only 32 bits of the register can be written to at a time, no changes are issued until the LOCK command is written to the COMMAND register. </spirit:description>
        <spirit:addressOffset>0x10</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>Res164</spirit:name>
          <spirit:displayName>Res164</spirit:displayName>
          <spirit:description>Res164</spirit:description>
          <spirit:bitOffset>6</spirit:bitOffset>
          <spirit:bitWidth>6</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>LOCKADDR_SIZE</spirit:name>
          <spirit:displayName>LOCKADDR_SIZE</spirit:displayName>
          <spirit:description>   This field contains the log  2 of the size of the region to lock, minus 1. Only values in the range 11 to 63 are valid values for this field, corresponding to region sizes of 4KB up to the entire address space. Values in the range 0 to 10 result in UNDEFINED behavior and should not be used.</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>6</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>ST1MMUAS5LOCKADDR_LO</spirit:name>
          <spirit:displayName>ST1MMUAS5LOCKADDR_LO</spirit:displayName>
          <spirit:description>   This field contains the lowest address in the region to be locked. The address is a virtual address in this address space.  Only the upper bits of the address are used. The address is aligned to a multiple of the region size, so a variable number of low-order bits are ignored, depending on the selected region size. It is recommended that software ensures that these low bits in the address are cleared, to avoid confusion. </spirit:description>
          <spirit:bitOffset>12</spirit:bitOffset>
          <spirit:bitWidth>20</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS5_LOCKADDR_HI</spirit:name>
        <spirit:displayName>ST1MMUAS5_LOCKADDR_HI</spirit:displayName>
        <spirit:description>   This register tells the MMU to lock a region of virtual memory. All page mappings within this region must be flushed, and no translation requests within this region can complete or fault before the area is unlocked.  Only one region can be locked at a time.  As only 32 bits of the register can be written to at a time, no changes are issued until the LOCK command is written to the COMMAND register. </spirit:description>
        <spirit:addressOffset>0x14</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>ST1MMUAS5LOCKADDR_HI</spirit:name>
          <spirit:displayName>ST1MMUAS5LOCKADDR_HI</spirit:displayName>
          <spirit:description>   This field contains the lowest address in the region to be locked. The address is a virtual address in this address space.  Only the upper bits of the address are used. The address is aligned to a multiple of the region size, so a variable number of low-order bits are ignored, depending on the selected region size. It is recommended that software ensures that these low bits in the address are cleared, to avoid confusion. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS5_COMMAND</spirit:name>
        <spirit:displayName>ST1MMUAS5_COMMAND</spirit:displayName>
        <spirit:description>   MMU commands are issued by writing to this register. Any command written to an address space while the corresponding STATUS.AS_ACTIVE flag is set will be ignored.  In general an MMU command only applies to the address space it is submitted to. However a command that invalidates the MMU cache may invalidate the whole MMU cache rather than only those entries specific to one address space. </spirit:description>
        <spirit:addressOffset>0x18</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>ST1MMUAS5COMMAND</spirit:name>
          <spirit:displayName>ST1MMUAS5COMMAND</spirit:displayName>
          <spirit:description>ST1MMUAS5COMMAND</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>write-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NOP</spirit:name>
              <spirit:description> No operation, nothing happens. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>UPDATE</spirit:name>
              <spirit:description> Broadcasts the values in TRANSTAB and MEMATTR to all MMUs. MMU caches are invalidated. Use this after changing the content of these registers. This will  not clear the effect of a LOCK set in the updated address space.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>LOCK</spirit:name>
              <spirit:description> Issues a lock region command to all MMUs, using the address and size set in the LOCKADDR register. MMU caches are invalidated. Use this before changing an in-memory page table. Any existing lock on this address space is cleared. Locks on other address spaces are not affected. Use a FLUSH or UNLOCK command to unlock a memory region. </spirit:description>
              <spirit:value>2</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>UNLOCK</spirit:name>
              <spirit:description> Issues an unlock region command to all MMUs, using the address and size set in the LOCKADDR register. Any existing lock on this address space is cleared. If no lock was present, the MMU caches are invalidated. Use this when finished changing an in-memory page table, except if the page table can be cached in the L2 cache, in which case, a FLUSH_MEM command must be issued instead. </spirit:description>
              <spirit:value>3</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FLUSH_PT</spirit:name>
              <spirit:description> First cleans and invalidates all L2 caches to force cached page tables to be invalidated, then performs an UNLOCK command. </spirit:description>
              <spirit:value>4</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FLUSH_MEM</spirit:name>
              <spirit:description> First waits until all memory accesses to a region locked by a preceding LOCK command have completed and have reached the nearest cache.
			This will ensure that all reads to a locked memory region have finished, and that any writes to a locked region have either been written out to memory or are present in the L1 or L2 cache as dirty data.
			Then cleans and invalidates the L1 cache in all shader cores, forcing dirty data for locked regions to be pushed out to the L2 cache.
			Then cleans and invalidates all L2 caches forcing all dirty data for locked regions to be written back to memory and page tables to be invalidated.
			Then performs an UNLOCK command on this address space.
			Use this when finished changing or removing entries in an in-memory page table. </spirit:description>
              <spirit:value>5</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS5_FAULTSTATUS</spirit:name>
        <spirit:displayName>ST1MMUAS5_FAULTSTATUS</spirit:displayName>
        <spirit:description>   This register contains extended status information after a fault. If read before a fault occurs, its contents are the reset value, 0, which indicates no fault.
						If multiple faults occur before the first is handled, the subsequent faults are ignored. They may fault again after handling the first one.  If the GPU is in protected mode, this register is not updated, and MMU faults are ignored. 
						They are not fatal but will halt the GPU until the MMU address space is updated. 
						However, no fault information wil be visible in this case.  Changed access type of MMU_FAULTSTATUS register when in protected mode. </spirit:description>
        <spirit:addressOffset>0x1c</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>Res165</spirit:name>
          <spirit:displayName>Res165</spirit:displayName>
          <spirit:description>Res165</spirit:description>
          <spirit:bitOffset>10</spirit:bitOffset>
          <spirit:bitWidth>6</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>SOURCE_ID</spirit:name>
          <spirit:displayName>SOURCE_ID</spirit:displayName>
          <spirit:description>   This field contains an implementation-defined ID that supplies additional data about the source of the fault. For example, it may be the ID of the internal bus master that issued the request that faulted. This makes it possible to distinguish between the job manager, the texture unit and the load/store unit. Another example might be an indication of the type of an invalid data structure. The values in this field are implementation defined. </spirit:description>
          <spirit:bitOffset>16</spirit:bitOffset>
          <spirit:bitWidth>16</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>EXCEPTION_TYPE</spirit:name>
          <spirit:displayName>EXCEPTION_TYPE</spirit:displayName>
          <spirit:description>   This field indicates the type of exception that caused the fault. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>8</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>OK</spirit:name>
              <spirit:description>   This indicates that the GPU has completed its work and is in a state ready to receive new commands. Its precise meaning depends on its usage:    In the job status field, this indicates that the job has not been started. This should be the initial state of a newly created job.  In the job slot status register, this indicates that the job slot is idle.  In the GPU and MMU exception status registers, this indicates that no exception has yet been received.  No additional error information is available (or indeed required). </spirit:description>
              <spirit:value>0x00</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>DONE</spirit:name>
              <spirit:description> The job completed successfully. The fault value is written to the job descriptor.
			The job descriptors fault address field contains the TIMESTAMP value when the job completed.
			If a job is terminated early using the  EUREKA instruction, then that job will be marked with the EUREKA exception status but the job chain status as a whole will still be DONE.</spirit:description>
              <spirit:value>0x01</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>SUSPENDED</spirit:name>
              <spirit:description> The job was interrupted by a SUSPEND command. The fault value is written both to the job slot  STATUS register and the job descriptor.
			The job descriptor contains the partition index of the first task to be interrupted. The fault address field contains the TIMESTAMP value when the job was interrupted.</spirit:description>
              <spirit:value>0x02</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>STOPPED</spirit:name>
              <spirit:description> The job was interrupted by a SOFT_STOP command. The fault value is written both to the job slot  STATUS register and the job descriptor.
			The job descriptor contains the partition index of the first task that was not completed. This will be the index of the first task issued if the job is resumed. The fault address is UNDEFINED .</spirit:description>
              <spirit:value>0x03</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TERMINATED</spirit:name>
              <spirit:description> The job was interrupted by a HARD_STOP command or a  KABOOM instruction from another job. The fault value is written both to the job slot STATUS register and the job descriptor.
			This status is treated in the same way as an error condition. The job descriptor contains the partition index of the first task to be terminated. The fault address field contains the TIMESTAMP value when the job was interrupted.</spirit:description>
              <spirit:value>0x04</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>KABOOM</spirit:name>
              <spirit:description> The job was interrupted by a shader executing a  KABOOM instruction. The fault value is written both to the job slot STATUS register and the job descriptor.
			This status is treated in the same way as an error condition. The job descriptor contains the partition index of the first task to be terminated. The fault address field contains the TIMESTAMP value when the job was interrupted.</spirit:description>
              <spirit:value>0x05</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>EUREKA</spirit:name>
              <spirit:description> The job was interrupted by a shader executing a  EUREKA instruction. The fault value is written only to the job descriptor, and does not affect subsequent jobs in the job chain.
			The job descriptor contains the partition index of the first task to be terminated. The fault address field contains the TIMESTAMP value when the job was interrupted.</spirit:description>
              <spirit:value>0x06</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ACTIVE</spirit:name>
              <spirit:description> In the JSn_STATUS register, this indicates that the job slot is active.
			The JSn_HEAD and JSn_TAIL registers contain the range of job descriptors currently in progress. </spirit:description>
              <spirit:value>0x08</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>JOB_CONFIG_FAULT</spirit:name>
              <spirit:description>   The job configuration specified in the job slot registers is invalid, so it is not possible to read job descriptors.
				For example this includes setting a NULL job descriptor pointer, selecting an address space that isnt present.
				No additional information is available. </spirit:description>
              <spirit:value>0x40</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>JOB_POWER_FAULT</spirit:name>
              <spirit:description>   The job could not be executed because the part of the memory system required to access job descriptors was not powered on.
				No additional information is available. </spirit:description>
              <spirit:value>0x41</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>JOB_READ_FAULT</spirit:name>
              <spirit:description>   Reading a job descriptor into the Job manager failed.
				The JSn_HEAD register contains the virtual address of the job descriptor that could not be read. </spirit:description>
              <spirit:value>0x42</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>JOB_WRITE_FAULT</spirit:name>
              <spirit:description>   Writing a job descriptor from the Job manager failed.
				The JSn_TAIL register contains the virtual address of the job descriptor that could not be written. </spirit:description>
              <spirit:value>0x43</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>JOB_AFFINITY_FAULT</spirit:name>
              <spirit:description>   The job could not be executed because the specified affinity mask does not intersect any available cores.
				No additional information is available. </spirit:description>
              <spirit:value>0x44</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>JOB_BUS_FAULT</spirit:name>
              <spirit:description>   A bus access failed while executing a job.
				The job descriptor contains the virtual address of the failing access, the type of access, and which part of the GPU initiated the access.
				This error code may also be reported if a bus fault occurs while writing the performance counters to memory. In this case, the GPU_FAULT* registers are updated, but the active JASID is not reported. It is possible to distinguish this case from a genuine Job Bus Fault exception by examining the SOURCE_ID field. </spirit:description>
              <spirit:value>0x48</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>INSTR_INVALID_PC</spirit:name>
              <spirit:description>   A shader instruction with an illegal program counter was executed.
				The job descriptors fault address field contains the offending program counter value. </spirit:description>
              <spirit:value>0x50</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>INSTR_INVALID_ENC</spirit:name>
              <spirit:description>   A shader instruction with an illegal encoding was executed.
				The job descriptors fault address field contains the program counter used to reach the offending instruction. </spirit:description>
              <spirit:value>0x51</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>INSTR_BARRIER_FAULT</spirit:name>
              <spirit:description>   A shader instruction was executed that failed to complete an instruction barrier.
				The job descriptors fault address field contains the program counter used to reach the offending instruction. </spirit:description>
              <spirit:value>0x55</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>DATA_INVALID_FAULT</spirit:name>
              <spirit:description>   Any data structure read as part of the job contains invalid combinations of data.
				The job descriptors fault address field contains the virtual address of the invalid data structure. </spirit:description>
              <spirit:value>0x58</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TILE_RANGE_FAULT</spirit:name>
              <spirit:description>   Tile or fragment shading was asked to process a tile that is entirely outside the bounding box of the frame.
				The job descriptors fault address field contains the coordinates of the top left corner of the failing tile, with X in the bits [15:0], and Y in the bits [31:16].  Clarified description of TILE_RANGE_FAULT. </spirit:description>
              <spirit:value>0x59</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ADDR_RANGE_FAULT</spirit:name>
              <spirit:description>   A virtual address has been found that exceeds the virtual address range.
				The job descriptors fault address field contains the virtual address which is out of range. </spirit:description>
              <spirit:value>0x5A</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>IMPRECISE_FAULT</spirit:name>
              <spirit:description>   A fault has been generated without precise fault information.
				This can happen if appropriate source information is not available at the point where the fault happens.
				The job descriptors fault address field may contain a virtual address related to the fault. </spirit:description>
              <spirit:value>0x5B</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>OUT_OF_MEMORY</spirit:name>
              <spirit:description>   The tiler ran out of memory when executing a job.
				The job descriptors fault address field contains the index of the last completed vertex sent through the tiler. </spirit:description>
              <spirit:value>0x60</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>UNKNOWN</spirit:name>
              <spirit:description>   If multiple jobs in a job chain fail, only the first one the reports an error will set and return full error information. Subsequent failing jobs will not update the error status registers, and may write an error status of UNKNOWN.
				Note that the first job to fail may not be the first job in the chain, which may lead to jobs with  UNKNOWN error status being encountered first when traversing the job chain.
				For example, you may see: Done, Done, Unknown, Bus Error, Unknown, New. In this case, the first two jobs ran successfully, the fourth job hit a bus error, and then jobs three and five also failed. The sixth and subsequent jobs had not been started at that point.</spirit:description>
              <spirit:value>0x7F</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>DELAYED_BUS_FAULT</spirit:name>
              <spirit:description>   The GPU received a bus fault for access to physical memory where the original virtual address is no longer available. This is the result of evicting a dirty line from a cache.
				This may also be triggered by a bus fault during a Tiler cache flush operation. In this case, the address reported in  GPU_FAULTADDRESS is a virtual address.</spirit:description>
              <spirit:value>0x80</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>GPU_SHAREABILITY_FAULT</spirit:name>
              <spirit:description>   A cache has detected that the same line has been accessed as both shareable and non-shareable memory from inside the GPU. Coherency after this point can no longer be guaranteed. </spirit:description>
              <spirit:value>0x88</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>SYSTEM_SHAREABILITY_FAULT</spirit:name>
              <spirit:description>   A cache has detected that the same line has been accessed as both shareable and non-shareable memory from outside the GPU. Coherency after this point can no longer be guaranteed. </spirit:description>
              <spirit:value>0x89</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>GPU_CACHEABILITY_FAULT</spirit:name>
              <spirit:description>   A cache has detected that the same line has been accessed as both cacheable and non-cacheable memory from inside the GPU. Non-cacheable memory may have been cached. </spirit:description>
              <spirit:value>0x8A</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TRANSLATION_FAULT_0</spirit:name>
              <spirit:description>   A memory access hit an invalid table entry at level 0 of the translation table. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xC0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TRANSLATION_FAULT_1</spirit:name>
              <spirit:description>   A memory access hit an invalid table entry at level 1 of the translation table. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xC1</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TRANSLATION_FAULT_2</spirit:name>
              <spirit:description>   A memory access hit an invalid table entry at level 2 of the translation table. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xC2</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TRANSLATION_FAULT_3</spirit:name>
              <spirit:description>   A memory access hit an invalid table entry at level 3 of the translation table. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xC3</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TRANSLATION_FAULT_IDENTITY</spirit:name>
              <spirit:description>   In IDENTITY translation mode, the virtual address exceeds the maximum physical address. </spirit:description>
              <spirit:value>0xC7</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>PERMISSION_FAULT_0</spirit:name>
              <spirit:description>   A memory access could not be allowed due to the permission flags set in level 0 of the translation table. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set. Added MMU translation level information to permission fault. </spirit:description>
              <spirit:value>0xC8</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>PERMISSION_FAULT_1</spirit:name>
              <spirit:description>   A memory access could not be allowed due to the permission flags set in level 1 of the translation table. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xC9</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>PERMISSION_FAULT_2</spirit:name>
              <spirit:description>   A memory access could not be allowed due to the permission flags set in level 2 of the translation table. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xCA</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>PERMISSION_FAULT_3</spirit:name>
              <spirit:description>   A memory access could not be allowed due to the permission flags set in level 3 of the translation table. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xCB</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TRANSTAB_BUS_FAULT_0</spirit:name>
              <spirit:description>   A bus fault occurred while reading level 0 of the translation tables. The appropriate  BUS_ERROR flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xD0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TRANSTAB_BUS_FAULT_1</spirit:name>
              <spirit:description>   A bus fault occurred while reading level 1 of the translation tables. The appropriate  BUS_ERROR flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xD1</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TRANSTAB_BUS_FAULT_2</spirit:name>
              <spirit:description>   A bus fault occurred while reading level 2 of the translation tables. The appropriate  BUS_ERROR flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xD2</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TRANSTAB_BUS_FAULT_3</spirit:name>
              <spirit:description>   A bus fault occurred while reading level 3 of the translation tables. The appropriate  BUS_ERROR flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xD3</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ACCESS_FLAG_0</spirit:name>
              <spirit:description>   A memory access hit a translation table entry with the ACCESS_FLAG bit set in level 0 of the translation table. This is not treated as a fault by the accessor. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set. Added MMU translation level information to access flag fault. </spirit:description>
              <spirit:value>0xD8</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ACCESS_FLAG_1</spirit:name>
              <spirit:description>   A memory access hit a translation table entry with the ACCESS_FLAG bit set in level 1 of the translation table. This is not treated as a fault by the accessor. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xD9</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ACCESS_FLAG_2</spirit:name>
              <spirit:description>   A memory access hit a translation table entry with the ACCESS_FLAG bit set in level 2 of the translation table. This is not treated as a fault by the accessor. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xDA</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ACCESS_FLAG_3</spirit:name>
              <spirit:description>   A memory access hit a translation table entry with the ACCESS_FLAG bit set in level 3 of the translation table. This is not treated as a fault by the accessor. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xDB</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ADDRESS_SIZE_FAULT_IN0</spirit:name>
              <spirit:description>   An input address size fault occurred while reading level 0 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ADDRESS_SIZE_FAULT_IN1</spirit:name>
              <spirit:description>   An input address size fault occurred while reading level 1 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE1</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ADDRESS_SIZE_FAULT_IN2</spirit:name>
              <spirit:description>   An input address size fault occurred while reading level 2 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE2</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ADDRESS_SIZE_FAULT_IN3</spirit:name>
              <spirit:description>   An input address size fault occurred while reading level 3 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE3</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ADDRESS_SIZE_FAULT_OUT0</spirit:name>
              <spirit:description>   An output address size fault occurred while reading level 0 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE4</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ADDRESS_SIZE_FAULT_OUT1</spirit:name>
              <spirit:description>   An output address size fault occurred while reading level 1 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE5</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ADDRESS_SIZE_FAULT_OUT2</spirit:name>
              <spirit:description>   An output address size fault occurred while reading level 2 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE6</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ADDRESS_SIZE_FAULT_OUT3</spirit:name>
              <spirit:description>   An output address size fault occurred while reading level 3 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE7</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>MEMORY_ATTRIBUTE_FAULT_0</spirit:name>
              <spirit:description>   A memory access could not be allowed due to an attempt to access a page with its memory attribute set to  FAULT in the MEMATTR register. This fault happened when reading level 0 of the translation tables. The appropriate PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE8</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>MEMORY_ATTRIBUTE_FAULT_1</spirit:name>
              <spirit:description>   A memory access could not be allowed due to an attempt to access a page with its memory attribute set to  FAULT in the MEMATTR register. This fault happened when reading level 1 of the translation tables. The appropriate PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE9</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>MEMORY_ATTRIBUTE_FAULT_2</spirit:name>
              <spirit:description>   A memory access could not be allowed due to an attempt to access a page with its memory attribute set to  FAULT in the MEMATTR register. This fault happened when reading level 2 of the translation tables. The appropriate PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xEA</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>MEMORY_ATTRIBUTE_FAULT_3</spirit:name>
              <spirit:description>   A memory access could not be allowed due to an attempt to access a page with its memory attribute set to  FAULT in the MEMATTR register. This fault happened when reading level 3 of the translation tables. The appropriate PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xEB</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>MEMORY_ATTRIBUTE_NONCACHEABLE_0</spirit:name>
              <spirit:description>   A memory access could not be allowed due to an attempt to access a non-cacheable page from a bus master which does not support non-cacheable accessess. This fault happened when reading level 0 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xEC</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>MEMORY_ATTRIBUTE_NONCACHEABLE_1</spirit:name>
              <spirit:description>   A memory access could not be allowed due to an attempt to access a non-cacheable page from a bus master which does not support non-cacheable accessess. This fault happened when reading level 1 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xED</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>MEMORY_ATTRIBUTE_NONCACHEABLE_2</spirit:name>
              <spirit:description>   A memory access could not be allowed due to an attempt to access a non-cacheable page from a bus master which does not support non-cacheable accessess. This fault happened when reading level 2 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xEE</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>MEMORY_ATTRIBUTE_NONCACHEABLE_3</spirit:name>
              <spirit:description>   A memory access could not be allowed due to an attempt to access a non-cacheable page from a bus master which does not support non-cacheable accessess. This fault happened when reading level 3 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xEF</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ACCESS_TYPE</spirit:name>
          <spirit:displayName>ACCESS_TYPE</spirit:displayName>
          <spirit:description>   This field contains the direction of data transfer that caused the fault, if known.  For the purposes of error reporting, atomic transactions act like a read followed by a write, so denying either permission will result in the atomic transaction failing, and the exceptions ACCESS_TYPE field will be set to "atomic". </spirit:description>
          <spirit:bitOffset>8</spirit:bitOffset>
          <spirit:bitWidth>2</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>atomic</spirit:name>
              <spirit:description> An atomic (read/write) transaction. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>execute</spirit:name>
              <spirit:description> An execute transaction. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>read</spirit:name>
              <spirit:description> A read transaction. </spirit:description>
              <spirit:value>2</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>write</spirit:name>
              <spirit:description> A write transaction. </spirit:description>
              <spirit:value>3</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS5_FAULTADDRESS_LO</spirit:name>
        <spirit:displayName>ST1MMUAS5_FAULTADDRESS_LO</spirit:displayName>
        <spirit:description>   This register contains information about the cause of a page fault or bus error. </spirit:description>
        <spirit:addressOffset>0x20</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>ST1MMUAS5FAULTADDRESS_LO</spirit:name>
          <spirit:displayName>ST1MMUAS5FAULTADDRESS_LO</spirit:displayName>
          <spirit:description>   This field contains the virtual address (in this address space) of the access that caused the fault.  Additional information about the fault is also available in the FAULTSTATUS register.  If multiple faults occur before the first is handled, the subsequent faults are ignored. They may fault again after handling the first one. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS5_FAULTADDRESS_HI</spirit:name>
        <spirit:displayName>ST1MMUAS5_FAULTADDRESS_HI</spirit:displayName>
        <spirit:description>   This register contains information about the cause of a page fault or bus error. </spirit:description>
        <spirit:addressOffset>0x24</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>ST1MMUAS5FAULTADDRESS_HI</spirit:name>
          <spirit:displayName>ST1MMUAS5FAULTADDRESS_HI</spirit:displayName>
          <spirit:description>   This field contains the virtual address (in this address space) of the access that caused the fault.  Additional information about the fault is also available in the FAULTSTATUS register.  If multiple faults occur before the first is handled, the subsequent faults are ignored. They may fault again after handling the first one. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS5_STATUS</spirit:name>
        <spirit:displayName>ST1MMUAS5_STATUS</spirit:displayName>
        <spirit:description>   This register contains dynamic status information about this address space. </spirit:description>
        <spirit:addressOffset>0x28</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>Res166</spirit:name>
          <spirit:displayName>Res166</spirit:displayName>
          <spirit:description>Res166</spirit:description>
          <spirit:bitOffset>1</spirit:bitOffset>
          <spirit:bitWidth>31</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>AS_ACTIVE</spirit:name>
          <spirit:displayName>AS_ACTIVE</spirit:displayName>
          <spirit:description>   This flag is set while a MMU_UPDATE, LOCK, UNLOCK, FLUSH_PT or FLUSH_MEM command is active on this address space. This allows software to safely verify that the address space is in a consistent state after reconfiguring the MMU page tables.  If a new command is written to the corresponding COMMAND register while the AS_ACTIVE bit is set, then the command is ignored. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> Address space command register is inactive. A new command may be written to the COMMAND register. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Address space command register is active. Any new command written to the COMMAND register will be ignored. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS5_TRANSCFG_LO</spirit:name>
        <spirit:displayName>ST1MMUAS5_TRANSCFG_LO</spirit:displayName>
        <spirit:description>ST1MMUAS5_TRANSCFG_LO</spirit:description>
        <spirit:addressOffset>0x30</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>Res167</spirit:name>
          <spirit:displayName>Res167</spirit:displayName>
          <spirit:description>Res167</spirit:description>
          <spirit:bitOffset>4</spirit:bitOffset>
          <spirit:bitWidth>2</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>Res168</spirit:name>
          <spirit:displayName>Res168</spirit:displayName>
          <spirit:description>Res168</spirit:description>
          <spirit:bitOffset>11</spirit:bitOffset>
          <spirit:bitWidth>3</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>Res169</spirit:name>
          <spirit:displayName>Res169</spirit:displayName>
          <spirit:description>Res169</spirit:description>
          <spirit:bitOffset>19</spirit:bitOffset>
          <spirit:bitWidth>3</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>Res170</spirit:name>
          <spirit:displayName>Res170</spirit:displayName>
          <spirit:description>Res170</spirit:description>
          <spirit:bitOffset>23</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>Res171</spirit:name>
          <spirit:displayName>Res171</spirit:displayName>
          <spirit:description>Res171</spirit:description>
          <spirit:bitOffset>26</spirit:bitOffset>
          <spirit:bitWidth>2</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>Res172</spirit:name>
          <spirit:displayName>Res172</spirit:displayName>
          <spirit:description>Res172</spirit:description>
          <spirit:bitOffset>31</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>INA_BITS</spirit:name>
          <spirit:displayName>INA_BITS</spirit:displayName>
          <spirit:description>   This field allows the system software to restrict the range of input addresses accepted by this translation stage. This is used in conjunction with the hardware limits to determine the valid address range as follows:  INA_BITS_VALID = min(HW_INA_BITS, 55-INA_BITS)  If the input address is outside the range (0, 2  INA_BITS_VALID -1), then a TRANSLATION_FAULT error is generated.</spirit:description>
          <spirit:bitOffset>6</spirit:bitOffset>
          <spirit:bitWidth>5</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>OUTA_BITS</spirit:name>
          <spirit:displayName>OUTA_BITS</spirit:displayName>
          <spirit:description>   This field allows the system software to restrict the range of output addresses generated by this translation stage. This is used in conjunction with the hardware limits to determine the valid address range as follows:  OUTA_BITS_VALID = min(HW_OUTA_BITS, 55-OUTA_BITS)  If the translated output address is outside the range (0, 2  OUTA_BITS_VALID -1), then a TRANSLATION_FAULT error is generated.</spirit:description>
          <spirit:bitOffset>14</spirit:bitOffset>
          <spirit:bitWidth>5</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>MODE</spirit:name>
          <spirit:displayName>MODE</spirit:displayName>
          <spirit:description>   This field controls the overall operation of the MMU. There are some differences between stage 1 and stage 2.  Execute permissions for a page are evaluated as follows (PTE.&amp;lt;W|R|X&gt; refers to page table entry permissions resolved for hierarchical permissions (if applicable):  EXECUTE_ALLOWED = !((TRANSCFG.WXN &amp;amp; !PTE.W) | (TRANSCFG.XREADABLE &amp;amp; !PTE.R) | (!TRANSCFG.XREADABLE &amp;amp; !PTE.X)) </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>LEGACY</spirit:name>
              <spirit:description>   The contents of TRANSTAB and MEMATTR are interpreted according to the legacy behaviour, as used in previous Midgard GPUs. The rest of the TRANSCFG bits are ignored.  Input and output address sizes are set according to the hardware configuration.  Stage 1 will follow the legacy behaviour.  Stage 2 will be transparent, will ignore TRANSTAB settings and will not generate any faults.  Note: as the reset value of TRANSCFG is 0, this is a mechanism to ensure backwards-compatibility and alignment between the stages. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>UNMAPPED</spirit:name>
              <spirit:description> The MMU forces all memory access to fail with a decode fault. No actual page table is required. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>IDENTITY</spirit:name>
              <spirit:description>   The MMU behaves as if using an address translation table with all entries valid and giving an identity mapping (output address is the same as the input address) with full read/write/execute access. Addresses outside the configured address ranges cause page faults.  For Stage 1, cacheability and shareability are defined by MEMATTR0. For Stage 2, cacheablity and sharebility are defined so that they dont change whats set by Stage 1 (non-shareable and inner/outer write-back cacheable and master-defined allocation). </spirit:description>
              <spirit:value>2</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>AARCH64_4K</spirit:name>
              <spirit:description> Page tables are interpreted according to the AArch64 4kB granule specification. </spirit:description>
              <spirit:value>6</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>AARCH64_64K</spirit:name>
              <spirit:description> Page tables are interpreted according to the AArch64 64kB granule specification. </spirit:description>
              <spirit:value>8</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>PTW_MEMATTR</spirit:name>
          <spirit:displayName>PTW_MEMATTR</spirit:displayName>
          <spirit:description>   Memory attributes for page table walks. The allowed values are compatible with the values allowed for  MEMORY_TYPE . For outer cache transactions, the desired attributes for the transaction will be decided by the bus master and communicated to the memory system using signals on the bus.  Changed allowed values for TRANSCFG.PTW_MEMATTR. </spirit:description>
          <spirit:bitOffset>24</spirit:bitOffset>
          <spirit:bitWidth>2</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NON_CACHEABLE</spirit:name>
              <spirit:description> Normal memory, inner non-cacheable, outer non-cacheable. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>WRITE_BACK</spirit:name>
              <spirit:description> Normal memory, inner write-back cacheable, outer write-back cacheable. </spirit:description>
              <spirit:value>2</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>PTW_SH</spirit:name>
          <spirit:displayName>PTW_SH</spirit:displayName>
          <spirit:description>   This field specifies the shareability for the page table walks. This is the same encoding as used for ARMv8 page tables. </spirit:description>
          <spirit:bitOffset>28</spirit:bitOffset>
          <spirit:bitWidth>2</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>non_shareable</spirit:name>
              <spirit:description> The memory region is non-shareable, and coherency with other observers will not automatically be maintained. Software will have to ensure that caches are flushed or invalidated at appropriate times. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>outer_shareable</spirit:name>
              <spirit:description> The memory region is marked as outer shareable. Each outer shareability domain contains a set of observers that are data coherent for each member of that set for	data accesses with the outer shareable attribute made by any member of that set. </spirit:description>
              <spirit:value>2</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>inner_shareable</spirit:name>
              <spirit:description> The memory region is marked as inner shareable. Each inner shareability domain contains a set of observers that are data coherent for each member of that set for	data accesses with the inner shareable attribute made by any member of that set. All observers in an inner shareability domain are always members of the same outer shareability domain. This means that an inner shareability domain is a subset of an Outer Shareability domain, although it is not required to be a proper subset. </spirit:description>
              <spirit:value>3</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>R_ALLOCATE</spirit:name>
          <spirit:displayName>R_ALLOCATE</spirit:displayName>
          <spirit:description>   This field sets the inner read allocation hint for the page table walks. This is the same encoding as used for ARMv8 page tables. </spirit:description>
          <spirit:bitOffset>30</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>no_read_allocate</spirit:name>
              <spirit:description> Hints that the cache should not allocate space when reading a page table entry. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>read_allocate</spirit:name>
              <spirit:description> Hints that the cache should allocate space when reading a page table entry. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>SL_CONCAT_EN</spirit:name>
          <spirit:displayName>SL_CONCAT_EN</spirit:displayName>
          <spirit:description>   If set then the page table walk starting level will be increased if possible by concatenating up to 16 tables in the starting level. </spirit:description>
          <spirit:bitOffset>22</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> Page table concatenation is disabled. 	This mode must be used for Stage 1 if sharing page tables with the CPU, otherwise  UNDEFINED behavior results.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Page table concatenation is enabled. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS5_TRANSCFG_HI</spirit:name>
        <spirit:displayName>ST1MMUAS5_TRANSCFG_HI</spirit:displayName>
        <spirit:description>ST1MMUAS5_TRANSCFG_HI</spirit:description>
        <spirit:addressOffset>0x34</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>Res173</spirit:name>
          <spirit:displayName>Res173</spirit:displayName>
          <spirit:description>Res173</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>Res174</spirit:name>
          <spirit:displayName>Res174</spirit:displayName>
          <spirit:description>Res174</spirit:description>
          <spirit:bitOffset>5</spirit:bitOffset>
          <spirit:bitWidth>27</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>DISABLE_HIER_AP</spirit:name>
          <spirit:displayName>DISABLE_HIER_AP</spirit:displayName>
          <spirit:description>   This flag only has an effect on stage 1 of translation. It is ignored for stage 2. Note the inverted logic - the flag must be set to  dis able hierarchical access permissions.</spirit:description>
          <spirit:bitOffset>1</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> Hierarchical access permissions are enabled. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Hierarchical access permissions are disabled. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>DISABLE_AF_FAULT</spirit:name>
          <spirit:displayName>DISABLE_AF_FAULT</spirit:displayName>
          <spirit:description>   This flag can be used to disable access fault checking when in one of AARCH64 modes. </spirit:description>
          <spirit:bitOffset>2</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> Access fault checking is enabled. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Access fault checking is disabled. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>WXN</spirit:name>
          <spirit:displayName>WXN</spirit:displayName>
          <spirit:description>   This flag can be used to disable all writes to executable pages, overriding access permissions specified in the page table. </spirit:description>
          <spirit:bitOffset>3</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> Write access permissions are read as usual from the page table. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Write access to all executable pages is disabled. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>XREADABLE</spirit:name>
          <spirit:displayName>XREADABLE</spirit:displayName>
          <spirit:description>   This flag can be used to enable execution on all readable pages, overriding access permissions specified in the page table. </spirit:description>
          <spirit:bitOffset>4</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> Execute access permissions are read as usual from the page table. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Execute access to all readable pages is enabled. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS5_FAULTEXTRA_LO</spirit:name>
        <spirit:displayName>ST1MMUAS5_FAULTEXTRA_LO</spirit:displayName>
        <spirit:description>   This register contains additional information about the cause of a page fault or bus error. </spirit:description>
        <spirit:addressOffset>0x38</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>ST1MMUAS5FAULTEXTRA_LO</spirit:name>
          <spirit:displayName>ST1MMUAS5FAULTEXTRA_LO</spirit:displayName>
          <spirit:description>   This field contains the virtual address (in this address space) of the access that caused the fault.  Additional information about the fault is also available in the  FAULTSTATUS and FAULTADDRESS registers. If multiple faults occur before the first is handled, the subsequent faults are ignored. They may fault again after handling the first one.  Fixed duplicate state name in FAULT_ADDRESS - exposes previously hidden field S2FS1WALK. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS5_FAULTEXTRA_HI</spirit:name>
        <spirit:displayName>ST1MMUAS5_FAULTEXTRA_HI</spirit:displayName>
        <spirit:description>   This register contains additional information about the cause of a page fault or bus error. </spirit:description>
        <spirit:addressOffset>0x3c</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>Res175</spirit:name>
          <spirit:displayName>Res175</spirit:displayName>
          <spirit:description>Res175</spirit:description>
          <spirit:bitOffset>16</spirit:bitOffset>
          <spirit:bitWidth>15</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>ST1MMUAS5FAULTEXTRA_HI</spirit:name>
          <spirit:displayName>ST1MMUAS5FAULTEXTRA_HI</spirit:displayName>
          <spirit:description>   This field contains the virtual address (in this address space) of the access that caused the fault.  Additional information about the fault is also available in the  FAULTSTATUS and FAULTADDRESS registers. If multiple faults occur before the first is handled, the subsequent faults are ignored. They may fault again after handling the first one.  Fixed duplicate state name in FAULT_ADDRESS - exposes previously hidden field S2FS1WALK. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>16</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>S2FS1WALK</spirit:name>
          <spirit:displayName>S2FS1WALK</spirit:displayName>
          <spirit:description>S2FS1WALK</spirit:description>
          <spirit:bitOffset>31</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>stage2</spirit:name>
              <spirit:description> Fault source is a stage 2 translation. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>stage1</spirit:name>
              <spirit:description> Fault source is a stage 1 page table walk. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
    </spirit:addressBlock>
    <spirit:addressBlock>
      <spirit:name>jm_mmu_as6_regs</spirit:name>
      <spirit:baseAddress>9600</spirit:baseAddress>
      <spirit:range>64</spirit:range>
      <spirit:width>32</spirit:width>
      <spirit:usage>register</spirit:usage>
      <spirit:register>
        <spirit:name>ST1MMUAS6_TRANSTAB_LO</spirit:name>
        <spirit:displayName>ST1MMUAS6_TRANSTAB_LO</spirit:displayName>
        <spirit:description>   This register contains the address of the base level of the translation table, together with some related flags.  Details on the layout of the page tables, and the address translation process, can be found in the section  Memory Management Unit .</spirit:description>
        <spirit:addressOffset>0x0</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>Res176</spirit:name>
          <spirit:displayName>Res176</spirit:displayName>
          <spirit:description>Res176</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>ST1MMUAS6TRANSTAB_LO</spirit:name>
          <spirit:displayName>ST1MMUAS6TRANSTAB_LO</spirit:displayName>
          <spirit:description>   This field contains the address of the top level of a page table structure. This must be 16-byte-aligned, so address bits [3:0] are assumed to be zero.  For a stage 1 page table, this will be an intermediate physical address, and for stage 2 it will be a physical address. The number of actual translated address bits is stored in  OUTA_BITS . The unused high bits must be set to 0. Changed alignment text for TRANSTAB.BASE  TRANSTAB.BASE pointer is a physical (or intermediate) address </spirit:description>
          <spirit:bitOffset>4</spirit:bitOffset>
          <spirit:bitWidth>28</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS6_TRANSTAB_HI</spirit:name>
        <spirit:displayName>ST1MMUAS6_TRANSTAB_HI</spirit:displayName>
        <spirit:description>   This register contains the address of the base level of the translation table, together with some related flags.  Details on the layout of the page tables, and the address translation process, can be found in the section  Memory Management Unit .</spirit:description>
        <spirit:addressOffset>0x4</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>ST1MMUAS6TRANSTAB_HI</spirit:name>
          <spirit:displayName>ST1MMUAS6TRANSTAB_HI</spirit:displayName>
          <spirit:description>   This field contains the address of the top level of a page table structure. This must be 16-byte-aligned, so address bits [3:0] are assumed to be zero.  For a stage 1 page table, this will be an intermediate physical address, and for stage 2 it will be a physical address. The number of actual translated address bits is stored in  OUTA_BITS . The unused high bits must be set to 0. Changed alignment text for TRANSTAB.BASE  TRANSTAB.BASE pointer is a physical (or intermediate) address </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS6_MEMATTR_LO</spirit:name>
        <spirit:displayName>ST1MMUAS6_MEMATTR_LO</spirit:displayName>
        <spirit:description>  </spirit:description>
        <spirit:addressOffset>0x8</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>ATTRIBUTE0</spirit:name>
          <spirit:displayName>ATTRIBUTE0</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 0. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE1</spirit:name>
          <spirit:displayName>ATTRIBUTE1</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 1. </spirit:description>
          <spirit:bitOffset>4</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE2</spirit:name>
          <spirit:displayName>ATTRIBUTE2</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 2. </spirit:description>
          <spirit:bitOffset>8</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE3</spirit:name>
          <spirit:displayName>ATTRIBUTE3</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 3. </spirit:description>
          <spirit:bitOffset>12</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE4</spirit:name>
          <spirit:displayName>ATTRIBUTE4</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 4. </spirit:description>
          <spirit:bitOffset>16</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE5</spirit:name>
          <spirit:displayName>ATTRIBUTE5</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 5. </spirit:description>
          <spirit:bitOffset>20</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE6</spirit:name>
          <spirit:displayName>ATTRIBUTE6</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 6. </spirit:description>
          <spirit:bitOffset>24</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE7</spirit:name>
          <spirit:displayName>ATTRIBUTE7</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 7. </spirit:description>
          <spirit:bitOffset>28</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS6_MEMATTR_HI</spirit:name>
        <spirit:displayName>ST1MMUAS6_MEMATTR_HI</spirit:displayName>
        <spirit:description>  </spirit:description>
        <spirit:addressOffset>0xc</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>ATTRIBUTE8</spirit:name>
          <spirit:displayName>ATTRIBUTE8</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 8. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE9</spirit:name>
          <spirit:displayName>ATTRIBUTE9</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 9. </spirit:description>
          <spirit:bitOffset>4</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE10</spirit:name>
          <spirit:displayName>ATTRIBUTE10</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 10. </spirit:description>
          <spirit:bitOffset>8</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE11</spirit:name>
          <spirit:displayName>ATTRIBUTE11</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 11. </spirit:description>
          <spirit:bitOffset>12</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE12</spirit:name>
          <spirit:displayName>ATTRIBUTE12</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 12. </spirit:description>
          <spirit:bitOffset>16</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE13</spirit:name>
          <spirit:displayName>ATTRIBUTE13</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 13. </spirit:description>
          <spirit:bitOffset>20</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE14</spirit:name>
          <spirit:displayName>ATTRIBUTE14</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 14. </spirit:description>
          <spirit:bitOffset>24</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE15</spirit:name>
          <spirit:displayName>ATTRIBUTE15</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 15. </spirit:description>
          <spirit:bitOffset>28</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS6_LOCKADDR_LO</spirit:name>
        <spirit:displayName>ST1MMUAS6_LOCKADDR_LO</spirit:displayName>
        <spirit:description>   This register tells the MMU to lock a region of virtual memory. All page mappings within this region must be flushed, and no translation requests within this region can complete or fault before the area is unlocked.  Only one region can be locked at a time.  As only 32 bits of the register can be written to at a time, no changes are issued until the LOCK command is written to the COMMAND register. </spirit:description>
        <spirit:addressOffset>0x10</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>Res177</spirit:name>
          <spirit:displayName>Res177</spirit:displayName>
          <spirit:description>Res177</spirit:description>
          <spirit:bitOffset>6</spirit:bitOffset>
          <spirit:bitWidth>6</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>LOCKADDR_SIZE</spirit:name>
          <spirit:displayName>LOCKADDR_SIZE</spirit:displayName>
          <spirit:description>   This field contains the log  2 of the size of the region to lock, minus 1. Only values in the range 11 to 63 are valid values for this field, corresponding to region sizes of 4KB up to the entire address space. Values in the range 0 to 10 result in UNDEFINED behavior and should not be used.</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>6</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>ST1MMUAS6LOCKADDR_LO</spirit:name>
          <spirit:displayName>ST1MMUAS6LOCKADDR_LO</spirit:displayName>
          <spirit:description>   This field contains the lowest address in the region to be locked. The address is a virtual address in this address space.  Only the upper bits of the address are used. The address is aligned to a multiple of the region size, so a variable number of low-order bits are ignored, depending on the selected region size. It is recommended that software ensures that these low bits in the address are cleared, to avoid confusion. </spirit:description>
          <spirit:bitOffset>12</spirit:bitOffset>
          <spirit:bitWidth>20</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS6_LOCKADDR_HI</spirit:name>
        <spirit:displayName>ST1MMUAS6_LOCKADDR_HI</spirit:displayName>
        <spirit:description>   This register tells the MMU to lock a region of virtual memory. All page mappings within this region must be flushed, and no translation requests within this region can complete or fault before the area is unlocked.  Only one region can be locked at a time.  As only 32 bits of the register can be written to at a time, no changes are issued until the LOCK command is written to the COMMAND register. </spirit:description>
        <spirit:addressOffset>0x14</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>ST1MMUAS6LOCKADDR_HI</spirit:name>
          <spirit:displayName>ST1MMUAS6LOCKADDR_HI</spirit:displayName>
          <spirit:description>   This field contains the lowest address in the region to be locked. The address is a virtual address in this address space.  Only the upper bits of the address are used. The address is aligned to a multiple of the region size, so a variable number of low-order bits are ignored, depending on the selected region size. It is recommended that software ensures that these low bits in the address are cleared, to avoid confusion. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS6_COMMAND</spirit:name>
        <spirit:displayName>ST1MMUAS6_COMMAND</spirit:displayName>
        <spirit:description>   MMU commands are issued by writing to this register. Any command written to an address space while the corresponding STATUS.AS_ACTIVE flag is set will be ignored.  In general an MMU command only applies to the address space it is submitted to. However a command that invalidates the MMU cache may invalidate the whole MMU cache rather than only those entries specific to one address space. </spirit:description>
        <spirit:addressOffset>0x18</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>ST1MMUAS6COMMAND</spirit:name>
          <spirit:displayName>ST1MMUAS6COMMAND</spirit:displayName>
          <spirit:description>ST1MMUAS6COMMAND</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>write-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NOP</spirit:name>
              <spirit:description> No operation, nothing happens. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>UPDATE</spirit:name>
              <spirit:description> Broadcasts the values in TRANSTAB and MEMATTR to all MMUs. MMU caches are invalidated. Use this after changing the content of these registers. This will  not clear the effect of a LOCK set in the updated address space.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>LOCK</spirit:name>
              <spirit:description> Issues a lock region command to all MMUs, using the address and size set in the LOCKADDR register. MMU caches are invalidated. Use this before changing an in-memory page table. Any existing lock on this address space is cleared. Locks on other address spaces are not affected. Use a FLUSH or UNLOCK command to unlock a memory region. </spirit:description>
              <spirit:value>2</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>UNLOCK</spirit:name>
              <spirit:description> Issues an unlock region command to all MMUs, using the address and size set in the LOCKADDR register. Any existing lock on this address space is cleared. If no lock was present, the MMU caches are invalidated. Use this when finished changing an in-memory page table, except if the page table can be cached in the L2 cache, in which case, a FLUSH_MEM command must be issued instead. </spirit:description>
              <spirit:value>3</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FLUSH_PT</spirit:name>
              <spirit:description> First cleans and invalidates all L2 caches to force cached page tables to be invalidated, then performs an UNLOCK command. </spirit:description>
              <spirit:value>4</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FLUSH_MEM</spirit:name>
              <spirit:description> First waits until all memory accesses to a region locked by a preceding LOCK command have completed and have reached the nearest cache.
			This will ensure that all reads to a locked memory region have finished, and that any writes to a locked region have either been written out to memory or are present in the L1 or L2 cache as dirty data.
			Then cleans and invalidates the L1 cache in all shader cores, forcing dirty data for locked regions to be pushed out to the L2 cache.
			Then cleans and invalidates all L2 caches forcing all dirty data for locked regions to be written back to memory and page tables to be invalidated.
			Then performs an UNLOCK command on this address space.
			Use this when finished changing or removing entries in an in-memory page table. </spirit:description>
              <spirit:value>5</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS6_FAULTSTATUS</spirit:name>
        <spirit:displayName>ST1MMUAS6_FAULTSTATUS</spirit:displayName>
        <spirit:description>   This register contains extended status information after a fault. If read before a fault occurs, its contents are the reset value, 0, which indicates no fault.
						If multiple faults occur before the first is handled, the subsequent faults are ignored. They may fault again after handling the first one.  If the GPU is in protected mode, this register is not updated, and MMU faults are ignored. 
						They are not fatal but will halt the GPU until the MMU address space is updated. 
						However, no fault information wil be visible in this case.  Changed access type of MMU_FAULTSTATUS register when in protected mode. </spirit:description>
        <spirit:addressOffset>0x1c</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>Res178</spirit:name>
          <spirit:displayName>Res178</spirit:displayName>
          <spirit:description>Res178</spirit:description>
          <spirit:bitOffset>10</spirit:bitOffset>
          <spirit:bitWidth>6</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>SOURCE_ID</spirit:name>
          <spirit:displayName>SOURCE_ID</spirit:displayName>
          <spirit:description>   This field contains an implementation-defined ID that supplies additional data about the source of the fault. For example, it may be the ID of the internal bus master that issued the request that faulted. This makes it possible to distinguish between the job manager, the texture unit and the load/store unit. Another example might be an indication of the type of an invalid data structure. The values in this field are implementation defined. </spirit:description>
          <spirit:bitOffset>16</spirit:bitOffset>
          <spirit:bitWidth>16</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>EXCEPTION_TYPE</spirit:name>
          <spirit:displayName>EXCEPTION_TYPE</spirit:displayName>
          <spirit:description>   This field indicates the type of exception that caused the fault. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>8</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>OK</spirit:name>
              <spirit:description>   This indicates that the GPU has completed its work and is in a state ready to receive new commands. Its precise meaning depends on its usage:    In the job status field, this indicates that the job has not been started. This should be the initial state of a newly created job.  In the job slot status register, this indicates that the job slot is idle.  In the GPU and MMU exception status registers, this indicates that no exception has yet been received.  No additional error information is available (or indeed required). </spirit:description>
              <spirit:value>0x00</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>DONE</spirit:name>
              <spirit:description> The job completed successfully. The fault value is written to the job descriptor.
			The job descriptors fault address field contains the TIMESTAMP value when the job completed.
			If a job is terminated early using the  EUREKA instruction, then that job will be marked with the EUREKA exception status but the job chain status as a whole will still be DONE.</spirit:description>
              <spirit:value>0x01</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>SUSPENDED</spirit:name>
              <spirit:description> The job was interrupted by a SUSPEND command. The fault value is written both to the job slot  STATUS register and the job descriptor.
			The job descriptor contains the partition index of the first task to be interrupted. The fault address field contains the TIMESTAMP value when the job was interrupted.</spirit:description>
              <spirit:value>0x02</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>STOPPED</spirit:name>
              <spirit:description> The job was interrupted by a SOFT_STOP command. The fault value is written both to the job slot  STATUS register and the job descriptor.
			The job descriptor contains the partition index of the first task that was not completed. This will be the index of the first task issued if the job is resumed. The fault address is UNDEFINED .</spirit:description>
              <spirit:value>0x03</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TERMINATED</spirit:name>
              <spirit:description> The job was interrupted by a HARD_STOP command or a  KABOOM instruction from another job. The fault value is written both to the job slot STATUS register and the job descriptor.
			This status is treated in the same way as an error condition. The job descriptor contains the partition index of the first task to be terminated. The fault address field contains the TIMESTAMP value when the job was interrupted.</spirit:description>
              <spirit:value>0x04</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>KABOOM</spirit:name>
              <spirit:description> The job was interrupted by a shader executing a  KABOOM instruction. The fault value is written both to the job slot STATUS register and the job descriptor.
			This status is treated in the same way as an error condition. The job descriptor contains the partition index of the first task to be terminated. The fault address field contains the TIMESTAMP value when the job was interrupted.</spirit:description>
              <spirit:value>0x05</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>EUREKA</spirit:name>
              <spirit:description> The job was interrupted by a shader executing a  EUREKA instruction. The fault value is written only to the job descriptor, and does not affect subsequent jobs in the job chain.
			The job descriptor contains the partition index of the first task to be terminated. The fault address field contains the TIMESTAMP value when the job was interrupted.</spirit:description>
              <spirit:value>0x06</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ACTIVE</spirit:name>
              <spirit:description> In the JSn_STATUS register, this indicates that the job slot is active.
			The JSn_HEAD and JSn_TAIL registers contain the range of job descriptors currently in progress. </spirit:description>
              <spirit:value>0x08</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>JOB_CONFIG_FAULT</spirit:name>
              <spirit:description>   The job configuration specified in the job slot registers is invalid, so it is not possible to read job descriptors.
				For example this includes setting a NULL job descriptor pointer, selecting an address space that isnt present.
				No additional information is available. </spirit:description>
              <spirit:value>0x40</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>JOB_POWER_FAULT</spirit:name>
              <spirit:description>   The job could not be executed because the part of the memory system required to access job descriptors was not powered on.
				No additional information is available. </spirit:description>
              <spirit:value>0x41</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>JOB_READ_FAULT</spirit:name>
              <spirit:description>   Reading a job descriptor into the Job manager failed.
				The JSn_HEAD register contains the virtual address of the job descriptor that could not be read. </spirit:description>
              <spirit:value>0x42</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>JOB_WRITE_FAULT</spirit:name>
              <spirit:description>   Writing a job descriptor from the Job manager failed.
				The JSn_TAIL register contains the virtual address of the job descriptor that could not be written. </spirit:description>
              <spirit:value>0x43</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>JOB_AFFINITY_FAULT</spirit:name>
              <spirit:description>   The job could not be executed because the specified affinity mask does not intersect any available cores.
				No additional information is available. </spirit:description>
              <spirit:value>0x44</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>JOB_BUS_FAULT</spirit:name>
              <spirit:description>   A bus access failed while executing a job.
				The job descriptor contains the virtual address of the failing access, the type of access, and which part of the GPU initiated the access.
				This error code may also be reported if a bus fault occurs while writing the performance counters to memory. In this case, the GPU_FAULT* registers are updated, but the active JASID is not reported. It is possible to distinguish this case from a genuine Job Bus Fault exception by examining the SOURCE_ID field. </spirit:description>
              <spirit:value>0x48</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>INSTR_INVALID_PC</spirit:name>
              <spirit:description>   A shader instruction with an illegal program counter was executed.
				The job descriptors fault address field contains the offending program counter value. </spirit:description>
              <spirit:value>0x50</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>INSTR_INVALID_ENC</spirit:name>
              <spirit:description>   A shader instruction with an illegal encoding was executed.
				The job descriptors fault address field contains the program counter used to reach the offending instruction. </spirit:description>
              <spirit:value>0x51</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>INSTR_BARRIER_FAULT</spirit:name>
              <spirit:description>   A shader instruction was executed that failed to complete an instruction barrier.
				The job descriptors fault address field contains the program counter used to reach the offending instruction. </spirit:description>
              <spirit:value>0x55</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>DATA_INVALID_FAULT</spirit:name>
              <spirit:description>   Any data structure read as part of the job contains invalid combinations of data.
				The job descriptors fault address field contains the virtual address of the invalid data structure. </spirit:description>
              <spirit:value>0x58</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TILE_RANGE_FAULT</spirit:name>
              <spirit:description>   Tile or fragment shading was asked to process a tile that is entirely outside the bounding box of the frame.
				The job descriptors fault address field contains the coordinates of the top left corner of the failing tile, with X in the bits [15:0], and Y in the bits [31:16].  Clarified description of TILE_RANGE_FAULT. </spirit:description>
              <spirit:value>0x59</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ADDR_RANGE_FAULT</spirit:name>
              <spirit:description>   A virtual address has been found that exceeds the virtual address range.
				The job descriptors fault address field contains the virtual address which is out of range. </spirit:description>
              <spirit:value>0x5A</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>IMPRECISE_FAULT</spirit:name>
              <spirit:description>   A fault has been generated without precise fault information.
				This can happen if appropriate source information is not available at the point where the fault happens.
				The job descriptors fault address field may contain a virtual address related to the fault. </spirit:description>
              <spirit:value>0x5B</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>OUT_OF_MEMORY</spirit:name>
              <spirit:description>   The tiler ran out of memory when executing a job.
				The job descriptors fault address field contains the index of the last completed vertex sent through the tiler. </spirit:description>
              <spirit:value>0x60</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>UNKNOWN</spirit:name>
              <spirit:description>   If multiple jobs in a job chain fail, only the first one the reports an error will set and return full error information. Subsequent failing jobs will not update the error status registers, and may write an error status of UNKNOWN.
				Note that the first job to fail may not be the first job in the chain, which may lead to jobs with  UNKNOWN error status being encountered first when traversing the job chain.
				For example, you may see: Done, Done, Unknown, Bus Error, Unknown, New. In this case, the first two jobs ran successfully, the fourth job hit a bus error, and then jobs three and five also failed. The sixth and subsequent jobs had not been started at that point.</spirit:description>
              <spirit:value>0x7F</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>DELAYED_BUS_FAULT</spirit:name>
              <spirit:description>   The GPU received a bus fault for access to physical memory where the original virtual address is no longer available. This is the result of evicting a dirty line from a cache.
				This may also be triggered by a bus fault during a Tiler cache flush operation. In this case, the address reported in  GPU_FAULTADDRESS is a virtual address.</spirit:description>
              <spirit:value>0x80</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>GPU_SHAREABILITY_FAULT</spirit:name>
              <spirit:description>   A cache has detected that the same line has been accessed as both shareable and non-shareable memory from inside the GPU. Coherency after this point can no longer be guaranteed. </spirit:description>
              <spirit:value>0x88</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>SYSTEM_SHAREABILITY_FAULT</spirit:name>
              <spirit:description>   A cache has detected that the same line has been accessed as both shareable and non-shareable memory from outside the GPU. Coherency after this point can no longer be guaranteed. </spirit:description>
              <spirit:value>0x89</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>GPU_CACHEABILITY_FAULT</spirit:name>
              <spirit:description>   A cache has detected that the same line has been accessed as both cacheable and non-cacheable memory from inside the GPU. Non-cacheable memory may have been cached. </spirit:description>
              <spirit:value>0x8A</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TRANSLATION_FAULT_0</spirit:name>
              <spirit:description>   A memory access hit an invalid table entry at level 0 of the translation table. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xC0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TRANSLATION_FAULT_1</spirit:name>
              <spirit:description>   A memory access hit an invalid table entry at level 1 of the translation table. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xC1</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TRANSLATION_FAULT_2</spirit:name>
              <spirit:description>   A memory access hit an invalid table entry at level 2 of the translation table. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xC2</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TRANSLATION_FAULT_3</spirit:name>
              <spirit:description>   A memory access hit an invalid table entry at level 3 of the translation table. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xC3</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TRANSLATION_FAULT_IDENTITY</spirit:name>
              <spirit:description>   In IDENTITY translation mode, the virtual address exceeds the maximum physical address. </spirit:description>
              <spirit:value>0xC7</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>PERMISSION_FAULT_0</spirit:name>
              <spirit:description>   A memory access could not be allowed due to the permission flags set in level 0 of the translation table. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set. Added MMU translation level information to permission fault. </spirit:description>
              <spirit:value>0xC8</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>PERMISSION_FAULT_1</spirit:name>
              <spirit:description>   A memory access could not be allowed due to the permission flags set in level 1 of the translation table. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xC9</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>PERMISSION_FAULT_2</spirit:name>
              <spirit:description>   A memory access could not be allowed due to the permission flags set in level 2 of the translation table. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xCA</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>PERMISSION_FAULT_3</spirit:name>
              <spirit:description>   A memory access could not be allowed due to the permission flags set in level 3 of the translation table. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xCB</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TRANSTAB_BUS_FAULT_0</spirit:name>
              <spirit:description>   A bus fault occurred while reading level 0 of the translation tables. The appropriate  BUS_ERROR flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xD0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TRANSTAB_BUS_FAULT_1</spirit:name>
              <spirit:description>   A bus fault occurred while reading level 1 of the translation tables. The appropriate  BUS_ERROR flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xD1</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TRANSTAB_BUS_FAULT_2</spirit:name>
              <spirit:description>   A bus fault occurred while reading level 2 of the translation tables. The appropriate  BUS_ERROR flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xD2</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TRANSTAB_BUS_FAULT_3</spirit:name>
              <spirit:description>   A bus fault occurred while reading level 3 of the translation tables. The appropriate  BUS_ERROR flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xD3</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ACCESS_FLAG_0</spirit:name>
              <spirit:description>   A memory access hit a translation table entry with the ACCESS_FLAG bit set in level 0 of the translation table. This is not treated as a fault by the accessor. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set. Added MMU translation level information to access flag fault. </spirit:description>
              <spirit:value>0xD8</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ACCESS_FLAG_1</spirit:name>
              <spirit:description>   A memory access hit a translation table entry with the ACCESS_FLAG bit set in level 1 of the translation table. This is not treated as a fault by the accessor. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xD9</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ACCESS_FLAG_2</spirit:name>
              <spirit:description>   A memory access hit a translation table entry with the ACCESS_FLAG bit set in level 2 of the translation table. This is not treated as a fault by the accessor. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xDA</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ACCESS_FLAG_3</spirit:name>
              <spirit:description>   A memory access hit a translation table entry with the ACCESS_FLAG bit set in level 3 of the translation table. This is not treated as a fault by the accessor. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xDB</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ADDRESS_SIZE_FAULT_IN0</spirit:name>
              <spirit:description>   An input address size fault occurred while reading level 0 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ADDRESS_SIZE_FAULT_IN1</spirit:name>
              <spirit:description>   An input address size fault occurred while reading level 1 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE1</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ADDRESS_SIZE_FAULT_IN2</spirit:name>
              <spirit:description>   An input address size fault occurred while reading level 2 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE2</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ADDRESS_SIZE_FAULT_IN3</spirit:name>
              <spirit:description>   An input address size fault occurred while reading level 3 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE3</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ADDRESS_SIZE_FAULT_OUT0</spirit:name>
              <spirit:description>   An output address size fault occurred while reading level 0 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE4</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ADDRESS_SIZE_FAULT_OUT1</spirit:name>
              <spirit:description>   An output address size fault occurred while reading level 1 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE5</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ADDRESS_SIZE_FAULT_OUT2</spirit:name>
              <spirit:description>   An output address size fault occurred while reading level 2 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE6</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ADDRESS_SIZE_FAULT_OUT3</spirit:name>
              <spirit:description>   An output address size fault occurred while reading level 3 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE7</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>MEMORY_ATTRIBUTE_FAULT_0</spirit:name>
              <spirit:description>   A memory access could not be allowed due to an attempt to access a page with its memory attribute set to  FAULT in the MEMATTR register. This fault happened when reading level 0 of the translation tables. The appropriate PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE8</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>MEMORY_ATTRIBUTE_FAULT_1</spirit:name>
              <spirit:description>   A memory access could not be allowed due to an attempt to access a page with its memory attribute set to  FAULT in the MEMATTR register. This fault happened when reading level 1 of the translation tables. The appropriate PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE9</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>MEMORY_ATTRIBUTE_FAULT_2</spirit:name>
              <spirit:description>   A memory access could not be allowed due to an attempt to access a page with its memory attribute set to  FAULT in the MEMATTR register. This fault happened when reading level 2 of the translation tables. The appropriate PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xEA</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>MEMORY_ATTRIBUTE_FAULT_3</spirit:name>
              <spirit:description>   A memory access could not be allowed due to an attempt to access a page with its memory attribute set to  FAULT in the MEMATTR register. This fault happened when reading level 3 of the translation tables. The appropriate PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xEB</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>MEMORY_ATTRIBUTE_NONCACHEABLE_0</spirit:name>
              <spirit:description>   A memory access could not be allowed due to an attempt to access a non-cacheable page from a bus master which does not support non-cacheable accessess. This fault happened when reading level 0 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xEC</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>MEMORY_ATTRIBUTE_NONCACHEABLE_1</spirit:name>
              <spirit:description>   A memory access could not be allowed due to an attempt to access a non-cacheable page from a bus master which does not support non-cacheable accessess. This fault happened when reading level 1 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xED</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>MEMORY_ATTRIBUTE_NONCACHEABLE_2</spirit:name>
              <spirit:description>   A memory access could not be allowed due to an attempt to access a non-cacheable page from a bus master which does not support non-cacheable accessess. This fault happened when reading level 2 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xEE</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>MEMORY_ATTRIBUTE_NONCACHEABLE_3</spirit:name>
              <spirit:description>   A memory access could not be allowed due to an attempt to access a non-cacheable page from a bus master which does not support non-cacheable accessess. This fault happened when reading level 3 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xEF</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ACCESS_TYPE</spirit:name>
          <spirit:displayName>ACCESS_TYPE</spirit:displayName>
          <spirit:description>   This field contains the direction of data transfer that caused the fault, if known.  For the purposes of error reporting, atomic transactions act like a read followed by a write, so denying either permission will result in the atomic transaction failing, and the exceptions ACCESS_TYPE field will be set to "atomic". </spirit:description>
          <spirit:bitOffset>8</spirit:bitOffset>
          <spirit:bitWidth>2</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>atomic</spirit:name>
              <spirit:description> An atomic (read/write) transaction. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>execute</spirit:name>
              <spirit:description> An execute transaction. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>read</spirit:name>
              <spirit:description> A read transaction. </spirit:description>
              <spirit:value>2</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>write</spirit:name>
              <spirit:description> A write transaction. </spirit:description>
              <spirit:value>3</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS6_FAULTADDRESS_LO</spirit:name>
        <spirit:displayName>ST1MMUAS6_FAULTADDRESS_LO</spirit:displayName>
        <spirit:description>   This register contains information about the cause of a page fault or bus error. </spirit:description>
        <spirit:addressOffset>0x20</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>ST1MMUAS6FAULTADDRESS_LO</spirit:name>
          <spirit:displayName>ST1MMUAS6FAULTADDRESS_LO</spirit:displayName>
          <spirit:description>   This field contains the virtual address (in this address space) of the access that caused the fault.  Additional information about the fault is also available in the FAULTSTATUS register.  If multiple faults occur before the first is handled, the subsequent faults are ignored. They may fault again after handling the first one. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS6_FAULTADDRESS_HI</spirit:name>
        <spirit:displayName>ST1MMUAS6_FAULTADDRESS_HI</spirit:displayName>
        <spirit:description>   This register contains information about the cause of a page fault or bus error. </spirit:description>
        <spirit:addressOffset>0x24</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>ST1MMUAS6FAULTADDRESS_HI</spirit:name>
          <spirit:displayName>ST1MMUAS6FAULTADDRESS_HI</spirit:displayName>
          <spirit:description>   This field contains the virtual address (in this address space) of the access that caused the fault.  Additional information about the fault is also available in the FAULTSTATUS register.  If multiple faults occur before the first is handled, the subsequent faults are ignored. They may fault again after handling the first one. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS6_STATUS</spirit:name>
        <spirit:displayName>ST1MMUAS6_STATUS</spirit:displayName>
        <spirit:description>   This register contains dynamic status information about this address space. </spirit:description>
        <spirit:addressOffset>0x28</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>Res179</spirit:name>
          <spirit:displayName>Res179</spirit:displayName>
          <spirit:description>Res179</spirit:description>
          <spirit:bitOffset>1</spirit:bitOffset>
          <spirit:bitWidth>31</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>AS_ACTIVE</spirit:name>
          <spirit:displayName>AS_ACTIVE</spirit:displayName>
          <spirit:description>   This flag is set while a MMU_UPDATE, LOCK, UNLOCK, FLUSH_PT or FLUSH_MEM command is active on this address space. This allows software to safely verify that the address space is in a consistent state after reconfiguring the MMU page tables.  If a new command is written to the corresponding COMMAND register while the AS_ACTIVE bit is set, then the command is ignored. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> Address space command register is inactive. A new command may be written to the COMMAND register. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Address space command register is active. Any new command written to the COMMAND register will be ignored. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS6_TRANSCFG_LO</spirit:name>
        <spirit:displayName>ST1MMUAS6_TRANSCFG_LO</spirit:displayName>
        <spirit:description>ST1MMUAS6_TRANSCFG_LO</spirit:description>
        <spirit:addressOffset>0x30</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>Res180</spirit:name>
          <spirit:displayName>Res180</spirit:displayName>
          <spirit:description>Res180</spirit:description>
          <spirit:bitOffset>4</spirit:bitOffset>
          <spirit:bitWidth>2</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>Res181</spirit:name>
          <spirit:displayName>Res181</spirit:displayName>
          <spirit:description>Res181</spirit:description>
          <spirit:bitOffset>11</spirit:bitOffset>
          <spirit:bitWidth>3</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>Res182</spirit:name>
          <spirit:displayName>Res182</spirit:displayName>
          <spirit:description>Res182</spirit:description>
          <spirit:bitOffset>19</spirit:bitOffset>
          <spirit:bitWidth>3</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>Res183</spirit:name>
          <spirit:displayName>Res183</spirit:displayName>
          <spirit:description>Res183</spirit:description>
          <spirit:bitOffset>23</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>Res184</spirit:name>
          <spirit:displayName>Res184</spirit:displayName>
          <spirit:description>Res184</spirit:description>
          <spirit:bitOffset>26</spirit:bitOffset>
          <spirit:bitWidth>2</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>Res185</spirit:name>
          <spirit:displayName>Res185</spirit:displayName>
          <spirit:description>Res185</spirit:description>
          <spirit:bitOffset>31</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>INA_BITS</spirit:name>
          <spirit:displayName>INA_BITS</spirit:displayName>
          <spirit:description>   This field allows the system software to restrict the range of input addresses accepted by this translation stage. This is used in conjunction with the hardware limits to determine the valid address range as follows:  INA_BITS_VALID = min(HW_INA_BITS, 55-INA_BITS)  If the input address is outside the range (0, 2  INA_BITS_VALID -1), then a TRANSLATION_FAULT error is generated.</spirit:description>
          <spirit:bitOffset>6</spirit:bitOffset>
          <spirit:bitWidth>5</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>OUTA_BITS</spirit:name>
          <spirit:displayName>OUTA_BITS</spirit:displayName>
          <spirit:description>   This field allows the system software to restrict the range of output addresses generated by this translation stage. This is used in conjunction with the hardware limits to determine the valid address range as follows:  OUTA_BITS_VALID = min(HW_OUTA_BITS, 55-OUTA_BITS)  If the translated output address is outside the range (0, 2  OUTA_BITS_VALID -1), then a TRANSLATION_FAULT error is generated.</spirit:description>
          <spirit:bitOffset>14</spirit:bitOffset>
          <spirit:bitWidth>5</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>MODE</spirit:name>
          <spirit:displayName>MODE</spirit:displayName>
          <spirit:description>   This field controls the overall operation of the MMU. There are some differences between stage 1 and stage 2.  Execute permissions for a page are evaluated as follows (PTE.&amp;lt;W|R|X&gt; refers to page table entry permissions resolved for hierarchical permissions (if applicable):  EXECUTE_ALLOWED = !((TRANSCFG.WXN &amp;amp; !PTE.W) | (TRANSCFG.XREADABLE &amp;amp; !PTE.R) | (!TRANSCFG.XREADABLE &amp;amp; !PTE.X)) </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>LEGACY</spirit:name>
              <spirit:description>   The contents of TRANSTAB and MEMATTR are interpreted according to the legacy behaviour, as used in previous Midgard GPUs. The rest of the TRANSCFG bits are ignored.  Input and output address sizes are set according to the hardware configuration.  Stage 1 will follow the legacy behaviour.  Stage 2 will be transparent, will ignore TRANSTAB settings and will not generate any faults.  Note: as the reset value of TRANSCFG is 0, this is a mechanism to ensure backwards-compatibility and alignment between the stages. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>UNMAPPED</spirit:name>
              <spirit:description> The MMU forces all memory access to fail with a decode fault. No actual page table is required. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>IDENTITY</spirit:name>
              <spirit:description>   The MMU behaves as if using an address translation table with all entries valid and giving an identity mapping (output address is the same as the input address) with full read/write/execute access. Addresses outside the configured address ranges cause page faults.  For Stage 1, cacheability and shareability are defined by MEMATTR0. For Stage 2, cacheablity and sharebility are defined so that they dont change whats set by Stage 1 (non-shareable and inner/outer write-back cacheable and master-defined allocation). </spirit:description>
              <spirit:value>2</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>AARCH64_4K</spirit:name>
              <spirit:description> Page tables are interpreted according to the AArch64 4kB granule specification. </spirit:description>
              <spirit:value>6</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>AARCH64_64K</spirit:name>
              <spirit:description> Page tables are interpreted according to the AArch64 64kB granule specification. </spirit:description>
              <spirit:value>8</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>PTW_MEMATTR</spirit:name>
          <spirit:displayName>PTW_MEMATTR</spirit:displayName>
          <spirit:description>   Memory attributes for page table walks. The allowed values are compatible with the values allowed for  MEMORY_TYPE . For outer cache transactions, the desired attributes for the transaction will be decided by the bus master and communicated to the memory system using signals on the bus.  Changed allowed values for TRANSCFG.PTW_MEMATTR. </spirit:description>
          <spirit:bitOffset>24</spirit:bitOffset>
          <spirit:bitWidth>2</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NON_CACHEABLE</spirit:name>
              <spirit:description> Normal memory, inner non-cacheable, outer non-cacheable. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>WRITE_BACK</spirit:name>
              <spirit:description> Normal memory, inner write-back cacheable, outer write-back cacheable. </spirit:description>
              <spirit:value>2</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>PTW_SH</spirit:name>
          <spirit:displayName>PTW_SH</spirit:displayName>
          <spirit:description>   This field specifies the shareability for the page table walks. This is the same encoding as used for ARMv8 page tables. </spirit:description>
          <spirit:bitOffset>28</spirit:bitOffset>
          <spirit:bitWidth>2</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>non_shareable</spirit:name>
              <spirit:description> The memory region is non-shareable, and coherency with other observers will not automatically be maintained. Software will have to ensure that caches are flushed or invalidated at appropriate times. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>outer_shareable</spirit:name>
              <spirit:description> The memory region is marked as outer shareable. Each outer shareability domain contains a set of observers that are data coherent for each member of that set for	data accesses with the outer shareable attribute made by any member of that set. </spirit:description>
              <spirit:value>2</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>inner_shareable</spirit:name>
              <spirit:description> The memory region is marked as inner shareable. Each inner shareability domain contains a set of observers that are data coherent for each member of that set for	data accesses with the inner shareable attribute made by any member of that set. All observers in an inner shareability domain are always members of the same outer shareability domain. This means that an inner shareability domain is a subset of an Outer Shareability domain, although it is not required to be a proper subset. </spirit:description>
              <spirit:value>3</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>R_ALLOCATE</spirit:name>
          <spirit:displayName>R_ALLOCATE</spirit:displayName>
          <spirit:description>   This field sets the inner read allocation hint for the page table walks. This is the same encoding as used for ARMv8 page tables. </spirit:description>
          <spirit:bitOffset>30</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>no_read_allocate</spirit:name>
              <spirit:description> Hints that the cache should not allocate space when reading a page table entry. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>read_allocate</spirit:name>
              <spirit:description> Hints that the cache should allocate space when reading a page table entry. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>SL_CONCAT_EN</spirit:name>
          <spirit:displayName>SL_CONCAT_EN</spirit:displayName>
          <spirit:description>   If set then the page table walk starting level will be increased if possible by concatenating up to 16 tables in the starting level. </spirit:description>
          <spirit:bitOffset>22</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> Page table concatenation is disabled. 	This mode must be used for Stage 1 if sharing page tables with the CPU, otherwise  UNDEFINED behavior results.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Page table concatenation is enabled. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS6_TRANSCFG_HI</spirit:name>
        <spirit:displayName>ST1MMUAS6_TRANSCFG_HI</spirit:displayName>
        <spirit:description>ST1MMUAS6_TRANSCFG_HI</spirit:description>
        <spirit:addressOffset>0x34</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>Res186</spirit:name>
          <spirit:displayName>Res186</spirit:displayName>
          <spirit:description>Res186</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>Res187</spirit:name>
          <spirit:displayName>Res187</spirit:displayName>
          <spirit:description>Res187</spirit:description>
          <spirit:bitOffset>5</spirit:bitOffset>
          <spirit:bitWidth>27</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>DISABLE_HIER_AP</spirit:name>
          <spirit:displayName>DISABLE_HIER_AP</spirit:displayName>
          <spirit:description>   This flag only has an effect on stage 1 of translation. It is ignored for stage 2. Note the inverted logic - the flag must be set to  dis able hierarchical access permissions.</spirit:description>
          <spirit:bitOffset>1</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> Hierarchical access permissions are enabled. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Hierarchical access permissions are disabled. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>DISABLE_AF_FAULT</spirit:name>
          <spirit:displayName>DISABLE_AF_FAULT</spirit:displayName>
          <spirit:description>   This flag can be used to disable access fault checking when in one of AARCH64 modes. </spirit:description>
          <spirit:bitOffset>2</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> Access fault checking is enabled. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Access fault checking is disabled. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>WXN</spirit:name>
          <spirit:displayName>WXN</spirit:displayName>
          <spirit:description>   This flag can be used to disable all writes to executable pages, overriding access permissions specified in the page table. </spirit:description>
          <spirit:bitOffset>3</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> Write access permissions are read as usual from the page table. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Write access to all executable pages is disabled. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>XREADABLE</spirit:name>
          <spirit:displayName>XREADABLE</spirit:displayName>
          <spirit:description>   This flag can be used to enable execution on all readable pages, overriding access permissions specified in the page table. </spirit:description>
          <spirit:bitOffset>4</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> Execute access permissions are read as usual from the page table. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Execute access to all readable pages is enabled. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS6_FAULTEXTRA_LO</spirit:name>
        <spirit:displayName>ST1MMUAS6_FAULTEXTRA_LO</spirit:displayName>
        <spirit:description>   This register contains additional information about the cause of a page fault or bus error. </spirit:description>
        <spirit:addressOffset>0x38</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>ST1MMUAS6FAULTEXTRA_LO</spirit:name>
          <spirit:displayName>ST1MMUAS6FAULTEXTRA_LO</spirit:displayName>
          <spirit:description>   This field contains the virtual address (in this address space) of the access that caused the fault.  Additional information about the fault is also available in the  FAULTSTATUS and FAULTADDRESS registers. If multiple faults occur before the first is handled, the subsequent faults are ignored. They may fault again after handling the first one.  Fixed duplicate state name in FAULT_ADDRESS - exposes previously hidden field S2FS1WALK. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS6_FAULTEXTRA_HI</spirit:name>
        <spirit:displayName>ST1MMUAS6_FAULTEXTRA_HI</spirit:displayName>
        <spirit:description>   This register contains additional information about the cause of a page fault or bus error. </spirit:description>
        <spirit:addressOffset>0x3c</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>Res188</spirit:name>
          <spirit:displayName>Res188</spirit:displayName>
          <spirit:description>Res188</spirit:description>
          <spirit:bitOffset>16</spirit:bitOffset>
          <spirit:bitWidth>15</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>ST1MMUAS6FAULTEXTRA_HI</spirit:name>
          <spirit:displayName>ST1MMUAS6FAULTEXTRA_HI</spirit:displayName>
          <spirit:description>   This field contains the virtual address (in this address space) of the access that caused the fault.  Additional information about the fault is also available in the  FAULTSTATUS and FAULTADDRESS registers. If multiple faults occur before the first is handled, the subsequent faults are ignored. They may fault again after handling the first one.  Fixed duplicate state name in FAULT_ADDRESS - exposes previously hidden field S2FS1WALK. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>16</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>S2FS1WALK</spirit:name>
          <spirit:displayName>S2FS1WALK</spirit:displayName>
          <spirit:description>S2FS1WALK</spirit:description>
          <spirit:bitOffset>31</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>stage2</spirit:name>
              <spirit:description> Fault source is a stage 2 translation. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>stage1</spirit:name>
              <spirit:description> Fault source is a stage 1 page table walk. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
    </spirit:addressBlock>
    <spirit:addressBlock>
      <spirit:name>jm_mmu_as7_regs</spirit:name>
      <spirit:baseAddress>9664</spirit:baseAddress>
      <spirit:range>64</spirit:range>
      <spirit:width>32</spirit:width>
      <spirit:usage>register</spirit:usage>
      <spirit:register>
        <spirit:name>ST1MMUAS7_TRANSTAB_LO</spirit:name>
        <spirit:displayName>ST1MMUAS7_TRANSTAB_LO</spirit:displayName>
        <spirit:description>   This register contains the address of the base level of the translation table, together with some related flags.  Details on the layout of the page tables, and the address translation process, can be found in the section  Memory Management Unit .</spirit:description>
        <spirit:addressOffset>0x0</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>Res189</spirit:name>
          <spirit:displayName>Res189</spirit:displayName>
          <spirit:description>Res189</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>ST1MMUAS7TRANSTAB_LO</spirit:name>
          <spirit:displayName>ST1MMUAS7TRANSTAB_LO</spirit:displayName>
          <spirit:description>   This field contains the address of the top level of a page table structure. This must be 16-byte-aligned, so address bits [3:0] are assumed to be zero.  For a stage 1 page table, this will be an intermediate physical address, and for stage 2 it will be a physical address. The number of actual translated address bits is stored in  OUTA_BITS . The unused high bits must be set to 0. Changed alignment text for TRANSTAB.BASE  TRANSTAB.BASE pointer is a physical (or intermediate) address </spirit:description>
          <spirit:bitOffset>4</spirit:bitOffset>
          <spirit:bitWidth>28</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS7_TRANSTAB_HI</spirit:name>
        <spirit:displayName>ST1MMUAS7_TRANSTAB_HI</spirit:displayName>
        <spirit:description>   This register contains the address of the base level of the translation table, together with some related flags.  Details on the layout of the page tables, and the address translation process, can be found in the section  Memory Management Unit .</spirit:description>
        <spirit:addressOffset>0x4</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>ST1MMUAS7TRANSTAB_HI</spirit:name>
          <spirit:displayName>ST1MMUAS7TRANSTAB_HI</spirit:displayName>
          <spirit:description>   This field contains the address of the top level of a page table structure. This must be 16-byte-aligned, so address bits [3:0] are assumed to be zero.  For a stage 1 page table, this will be an intermediate physical address, and for stage 2 it will be a physical address. The number of actual translated address bits is stored in  OUTA_BITS . The unused high bits must be set to 0. Changed alignment text for TRANSTAB.BASE  TRANSTAB.BASE pointer is a physical (or intermediate) address </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS7_MEMATTR_LO</spirit:name>
        <spirit:displayName>ST1MMUAS7_MEMATTR_LO</spirit:displayName>
        <spirit:description>  </spirit:description>
        <spirit:addressOffset>0x8</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>ATTRIBUTE0</spirit:name>
          <spirit:displayName>ATTRIBUTE0</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 0. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE1</spirit:name>
          <spirit:displayName>ATTRIBUTE1</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 1. </spirit:description>
          <spirit:bitOffset>4</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE2</spirit:name>
          <spirit:displayName>ATTRIBUTE2</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 2. </spirit:description>
          <spirit:bitOffset>8</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE3</spirit:name>
          <spirit:displayName>ATTRIBUTE3</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 3. </spirit:description>
          <spirit:bitOffset>12</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE4</spirit:name>
          <spirit:displayName>ATTRIBUTE4</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 4. </spirit:description>
          <spirit:bitOffset>16</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE5</spirit:name>
          <spirit:displayName>ATTRIBUTE5</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 5. </spirit:description>
          <spirit:bitOffset>20</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE6</spirit:name>
          <spirit:displayName>ATTRIBUTE6</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 6. </spirit:description>
          <spirit:bitOffset>24</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE7</spirit:name>
          <spirit:displayName>ATTRIBUTE7</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 7. </spirit:description>
          <spirit:bitOffset>28</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS7_MEMATTR_HI</spirit:name>
        <spirit:displayName>ST1MMUAS7_MEMATTR_HI</spirit:displayName>
        <spirit:description>  </spirit:description>
        <spirit:addressOffset>0xc</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>ATTRIBUTE8</spirit:name>
          <spirit:displayName>ATTRIBUTE8</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 8. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE9</spirit:name>
          <spirit:displayName>ATTRIBUTE9</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 9. </spirit:description>
          <spirit:bitOffset>4</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE10</spirit:name>
          <spirit:displayName>ATTRIBUTE10</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 10. </spirit:description>
          <spirit:bitOffset>8</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE11</spirit:name>
          <spirit:displayName>ATTRIBUTE11</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 11. </spirit:description>
          <spirit:bitOffset>12</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE12</spirit:name>
          <spirit:displayName>ATTRIBUTE12</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 12. </spirit:description>
          <spirit:bitOffset>16</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE13</spirit:name>
          <spirit:displayName>ATTRIBUTE13</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 13. </spirit:description>
          <spirit:bitOffset>20</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE14</spirit:name>
          <spirit:displayName>ATTRIBUTE14</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 14. </spirit:description>
          <spirit:bitOffset>24</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ATTRIBUTE15</spirit:name>
          <spirit:displayName>ATTRIBUTE15</spirit:displayName>
          <spirit:description>   This field specifies the memory attributes for memory type index 15. </spirit:description>
          <spirit:bitOffset>28</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NORMAL</spirit:name>
              <spirit:description> Normal stage 2 translation is applied. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FAULT</spirit:name>
              <spirit:description> A MEMATTR fault is reported for this access. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS7_LOCKADDR_LO</spirit:name>
        <spirit:displayName>ST1MMUAS7_LOCKADDR_LO</spirit:displayName>
        <spirit:description>   This register tells the MMU to lock a region of virtual memory. All page mappings within this region must be flushed, and no translation requests within this region can complete or fault before the area is unlocked.  Only one region can be locked at a time.  As only 32 bits of the register can be written to at a time, no changes are issued until the LOCK command is written to the COMMAND register. </spirit:description>
        <spirit:addressOffset>0x10</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>Res190</spirit:name>
          <spirit:displayName>Res190</spirit:displayName>
          <spirit:description>Res190</spirit:description>
          <spirit:bitOffset>6</spirit:bitOffset>
          <spirit:bitWidth>6</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>LOCKADDR_SIZE</spirit:name>
          <spirit:displayName>LOCKADDR_SIZE</spirit:displayName>
          <spirit:description>   This field contains the log  2 of the size of the region to lock, minus 1. Only values in the range 11 to 63 are valid values for this field, corresponding to region sizes of 4KB up to the entire address space. Values in the range 0 to 10 result in UNDEFINED behavior and should not be used.</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>6</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>ST1MMUAS7LOCKADDR_LO</spirit:name>
          <spirit:displayName>ST1MMUAS7LOCKADDR_LO</spirit:displayName>
          <spirit:description>   This field contains the lowest address in the region to be locked. The address is a virtual address in this address space.  Only the upper bits of the address are used. The address is aligned to a multiple of the region size, so a variable number of low-order bits are ignored, depending on the selected region size. It is recommended that software ensures that these low bits in the address are cleared, to avoid confusion. </spirit:description>
          <spirit:bitOffset>12</spirit:bitOffset>
          <spirit:bitWidth>20</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS7_LOCKADDR_HI</spirit:name>
        <spirit:displayName>ST1MMUAS7_LOCKADDR_HI</spirit:displayName>
        <spirit:description>   This register tells the MMU to lock a region of virtual memory. All page mappings within this region must be flushed, and no translation requests within this region can complete or fault before the area is unlocked.  Only one region can be locked at a time.  As only 32 bits of the register can be written to at a time, no changes are issued until the LOCK command is written to the COMMAND register. </spirit:description>
        <spirit:addressOffset>0x14</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>ST1MMUAS7LOCKADDR_HI</spirit:name>
          <spirit:displayName>ST1MMUAS7LOCKADDR_HI</spirit:displayName>
          <spirit:description>   This field contains the lowest address in the region to be locked. The address is a virtual address in this address space.  Only the upper bits of the address are used. The address is aligned to a multiple of the region size, so a variable number of low-order bits are ignored, depending on the selected region size. It is recommended that software ensures that these low bits in the address are cleared, to avoid confusion. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS7_COMMAND</spirit:name>
        <spirit:displayName>ST1MMUAS7_COMMAND</spirit:displayName>
        <spirit:description>   MMU commands are issued by writing to this register. Any command written to an address space while the corresponding STATUS.AS_ACTIVE flag is set will be ignored.  In general an MMU command only applies to the address space it is submitted to. However a command that invalidates the MMU cache may invalidate the whole MMU cache rather than only those entries specific to one address space. </spirit:description>
        <spirit:addressOffset>0x18</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>ST1MMUAS7COMMAND</spirit:name>
          <spirit:displayName>ST1MMUAS7COMMAND</spirit:displayName>
          <spirit:description>ST1MMUAS7COMMAND</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>write-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NOP</spirit:name>
              <spirit:description> No operation, nothing happens. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>UPDATE</spirit:name>
              <spirit:description> Broadcasts the values in TRANSTAB and MEMATTR to all MMUs. MMU caches are invalidated. Use this after changing the content of these registers. This will  not clear the effect of a LOCK set in the updated address space.</spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>LOCK</spirit:name>
              <spirit:description> Issues a lock region command to all MMUs, using the address and size set in the LOCKADDR register. MMU caches are invalidated. Use this before changing an in-memory page table. Any existing lock on this address space is cleared. Locks on other address spaces are not affected. Use a FLUSH or UNLOCK command to unlock a memory region. </spirit:description>
              <spirit:value>2</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>UNLOCK</spirit:name>
              <spirit:description> Issues an unlock region command to all MMUs, using the address and size set in the LOCKADDR register. Any existing lock on this address space is cleared. If no lock was present, the MMU caches are invalidated. Use this when finished changing an in-memory page table, except if the page table can be cached in the L2 cache, in which case, a FLUSH_MEM command must be issued instead. </spirit:description>
              <spirit:value>3</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FLUSH_PT</spirit:name>
              <spirit:description> First cleans and invalidates all L2 caches to force cached page tables to be invalidated, then performs an UNLOCK command. </spirit:description>
              <spirit:value>4</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>FLUSH_MEM</spirit:name>
              <spirit:description> First waits until all memory accesses to a region locked by a preceding LOCK command have completed and have reached the nearest cache.
			This will ensure that all reads to a locked memory region have finished, and that any writes to a locked region have either been written out to memory or are present in the L1 or L2 cache as dirty data.
			Then cleans and invalidates the L1 cache in all shader cores, forcing dirty data for locked regions to be pushed out to the L2 cache.
			Then cleans and invalidates all L2 caches forcing all dirty data for locked regions to be written back to memory and page tables to be invalidated.
			Then performs an UNLOCK command on this address space.
			Use this when finished changing or removing entries in an in-memory page table. </spirit:description>
              <spirit:value>5</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS7_FAULTSTATUS</spirit:name>
        <spirit:displayName>ST1MMUAS7_FAULTSTATUS</spirit:displayName>
        <spirit:description>   This register contains extended status information after a fault. If read before a fault occurs, its contents are the reset value, 0, which indicates no fault.
						If multiple faults occur before the first is handled, the subsequent faults are ignored. They may fault again after handling the first one.  If the GPU is in protected mode, this register is not updated, and MMU faults are ignored. 
						They are not fatal but will halt the GPU until the MMU address space is updated. 
						However, no fault information wil be visible in this case.  Changed access type of MMU_FAULTSTATUS register when in protected mode. </spirit:description>
        <spirit:addressOffset>0x1c</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>Res191</spirit:name>
          <spirit:displayName>Res191</spirit:displayName>
          <spirit:description>Res191</spirit:description>
          <spirit:bitOffset>10</spirit:bitOffset>
          <spirit:bitWidth>6</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>SOURCE_ID</spirit:name>
          <spirit:displayName>SOURCE_ID</spirit:displayName>
          <spirit:description>   This field contains an implementation-defined ID that supplies additional data about the source of the fault. For example, it may be the ID of the internal bus master that issued the request that faulted. This makes it possible to distinguish between the job manager, the texture unit and the load/store unit. Another example might be an indication of the type of an invalid data structure. The values in this field are implementation defined. </spirit:description>
          <spirit:bitOffset>16</spirit:bitOffset>
          <spirit:bitWidth>16</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>EXCEPTION_TYPE</spirit:name>
          <spirit:displayName>EXCEPTION_TYPE</spirit:displayName>
          <spirit:description>   This field indicates the type of exception that caused the fault. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>8</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>OK</spirit:name>
              <spirit:description>   This indicates that the GPU has completed its work and is in a state ready to receive new commands. Its precise meaning depends on its usage:    In the job status field, this indicates that the job has not been started. This should be the initial state of a newly created job.  In the job slot status register, this indicates that the job slot is idle.  In the GPU and MMU exception status registers, this indicates that no exception has yet been received.  No additional error information is available (or indeed required). </spirit:description>
              <spirit:value>0x00</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>DONE</spirit:name>
              <spirit:description> The job completed successfully. The fault value is written to the job descriptor.
			The job descriptors fault address field contains the TIMESTAMP value when the job completed.
			If a job is terminated early using the  EUREKA instruction, then that job will be marked with the EUREKA exception status but the job chain status as a whole will still be DONE.</spirit:description>
              <spirit:value>0x01</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>SUSPENDED</spirit:name>
              <spirit:description> The job was interrupted by a SUSPEND command. The fault value is written both to the job slot  STATUS register and the job descriptor.
			The job descriptor contains the partition index of the first task to be interrupted. The fault address field contains the TIMESTAMP value when the job was interrupted.</spirit:description>
              <spirit:value>0x02</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>STOPPED</spirit:name>
              <spirit:description> The job was interrupted by a SOFT_STOP command. The fault value is written both to the job slot  STATUS register and the job descriptor.
			The job descriptor contains the partition index of the first task that was not completed. This will be the index of the first task issued if the job is resumed. The fault address is UNDEFINED .</spirit:description>
              <spirit:value>0x03</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TERMINATED</spirit:name>
              <spirit:description> The job was interrupted by a HARD_STOP command or a  KABOOM instruction from another job. The fault value is written both to the job slot STATUS register and the job descriptor.
			This status is treated in the same way as an error condition. The job descriptor contains the partition index of the first task to be terminated. The fault address field contains the TIMESTAMP value when the job was interrupted.</spirit:description>
              <spirit:value>0x04</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>KABOOM</spirit:name>
              <spirit:description> The job was interrupted by a shader executing a  KABOOM instruction. The fault value is written both to the job slot STATUS register and the job descriptor.
			This status is treated in the same way as an error condition. The job descriptor contains the partition index of the first task to be terminated. The fault address field contains the TIMESTAMP value when the job was interrupted.</spirit:description>
              <spirit:value>0x05</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>EUREKA</spirit:name>
              <spirit:description> The job was interrupted by a shader executing a  EUREKA instruction. The fault value is written only to the job descriptor, and does not affect subsequent jobs in the job chain.
			The job descriptor contains the partition index of the first task to be terminated. The fault address field contains the TIMESTAMP value when the job was interrupted.</spirit:description>
              <spirit:value>0x06</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ACTIVE</spirit:name>
              <spirit:description> In the JSn_STATUS register, this indicates that the job slot is active.
			The JSn_HEAD and JSn_TAIL registers contain the range of job descriptors currently in progress. </spirit:description>
              <spirit:value>0x08</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>JOB_CONFIG_FAULT</spirit:name>
              <spirit:description>   The job configuration specified in the job slot registers is invalid, so it is not possible to read job descriptors.
				For example this includes setting a NULL job descriptor pointer, selecting an address space that isnt present.
				No additional information is available. </spirit:description>
              <spirit:value>0x40</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>JOB_POWER_FAULT</spirit:name>
              <spirit:description>   The job could not be executed because the part of the memory system required to access job descriptors was not powered on.
				No additional information is available. </spirit:description>
              <spirit:value>0x41</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>JOB_READ_FAULT</spirit:name>
              <spirit:description>   Reading a job descriptor into the Job manager failed.
				The JSn_HEAD register contains the virtual address of the job descriptor that could not be read. </spirit:description>
              <spirit:value>0x42</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>JOB_WRITE_FAULT</spirit:name>
              <spirit:description>   Writing a job descriptor from the Job manager failed.
				The JSn_TAIL register contains the virtual address of the job descriptor that could not be written. </spirit:description>
              <spirit:value>0x43</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>JOB_AFFINITY_FAULT</spirit:name>
              <spirit:description>   The job could not be executed because the specified affinity mask does not intersect any available cores.
				No additional information is available. </spirit:description>
              <spirit:value>0x44</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>JOB_BUS_FAULT</spirit:name>
              <spirit:description>   A bus access failed while executing a job.
				The job descriptor contains the virtual address of the failing access, the type of access, and which part of the GPU initiated the access.
				This error code may also be reported if a bus fault occurs while writing the performance counters to memory. In this case, the GPU_FAULT* registers are updated, but the active JASID is not reported. It is possible to distinguish this case from a genuine Job Bus Fault exception by examining the SOURCE_ID field. </spirit:description>
              <spirit:value>0x48</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>INSTR_INVALID_PC</spirit:name>
              <spirit:description>   A shader instruction with an illegal program counter was executed.
				The job descriptors fault address field contains the offending program counter value. </spirit:description>
              <spirit:value>0x50</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>INSTR_INVALID_ENC</spirit:name>
              <spirit:description>   A shader instruction with an illegal encoding was executed.
				The job descriptors fault address field contains the program counter used to reach the offending instruction. </spirit:description>
              <spirit:value>0x51</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>INSTR_BARRIER_FAULT</spirit:name>
              <spirit:description>   A shader instruction was executed that failed to complete an instruction barrier.
				The job descriptors fault address field contains the program counter used to reach the offending instruction. </spirit:description>
              <spirit:value>0x55</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>DATA_INVALID_FAULT</spirit:name>
              <spirit:description>   Any data structure read as part of the job contains invalid combinations of data.
				The job descriptors fault address field contains the virtual address of the invalid data structure. </spirit:description>
              <spirit:value>0x58</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TILE_RANGE_FAULT</spirit:name>
              <spirit:description>   Tile or fragment shading was asked to process a tile that is entirely outside the bounding box of the frame.
				The job descriptors fault address field contains the coordinates of the top left corner of the failing tile, with X in the bits [15:0], and Y in the bits [31:16].  Clarified description of TILE_RANGE_FAULT. </spirit:description>
              <spirit:value>0x59</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ADDR_RANGE_FAULT</spirit:name>
              <spirit:description>   A virtual address has been found that exceeds the virtual address range.
				The job descriptors fault address field contains the virtual address which is out of range. </spirit:description>
              <spirit:value>0x5A</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>IMPRECISE_FAULT</spirit:name>
              <spirit:description>   A fault has been generated without precise fault information.
				This can happen if appropriate source information is not available at the point where the fault happens.
				The job descriptors fault address field may contain a virtual address related to the fault. </spirit:description>
              <spirit:value>0x5B</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>OUT_OF_MEMORY</spirit:name>
              <spirit:description>   The tiler ran out of memory when executing a job.
				The job descriptors fault address field contains the index of the last completed vertex sent through the tiler. </spirit:description>
              <spirit:value>0x60</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>UNKNOWN</spirit:name>
              <spirit:description>   If multiple jobs in a job chain fail, only the first one the reports an error will set and return full error information. Subsequent failing jobs will not update the error status registers, and may write an error status of UNKNOWN.
				Note that the first job to fail may not be the first job in the chain, which may lead to jobs with  UNKNOWN error status being encountered first when traversing the job chain.
				For example, you may see: Done, Done, Unknown, Bus Error, Unknown, New. In this case, the first two jobs ran successfully, the fourth job hit a bus error, and then jobs three and five also failed. The sixth and subsequent jobs had not been started at that point.</spirit:description>
              <spirit:value>0x7F</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>DELAYED_BUS_FAULT</spirit:name>
              <spirit:description>   The GPU received a bus fault for access to physical memory where the original virtual address is no longer available. This is the result of evicting a dirty line from a cache.
				This may also be triggered by a bus fault during a Tiler cache flush operation. In this case, the address reported in  GPU_FAULTADDRESS is a virtual address.</spirit:description>
              <spirit:value>0x80</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>GPU_SHAREABILITY_FAULT</spirit:name>
              <spirit:description>   A cache has detected that the same line has been accessed as both shareable and non-shareable memory from inside the GPU. Coherency after this point can no longer be guaranteed. </spirit:description>
              <spirit:value>0x88</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>SYSTEM_SHAREABILITY_FAULT</spirit:name>
              <spirit:description>   A cache has detected that the same line has been accessed as both shareable and non-shareable memory from outside the GPU. Coherency after this point can no longer be guaranteed. </spirit:description>
              <spirit:value>0x89</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>GPU_CACHEABILITY_FAULT</spirit:name>
              <spirit:description>   A cache has detected that the same line has been accessed as both cacheable and non-cacheable memory from inside the GPU. Non-cacheable memory may have been cached. </spirit:description>
              <spirit:value>0x8A</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TRANSLATION_FAULT_0</spirit:name>
              <spirit:description>   A memory access hit an invalid table entry at level 0 of the translation table. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xC0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TRANSLATION_FAULT_1</spirit:name>
              <spirit:description>   A memory access hit an invalid table entry at level 1 of the translation table. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xC1</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TRANSLATION_FAULT_2</spirit:name>
              <spirit:description>   A memory access hit an invalid table entry at level 2 of the translation table. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xC2</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TRANSLATION_FAULT_3</spirit:name>
              <spirit:description>   A memory access hit an invalid table entry at level 3 of the translation table. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xC3</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TRANSLATION_FAULT_IDENTITY</spirit:name>
              <spirit:description>   In IDENTITY translation mode, the virtual address exceeds the maximum physical address. </spirit:description>
              <spirit:value>0xC7</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>PERMISSION_FAULT_0</spirit:name>
              <spirit:description>   A memory access could not be allowed due to the permission flags set in level 0 of the translation table. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set. Added MMU translation level information to permission fault. </spirit:description>
              <spirit:value>0xC8</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>PERMISSION_FAULT_1</spirit:name>
              <spirit:description>   A memory access could not be allowed due to the permission flags set in level 1 of the translation table. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xC9</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>PERMISSION_FAULT_2</spirit:name>
              <spirit:description>   A memory access could not be allowed due to the permission flags set in level 2 of the translation table. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xCA</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>PERMISSION_FAULT_3</spirit:name>
              <spirit:description>   A memory access could not be allowed due to the permission flags set in level 3 of the translation table. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xCB</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TRANSTAB_BUS_FAULT_0</spirit:name>
              <spirit:description>   A bus fault occurred while reading level 0 of the translation tables. The appropriate  BUS_ERROR flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xD0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TRANSTAB_BUS_FAULT_1</spirit:name>
              <spirit:description>   A bus fault occurred while reading level 1 of the translation tables. The appropriate  BUS_ERROR flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xD1</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TRANSTAB_BUS_FAULT_2</spirit:name>
              <spirit:description>   A bus fault occurred while reading level 2 of the translation tables. The appropriate  BUS_ERROR flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xD2</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>TRANSTAB_BUS_FAULT_3</spirit:name>
              <spirit:description>   A bus fault occurred while reading level 3 of the translation tables. The appropriate  BUS_ERROR flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xD3</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ACCESS_FLAG_0</spirit:name>
              <spirit:description>   A memory access hit a translation table entry with the ACCESS_FLAG bit set in level 0 of the translation table. This is not treated as a fault by the accessor. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set. Added MMU translation level information to access flag fault. </spirit:description>
              <spirit:value>0xD8</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ACCESS_FLAG_1</spirit:name>
              <spirit:description>   A memory access hit a translation table entry with the ACCESS_FLAG bit set in level 1 of the translation table. This is not treated as a fault by the accessor. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xD9</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ACCESS_FLAG_2</spirit:name>
              <spirit:description>   A memory access hit a translation table entry with the ACCESS_FLAG bit set in level 2 of the translation table. This is not treated as a fault by the accessor. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xDA</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ACCESS_FLAG_3</spirit:name>
              <spirit:description>   A memory access hit a translation table entry with the ACCESS_FLAG bit set in level 3 of the translation table. This is not treated as a fault by the accessor. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xDB</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ADDRESS_SIZE_FAULT_IN0</spirit:name>
              <spirit:description>   An input address size fault occurred while reading level 0 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ADDRESS_SIZE_FAULT_IN1</spirit:name>
              <spirit:description>   An input address size fault occurred while reading level 1 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE1</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ADDRESS_SIZE_FAULT_IN2</spirit:name>
              <spirit:description>   An input address size fault occurred while reading level 2 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE2</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ADDRESS_SIZE_FAULT_IN3</spirit:name>
              <spirit:description>   An input address size fault occurred while reading level 3 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE3</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ADDRESS_SIZE_FAULT_OUT0</spirit:name>
              <spirit:description>   An output address size fault occurred while reading level 0 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE4</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ADDRESS_SIZE_FAULT_OUT1</spirit:name>
              <spirit:description>   An output address size fault occurred while reading level 1 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE5</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ADDRESS_SIZE_FAULT_OUT2</spirit:name>
              <spirit:description>   An output address size fault occurred while reading level 2 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE6</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>ADDRESS_SIZE_FAULT_OUT3</spirit:name>
              <spirit:description>   An output address size fault occurred while reading level 3 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE7</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>MEMORY_ATTRIBUTE_FAULT_0</spirit:name>
              <spirit:description>   A memory access could not be allowed due to an attempt to access a page with its memory attribute set to  FAULT in the MEMATTR register. This fault happened when reading level 0 of the translation tables. The appropriate PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE8</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>MEMORY_ATTRIBUTE_FAULT_1</spirit:name>
              <spirit:description>   A memory access could not be allowed due to an attempt to access a page with its memory attribute set to  FAULT in the MEMATTR register. This fault happened when reading level 1 of the translation tables. The appropriate PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xE9</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>MEMORY_ATTRIBUTE_FAULT_2</spirit:name>
              <spirit:description>   A memory access could not be allowed due to an attempt to access a page with its memory attribute set to  FAULT in the MEMATTR register. This fault happened when reading level 2 of the translation tables. The appropriate PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xEA</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>MEMORY_ATTRIBUTE_FAULT_3</spirit:name>
              <spirit:description>   A memory access could not be allowed due to an attempt to access a page with its memory attribute set to  FAULT in the MEMATTR register. This fault happened when reading level 3 of the translation tables. The appropriate PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xEB</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>MEMORY_ATTRIBUTE_NONCACHEABLE_0</spirit:name>
              <spirit:description>   A memory access could not be allowed due to an attempt to access a non-cacheable page from a bus master which does not support non-cacheable accessess. This fault happened when reading level 0 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xEC</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>MEMORY_ATTRIBUTE_NONCACHEABLE_1</spirit:name>
              <spirit:description>   A memory access could not be allowed due to an attempt to access a non-cacheable page from a bus master which does not support non-cacheable accessess. This fault happened when reading level 1 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xED</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>MEMORY_ATTRIBUTE_NONCACHEABLE_2</spirit:name>
              <spirit:description>   A memory access could not be allowed due to an attempt to access a non-cacheable page from a bus master which does not support non-cacheable accessess. This fault happened when reading level 2 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xEE</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>MEMORY_ATTRIBUTE_NONCACHEABLE_3</spirit:name>
              <spirit:description>   A memory access could not be allowed due to an attempt to access a non-cacheable page from a bus master which does not support non-cacheable accessess. This fault happened when reading level 3 of the translation tables. The appropriate  PAGE_FAULT flag in the IRQ_RAWSTAT register is also set.</spirit:description>
              <spirit:value>0xEF</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>ACCESS_TYPE</spirit:name>
          <spirit:displayName>ACCESS_TYPE</spirit:displayName>
          <spirit:description>   This field contains the direction of data transfer that caused the fault, if known.  For the purposes of error reporting, atomic transactions act like a read followed by a write, so denying either permission will result in the atomic transaction failing, and the exceptions ACCESS_TYPE field will be set to "atomic". </spirit:description>
          <spirit:bitOffset>8</spirit:bitOffset>
          <spirit:bitWidth>2</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>atomic</spirit:name>
              <spirit:description> An atomic (read/write) transaction. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>execute</spirit:name>
              <spirit:description> An execute transaction. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>read</spirit:name>
              <spirit:description> A read transaction. </spirit:description>
              <spirit:value>2</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>write</spirit:name>
              <spirit:description> A write transaction. </spirit:description>
              <spirit:value>3</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS7_FAULTADDRESS_LO</spirit:name>
        <spirit:displayName>ST1MMUAS7_FAULTADDRESS_LO</spirit:displayName>
        <spirit:description>   This register contains information about the cause of a page fault or bus error. </spirit:description>
        <spirit:addressOffset>0x20</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>ST1MMUAS7FAULTADDRESS_LO</spirit:name>
          <spirit:displayName>ST1MMUAS7FAULTADDRESS_LO</spirit:displayName>
          <spirit:description>   This field contains the virtual address (in this address space) of the access that caused the fault.  Additional information about the fault is also available in the FAULTSTATUS register.  If multiple faults occur before the first is handled, the subsequent faults are ignored. They may fault again after handling the first one. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS7_FAULTADDRESS_HI</spirit:name>
        <spirit:displayName>ST1MMUAS7_FAULTADDRESS_HI</spirit:displayName>
        <spirit:description>   This register contains information about the cause of a page fault or bus error. </spirit:description>
        <spirit:addressOffset>0x24</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>ST1MMUAS7FAULTADDRESS_HI</spirit:name>
          <spirit:displayName>ST1MMUAS7FAULTADDRESS_HI</spirit:displayName>
          <spirit:description>   This field contains the virtual address (in this address space) of the access that caused the fault.  Additional information about the fault is also available in the FAULTSTATUS register.  If multiple faults occur before the first is handled, the subsequent faults are ignored. They may fault again after handling the first one. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS7_STATUS</spirit:name>
        <spirit:displayName>ST1MMUAS7_STATUS</spirit:displayName>
        <spirit:description>   This register contains dynamic status information about this address space. </spirit:description>
        <spirit:addressOffset>0x28</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>Res192</spirit:name>
          <spirit:displayName>Res192</spirit:displayName>
          <spirit:description>Res192</spirit:description>
          <spirit:bitOffset>1</spirit:bitOffset>
          <spirit:bitWidth>31</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>AS_ACTIVE</spirit:name>
          <spirit:displayName>AS_ACTIVE</spirit:displayName>
          <spirit:description>   This flag is set while a MMU_UPDATE, LOCK, UNLOCK, FLUSH_PT or FLUSH_MEM command is active on this address space. This allows software to safely verify that the address space is in a consistent state after reconfiguring the MMU page tables.  If a new command is written to the corresponding COMMAND register while the AS_ACTIVE bit is set, then the command is ignored. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> Address space command register is inactive. A new command may be written to the COMMAND register. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Address space command register is active. Any new command written to the COMMAND register will be ignored. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS7_TRANSCFG_LO</spirit:name>
        <spirit:displayName>ST1MMUAS7_TRANSCFG_LO</spirit:displayName>
        <spirit:description>ST1MMUAS7_TRANSCFG_LO</spirit:description>
        <spirit:addressOffset>0x30</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>Res193</spirit:name>
          <spirit:displayName>Res193</spirit:displayName>
          <spirit:description>Res193</spirit:description>
          <spirit:bitOffset>4</spirit:bitOffset>
          <spirit:bitWidth>2</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>Res194</spirit:name>
          <spirit:displayName>Res194</spirit:displayName>
          <spirit:description>Res194</spirit:description>
          <spirit:bitOffset>11</spirit:bitOffset>
          <spirit:bitWidth>3</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>Res195</spirit:name>
          <spirit:displayName>Res195</spirit:displayName>
          <spirit:description>Res195</spirit:description>
          <spirit:bitOffset>19</spirit:bitOffset>
          <spirit:bitWidth>3</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>Res196</spirit:name>
          <spirit:displayName>Res196</spirit:displayName>
          <spirit:description>Res196</spirit:description>
          <spirit:bitOffset>23</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>Res197</spirit:name>
          <spirit:displayName>Res197</spirit:displayName>
          <spirit:description>Res197</spirit:description>
          <spirit:bitOffset>26</spirit:bitOffset>
          <spirit:bitWidth>2</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>Res198</spirit:name>
          <spirit:displayName>Res198</spirit:displayName>
          <spirit:description>Res198</spirit:description>
          <spirit:bitOffset>31</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>INA_BITS</spirit:name>
          <spirit:displayName>INA_BITS</spirit:displayName>
          <spirit:description>   This field allows the system software to restrict the range of input addresses accepted by this translation stage. This is used in conjunction with the hardware limits to determine the valid address range as follows:  INA_BITS_VALID = min(HW_INA_BITS, 55-INA_BITS)  If the input address is outside the range (0, 2  INA_BITS_VALID -1), then a TRANSLATION_FAULT error is generated.</spirit:description>
          <spirit:bitOffset>6</spirit:bitOffset>
          <spirit:bitWidth>5</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>OUTA_BITS</spirit:name>
          <spirit:displayName>OUTA_BITS</spirit:displayName>
          <spirit:description>   This field allows the system software to restrict the range of output addresses generated by this translation stage. This is used in conjunction with the hardware limits to determine the valid address range as follows:  OUTA_BITS_VALID = min(HW_OUTA_BITS, 55-OUTA_BITS)  If the translated output address is outside the range (0, 2  OUTA_BITS_VALID -1), then a TRANSLATION_FAULT error is generated.</spirit:description>
          <spirit:bitOffset>14</spirit:bitOffset>
          <spirit:bitWidth>5</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>MODE</spirit:name>
          <spirit:displayName>MODE</spirit:displayName>
          <spirit:description>   This field controls the overall operation of the MMU. There are some differences between stage 1 and stage 2.  Execute permissions for a page are evaluated as follows (PTE.&amp;lt;W|R|X&gt; refers to page table entry permissions resolved for hierarchical permissions (if applicable):  EXECUTE_ALLOWED = !((TRANSCFG.WXN &amp;amp; !PTE.W) | (TRANSCFG.XREADABLE &amp;amp; !PTE.R) | (!TRANSCFG.XREADABLE &amp;amp; !PTE.X)) </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>4</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>LEGACY</spirit:name>
              <spirit:description>   The contents of TRANSTAB and MEMATTR are interpreted according to the legacy behaviour, as used in previous Midgard GPUs. The rest of the TRANSCFG bits are ignored.  Input and output address sizes are set according to the hardware configuration.  Stage 1 will follow the legacy behaviour.  Stage 2 will be transparent, will ignore TRANSTAB settings and will not generate any faults.  Note: as the reset value of TRANSCFG is 0, this is a mechanism to ensure backwards-compatibility and alignment between the stages. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>UNMAPPED</spirit:name>
              <spirit:description> The MMU forces all memory access to fail with a decode fault. No actual page table is required. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>IDENTITY</spirit:name>
              <spirit:description>   The MMU behaves as if using an address translation table with all entries valid and giving an identity mapping (output address is the same as the input address) with full read/write/execute access. Addresses outside the configured address ranges cause page faults.  For Stage 1, cacheability and shareability are defined by MEMATTR0. For Stage 2, cacheablity and sharebility are defined so that they dont change whats set by Stage 1 (non-shareable and inner/outer write-back cacheable and master-defined allocation). </spirit:description>
              <spirit:value>2</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>AARCH64_4K</spirit:name>
              <spirit:description> Page tables are interpreted according to the AArch64 4kB granule specification. </spirit:description>
              <spirit:value>6</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>AARCH64_64K</spirit:name>
              <spirit:description> Page tables are interpreted according to the AArch64 64kB granule specification. </spirit:description>
              <spirit:value>8</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>PTW_MEMATTR</spirit:name>
          <spirit:displayName>PTW_MEMATTR</spirit:displayName>
          <spirit:description>   Memory attributes for page table walks. The allowed values are compatible with the values allowed for  MEMORY_TYPE . For outer cache transactions, the desired attributes for the transaction will be decided by the bus master and communicated to the memory system using signals on the bus.  Changed allowed values for TRANSCFG.PTW_MEMATTR. </spirit:description>
          <spirit:bitOffset>24</spirit:bitOffset>
          <spirit:bitWidth>2</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>NON_CACHEABLE</spirit:name>
              <spirit:description> Normal memory, inner non-cacheable, outer non-cacheable. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>WRITE_BACK</spirit:name>
              <spirit:description> Normal memory, inner write-back cacheable, outer write-back cacheable. </spirit:description>
              <spirit:value>2</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>PTW_SH</spirit:name>
          <spirit:displayName>PTW_SH</spirit:displayName>
          <spirit:description>   This field specifies the shareability for the page table walks. This is the same encoding as used for ARMv8 page tables. </spirit:description>
          <spirit:bitOffset>28</spirit:bitOffset>
          <spirit:bitWidth>2</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>non_shareable</spirit:name>
              <spirit:description> The memory region is non-shareable, and coherency with other observers will not automatically be maintained. Software will have to ensure that caches are flushed or invalidated at appropriate times. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>outer_shareable</spirit:name>
              <spirit:description> The memory region is marked as outer shareable. Each outer shareability domain contains a set of observers that are data coherent for each member of that set for	data accesses with the outer shareable attribute made by any member of that set. </spirit:description>
              <spirit:value>2</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>inner_shareable</spirit:name>
              <spirit:description> The memory region is marked as inner shareable. Each inner shareability domain contains a set of observers that are data coherent for each member of that set for	data accesses with the inner shareable attribute made by any member of that set. All observers in an inner shareability domain are always members of the same outer shareability domain. This means that an inner shareability domain is a subset of an Outer Shareability domain, although it is not required to be a proper subset. </spirit:description>
              <spirit:value>3</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>R_ALLOCATE</spirit:name>
          <spirit:displayName>R_ALLOCATE</spirit:displayName>
          <spirit:description>   This field sets the inner read allocation hint for the page table walks. This is the same encoding as used for ARMv8 page tables. </spirit:description>
          <spirit:bitOffset>30</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>no_read_allocate</spirit:name>
              <spirit:description> Hints that the cache should not allocate space when reading a page table entry. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>read_allocate</spirit:name>
              <spirit:description> Hints that the cache should allocate space when reading a page table entry. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>SL_CONCAT_EN</spirit:name>
          <spirit:displayName>SL_CONCAT_EN</spirit:displayName>
          <spirit:description>   If set then the page table walk starting level will be increased if possible by concatenating up to 16 tables in the starting level. </spirit:description>
          <spirit:bitOffset>22</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> Page table concatenation is disabled. 	This mode must be used for Stage 1 if sharing page tables with the CPU, otherwise  UNDEFINED behavior results.</spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Page table concatenation is enabled. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS7_TRANSCFG_HI</spirit:name>
        <spirit:displayName>ST1MMUAS7_TRANSCFG_HI</spirit:displayName>
        <spirit:description>ST1MMUAS7_TRANSCFG_HI</spirit:description>
        <spirit:addressOffset>0x34</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>Res199</spirit:name>
          <spirit:displayName>Res199</spirit:displayName>
          <spirit:description>Res199</spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>Res200</spirit:name>
          <spirit:displayName>Res200</spirit:displayName>
          <spirit:description>Res200</spirit:description>
          <spirit:bitOffset>5</spirit:bitOffset>
          <spirit:bitWidth>27</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>DISABLE_HIER_AP</spirit:name>
          <spirit:displayName>DISABLE_HIER_AP</spirit:displayName>
          <spirit:description>   This flag only has an effect on stage 1 of translation. It is ignored for stage 2. Note the inverted logic - the flag must be set to  dis able hierarchical access permissions.</spirit:description>
          <spirit:bitOffset>1</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> Hierarchical access permissions are enabled. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Hierarchical access permissions are disabled. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>DISABLE_AF_FAULT</spirit:name>
          <spirit:displayName>DISABLE_AF_FAULT</spirit:displayName>
          <spirit:description>   This flag can be used to disable access fault checking when in one of AARCH64 modes. </spirit:description>
          <spirit:bitOffset>2</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> Access fault checking is enabled. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Access fault checking is disabled. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>WXN</spirit:name>
          <spirit:displayName>WXN</spirit:displayName>
          <spirit:description>   This flag can be used to disable all writes to executable pages, overriding access permissions specified in the page table. </spirit:description>
          <spirit:bitOffset>3</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> Write access permissions are read as usual from the page table. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Write access to all executable pages is disabled. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
        <spirit:field>
          <spirit:name>XREADABLE</spirit:name>
          <spirit:displayName>XREADABLE</spirit:displayName>
          <spirit:description>   This flag can be used to enable execution on all readable pages, overriding access permissions specified in the page table. </spirit:description>
          <spirit:bitOffset>4</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-write</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>false</spirit:name>
              <spirit:description> Execute access permissions are read as usual from the page table. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>true</spirit:name>
              <spirit:description> Execute access to all readable pages is enabled. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS7_FAULTEXTRA_LO</spirit:name>
        <spirit:displayName>ST1MMUAS7_FAULTEXTRA_LO</spirit:displayName>
        <spirit:description>   This register contains additional information about the cause of a page fault or bus error. </spirit:description>
        <spirit:addressOffset>0x38</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>ST1MMUAS7FAULTEXTRA_LO</spirit:name>
          <spirit:displayName>ST1MMUAS7FAULTEXTRA_LO</spirit:displayName>
          <spirit:description>   This field contains the virtual address (in this address space) of the access that caused the fault.  Additional information about the fault is also available in the  FAULTSTATUS and FAULTADDRESS registers. If multiple faults occur before the first is handled, the subsequent faults are ignored. They may fault again after handling the first one.  Fixed duplicate state name in FAULT_ADDRESS - exposes previously hidden field S2FS1WALK. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>32</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
      </spirit:register>
      <spirit:register>
        <spirit:name>ST1MMUAS7_FAULTEXTRA_HI</spirit:name>
        <spirit:displayName>ST1MMUAS7_FAULTEXTRA_HI</spirit:displayName>
        <spirit:description>   This register contains additional information about the cause of a page fault or bus error. </spirit:description>
        <spirit:addressOffset>0x3c</spirit:addressOffset>
        <spirit:size>32</spirit:size>
        <spirit:reset>
          <spirit:value>0x0</spirit:value>
        </spirit:reset>
        <spirit:field>
          <spirit:name>Res201</spirit:name>
          <spirit:displayName>Res201</spirit:displayName>
          <spirit:description>Res201</spirit:description>
          <spirit:bitOffset>16</spirit:bitOffset>
          <spirit:bitWidth>15</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>ST1MMUAS7FAULTEXTRA_HI</spirit:name>
          <spirit:displayName>ST1MMUAS7FAULTEXTRA_HI</spirit:displayName>
          <spirit:description>   This field contains the virtual address (in this address space) of the access that caused the fault.  Additional information about the fault is also available in the  FAULTSTATUS and FAULTADDRESS registers. If multiple faults occur before the first is handled, the subsequent faults are ignored. They may fault again after handling the first one.  Fixed duplicate state name in FAULT_ADDRESS - exposes previously hidden field S2FS1WALK. </spirit:description>
          <spirit:bitOffset>0</spirit:bitOffset>
          <spirit:bitWidth>16</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
        </spirit:field>
        <spirit:field>
          <spirit:name>S2FS1WALK</spirit:name>
          <spirit:displayName>S2FS1WALK</spirit:displayName>
          <spirit:description>S2FS1WALK</spirit:description>
          <spirit:bitOffset>31</spirit:bitOffset>
          <spirit:bitWidth>1</spirit:bitWidth>
          <spirit:access>read-only</spirit:access>
          <spirit:enumeratedValues>
            <spirit:enumeratedValue>
              <spirit:name>stage2</spirit:name>
              <spirit:description> Fault source is a stage 2 translation. </spirit:description>
              <spirit:value>0</spirit:value>
            </spirit:enumeratedValue>
            <spirit:enumeratedValue>
              <spirit:name>stage1</spirit:name>
              <spirit:description> Fault source is a stage 1 page table walk. </spirit:description>
              <spirit:value>1</spirit:value>
            </spirit:enumeratedValue>
          </spirit:enumeratedValues>
        </spirit:field>
      </spirit:register>
    </spirit:addressBlock>
  </spirit:memoryMap>
</spirit:memoryMaps><spirit:model>
     <spirit:views>
       <spirit:view>
	 <spirit:name>RTL</spirit:name>
	 <spirit:description>Mali RTL</spirit:description>
	 <spirit:envIdentifier>verilogSource:*Synthesis:</spirit:envIdentifier>
	 <spirit:language>verilog</spirit:language>
	 <spirit:modelName>mimir_toplevel</spirit:modelName>
 	 <spirit:fileSetRef>
	   <spirit:localName>RTL</spirit:localName>
	 </spirit:fileSetRef>
       </spirit:view>
      </spirit:views>
      <spirit:ports>
         <spirit:port>
            <spirit:name>CLK</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>RESETn</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>DFTRSTDISABLE</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:vector>
                  <spirit:left>1</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>DFTRAMHOLD</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>DFTCGEN</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>DFTTOPCLKDISABLE</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>DFTSC0CLKDISABLE</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>DFTSC1CLKDISABLE</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>DFTSC2CLKDISABLE</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>DFTSC3CLKDISABLE</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>DFTSC4CLKDISABLE</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>DFTSC5CLKDISABLE</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>DFTSC6CLKDISABLE</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>DFTSC7CLKDISABLE</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>DFTSC8CLKDISABLE</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>DFTSC9CLKDISABLE</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>DFTSC10CLKDISABLE</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>DFTSC11CLKDISABLE</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>DFTSC12CLKDISABLE</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>DFTSC13CLKDISABLE</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>DFTSC14CLKDISABLE</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>DFTSC15CLKDISABLE</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>DFTPWRUP</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>DFTISODISABLE</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>DFTSCANMODE</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>DFTSE</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>CNTVALUEB</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:vector>
                  <spirit:left>63</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>IRQEVENT</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>IRQJOB</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>IRQMMU</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>IRQGPU</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>ACLKENS</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>AWAKEUPS</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>ARVALIDS</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>ARREADYS</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>ARADDRS</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:vector>
                  <spirit:left>15</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>ARLENS</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:vector>
                  <spirit:left>7</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>ARCACHES</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:vector>
                  <spirit:left>3</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>ARIDS</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:vector>
                  <spirit:left>3</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>ARSIZES</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:vector>
                  <spirit:left>2</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>ARBURSTS</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:vector>
                  <spirit:left>1</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>ARLOCKS</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>ARPROTS</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:vector>
                  <spirit:left>2</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>ARUSERS</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:vector>
                  <spirit:left>0</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>RVALIDS</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>RREADYS</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>RDATAS</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left>31</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>RRESPS</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left>1</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>RLASTS</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>RIDS</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left>3</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>RUSERS</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left>0</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>AWVALIDS</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>AWREADYS</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>AWADDRS</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:vector>
                  <spirit:left>15</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>AWLENS</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:vector>
                  <spirit:left>7</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>AWCACHES</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:vector>
                  <spirit:left>3</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>AWIDS</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:vector>
                  <spirit:left>3</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>AWSIZES</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:vector>
                  <spirit:left>2</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>AWBURSTS</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:vector>
                  <spirit:left>1</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>AWLOCKS</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>AWPROTS</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:vector>
                  <spirit:left>2</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>AWUSERS</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:vector>
                  <spirit:left>0</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>WVALIDS</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>WREADYS</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>WDATAS</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:vector>
                  <spirit:left>31</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>WSTRBS</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:vector>
                  <spirit:left>3</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>WLASTS</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>WUSERS</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:vector>
                  <spirit:left>0</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>BVALIDS</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>BREADYS</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>BRESPS</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left>1</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>BIDS</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left>3</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>BUSERS</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left>0</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>ACLKENM0</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>PROTMODEM0</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>AWAKEUPM0</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>AWREADYM0</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>AWVALIDM0</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>AWIDM0</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left>4</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>AWADDRM0</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left>39</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>AWLENM0</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left>7</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>AWSIZEM0</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left>2</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>AWBURSTM0</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left>1</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>AWLOCKM0</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>AWCACHEM0</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left>3</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>AWPROTM0</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left>2</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>AWQOSM0</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left>3</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>AWSNOOPM0</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left>2</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>AWDOMAINM0</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left>1</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>AWBARM0</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left>1</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>WREADYM0</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>WVALIDM0</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>WDATAM0</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left spirit:dependency="spirit:decode(id('CONFIG_AXI_WIDTH'))- 1 " spirit:resolve="dependent">0</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>WSTRBM0</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left spirit:dependency="(spirit:decode(id('CONFIG_AXI_WIDTH')) div 8) - 1" spirit:format="long" spirit:resolve="dependent">15</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>WLASTM0</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>BREADYM0</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>BVALIDM0</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>BIDM0</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:vector>
                  <spirit:left>4</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>BRESPM0</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:vector>
                  <spirit:left>1</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>WACKM0</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>ARREADYM0</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>ARVALIDM0</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>ARIDM0</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left>5</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>ARADDRM0</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left>39</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>ARLENM0</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left>7</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>ARSIZEM0</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left>2</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>ARBURSTM0</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left>1</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>ARLOCKM0</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>ARCACHEM0</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left>3</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>ARPROTM0</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left>2</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>ARQOSM0</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left>3</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>ARSNOOPM0</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left>3</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>ARDOMAINM0</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left>1</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>ARBARM0</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left>1</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>RREADYM0</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>RVALIDM0</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>RIDM0</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:vector>
                  <spirit:left>5</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>RRESPM0</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:vector>
                  <spirit:left>3</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>RDATAM0</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:vector>
                  <spirit:left spirit:dependency="spirit:decode(id('CONFIG_AXI_WIDTH'))- 1 " spirit:resolve="dependent">0</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>RLASTM0</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>RACKM0</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>ACADDRM0</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:vector>
                  <spirit:left>39</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>ACREADYM0</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>ACVALIDM0</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>ACPROTM0</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:vector>
                  <spirit:left>2</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>ACSNOOPM0</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:vector>
                  <spirit:left>3</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>CRREADYM0</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>CRVALIDM0</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>CRRESPM0</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left>4</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>CDREADYM0</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>CDVALIDM0</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>CDDATAM0</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left spirit:dependency="spirit:decode(id('CONFIG_AXI_WIDTH'))- 1 " spirit:resolve="dependent">0</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>CDLASTM0</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>SYSCOREQM0</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>SYSCOACKM0</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>ACLKENM1</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>PROTMODEM1</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>AWAKEUPM1</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>AWREADYM1</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>AWVALIDM1</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>AWIDM1</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left>4</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>AWADDRM1</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left>39</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>AWLENM1</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left>7</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>AWSIZEM1</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left>2</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>AWBURSTM1</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left>1</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>AWLOCKM1</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>AWCACHEM1</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left>3</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>AWPROTM1</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left>2</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>AWQOSM1</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left>3</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>AWSNOOPM1</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left>2</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>AWDOMAINM1</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left>1</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>AWBARM1</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left>1</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>WREADYM1</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>WVALIDM1</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>WDATAM1</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left spirit:dependency="spirit:decode(id('CONFIG_AXI_WIDTH'))- 1 " spirit:resolve="dependent">0</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>WSTRBM1</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left spirit:dependency="(spirit:decode(id('CONFIG_AXI_WIDTH')) div 8) - 1" spirit:format="long" spirit:resolve="dependent">15</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>WLASTM1</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>BREADYM1</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>BVALIDM1</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>BIDM1</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:vector>
                  <spirit:left>4</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>BRESPM1</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:vector>
                  <spirit:left>1</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>WACKM1</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>ARREADYM1</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>ARVALIDM1</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>ARIDM1</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left>5</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>ARADDRM1</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left>39</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>ARLENM1</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left>7</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>ARSIZEM1</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left>2</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>ARBURSTM1</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left>1</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>ARLOCKM1</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>ARCACHEM1</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left>3</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>ARPROTM1</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left>2</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>ARQOSM1</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left>3</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>ARSNOOPM1</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left>3</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>ARDOMAINM1</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left>1</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>ARBARM1</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left>1</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>RREADYM1</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>RVALIDM1</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>RIDM1</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:vector>
                  <spirit:left>5</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>RRESPM1</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:vector>
                  <spirit:left>3</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>RDATAM1</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:vector>
                  <spirit:left spirit:dependency="spirit:decode(id('CONFIG_AXI_WIDTH'))- 1 " spirit:resolve="dependent">0</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>RLASTM1</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>RACKM1</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>ACREADYM1</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>ACVALIDM1</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>ACADDRM1</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:vector>
                  <spirit:left>39</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>ACPROTM1</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:vector>
                  <spirit:left>2</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>ACSNOOPM1</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:vector>
                  <spirit:left>3</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>CRREADYM1</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>CRVALIDM1</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>CRRESPM1</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left>4</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>CDREADYM1</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>CDVALIDM1</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>CDDATAM1</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left spirit:dependency="spirit:decode(id('CONFIG_AXI_WIDTH'))- 1 " spirit:resolve="dependent">0</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>CDLASTM1</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>SYSCOREQM1</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>SYSCOACKM1</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>ACLKENM2</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>PROTMODEM2</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>AWAKEUPM2</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>AWREADYM2</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>AWVALIDM2</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>AWIDM2</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left>4</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>AWADDRM2</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left>39</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>AWLENM2</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left>7</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>AWSIZEM2</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left>2</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>AWBURSTM2</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left>1</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>AWLOCKM2</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>AWCACHEM2</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left>3</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>AWPROTM2</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left>2</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>AWQOSM2</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left>3</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>AWSNOOPM2</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left>2</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>AWDOMAINM2</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left>1</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>AWBARM2</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left>1</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>WREADYM2</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>WVALIDM2</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>WDATAM2</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left spirit:dependency="spirit:decode(id('CONFIG_AXI_WIDTH'))- 1 " spirit:resolve="dependent">0</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>WSTRBM2</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left spirit:dependency="(spirit:decode(id('CONFIG_AXI_WIDTH')) div 8) - 1" spirit:format="long" spirit:resolve="dependent">15</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>WLASTM2</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>BREADYM2</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>BVALIDM2</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>BIDM2</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:vector>
                  <spirit:left>4</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>BRESPM2</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:vector>
                  <spirit:left>1</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>WACKM2</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>ARREADYM2</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>ARVALIDM2</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>ARIDM2</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left>5</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>ARADDRM2</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left>39</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>ARLENM2</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left>7</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>ARSIZEM2</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left>2</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>ARBURSTM2</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left>1</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>ARLOCKM2</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>ARCACHEM2</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left>3</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>ARPROTM2</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left>2</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>ARQOSM2</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left>3</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>ARSNOOPM2</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left>3</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>ARDOMAINM2</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left>1</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>ARBARM2</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left>1</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>RREADYM2</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>RVALIDM2</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>RIDM2</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:vector>
                  <spirit:left>5</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>RRESPM2</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:vector>
                  <spirit:left>3</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>RDATAM2</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:vector>
                  <spirit:left spirit:dependency="spirit:decode(id('CONFIG_AXI_WIDTH'))- 1 " spirit:resolve="dependent">0</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>RLASTM2</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>RACKM2</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>ACREADYM2</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>ACVALIDM2</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>ACADDRM2</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:vector>
                  <spirit:left>39</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>ACPROTM2</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:vector>
                  <spirit:left>2</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>ACSNOOPM2</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:vector>
                  <spirit:left>3</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>CRREADYM2</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>CRVALIDM2</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>CRRESPM2</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left>4</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>CDREADYM2</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>CDVALIDM2</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>CDDATAM2</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left spirit:dependency="spirit:decode(id('CONFIG_AXI_WIDTH'))- 1 " spirit:resolve="dependent">0</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>CDLASTM2</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>SYSCOREQM2</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>SYSCOACKM2</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>ACLKENM3</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>PROTMODEM3</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>AWAKEUPM3</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>AWREADYM3</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>AWVALIDM3</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>AWIDM3</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left>4</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>AWADDRM3</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left>39</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>AWLENM3</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left>7</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>AWSIZEM3</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left>2</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>AWBURSTM3</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left>1</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>AWLOCKM3</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>AWCACHEM3</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left>3</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>AWPROTM3</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left>2</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>AWQOSM3</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left>3</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>AWSNOOPM3</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left>2</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>AWDOMAINM3</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left>1</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>AWBARM3</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left>1</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>WREADYM3</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>WVALIDM3</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>WDATAM3</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left spirit:dependency="spirit:decode(id('CONFIG_AXI_WIDTH'))- 1 " spirit:resolve="dependent">0</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>WSTRBM3</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left spirit:dependency="(spirit:decode(id('CONFIG_AXI_WIDTH')) div 8) - 1" spirit:format="long" spirit:resolve="dependent">15</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>WLASTM3</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>BREADYM3</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>BVALIDM3</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>BIDM3</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:vector>
                  <spirit:left>4</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>BRESPM3</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:vector>
                  <spirit:left>1</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>WACKM3</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>ARREADYM3</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>ARVALIDM3</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>ARIDM3</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left>5</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>ARADDRM3</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left>39</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>ARLENM3</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left>7</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>ARSIZEM3</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left>2</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>ARBURSTM3</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left>1</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>ARLOCKM3</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>ARCACHEM3</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left>3</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>ARPROTM3</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left>2</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>ARQOSM3</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left>3</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>ARSNOOPM3</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left>3</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>ARDOMAINM3</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left>1</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>ARBARM3</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left>1</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>RREADYM3</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>RVALIDM3</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>RIDM3</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:vector>
                  <spirit:left>5</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>RRESPM3</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:vector>
                  <spirit:left>3</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>RDATAM3</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:vector>
                  <spirit:left spirit:dependency="spirit:decode(id('CONFIG_AXI_WIDTH'))- 1 " spirit:resolve="dependent">0</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>RLASTM3</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>RACKM3</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>ACREADYM3</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>ACVALIDM3</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>ACADDRM3</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:vector>
                  <spirit:left>39</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>ACPROTM3</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:vector>
                  <spirit:left>2</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>ACSNOOPM3</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:vector>
                  <spirit:left>3</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>CRREADYM3</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>CRVALIDM3</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>CRRESPM3</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left>4</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>CDREADYM3</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>CDVALIDM3</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>CDDATAM3</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
               <spirit:vector>
                  <spirit:left spirit:dependency="spirit:decode(id('CONFIG_AXI_WIDTH'))- 1 " spirit:resolve="dependent">0</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>CDLASTM3</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>SYSCOREQM3</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>SYSCOACKM3</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>MBISTREQ</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>nMBISTRESET</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:driver>
                  <spirit:defaultValue>1</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>STRIPING_GRANULE</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:vector>
                  <spirit:left>2</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>QACTIVE</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>QREQn</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>QACCEPTn</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>QDENY</spirit:name>
            <spirit:wire>
               <spirit:direction>out</spirit:direction>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>TEXFMTENABLE</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:vector>
                  <spirit:left>31</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
         <spirit:port>
            <spirit:name>COHERENCYFEATURES</spirit:name>
            <spirit:wire>
               <spirit:direction>in</spirit:direction>
               <spirit:vector>
                  <spirit:left>1</spirit:left>
                  <spirit:right>0</spirit:right>
               </spirit:vector>
               <spirit:driver>
                  <spirit:defaultValue>0</spirit:defaultValue>
               </spirit:driver>
            </spirit:wire>
         </spirit:port>
      </spirit:ports>
      <spirit:modelParameters>
         <spirit:modelParameter>
            <spirit:name>CONFIG_CORE_COUNT</spirit:name>
            <spirit:description>Number of shader cores present</spirit:description>
            <spirit:value spirit:format="long" spirit:id="CONFIG_CORE_COUNT" spirit:maximum="16" spirit:minimum="1" spirit:prompt="Number of shader cores present" spirit:resolve="user">8</spirit:value>
         </spirit:modelParameter>
         <spirit:modelParameter>
            <spirit:name>CONFIG_L2_COUNT</spirit:name>
            <spirit:description>Number of L2 slices present</spirit:description>
            <spirit:value spirit:format="long" spirit:id="CONFIG_L2_COUNT" spirit:maximum="4" spirit:minimum="1" spirit:prompt="Number of L2 slices present" spirit:resolve="user">2</spirit:value>
         </spirit:modelParameter>
         <spirit:modelParameter>
            <spirit:name>CONFIG_L2_CACHE_SIZE</spirit:name>
            <spirit:description>L2 cache size</spirit:description>
            <spirit:value spirit:format="long" spirit:id="CONFIG_L2_CACHE_SIZE" spirit:maximum="4" spirit:minimum="3" spirit:prompt="L2 cache size" spirit:resolve="user">4</spirit:value>
         </spirit:modelParameter>
         <spirit:modelParameter>
            <spirit:name>CONFIG_AXI_WIDTH</spirit:name>
	    <spirit:description>Data width of the AXI master ports</spirit:description>
            <spirit:value spirit:format="long" spirit:id="CONFIG_AXI_WIDTH" spirit:maximum="128" spirit:minimum="128" spirit:prompt="Data width of the AXI master ports" spirit:resolve="user">128</spirit:value>
         </spirit:modelParameter>
         <spirit:modelParameter>
            <spirit:name>CONFIG_NUM_ENGINES</spirit:name>
            <spirit:description>Number of Execution Engines per shader core</spirit:description>
            <spirit:value spirit:format="long" spirit:id="CONFIG_NUM_ENGINES" spirit:maximum="3" spirit:minimum="3" spirit:prompt="Number of Execution Engines per shader core" spirit:resolve="user">3</spirit:value>
         </spirit:modelParameter>
         <spirit:modelParameter>
            <spirit:name>CONFIG_ASYNC_STACK</spirit:name>
            <spirit:description>Enable/disable asynchronous bridges for the shader tile stack</spirit:description>
            <spirit:value spirit:format="long" spirit:id="CONFIG_ASYNC_STACK" spirit:maximum="1" spirit:minimum="0" spirit:prompt="Enable/disable asynchronous bridges for the shader tile stack" spirit:resolve="user">1</spirit:value>
         </spirit:modelParameter>
         <spirit:modelParameter>
            <spirit:name>CONFIG_ASYNC_TILE</spirit:name>
            <spirit:description>Enable/disable asynchronous bridges for the shader tile</spirit:description>
            <spirit:value spirit:format="long" spirit:id="CONFIG_ASYNC_TILE" spirit:maximum="1" spirit:minimum="0" spirit:prompt="Enable/disable asynchronous bridges for the shader tile" spirit:resolve="user">1</spirit:value>
         </spirit:modelParameter>
         <spirit:modelParameter>
            <spirit:name>CONFIG_ASYNC_GLOBAL</spirit:name>
            <spirit:description>Enable/disable asynchronous bridges for the global domain</spirit:description>
            <spirit:value spirit:format="long" spirit:id="CONFIG_ASYNC_GLOBAL" spirit:maximum="1" spirit:minimum="0" spirit:prompt="Enable/disable asynchronous bridges for the global domain" spirit:resolve="user">1</spirit:value>
         </spirit:modelParameter>
         <spirit:modelParameter>
            <spirit:name>CONFIG_AXIS_ID_WIDTH</spirit:name>
	    <spirit:description>ID width of the AXI slave port</spirit:description>
            <spirit:value spirit:format="long" spirit:id="CONFIG_AXIS_ID_WIDTH" spirit:maximum="4" spirit:minimum="4" spirit:prompt="ID width of the AXI slave port" spirit:resolve="user">4</spirit:value>
         </spirit:modelParameter>
         <spirit:modelParameter>
            <spirit:name>CONFIG_SELECT_CORES</spirit:name>
            <spirit:description>Select explicitly which shader cores are present</spirit:description>
            <spirit:value spirit:format="long" spirit:id="CONFIG_SELECT_CORES" spirit:maximum="0" spirit:minimum="0" spirit:prompt="Select explicitly which shader cores are present" spirit:resolve="user">0</spirit:value>
         </spirit:modelParameter>
      </spirit:modelParameters>
   </spirit:model>
   <spirit:fileSets>
  <spirit:fileSet>
    <spirit:name>RTL</spirit:name>
    <spirit:description>All verilog RTL source files for tMIx</spirit:description>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_regslice_core.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_regslice_core_reset.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_axi_regslice_iar.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_axi_regslice_r.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_axi_regslice_iaw.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_axi_regslice_iw.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_axi_regslice_b.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_rshift32.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_encode.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_bitscan_msb.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_bitscan_msb_w.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_bitscan_lsb.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_bitscan_lsb_w.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_round_robin.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_round_robin_one_hot.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_rr_arb.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_pseudo_random_one_hot.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_pseudo_random_lfsr.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_gray_incr.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_gray_inc_dec_core.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_gray_inc_dec.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_align_bin_gray.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_fifo_reg.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_fifo_reg_sh_fsm.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_fifo_reg_sh.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_fifo_reg_sh_comb_dh.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_fifo_reg_ptr_data.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_fifo_reg_ptr.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_skid_fifo_reg.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_uu_int_mul.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_ss_int_mul.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_su_int_mul.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_fp_clz32.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_int_vec_adder.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_f32_mul_multi_roundmode.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_vec_rshift.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_vec_lshift.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_clz_hier.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_clz_offs.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_clz_skip_hier.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_clz.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_clz4.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_clz8.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_clz16.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_clz32.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_clz64.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_clz_non_pow2.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_clz34.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_clz54.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_u24_u24_mul.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_fp32_to_unorm.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_rgb_to_srgb.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_srgb_to_rgb.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_unorm_conv_up.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_unorm_conv_down.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_srgb8_to_rgb8_1_874ulp.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_rgb8_to_srgb8_1_874ulp_lut7.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_lru_4way_replacement.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_lru_4way_update.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_lru_buf_be.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_lru_buf.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_lru_buf_bin.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_modulo_sh.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_modulo_three.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_modulo_three_sh.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_modulo_six.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_modulo_seven.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_modulo_seven_sh.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_utlb_axi.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_utlb_aximif.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_utlb_axisif.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_utlb_cache_access_pipe.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_utlb_cache.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_utlb_cache_data_arb.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_utlb_cache_data_pipe.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_utlb_cache_tags.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_utlb_mmuif.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_utlb_ptreqif.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_utlb_wflowctrl.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_utlb_arbiter.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_utlb_invalidation_ctrl_axi.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_mmu_replay.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_mmu_arbiter.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_mmu_regslice.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_perf_count_multiport.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_perf_count.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_perf_count_axi_if.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_perf_count_control_if.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_perf_count_counter.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_perf_count_counter_decode.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_perf_count_counters.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_perf_count_decode_1_30.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_perf_count_engine.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_perf_count_fifo.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_perf_count_mux_30_1.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_perf_count_pipeline.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_gray_decoder.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_gray_encoder.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_fp32_partial_cancel_add.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_fp32_adder_main.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_fp32_ctz26.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_fp32_min5.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_fp32_pack.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_fp32_unpack.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_fp16_ctz13.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_fp16_adder_main.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_fp16_pack.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_fp16_partial_cancel_add.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_fp16_unpack.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_fp16_min4.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_reg_en_sliced.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_reg.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_reg_rst.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_reg_en.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_reg_en_rst.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_reg_pipe.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_counter.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_counter_m_core.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_counter_m_rst.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_counter_m_arr_rst.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_bin2oh.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_gray2oh.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_demux.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_demux_oh.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_extract.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_prio_dec.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_prio_mask.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_prio_mask_skip.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_revert.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_endian_conv.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_mux_oh.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_mux.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_extend.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_oh2bin.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_transpose.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_normalize.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_reduce_or.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_sum_tree.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_replic_slice.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_remap_id.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_lib_axi_addr_align.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_tiler_ram_gasket.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_tiler_ram_fifo.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_jcb_regslice.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_jcb_router.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_jcb_flits_to_msg.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_jcb_msg_to_flits.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_jcb_legacy_slave_shim.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_jcb_cmd_decoder_and_fifos.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_jcb_cmd_fifo.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_asn_mod3.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_asn_hst.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_asn_fifo.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_asn_sc_bridge_ar_channel.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_asn_sc_bridge_w_channel.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_asn_mux_4to1_sp_vc.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_asn_ps.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_asn_credit_ctrl.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_asn_fe_table.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_asn_async_master.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_asn_async_master_pm.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_asn_async_fifo.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_asn_async_slave.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_asn_async_slave_pm.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_asn_async_mux.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_asn_depth_6_gray_count.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_asn_mux.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_asn_mux_4to1.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_asn_msa_to_hdr.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_asn_mux_1to4_ps.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_asn_mux_1to4.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_asn_switch_group.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_asn_switch.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_asn_wlrg_arb.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_asn_wlrg_vc_arb.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_asn_vc_sp_buffer.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_asn_switch_outp_stage.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_asn_switch_input_buffer.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_asn_switch_hdr_decoder.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_asn_vc_fifo.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_asn_credit_converter.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/verilog/mimir_asn_async_burst_buffer.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/include/mimir_constants.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/include/mimir_localparam_map.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/include/mimir_idvs_constants.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/include/mimir_mbist_constants.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/include/mimir_memory_l2c_constants.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/include/mimir_memory_constants.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/include/mimir_memory_frag_constants.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/include/mimir_memory_tex_constants.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/include/mimir_memory_cg_constants.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/include/mimir_memory_sc_constants.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/include/mimir_memory_jm_constants.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/include/mimir_memory_global_constants.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/include/mimir_memory_mmu_constants.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/include/mimir_memory_tri_constants.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/include/mimir_memory_lsc_skry_constants.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/include/mimir_memtype_constants.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/include/mimir_memtype_functions.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/include/mimir_memtype_includes.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/include/mimir_mmu_constants.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/include/mimir_mmu_stage_constants.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/include/mimir_mmu_stage_functions.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/include/mimir_mmu_regslice_constants.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/include/mimir_utlb_constants.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/include/mimir_tiler_plr_constants.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/include/mimir_tiler_constants.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/include/mimir_l2c_axi_constants.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/include/mimir_utlb_vaxi_constants.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/include/mimir_utlb_paxi_constants.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/include/mimir_jcb_constants.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/include/mimir_jcn_constants.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/include/mimir_jcn_conversion_constants.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/include/mimir_jcn_functions.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/include/mimir_lib_regslice_constants.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/include/mimir_lib_func_clog2.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/include/mimir_lib_func_umax.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/include/mimir_lib_func_umin.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/include/mimir_lib_func_intmax.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/include/mimir_lib_func_intmin.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/include/mimir_lib_float_utils.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/include/mimir_lib_func_bin2gray.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/include/mimir_lib_func_gray2bin.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/include/mimir_lib_func_revert.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/include/mimir_lib_func_replic_slice.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/include/mimir_lib_func_reduce_or.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/include/mimir_lib_func_transpose.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/include/mimir_lib_func_clz_hier_out_w.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/include/mimir_lib_func_clz_hier_out_pos.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/include/mimir_lib_func_clz_offs_out_w.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/include/mimir_perf_count_constants.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/include/mimir_lib_generic_type_constants.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/include/mimir_lib_func_clz32.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/include/mimir_msa_constants.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/include/mimir_msa_functions.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shared/include/mimir_asn_constants.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_shader_core.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_shader_tile.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_sc_logic.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_asn_async_bridge_sc.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_asn_async_bridge_tile.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_asn_bypass_tile_bridge.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_sc_mbist_intf.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_sc_mbist.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_sc_bus_interface.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_sc_shared.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_fragment.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_fragment_clock.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_fs_jcb_endpoint.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_compute.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_compute_clock.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_cs_jcb_endpoint.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_cse_cmd_decoder_and_fifos.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_cse_cmd_fifo.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_compute_id_tracker.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_compute_thread_creator.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_compute_thread_id_last.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_compute_thread_counter.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_compute_wg_thread_id_increment.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_compute_jd_thread_id_increment.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_compute_thread_id_increment.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_core_control.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_cc_jcb_endpoint.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_cu.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_cu_bypass_reg.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_cu_fifo_dual.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_cu_skid_buffer.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_cu_operand_count.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_cu_pipe.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_cu_pipe_dp.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_cu_add_pipe.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_cu_regblock_decode.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_cu_stg_reg_decode.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_cu_regfile_bank.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_cu_early_msg_form.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_cu_msg_stash_form.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_cu_pc_calc.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_cu_stall_regslice.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_cu_cmp_lanes.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_cu_cmp_lanes_special.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_sdc_cu_satellite.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_cu_writeport.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_cu_msg_dm.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_msg_dm_data_fifo.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_cu_msg_arb.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_cu_dep_fifo.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_cu_base_addr_calc.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_cu_shaddxl.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_cu_shaddxh.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_cu_addr_gen.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_cu_addr_calc.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_cu_alpha_to_coverage.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_cu_add.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_cu_add64.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_cu_fma.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_cu_fma64.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_cu_fma_booth_mul18x9_27x9.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_cu_fma_booth_mul18x9_pair_smallstub.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_cu_fma_booth_mul18x9_pair_twostubs.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_cu_fma_booth_mul28x28_largestub.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_cu_fma_clz_ctz_128_multi.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_cu_fma_composite_mul27x27_smallstub.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_cu_fma_composite_mul27x27_twostubs.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_cu_fma_composite_mul54x54_hpc.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_cu_fma_composite_mul54x54_hpc_merge.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_cu_fma_composite_mul54x54_hpc_premux.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_cu_fma_inf_nan_minmax3.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_cu_fma_multi_width_adder.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_cu_fma_res_shifter.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_cu_fma_round_adder.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_cu_fma_shifter.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_cu_add_shifter.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_cu_tbl.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_cu_tbl_analyze_inp0.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_cu_tbl_analyze_inp1.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_cu_tbl_analyze_inputs.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_cu_tbl_atan2_table_idx.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_cu_tbl_clz_ctz_32.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_cu_tbl_exponential.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_cu_tbl_fpow_sc_det.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_cu_tbl_log_tables.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_cu_tbl_rcbrt_approx_b.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_cu_tbl_rcp_rsq_rcb.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_cu_tbl_sine_cosine.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_stcvt_adder.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_stcvt_analyze_pfs.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_stcvt_clear_bits.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_stcvt_fp_to_srgb.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_stcvt_integer_overflow.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_stcvt_lane.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_stcvt_mantissa_expo_gather.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_stcvt_norm_shift.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_stcvt_prepare_controls.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_stcvt_r9e5_accumulate_scale.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_stcvt_rotate.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_stcvt_round_and_sticky.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_cu_store_converter.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_cu_store_converter_wrapper.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_cu_store_convert_register_schedule.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_ee_bitscan.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_ee_cnt.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_ee_diverge.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_ee_macro.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_ee_sched_token.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_ee_sched_queue.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_ee_sched_bank.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_ee_scheduler.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_ee_toplevel.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_ee_warp_create.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_ee_wc_dependency.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_ee_wc_zs.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_ee_wc_terminate.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_ee_dep_cnt.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_ee_wc_decoder.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_ee_wc_encoder.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_ee_wc_state.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_ee_wc_imsg.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_ee_wctrl.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_ee_msg_toplevel.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_ee_classify_decode.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_ee_msg_classify.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_ee_msg_packer.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_ee_msg_packer_big.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_ee_msg_packer_small.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_ee_msg_packer_transmiter.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_ee_msg_rx_conv.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_ee_msg_rx_buf.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_ee_msg_tx_buf.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_ee_msg_rx.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_ee_msg_tx.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_ee_msg_tx_out.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_ee_msg_lut.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_ee_mbist.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_ec_toplevel.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_ec_register_ready.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_ec_regslice.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_ec_regslice_reset.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_ec_stall_regslice.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_ec_stall_regslice_reset.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_ec_arb_rr.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_ec_arb_dynamic.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_ec_mbist.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_ic_toplevel.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_ic_tester.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_ic_tester_range_checker.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_ic_state.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_ic_data.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_ic_data_rtracker.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_ic_data_decode.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_ic_data_ram_driver.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_ic_clk_ctrl.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_wm_mod_spp.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_wm_ptile_alloc.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_wm_fdm_zs.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_wm_frame_setup.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_wm_fabric_decode.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_wm_compute_terminate.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_wm_fdm_output_stage.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_wm_fdm.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_wm_wg_status_arb.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_wm_fpk.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_wm_barrier_unit.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_wm_wmi_arb.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_wm_wmi_rx_decode.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_wm_register_preload.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_wm_create_warp.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_wm_scheduler.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_wm_tgc_arbiter.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_wm_instance_alloc.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_wm_instance_alloc_pipe.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_wm_toplevel.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_fabric_top.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_fabric_3_to_1_mux.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_fabric_arb.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_fabric_arb_credit.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_fabric_single_multy.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_fabric_slice_ready.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_fabric_slice_credit.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_fabric_credit_to_ready.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_var_attr_packet_demangler.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_var_attribute_eval.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_var_rcp.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_var_fp32_mul.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_var_bary_eval.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_var_bary_adjust.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_var_interp_ctrl.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_var_l0.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_var_l0_load_path.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_var_logic.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_var_mode_decode.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_var_parking_buffer.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_var_toplevel.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_var_tri_prepare.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_var_vary_interp.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_var_varying_cache.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_var_msg_out.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_var_bcoord_ram_if.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_var_bcoeff_ram_if.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_var_varying_cache_read_ctrl.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_var_varying_cache_tag_match_pipe.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_attr_toplevel.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_attr_msg_decode.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_attr_addr_pipe.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_attr_urt_cache.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_attr_ad_cache.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_attr_abd_cache.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_attr_calc.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_fabric_endpoint.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_fabric_ep_input_bridge.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_fabric_ep_output_bridge.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_fabric_mf_fifo.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_fabric_credit_ctrl.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_ftc_toplevel.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_ftc_mbist.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_pdw_toplevel.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_pdw_edge_cache.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_pdw_z_cache.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_rb_toplevel.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_rb_entry.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_rast_toplevel.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_rast_psc.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_rast_psc_patch_bounds.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_rast_psc_depth_bounds_to_fixed.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_rast_psc_vertex_checker.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_rast_psc_grid_checker.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_rast_psc_st_get_scissor_params.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_rast_psc_scissor_test.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_rast_psc_z_stencil_test.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_rast_hierz.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_rast_hierz_depth_eval.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_rast_fifos.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_rast_fifos_1.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_rast_fifos_2.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_rast_fifos_3.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_rast_sample_tester.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_trisetup_toplevel.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_trisetup_ucode.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_trisetup_regfile.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_trisetup_lut_toplevel.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_trisetup_vecadd_toplevel.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_trisetup_vecadd_absmax_major_pick.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_trisetup_vecadd_chooser.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_trisetup_fp32_adder_sp_toplevel.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_trisetup_fp32_round_helper.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_trisetup_multadd_toplevel.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_trisetup_multadd_compute_post_normalize_shifts.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_trisetup_multadd_normalize34.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_trisetup_multadd_normalize48.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_trisetup_multadd_2way_add_or_wide_add.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_trisetup_multadd_2way_add_w_shift.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_trisetup_multadd_3way_add_w_shift.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_trisetup_rcp_unit.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_trisetup_bary_unit.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_trisetup_bary_unit_rotate.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_trisetup_bary_unit_fp32_to_2_23.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_trisetup_bary_unit_multadd.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_trisetup_bary_unit_multadd_adder.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_trisetup_edge_unit.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_trisetup_edge_unit_adder.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_trisetup_edge_unit_fixed_to_vertex_coord.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_trisetup_edge_unit_fp32_to_fixed.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_trisetup_edge_unit_normalize.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_trisetup_edge_unit_signed_to_fp32.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_ra_toplevel.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_vl_toplevel.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_index_reorder.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_plr_toplevel.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_plr_pointer_manager.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_plr_pm_data_requestor.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_plr_pm_command_sorter.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_plr_list_fetcher.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_plr_multibank_rifo.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_plr_command_decompressor.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_plr_32_to_64_read_req_conv.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_plr_counter.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_plr_dbg.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_ppp.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_ppp_clock_controller.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_btb.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_blnd.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_blnd_srgb_to_rgb.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_blnd_comp.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_blnd_iter.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_blnd_msg_lut.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_blnd_ld_tile_buffer.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_blnd_msg_in.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_blnd_msg_out.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_blnd_subpixel_blender.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_blnd_tile_write.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_blnd_tile_write_pack.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_blnd_tile_read_demux.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_ppp_mbist.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_afbce.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_afbce_nxt_rt.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_afbce_addrgen_bbr.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_afbce_entr.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_afbce_entr_np.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_afbce_prep.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_afbce_ram_arbiter.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_afbce_addrgen.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_afbce_addrgen_mrtls.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_afbce_entr_stuf.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tib.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tib_mac.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tib_biu.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tib_col.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tib_col_eqc.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tib_col_buf.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tib_col_addr_dec.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tib_fbd.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tib_rshift.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tib_wb.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tib_wb_addr.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tib_wb_addr_axi.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tib_wb_addr_fsm.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tib_wb_addr_linear_calc.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tib_wb_addr_pix.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tib_wb_bc_mux.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tib_wb_fault.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tib_wb_fifo.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tib_wb_fifo_ctrl.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tib_wb_mem.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tib_wb_mem_aligner.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tib_wb_proc.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tib_wb_proc_yuv.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tib_wb_proc_yuv_trans.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tib_wb_proc_z.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tib_wb_proc_s.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tib_wb_proc_crc.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tib_wb_proc_pack.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tib_wb_proc_srgb_to_rgb.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tib_wb_te.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tib_zs.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tib_zs_buf.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tib_zs_addr_dec.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_utlb_lsc.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_utlb_lsc_respif.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_sdc.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_sdc_hsh_buf.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_axi_concentr.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_sdc_bus.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_sdc_data_fault.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_sdc_control.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_sdc_oq.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_sdc_rmu_tags.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_sdc_tags.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_sdc_vpd.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_sdc_vpd_data.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_sdc_bld.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_sdc_bld_data.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_sdc_bld_tags.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_sdc_rsd.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_sdc_rsd_data.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_sdc_tsd_data.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_sdc_dcd.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_sdc_dcd_data.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_sdc_dcd_alloc_ctrl.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_sdc_dcd_tags.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_sdc_dcd_retire.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_sdc_2nd_map.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_sdc_data.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_sdc_tex_satellite.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_sdc_ec_satellite.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_macro.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_macro_logic.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_toplevel.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_prf_cnt.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_sbf_ram_interface.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_mbist.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_coord_buf.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_clock_controller.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_quad_serializer.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_pipeline_control.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_axi_biu.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_afbcd_axi_biu.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_faultinfo.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_df_cache_line_tag.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_df_random_select.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_df_cache_line_selector.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_df_descr_cache.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_df_smd_cache.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_df_txd_cache.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_df_smd_check.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_df_txd_check.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_df_smdc_full_line.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_df_txdc_full_line.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_df_smdc_comp_line.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_df_txdc_comp_line.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_df_api_fault_check.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_df_txdc_fault_line.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_df_smdc_fault_line.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_df.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_msgin.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_msgin_input_buffer.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_msgin_msg_type_decoder.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_msgin_decoder.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_msgin_msg_hdr_dec.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_msgin_msg_pld_dec.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_buf_alloc.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_message_buffer.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_msgout.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_fifo.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_msgout_quad_fifo.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_msgout_demux.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_msgout_mux.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_msgout_bufrdr.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_msgout_nrm_compute.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_msgout_normalizor.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_msgout_normalizor_clamp.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_msgout_data_assembler.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_msgout_data_compressor.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_msgout_message_assembler.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_msgout_nrm_nn.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_msgout_nrm_nn_cmp0123_s0.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_msgout_nrm_nn_cmp0123_s1.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_msgout_nrm_nn_f32_to_f16.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_msgout_nrm_wn.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_msgout_nrm_wn_cmp0_s0.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_msgout_nrm_wn_cmp0_s1.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_msgout_nrm_wn_f32_to_f16.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_msgout_nrm_ux1_8_to_f32.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_msgout_conv_fp.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_f16_to_f32.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_f32_to_fxp1_27.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_f32_to_f16.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_f32_to_f16_trunc.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_f16_mul.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_gdg_half_log2.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_gdg_derivative.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_gdg_derivative_scaling.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_gdg_derivative_square_calculation.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_gdg_iso_lod_calculation.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_gdg_aniso_partial_result.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_gdg_lod_and_aniso.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_gdg_aniso_vector_calculator.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_gdg_input.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_gdg_calc.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_gdg_drvtv_and_scale.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_gdg_drvtv.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_gdg_drvtv_mux.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_gdg_scale.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_gdg_iso.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_gdg_aniso.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_gdg_lod_mux.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_gdg_lod_demux.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_gdg_lod_aniso_deg.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_gdg_output.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_gdg.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_gdg_result_scaling.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_sx3_27_to_fp32.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_f32_add_denormal.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_tf_bank_order_decode.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_tf_bor_modulo3_64.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_tf_bor_modulo3_8.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_tf.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_tf_afbc_index_remapping.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_tf_astc_adjacency_calculator.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_tf_aniso_offset_calculator.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_tf_aniso_offset_calculator_comp.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_tf_anisotropy_offsetter.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_tf_anisotropy_offsetter_comp.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_tf_bilinear_weight_calculator.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_tf_bilinear_weight_sfd_address_calculator.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_tf_cache_tester.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_tf_coal_address_selector.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_tf_coordinate_scale_and_wrap.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_tf_coordinate_scaler.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_tf_coordinate_scaler_comp.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_tf_cubemap_coordinate_converter.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_tf_cubemap_face_converter.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_tf_cubemap_texel_index_converter.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_tf_cubemap_coordinate_clamp.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_tf_instruction_decoder.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_tf_line_crossing_detector.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_tf_parking_buffer.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_tf_thread_gater.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_tf_sfd_address_calculator.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_tf_sfd_cache.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_tf_sfd_cache_line_tag.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_tf_tex_bank_selection.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_tf_tex_cache_ctrl.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_tf_tex_cache_block_remap.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_tf_tex_cache_data_fetcher.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_tf_tex_cache_texel_loader.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_tf_tex_cache_way.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_tf_tex_cache_mux_16_1.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_tf_tex_cache_mux_32_1.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_tf_tex_skew_mem_to_loc.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_tf_texel_address_assembly.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_tf_texel_address_calculator.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_tf_texel_address_generator.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_tf_texel_data_selector.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_tf_texel_index_converter.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_tf_texel_offsetter_coord_clamp.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_tf_txl_addr_dcprssr_ctnr.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_tf_txl_addr_dcprssr.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_tf_txl_addr_pckr.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_tf_float_to_fixedp_coord_converter.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_tf_texel_offset_reduction.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_tf_texel_offsetter_comp.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_tf_texture_cache.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_tf_texture_repeater_comp.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_tf_texture_repeater_cubemap_coord_converter.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_tf_thread_arbiter.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_tf_thread_progress_update.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_tf_thread_router.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_tf_wrap_cubemap_face_converter.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_tf_wrap_mode_calculator.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_tf_wrap_mode_coordinate_selection.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_tf_wrap_mode_texel_selector.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_tf_yuv_sub_texel_modifier.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_tf_yuv_component_pick.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_flt.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_flt_input.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_flt_output.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_flt_swizzle_and_border_ctrl.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_flt_narrow_unpacker.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_flt_narrow_unpackers.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_flt_wide_unpacker.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_flt_wide_unpackers.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_flt_block_decompressor.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_flt_narrow_block_decompressor.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_flt_texel_weight_calculation.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_flt_fp16weighed.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_flt_fp32weighed.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_flt_border_and_shadow.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_flt_border_calc.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_flt_shadow_comparator.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_flt_multi_valid_pipe.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_stall_multi_valid_pipe.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_flt_thread_out_pipe.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_flt_f32_to_nrm.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_flt_f32_to_nrm_cmp.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_flt_ints_router.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_flt_int_shadow_swz.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_flt_int_nn.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_flt_int_nn_exp.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_flt_int_nn_exp_cmp.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_flt_int_wn_exp.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_flt_int_wn_exp_cmp.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_flt_int_nn_lin.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_flt_int_nn_lin_cmp.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_flt_int_nn_sgn_mag.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_flt_int_nn_swz.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_flt_int_swz_dt.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_flt_int_nn_weight_mul.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_flt_int_wn.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_flt_int_wn_lin.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_flt_int_wn_lin_cmp.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_flt_int_wn_sgn_mag.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_flt_int_wn_srgb.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_flt_int_wn_swz.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_flt_int_wn_weight_mul.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_flt_int_fp16.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_flt_int_fp16_swz.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_flt_int_32b.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_flt_int_32b_swz.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_flt_int_32b_nn_swz.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_flt_int_fp32_weight_mul.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_flt_int_srgb_un12.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_9m5e_to_fp16.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_gdg_cube_map_face_transform.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_gdg_cube_map_descriptor_sub.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_bc6h_bc7_index_fetch.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_bc6h_color_decode.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_bc6h_color_picker.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_bc6h_finish_unquant.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_bc6h_unquantizer_full.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_bc6h_unquantizer_noadd.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_bc6h_unquantizer_reduced.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_bc7_color_decode.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_block_decompress.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_narrow_block_decompress.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_decompress_multiplier.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_dxt1_decode.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_eac_decode.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_eac_postprocess.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_etc2_decode.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_etc2_diff_add.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_ldr_postprocess.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_multiplier_input_reg.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_multiplier_mux.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_multiplier_output_reg.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_rgtc_decode.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_rgtc_postprocess.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_sc_lsc.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_sc_lsc_arb.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_sc_lsc_arb_arbmux.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_sc_lsc_arb_asnrdec.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_sc_lsc_arb_fwdprog.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_sc_lsc_arb_fwdprog_cnt.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_sc_lsc_arb_maintgen.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_sc_lsc_arb_pbreader.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_sc_lsc_arb_pbreader_cnt.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_sc_lsc_arb_wrr.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_sc_lsc_asnif_ar.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_sc_lsc_asnif_w.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_sc_lsc_ctrl.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_sc_lsc_da_alu.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_sc_lsc_da_alu_wrap.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_sc_lsc_fifo.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_sc_lsc_hash.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_sc_lsc_ihash.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_sc_lsc_pipe.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_sc_lsc_pipe_da.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_sc_lsc_pipe_ta.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_sc_lsc_pipe_ta2.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_sc_lsc_regslice.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_sc_lsc_ta2_ctrl.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_sc_lsc_ta2_fsm.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_sc_lsc_ta2_rt.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_sc_lsc_ta2_state_finder.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_sc_lsc_ta2_tag_compare.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_sc_lsc_ta2_vic_lru.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_sc_lsc_ta2_vic_replace.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_sc_lsc_ta2_victim_res.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_sc_lsc_ta2_victim_select.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_sc_lsc_ta2_wt.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_sc_lsc_utlbinval.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_sc_lsc_utlbmux.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_sc_lsc_wrr_arb.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_lsc_skry_mbist.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_z_and_stencil_frame.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_z_and_stencil.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_z_and_stencil_supersampler_wm_if.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_z_and_stencil_fpkq.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_lib_zs_skid_fifo_width20_depth4.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_z_and_stencil_fpkq_prio_queue_ctrl.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_z_and_stencil_fpkq_prio_queue_ctrl_core.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_z_and_stencil_reorder_core.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_z_and_stencil_reorder.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_z_and_stencil_msg_top.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_z_and_stencil_msg_in.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_z_and_stencil_msg_out.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_z_and_stencil_msg_out_buffer.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_z_and_stencil_prio_selector.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_z_calc.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_lib_zs_f32_add_multi_roundmode.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_lib_f32_add_multi_roundmode.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_zs_bitscan_offset_lsb.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_lib_zs_clz96.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_lib_bitscan_msb_w_8.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_lib_u10_to_fp32.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_lib_fp32_to_unorm32.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_lib_f32_mul_r.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_lib_f32_comp.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_astc_color_count_integers.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_astc_color_decode.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_astc_color_decode_hdr.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_astc_color_decode_ldr_rgb.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_astc_color_decode_misc.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_astc_color_decode_rgb_scale.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_astc_color_decode_rgba_delta.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_astc_color_integer_sequence_unpacker.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_astc_color_integer_unquantize_prepare.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_astc_color_unquantize_single_integer.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_astc_compute_index_weights_2d.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_astc_decode_index_bit_mode.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_astc_decode_postprocess.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_astc_decode_preprocess.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_astc_derive_implicits.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_astc_divide_by_blockdim.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_astc_get_color_endpoint_types.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_astc_hash52.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_astc_homogenous_block_coordinates.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_astc_homogenous_multiply.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_astc_homogenous_to_index_space.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_astc_index_integer_sequence_unpacker.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_astc_index_integer_unquantize_prepare.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_astc_index_interpolator.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_astc_index_interpolator_pair.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_astc_index_sequence_bitcount_onehot.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_astc_index_unquantize_single_integer.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_astc_index_unquantizer.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_astc_modulus_by_blockdim.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_astc_partition_comparator.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_astc_partition_multiply_add.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_astc_partition_process_coordinates.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_astc_partition_process_hash_results.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_astc_partition_selector.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_astc_pick_indexes_2d.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_astc_pick_weights_and_indexes.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_astc_pick_weights_and_indexes_3d.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_astc_quint_block_decode.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_astc_rgb_scale_mult.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_astc_squarer_u4h.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_astc_trit_block_decode.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_astc_preprocess.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_tex_dummy_passthrough.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_afbcd.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_afbcd_calc.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_afbcd_calc_pipeline.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_afbcd_cg.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_afbcd_dec4x4.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_afbcd_decprep.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_afbcd_fmt_bctree_l3_bits.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_afbcd_fmt_compbits.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_afbcd_fmt_defvals.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_afbcd_fmt_inputbits.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_afbcd_fmt_ncomponents.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_afbcd_fmt_texel_size.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_afbcd_fmt_rerun.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_afbcd_fmt_usbs.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_afbcd_fmt_yuv_transform.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_afbcd_fmt_sbs_mult.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_afbcd_hdrcache.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_afbcd_hdrcache_cache_ctrl.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_afbcd_hdrcache_cache_test.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_afbcd_hdrcache_fetcher.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_afbcd_hdrcache_fetcher_split.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_afbcd_pack.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_afbcd_payload_cache.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_afbcd_payload_cache_drt.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_afbcd_receive_id_dec.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_afbcd_res.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_afbcd_shifter.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_afbcd_trans.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_afbcd_yuv_invtrans.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_spb.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_asn_sc_bridge.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_asn_sc_interface.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_sc_lscbuf_fifo_reg.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_sc_lscbuf_data_buffer.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_sc_lscbuf_ctrl_buffer.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_sc_lscbuf_id_tracker.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_sc_lscbuf_req_creator.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_sc_lscbuf_resp_creator.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_sc_lscbuf_sp_buffer.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_sc_lscbuf.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_sc_arb_rr_alt.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_l1icache_arbiter.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_l1icache_aximif.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_l1icache_axisif.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_l1icache_dbuff.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_l1icache_pipe.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_l1icache_replay.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_l1icache_resp_buff.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_l1icache_tags.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_l1icache_toplevel.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_ec_ac_swz_valid.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_ec_fp2fp_extend_backend.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_ec_fp2fp_reduce.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_var_ld_attr_conv.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_ec_ld_conv.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_ec_ld_fe_conv.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_ec_ld_fe_mux.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_ec_ld_int_out.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_ec_ld_nint_reduce_mant.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_ec_ld_nint_replic.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_ec_ld_round_even.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_ec_ld_swz_en.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_ec_ld_type_enc.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_ec_ld_uint2fp_backend.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_ec_round_even_zero.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_ec_srgb5_fp16.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_ec_srgb6_fp16.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_ec_srgb8_fp16.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_vtile.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_vtile_rv_arb_core.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_vtile_rv_start_arb.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_vtile_rv_wb_arb.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_vtile_spawner.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_vtile_age_tracker.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_vtile_state.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_vtile_inc_dec_onehot.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_vtile_buffer_alloc.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_vtile_buffer_alloc_ctrl.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_vtile_fault_handler.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_ee_load_convert_altunorm_round.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_ee_load_convert_analyze_pfd.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_ee_load_convert_circular_add.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_ee_load_convert_compute_fp_expo.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_ee_load_convert_data_route.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_ee_load_convert_input_mask.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_ee_load_convert_lane.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_ee_load_convert_min_mux.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_ee_load_convert_prepare_controls.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_ee_load_convert_special_controls.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_ee_load_convert_srgb_table.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_ee_load_convert_top.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/verilog/mimir_ee_load_convert_multimsg_bitmap.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/include/mimir_fragment_constants.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/include/mimir_fs_jcb_endpoint_constants.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/include/mimir_ftc_functions.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/include/mimir_trisetup_constants.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/include/mimir_compute_constants.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/include/mimir_sc_constants.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/include/mimir_sc_conc_constants.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/include/mimir_rb_constants.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/include/mimir_rast_constants.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/include/mimir_plr_constants.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/include/mimir_vl_constants.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/include/mimir_afbce_constants.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/include/mimir_tib_constants.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/include/mimir_tex_constants.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/include/mimir_tex_flt_nn_constants.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/include/mimir_sdc_constants.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/include/mimir_sdc_oq_constants.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/include/mimir_sdc_tags_constants.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/include/mimir_sdc_dcd_tags_constants.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/include/mimir_sdc_rmu_constants.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/include/mimir_rsd_constants.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/include/mimir_dcd_constants.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/include/mimir_bld_constants.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/include/mimir_vpd_constants.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/include/mimir_tsd_constants.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/include/mimir_tex_unpacker_constants.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/include/mimir_blnd_constants.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/include/mimir_afbcd_constants.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/include/mimir_afbcd_dec4x4_constants.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/include/mimir_sc_lsc_constants.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/include/mimir_sc_lsc_constants_params.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/include/mimir_sc_lsc_constants_localparam.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/include/mimir_sc_lsc_includes.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/include/mimir_sc_lsc_func.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/include/mimir_zs_constants.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/include/mimir_zs_msg_constants.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/include/mimir_pdw_constants.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/include/mimir_var_constants.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/include/mimir_cu_constants.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/include/mimir_cu_functions.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/include/mimir_cu_reg_functions.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/include/mimir_ec_constants.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/include/mimir_ec_fault_code_constants.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/include/mimir_ee_constants.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/include/mimir_ee_msg_constants.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/include/mimir_attr_constants.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/include/mimir_fabric_constants.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/include/mimir_fabric_mfa_constants.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/include/mimir_fabric_msg_constants.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/include/mimir_cu_memory_constants.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/include/mimir_ic_constants.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/include/mimir_ic_functions.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/include/mimir_ee_func.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/include/mimir_ee_msg_func.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/include/mimir_ee_includes.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/include/mimir_ee_msg_includes.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/include/mimir_wm_includes.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/include/mimir_wm_constants.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/include/mimir_wm_functions.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/include/mimir_thread_creation_interface_constants.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/include/mimir_fabric_ep_functions.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/include/mimir_wmi_interface_constants.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/include/mimir_ec_pfs_funcs.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/include/mimir_ec_unorm_funcs.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/include/mimir_ec_ld_types.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/include/mimir_vtile_constants.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/include/mimir_compute_includes.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/include/mimir_compute_functions.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/include/mimir_sc_lscbuf_constants.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_shader_core/include/mimir_sc_lscbuf_includes.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_global/verilog/mimir_gl_logic.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_global/verilog/mimir_gl_scjcb.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_global/verilog/mimir_gl_scpdc.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_global/verilog/mimir_gl_cgpdc.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_global/verilog/mimir_gl_mbist_sequencer.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_global/verilog/mimir_gl_mbist.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_global/verilog/mimir_gl_mbist_intf.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_global/verilog/mimir_pdc.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_global/verilog/mimir_job_manager.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_global/verilog/mimir_jm_clock.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_global/verilog/mimir_jm_qactive_or.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_global/verilog/mimir_jm_haxi.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_global/verilog/mimir_jm_power.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_global/verilog/mimir_jm_jcb.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_global/verilog/mimir_jm_vaxi.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_global/verilog/mimir_jm_mmu.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_global/verilog/mimir_jm_mmu_as.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_global/verilog/mimir_jm_mmu_irq.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_global/verilog/mimir_jm_job.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_global/verilog/mimir_jm_job_idvs.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_global/verilog/mimir_jm_job_irq.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_global/verilog/mimir_jm_job_slot.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_global/verilog/mimir_jm_job_prefetch.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_global/verilog/mimir_jm_job_tasks.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_global/verilog/mimir_jm_job_ram.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_global/verilog/mimir_jm_job_epalloc.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_global/verilog/mimir_jm_glue.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_global/verilog/mimir_jm_gpu.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_global/verilog/mimir_jm_gpu_dbg.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_global/verilog/mimir_jm_gpu_irq.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_global/verilog/mimir_jm_gpu_timer.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_global/verilog/mimir_jm_gpu_prfcnt.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_global/verilog/mimir_jm_gpu_protect.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_global/verilog/mimir_jm_gpu_registers.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_global/verilog/mimir_jm_gpu_flush.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_global/verilog/mimir_jm_gpu_fault.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_global/verilog/mimir_jm_gpu_reset.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_global/verilog/mimir_jm_next_tile.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_global/verilog/mimir_jm_next_compute.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_global/verilog/mimir_jm_job_tilemap.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_global/include/mimir_jm_constants.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_global/include/mimir_jm_shader_hierarchy.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_global/include/mimir_jm_core_config.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_global/include/mimir_id_constants.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_global/include/mimir_haxi_constants.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_models/rams/generic/verilog/mimir_mem_2p.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_models/rams/generic/verilog/mimir_mem_sp.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_models/rams/generic/verilog/mimir_2p_118x10.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_models/rams/generic/verilog/mimir_2p_1888x10.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_models/rams/generic/verilog/mimir_2p_236x10.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_models/rams/generic/verilog/mimir_2p_472x10.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_models/rams/generic/verilog/mimir_2p_590x10.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_models/rams/generic/verilog/mimir_2p_59x10.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_models/rams/generic/verilog/mimir_2p_708x10.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_models/rams/generic/verilog/mimir_2p_944x10.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_models/rams/generic/verilog/mimir_2p_32x104_8.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_models/rams/generic/verilog/mimir_2p_16x128.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_models/rams/generic/verilog/mimir_2p_128x128.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_models/rams/generic/verilog/mimir_2p_128x64.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_models/rams/generic/verilog/mimir_2p_128x78.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_models/rams/generic/verilog/mimir_2p_168x92.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_models/rams/generic/verilog/mimir_2p_192x32.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_models/rams/generic/verilog/mimir_2p_192x36.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_models/rams/generic/verilog/mimir_2p_192x64_32.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_models/rams/generic/verilog/mimir_2p_200x72.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_models/rams/generic/verilog/mimir_2p_192x76.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_models/rams/generic/verilog/mimir_2p_24x90.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_models/rams/generic/verilog/mimir_2p_256x9.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_models/rams/generic/verilog/mimir_2p_256x128.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_models/rams/generic/verilog/mimir_2p_256x128_32.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_models/rams/generic/verilog/mimir_2p_256x16.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_models/rams/generic/verilog/mimir_2p_256x32.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_models/rams/generic/verilog/mimir_2p_256x32_8.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_models/rams/generic/verilog/mimir_2p_256x64.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_models/rams/generic/verilog/mimir_2p_256x65.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_models/rams/generic/verilog/mimir_2p_32x128.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_models/rams/generic/verilog/mimir_2p_32x128_8.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_models/rams/generic/verilog/mimir_2p_32x14.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_models/rams/generic/verilog/mimir_2p_32x48.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_models/rams/generic/verilog/mimir_2p_32x64_32.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_models/rams/generic/verilog/mimir_2p_42x82.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_models/rams/generic/verilog/mimir_2p_43x64.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_models/rams/generic/verilog/mimir_2p_48x128_8.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_models/rams/generic/verilog/mimir_2p_512x128_8.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_models/rams/generic/verilog/mimir_2p_512x64.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_models/rams/generic/verilog/mimir_2p_64x108.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_models/rams/generic/verilog/mimir_2p_64x112_28.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_models/rams/generic/verilog/mimir_2p_64x65_5.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_models/rams/generic/verilog/mimir_2p_64x72.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_models/rams/generic/verilog/mimir_2p_64x96.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_models/rams/generic/verilog/mimir_2p_l2owner.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_models/rams/generic/verilog/mimir_2p_l2rddata.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_models/rams/generic/verilog/mimir_2p_l2snoopdata.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_models/rams/generic/verilog/mimir_2p_l2state.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_models/rams/generic/verilog/mimir_2p_l2tag.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_models/rams/generic/verilog/mimir_2p_l2wrdata.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_models/rams/generic/verilog/mimir_2p_l2wrstrb.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_models/rams/generic/verilog/mimir_sp_128x128.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_models/rams/generic/verilog/mimir_sp_128x52.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_models/rams/generic/verilog/mimir_sp_128x64.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_models/rams/generic/verilog/mimir_sp_256x128_8.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_models/rams/generic/verilog/mimir_sp_256x16_1.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_models/rams/generic/verilog/mimir_sp_256x32.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_models/rams/generic/verilog/mimir_sp_256x42_3.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_models/rams/generic/verilog/mimir_sp_256x5.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_models/rams/generic/verilog/mimir_sp_256x52.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_models/rams/generic/verilog/mimir_sp_256x60_15.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_models/rams/generic/verilog/mimir_sp_256x64.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_models/rams/generic/verilog/mimir_sp_272x128_8.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_models/rams/generic/verilog/mimir_sp_32x52.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_models/rams/generic/verilog/mimir_sp_384x33_3.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_models/rams/generic/verilog/mimir_sp_384x45_3.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_models/rams/generic/verilog/mimir_sp_48x128.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_models/rams/generic/verilog/mimir_sp_512x116.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_models/rams/generic/verilog/mimir_sp_512x64.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_models/rams/generic/verilog/mimir_sp_576x64.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_models/rams/generic/verilog/mimir_sp_64x128.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_models/rams/generic/verilog/mimir_sp_64x64.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_models/rams/generic/verilog/mimir_sp_64x70_35.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_models/rams/generic/verilog/mimir_sp_64x72_36.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_models/rams/generic/verilog/mimir_sp_64x87.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_models/rams/generic/verilog/mimir_sp_96x110.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_models/rams/generic/verilog/mimir_sp_l2data.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_models/rams/generic/verilog/mimir_sp_l2strb.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_models/cells/generic/verilog/mimir_clock_gate.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_models/cells/generic/verilog/mimir_reset_sync.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_models/cells/generic/verilog/mimir_sync.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_models/cells/generic/verilog/mimir_gray_sync.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_models/modules/generic/verilog/mimir_gl_memories.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_models/modules/generic/verilog/mimir_cg_memories.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_models/modules/generic/verilog/mimir_sc_memories.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_models/modules/generic/verilog/mimir_gl_gating.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_models/modules/generic/verilog/mimir_cg_gating.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_models/modules/generic/verilog/mimir_sc_gating.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_models/modules/generic/verilog/mimir_pdc_adapter.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_models/modules/generic/verilog/mimir_ee_memories.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_models/modules/generic/verilog/mimir_var_memories.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_models/modules/generic/verilog/mimir_tex_macro_memories.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_models/modules/generic/verilog/mimir_tex_macro_gating.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_models/modules/generic/verilog/mimir_ee_gating.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_models/modules/generic/verilog/mimir_ec_gating.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_models/modules/generic/verilog/mimir_shader_tile_gating.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir/verilog/mimir_toplevel.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir/verilog/mimir_global.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir/verilog/mimir_cg_async.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir/verilog/mimir_shader_stack.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir/include/mimir_config.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir/include/mimir_fixed_config.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_asn_async_iso_ctrl.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_asn_async_bridge_cg.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_asn_async_bridge_stack.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_asn_bypass_stack_bridge.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_async_global_bridge_cg.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_async_global_bridge_gl.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_core_group.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_cg_mbist.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_cg_mbist_intf.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_cg_logic.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_cg_axi_mux.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_perf_mon_group.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_perf_mon.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_perf_mon_jcb_if.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_tiler_axi_wr.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_tiler_axi_wr_scoreboard.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_tiler_tcu.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_tiler_tcu_repeater.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_tiler_tcu_endpoint.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_tiler_clock_ctrl.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_tiler_reg_fifo.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_tiler_ready_reg.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_tiler_ht_iterator_fork.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_tiler_fast_prienc.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_tiler_jcb_interface.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_tiler_task_controller.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_tiler_task_fifo.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_tiler_descriptor_cache.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_tiler_vf_fifo.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_tiler_vf_tags.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_tiler_vf_bus.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_tiler_vf_output.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_tiler_index_fetcher.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_tiler_if_core.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_tiler_if_ctrl.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_tiler_vf_allocation.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_tiler_vertex_fetcher.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_tiler_vertex_prefetcher.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_tiler_primitive_assembly.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_tiler_bounding_box_generator.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_tiler_bbgen_sat.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_tiler_bbgen_sat_coeff.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_tiler_bbgen_sat_fp32_conv.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_tiler_bbgen_sat_tester.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_tiler_bbgen_state.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_tiler_bbgen_vtx_sorter.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_tiler_backface_table_calc.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_tiler_bbgen_f32_addsub.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_tiler_bbgen_macc.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_tiler_bbgen_dcalc.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_tiler_hierarchical_tiler.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_tiler_hierarchical_tiler_cost.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_tiler_memory_subsystem.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_tiler_ht_iterator.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_tiler_write_compressor.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_tiler_pcache_index_calc.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_tiler_pointer_cache.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_tiler_pointer_cache_ctrl.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_tiler_write_data_buffer.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_tiler_ref_cnt_array.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_tiler_tag_array.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_tiler_cache_validbits.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_tiler_pointer_manager.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_tiler_level_mask_calc.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_tiler_mbist.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_tiler_core.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_tiler_primitive_fetcher.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_tiler_primitive_process.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_tiler_prim_fetch_ctrl.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_tiler_prim_process_ctrl.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_tiler_cmd_process_ctrl.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_tiler_command_process.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_tiler_writeback.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_tiler_writeback_ctrl.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_tiler_interconnect.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_tiler_utlb_axi_wrapper.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_tiler_toplevel.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_tiler_heap_allocator.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_tiler_heap_mux.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_tiler_descr_control.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_tiler_descr_jd.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_tiler_descr_td.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_tiler_descr_vpd.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_tiler_descr_hd.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_tiler_descr_cache.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_tiler_descr_axi_mux.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_tiler_vbu.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_tiler_pf_fifo_ctrl.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_tiler_idvs_mux.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_tiler_fifo.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_l2c.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_l2c_mbist_intf.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_l2c_mbist_mux.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_l2c_arb.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_l2c_asn.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_l2c_ctrl.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_l2c_ext.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_l2c_sb.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_l2c_tp.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_l2c_dp.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_l2c_axi.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_l2c_axi_regslice.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_mmu_top.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_mmu_clock_ctrl.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_mmu_stage1.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_mmu_stage_core.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_mmu_stage_control.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_mmu_rmb.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_mmu_fifo_control.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_mmu_rmb_regslice.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_mmu_fault_mask.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_mmu_tlb.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_mmu_tlb_cache.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_mmu_tlb_hash_addr2way.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_mmu_tlb_range_check.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_mmu_tlb_l02_pipe.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_mmu_tlb_l02_tags.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_mmu_tlb_l3_pipe.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_mmu_tlb_locks.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_mmu_tlb_control.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_mmu_tlb_pteif.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_mmu_tlb_pteif_conv.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_mmu_tlb_ptwif.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_mmu_inv_ctrl.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_mmu_singlestage_ptwadp.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_asn_l2_bridge.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_asn_tiler_bridge.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_asn_tiler_jm_bridge.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_asn_mmu_bridge.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_asn_mmu_ar_bridge.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_asn_mmu_r_bridge.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_asn_mmu_req_bridge.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_asn_mmu_rsp_bridge.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_asn_jcb_bridge_m.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_asn_jcb_bridge_s.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_asn.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/verilog/mimir_asn_core.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/include/mimir_l2c_constants.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/include/mimir_l2c_includes.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/include/mimir_l2c_functions.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/include/mimir_l2c_sc_count.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/include/mimir_tiler_float_utils.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/include/mimir_perf_mon_constants.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/include/mimir_asn_frame_constants.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/include/mimir_asn_core_constants.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:file>
      <spirit:name>../../../logical/mimir_core_group/include/mimir_async_global_bridge_constants.v</spirit:name>
      <spirit:fileType>verilogSource-2001</spirit:fileType>
      <spirit:isIncludeFile>true</spirit:isIncludeFile>
    </spirit:file>
    <spirit:dependency>../../../logical/mimir_shared/include</spirit:dependency>
    <spirit:dependency>../../../logical/mimir_shader_core/include</spirit:dependency>
    <spirit:dependency>../../../logical/mimir_global/include</spirit:dependency>
    <spirit:dependency>../../../logical/mimir/include</spirit:dependency>
    <spirit:dependency>../../../logical/mimir_core_group/include</spirit:dependency>
  </spirit:fileSet>
</spirit:fileSets><spirit:description>ARM Mali Graphics Processing Unit (GPU)</spirit:description>
</spirit:component>
