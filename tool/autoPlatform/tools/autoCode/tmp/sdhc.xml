<?xml version="1.0" encoding="UTF-8"?>
	<spirit:component xmlns:kactus2="http://funbase.cs.tut.fi/" xmlns:spirit="http://www.spiritconsortium.org/XMLSchema/SPIRIT/1.5" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.spiritconsortium.org/XMLSchema/SPIRIT/1.5 http://www.spiritconsortium.org/XMLSchema/SPIRIT/1.5/index.xsd">
		<spirit:vendor>org.example</spirit:vendor>
		<spirit:library>example_lib</spirit:library>
		<spirit:name>sdhc</spirit:name>
		<spirit:version>example_version</spirit:version>
<spirit:memoryMaps>
<spirit:memoryMap>
<spirit:name>some_register_map</spirit:name>
<spirit:displayName>RDL Example Registers</spirit:displayName>
<spirit:addressBlock>
<spirit:name>some_register_map</spirit:name>
<spirit:displayName>ASR Module Registers</spirit:displayName>
<spirit:description>This address map contains some example registers to show how RDL can be utilized in various situations.</spirit:description>
<spirit:baseAddress>0xD4280000</spirit:baseAddress>
<spirit:range>0x2000</spirit:range>
<spirit:width>32</spirit:width>
<spirit:usage> </spirit:usage>
<spirit:volatile>true</spirit:volatile>
<spirit:register>
<spirit:name>SD_SYS_ADDR_LOW</spirit:name>
<spirit:description>System Address Low Register</spirit:description>
<spirit:addressOffset>0X00</spirit:addressOffset>
<spirit:size>32</spirit:size>
<spirit:volatile>true</spirit:volatile>
<spirit:access>read-write</spirit:access>
<spirit:reset>
<spirit:value>0</spirit:value>
<spirit:mask>0xffffffff</spirit:mask>
</spirit:reset>
<spirit:field>
<spirit:name>DMA_ADDR_L</spirit:name>
<spirit:description>dma address low   (1) 16 lsb of dma system buffer starting byte address.   (2)this register is used with the auto cmd 23 to set a 32-bit block count value to the argument of cmd23. this register would hold the lower 16bits of the cmd23 argument.</spirit:description>
<spirit:bitOffset>0</spirit:bitOffset>
<spirit:bitWidth>16</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
</spirit:register>
<spirit:register>
<spirit:name>SD_SYS_ADDR_HIGH</spirit:name>
<spirit:description>System Address High Register</spirit:description>
<spirit:addressOffset>0X02</spirit:addressOffset>
<spirit:size>32</spirit:size>
<spirit:volatile>true</spirit:volatile>
<spirit:access>read-write</spirit:access>
<spirit:reset>
<spirit:value>0</spirit:value>
<spirit:mask>0xffffffff</spirit:mask>
</spirit:reset>
<spirit:field>
<spirit:name>DMA_ADDR_H</spirit:name>
<spirit:description>dma address high  16 msb of dma system buffer starting byte address.   (2)this register is used with the auto cmd 23 to set a 32-bit block count value to the argument of cmd23. this register would hold the upper 16bits of the cmd23 argument.</spirit:description>
<spirit:bitOffset>0</spirit:bitOffset>
<spirit:bitWidth>16</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
</spirit:register>
<spirit:register>
<spirit:name>SD_BLOCK_SIZE</spirit:name>
<spirit:description>Block Size Register</spirit:description>
<spirit:addressOffset>0X04</spirit:addressOffset>
<spirit:size>32</spirit:size>
<spirit:volatile>true</spirit:volatile>
<spirit:access>read-write</spirit:access>
<spirit:reset>
<spirit:value>0</spirit:value>
<spirit:mask>0xffffffff</spirit:mask>
</spirit:reset>
<spirit:field>
<spirit:name>HOST_DMA_BDRY</spirit:name>
<spirit:description>host dma buffer boundary  this field specifies the host memory buffer boundary. if this boundary is crossed, an interrupt (dma_int) is generated. this interrupt is reflected in &lt;tx ready&gt; field in the normal interrupt status register.  0x0 = 4 kb  0x1 = 8 kb  0x2 = 16 kb  0x3 = 32 kb  0x4 = 64 kb  0x5 = 128 kb  0x6 = 256 kb  0x7 = 512 kb</spirit:description>
<spirit:bitOffset>12</spirit:bitOffset>
<spirit:bitWidth>3</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>SD1S_BLOCK_SIZE36</spirit:name>
<spirit:description>block size</spirit:description>
<spirit:bitOffset>0</spirit:bitOffset>
<spirit:bitWidth>12</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
</spirit:register>
<spirit:register>
<spirit:name>SD_BLOCK_COUNT</spirit:name>
<spirit:description>Block Count Register</spirit:description>
<spirit:addressOffset>0X06</spirit:addressOffset>
<spirit:size>32</spirit:size>
<spirit:volatile>true</spirit:volatile>
<spirit:access>read-write</spirit:access>
<spirit:reset>
<spirit:value>0</spirit:value>
<spirit:mask>0xffffffff</spirit:mask>
</spirit:reset>
<spirit:field>
<spirit:name>BLOCK_COUNT</spirit:name>
<spirit:description>block count  the host controller decrements the block count after each block transfer.  0x1 = 1 block  ...  0xffff = 65535 blocks  the current value of block count is reflected in the current block count register.</spirit:description>
<spirit:bitOffset>0</spirit:bitOffset>
<spirit:bitWidth>16</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
</spirit:register>
<spirit:register>
<spirit:name>SD_ARG_LOW</spirit:name>
<spirit:description>Argument Low Register</spirit:description>
<spirit:addressOffset>0X08</spirit:addressOffset>
<spirit:size>32</spirit:size>
<spirit:volatile>true</spirit:volatile>
<spirit:access>read-write</spirit:access>
<spirit:reset>
<spirit:value>0</spirit:value>
<spirit:mask>0xffffffff</spirit:mask>
</spirit:reset>
<spirit:field>
<spirit:name>ARG_L</spirit:name>
<spirit:description>argument low  16 lsb of command argument  this value is inserted into 48 bits command token bits[23:8].</spirit:description>
<spirit:bitOffset>0</spirit:bitOffset>
<spirit:bitWidth>16</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
</spirit:register>
<spirit:register>
<spirit:name>SD_ARG_HIGH</spirit:name>
<spirit:description>Argument High Register</spirit:description>
<spirit:addressOffset>0X0A</spirit:addressOffset>
<spirit:size>32</spirit:size>
<spirit:volatile>true</spirit:volatile>
<spirit:access>read-write</spirit:access>
<spirit:reset>
<spirit:value>0</spirit:value>
<spirit:mask>0xffffffff</spirit:mask>
</spirit:reset>
<spirit:field>
<spirit:name>ARG_H</spirit:name>
<spirit:description>argument high  16 msb of command argument  this value is inserted into 48 bits command token bits[39:24].</spirit:description>
<spirit:bitOffset>0</spirit:bitOffset>
<spirit:bitWidth>16</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
</spirit:register>
<spirit:register>
<spirit:name>SD_TRANSFER_MODE</spirit:name>
<spirit:description>Transfer Mode Register</spirit:description>
<spirit:addressOffset>0X0C</spirit:addressOffset>
<spirit:size>32</spirit:size>
<spirit:volatile>true</spirit:volatile>
<spirit:access>read-write</spirit:access>
<spirit:reset>
<spirit:value>0</spirit:value>
<spirit:mask>0xffffffff</spirit:mask>
</spirit:reset>
<spirit:field>
<spirit:name>MULTI_BLK_SEL</spirit:name>
<spirit:description>multiple block select  this bit should be set to 1 only when multiple blocks are to be transferred.</spirit:description>
<spirit:bitOffset>5</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>TO_HOST_DIR</spirit:name>
<spirit:description>data transfer direction select  this bit defines the direction of the mmc1_dat[3:0] line data transfer. this bit is set to 1 by the host driver to transfer data from the sd card to the sd host controller, and it is set to 0 for all other commands.</spirit:description>
<spirit:bitOffset>4</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>AUTO_CMD_EN</spirit:name>
<spirit:description>auto cmd enable  this field determines use of auto command functions.  0x0 = auto command disabled  0x1 = auto cmd12 enable  0x2 = auto cmd23 enable  0x3 = reserved</spirit:description>
<spirit:bitOffset>2</spirit:bitOffset>
<spirit:bitWidth>2</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>BLK_CNT_EN</spirit:name>
<spirit:description>block count enable  this bit validates the value in the block count register.</spirit:description>
<spirit:bitOffset>1</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>SD1S_DMA_EN69</spirit:name>
<spirit:description>dma enable  if programmed input/output (pio) mode is required, this bit should be reset to 0.</spirit:description>
<spirit:bitOffset>0</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
</spirit:register>
<spirit:register>
<spirit:name>SD_CMD</spirit:name>
<spirit:description>Command Register</spirit:description>
<spirit:addressOffset>0X0E</spirit:addressOffset>
<spirit:size>32</spirit:size>
<spirit:volatile>true</spirit:volatile>
<spirit:access>read-write</spirit:access>
<spirit:reset>
<spirit:value>0</spirit:value>
<spirit:mask>0xffffffff</spirit:mask>
</spirit:reset>
<spirit:field>
<spirit:name>CMD_INDEX</spirit:name>
<spirit:description>command index  these bits will be inserted into command token bits[45:40]</spirit:description>
<spirit:bitOffset>8</spirit:bitOffset>
<spirit:bitWidth>6</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>SD1S_CMD_TYPE78</spirit:name>
<spirit:description>command type  0x0 = normal command  0x1 = suspend command  0x2 = resume command  0x3 = abort command</spirit:description>
<spirit:bitOffset>6</spirit:bitOffset>
<spirit:bitWidth>2</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>DATA_PRESENT</spirit:name>
<spirit:description>data present  1 = indicates that data is present and will be transferred using the mmc1_dat[3:0] line.  0 = commands using only mmc1_cmd lines or commands with no data transfer but using busy signal on mmc1_dat[0] line (for example, cmd 38)</spirit:description>
<spirit:bitOffset>5</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>CMD_INDEX_CHK_EN</spirit:name>
<spirit:description>command index check enable  1 = host controller checks the index field in the response to see if it has the same value as the command index. if it is not, it is reported as a command index error.</spirit:description>
<spirit:bitOffset>4</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>CMD_CRC_CHK_EN</spirit:name>
<spirit:description>command crc check enable  1 = host controller checks the crc field in the response. if an error is detected, it is reported as a command crc error. the number of bits checked by the crc field value changes according to the length of response.</spirit:description>
<spirit:bitOffset>3</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>RESP_TYPE</spirit:name>
<spirit:description>response type select for sd/sd in spi modes  for sd mode:  0x0 = no response  0x1 = response length is 136 bits  0x2 = response length is 48 bits  0x3 = response length is 48 bits and check busy after response  crc field for r3 and r4 is expected to be all 1 bits. crc check should be disabled for these response types.    for sd in spi mode:  0x0 = response length is 8 bits  0x1 = response length is 16 bits  0x2 = response length is 40 bits  0x3 = reserved</spirit:description>
<spirit:bitOffset>0</spirit:bitOffset>
<spirit:bitWidth>2</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
</spirit:register>
<spirit:register>
<spirit:name>SD_RESP_0</spirit:name>
<spirit:description>Response Register 0</spirit:description>
<spirit:addressOffset>0X10</spirit:addressOffset>
<spirit:size>32</spirit:size>
<spirit:volatile>true</spirit:volatile>
<spirit:access>read-write</spirit:access>
<spirit:reset>
<spirit:value>0</spirit:value>
<spirit:mask>0xffffffff</spirit:mask>
</spirit:reset>
<spirit:field>
<spirit:name>RESP0</spirit:name>
<spirit:description>response 0  this register contains bits[23:8] of the response token.</spirit:description>
<spirit:bitOffset>0</spirit:bitOffset>
<spirit:bitWidth>16</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
</spirit:register>
<spirit:register>
<spirit:name>SD_RESP_1</spirit:name>
<spirit:description>Response Register 1</spirit:description>
<spirit:addressOffset>0X12</spirit:addressOffset>
<spirit:size>32</spirit:size>
<spirit:volatile>true</spirit:volatile>
<spirit:access>read-write</spirit:access>
<spirit:reset>
<spirit:value>0</spirit:value>
<spirit:mask>0xffffffff</spirit:mask>
</spirit:reset>
<spirit:field>
<spirit:name>RESP1</spirit:name>
<spirit:description>response 1  this register contains bits[39:24] of the response token.</spirit:description>
<spirit:bitOffset>0</spirit:bitOffset>
<spirit:bitWidth>16</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
</spirit:register>
<spirit:register>
<spirit:name>SD_RESP_2</spirit:name>
<spirit:description>Response Register 2</spirit:description>
<spirit:addressOffset>0X14</spirit:addressOffset>
<spirit:size>32</spirit:size>
<spirit:volatile>true</spirit:volatile>
<spirit:access>read-write</spirit:access>
<spirit:reset>
<spirit:value>0</spirit:value>
<spirit:mask>0xffffffff</spirit:mask>
</spirit:reset>
<spirit:field>
<spirit:name>RESP2</spirit:name>
<spirit:description>response 2  for 48-bits response token, this register is don't care.  for 136-bits response token, this register contains bits[55:40] of the response token.</spirit:description>
<spirit:bitOffset>0</spirit:bitOffset>
<spirit:bitWidth>16</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
</spirit:register>
<spirit:register>
<spirit:name>SD_RESP_3</spirit:name>
<spirit:description>Response Register 3</spirit:description>
<spirit:addressOffset>0X16</spirit:addressOffset>
<spirit:size>32</spirit:size>
<spirit:volatile>true</spirit:volatile>
<spirit:access>read-write</spirit:access>
<spirit:reset>
<spirit:value>0</spirit:value>
<spirit:mask>0xffffffff</spirit:mask>
</spirit:reset>
<spirit:field>
<spirit:name>RESP3</spirit:name>
<spirit:description>response 3  for 48-bits response token, this register is don't care.  for 136-bits response token, this register contains bits[71:56] of the response token.</spirit:description>
<spirit:bitOffset>0</spirit:bitOffset>
<spirit:bitWidth>16</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
</spirit:register>
<spirit:register>
<spirit:name>SD_RESP_4</spirit:name>
<spirit:description>Response Register 4</spirit:description>
<spirit:addressOffset>0X18</spirit:addressOffset>
<spirit:size>32</spirit:size>
<spirit:volatile>true</spirit:volatile>
<spirit:access>read-write</spirit:access>
<spirit:reset>
<spirit:value>0</spirit:value>
<spirit:mask>0xffffffff</spirit:mask>
</spirit:reset>
<spirit:field>
<spirit:name>RESP4</spirit:name>
<spirit:description>response 4  for 48-bits response token, this register is don't care.  for 136-bits response token, this register contains bits[87:72] of response token.</spirit:description>
<spirit:bitOffset>0</spirit:bitOffset>
<spirit:bitWidth>16</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
</spirit:register>
<spirit:register>
<spirit:name>SD_RESP_5</spirit:name>
<spirit:description>Response Register 5</spirit:description>
<spirit:addressOffset>0X1A</spirit:addressOffset>
<spirit:size>32</spirit:size>
<spirit:volatile>true</spirit:volatile>
<spirit:access>read-write</spirit:access>
<spirit:reset>
<spirit:value>0</spirit:value>
<spirit:mask>0xffffffff</spirit:mask>
</spirit:reset>
<spirit:field>
<spirit:name>RESP5</spirit:name>
<spirit:description>response 5  for 48 bits response token, this register is don't care.  for 136 bits response token, this register contains bits[103:88] of response token.</spirit:description>
<spirit:bitOffset>0</spirit:bitOffset>
<spirit:bitWidth>16</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
</spirit:register>
<spirit:register>
<spirit:name>SD_RESP_6</spirit:name>
<spirit:description>Response Register 6</spirit:description>
<spirit:addressOffset>0X1C</spirit:addressOffset>
<spirit:size>32</spirit:size>
<spirit:volatile>true</spirit:volatile>
<spirit:access>read-write</spirit:access>
<spirit:reset>
<spirit:value>0</spirit:value>
<spirit:mask>0xffffffff</spirit:mask>
</spirit:reset>
<spirit:field>
<spirit:name>RESP6</spirit:name>
<spirit:description>response 6  for 48-bits response token, this register is don't care.  for 136-bits response token, this register contains bits[119:104] of the response token.  for auto cmd12 response, this register contains bits[23:8] of the response token.</spirit:description>
<spirit:bitOffset>0</spirit:bitOffset>
<spirit:bitWidth>16</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
</spirit:register>
<spirit:register>
<spirit:name>SD_RESP_7</spirit:name>
<spirit:description>Response Register 7</spirit:description>
<spirit:addressOffset>0X1E</spirit:addressOffset>
<spirit:size>32</spirit:size>
<spirit:volatile>true</spirit:volatile>
<spirit:access>read-write</spirit:access>
<spirit:reset>
<spirit:value>0</spirit:value>
<spirit:mask>0xffffffff</spirit:mask>
</spirit:reset>
<spirit:field>
<spirit:name>RESP7</spirit:name>
<spirit:description>response 7  for 48-bits response token, this register is don't care.  for 136-bits response token, this register contains bits[127:120] of the response token.  for auto cmd12 response, this register contains bits[39:24] of the response token.</spirit:description>
<spirit:bitOffset>0</spirit:bitOffset>
<spirit:bitWidth>16</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
</spirit:register>
<spirit:register>
<spirit:name>SD_BUFFER_DATA_PORT_0</spirit:name>
<spirit:description>Buffer Data Port 0 Register</spirit:description>
<spirit:addressOffset>0X20</spirit:addressOffset>
<spirit:size>32</spirit:size>
<spirit:volatile>true</spirit:volatile>
<spirit:access>read-write</spirit:access>
<spirit:reset>
<spirit:value>0</spirit:value>
<spirit:mask>0xffffffff</spirit:mask>
</spirit:reset>
<spirit:field>
<spirit:name>CPU_DATA0</spirit:name>
<spirit:description>processor data 0  16 lsb of the buffer</spirit:description>
<spirit:bitOffset>0</spirit:bitOffset>
<spirit:bitWidth>16</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
</spirit:register>
<spirit:register>
<spirit:name>SD_BUFFER_DATA_PORT_1</spirit:name>
<spirit:description>Buffer Data Port 1 Register</spirit:description>
<spirit:addressOffset>0X22</spirit:addressOffset>
<spirit:size>32</spirit:size>
<spirit:volatile>true</spirit:volatile>
<spirit:access>read-write</spirit:access>
<spirit:reset>
<spirit:value>0</spirit:value>
<spirit:mask>0xffffffff</spirit:mask>
</spirit:reset>
<spirit:field>
<spirit:name>CPU_DATA1</spirit:name>
<spirit:description>processor data 1  16 msb of the buffer</spirit:description>
<spirit:bitOffset>0</spirit:bitOffset>
<spirit:bitWidth>16</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
</spirit:register>
<spirit:register>
<spirit:name>SD_PRESENT_STATE_1</spirit:name>
<spirit:description>Present State Register 1</spirit:description>
<spirit:addressOffset>0X24</spirit:addressOffset>
<spirit:size>32</spirit:size>
<spirit:volatile>true</spirit:volatile>
<spirit:access>read-write</spirit:access>
<spirit:reset>
<spirit:value>0</spirit:value>
<spirit:mask>0xffffffff</spirit:mask>
</spirit:reset>
<spirit:field>
<spirit:name>BUFFER_RD_EN</spirit:name>
<spirit:description>buffer read enable  this field changes from 0x0 to 0x1 when block data is ready in the buffer and from 0x1 to 0x0 when all the block data is read from the buffer.</spirit:description>
<spirit:bitOffset>11</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>BUFFER_WR_EN</spirit:name>
<spirit:description>buffer write enable  this field changes from 0x0 to 0x1 when block data can be written to the buffer. so if this bit is set to 0x1, the entire block can be written to the buffer.  this field changes from 0x1 to 0x0 when all the block data is written to the buffer.</spirit:description>
<spirit:bitOffset>10</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>RX_ACTIVE</spirit:name>
<spirit:description>rx active  this field indicates read transfer is active.  1 = set:</spirit:description>
<spirit:bitOffset>9</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>TX_ACTIVE</spirit:name>
<spirit:description>tx active  indicates write transfer is active.  0 = no valid write data exists in the host controller  1 = set:</spirit:description>
<spirit:bitOffset>8</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>RETUNING_REQ</spirit:name>
<spirit:description>re-tuning request  this field provides the status of the sampling clock.  0x0 = fixed or well tuned sampling clock  1 = sampling clock needs re-tuning</spirit:description>
<spirit:bitOffset>3</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>_DAT_ACTIVE</spirit:name>
<spirit:description>data line active  this field provides the status of the data line.  0 = data line is free  1 = data line is in use</spirit:description>
<spirit:bitOffset>2</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>CMD_INHIBIT_DAT</spirit:name>
<spirit:description>command inhibit data  this field provides the host driver status for issuing data commands.  0 = data command can be issued  1 = data command cannot be issued</spirit:description>
<spirit:bitOffset>1</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>CMD_INHIBIT_CMD</spirit:name>
<spirit:description>command inhibit command  if this bit is 0, it indicates the mmc1_cmd line is not in use, and the host controller can issue a command using mmc1_cmd line. this bit is set after the command register is written. this bit is cleared when the command response is received. even if the &lt;command inhibit data&gt; field is set to 1, commands using only the mmc1_cmd line can be issued if this bit is 0. changing from 1 to 0 generates a command complete interrupt in the normal interrupt status register. if the host controller cannot issue the command because of a command conflict error, this bit remains 1, and the command complete is not set.</spirit:description>
<spirit:bitOffset>0</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
</spirit:register>
<spirit:register>
<spirit:name>SD_PRESENT_STATE_2</spirit:name>
<spirit:description>Present State Register 2</spirit:description>
<spirit:addressOffset>0X26</spirit:addressOffset>
<spirit:size>32</spirit:size>
<spirit:volatile>true</spirit:volatile>
<spirit:access>read-write</spirit:access>
<spirit:reset>
<spirit:value>0</spirit:value>
<spirit:mask>0xffffffff</spirit:mask>
</spirit:reset>
<spirit:field>
<spirit:name>CMD_LEVEL</spirit:name>
<spirit:description>mmc1_cmd line signal level  this status is used to check the mmc1_cmd line level to recover from errors and for debugging.</spirit:description>
<spirit:bitOffset>8</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>DAT_LEVEL190</spirit:name>
<spirit:description>mmc1_dat[3:0] line signal level  this status is used to check the mmc1_dat[3:0] line level to recover from errors and for debugging. this is especially useful in detecting the busy signal level from mmc1_dat[0].</spirit:description>
<spirit:bitOffset>4</spirit:bitOffset>
<spirit:bitWidth>4</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>WRITE_PROT</spirit:name>
<spirit:description>write protect  this field reflects the position of the write_protect latch on the sd card. this field should be ignored if there is no such feature being provided by the card in use.</spirit:description>
<spirit:bitOffset>3</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>CARD_DET</spirit:name>
<spirit:description>card detect  this field reflects the value of the mmc1_cd pin. this field is only used for testing.  0 = card not detected  1 = card detected</spirit:description>
<spirit:bitOffset>2</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>CARD_STABLE</spirit:name>
<spirit:description>card stable  this field is only used for testing. it indicates the debounced value of the card present condition.  0 = card unstable  1 = card stable</spirit:description>
<spirit:bitOffset>1</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>CARD_INSERTED</spirit:name>
<spirit:description>card inserted  this field indicates the presence of an sd card.  0 = card not inserted  1 = card inserted</spirit:description>
<spirit:bitOffset>0</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
</spirit:register>
<spirit:register>
<spirit:name>SD_HOST_CTRL</spirit:name>
<spirit:description>Host Control Register</spirit:description>
<spirit:addressOffset>0X28</spirit:addressOffset>
<spirit:size>32</spirit:size>
<spirit:volatile>true</spirit:volatile>
<spirit:access>read-write</spirit:access>
<spirit:reset>
<spirit:value>0</spirit:value>
<spirit:mask>0xffffffff</spirit:mask>
</spirit:reset>
<spirit:field>
<spirit:name>SD_BUS_VLT</spirit:name>
<spirit:description>sd bus voltage  this field reflects the voltage at operating conditions.  0x7 = 3.3v  0x6 = 3.0v  0x5 = 1.8v  0x0 to 0x4 = reserved</spirit:description>
<spirit:bitOffset>9</spirit:bitOffset>
<spirit:bitWidth>3</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>SD_BUS_POWER</spirit:name>
<spirit:description>sd bus power  this field controls the power going out to the sd card. it will be cleared if one of the following occurs: the sd_bus_vlt and the voltage support in the capabilities register 1 do not match or if a card removal state was detected.</spirit:description>
<spirit:bitOffset>8</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>CARD_DET_S</spirit:name>
<spirit:description>card detect signal selection  this field selects the source for card detection.  0 = card detect input pin  1 = card detect test level (for debugging purposes only)  when the source for card detection is switched, the interrupt should be disabled during the switching period by clearing the normal interrupt status enable register in order to mask unexpected interrupts being caused by the glitch.  this signal should be disabled via the normal interrupt status enable register during debounce period.</spirit:description>
<spirit:bitOffset>7</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>CARD_DET_L</spirit:name>
<spirit:description>card detect test level  1 = card inserted  0 = no card inserted</spirit:description>
<spirit:bitOffset>6</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>EX_DATA_WIDTH</spirit:name>
<spirit:description>this bit controls the 8-bit mode.  0x0 = data width for bus mode is determined by &lt;data_width&gt;.  0x1 = 8-bit data width.</spirit:description>
<spirit:bitOffset>5</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>DMA_SEL</spirit:name>
<spirit:description>dma select  one of supported dma modes as selected. the host driver checks support of dma modes using the capabilities register 1. use of the selected dma is determined by the &lt;dma enable&gt; field in the transfer mode register.  0x0 = sdma  0x1 = adma 1  0x2 = 32-bit address adma2  0x3 = reserved</spirit:description>
<spirit:bitOffset>3</spirit:bitOffset>
<spirit:bitWidth>2</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>HI_SPEED_EN</spirit:name>
<spirit:description>extend data output enable  0 = normal  1 = mmc1_cmd and mmc1_dat[3:0] are driven from rising edge of clock</spirit:description>
<spirit:bitOffset>2</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>DATA_WIDTH</spirit:name>
<spirit:description>data width  1 = 4-bit data mode  0 = 1-bit data mode, using only mmc1_dat[0]  refer to the ce-ata register 2 for 8-bit mode support.</spirit:description>
<spirit:bitOffset>1</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>LED_CTRL</spirit:name>
<spirit:description>led control  1 = led on  0 = led off</spirit:description>
<spirit:bitOffset>0</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
</spirit:register>
<spirit:register>
<spirit:name>SD_BLOCK_GAP_CTRL</spirit:name>
<spirit:description>Block Gap Control Register</spirit:description>
<spirit:addressOffset>0X2A</spirit:addressOffset>
<spirit:size>32</spirit:size>
<spirit:volatile>true</spirit:volatile>
<spirit:access>read-write</spirit:access>
<spirit:reset>
<spirit:value>0</spirit:value>
<spirit:mask>0xffffffff</spirit:mask>
</spirit:reset>
<spirit:field>
<spirit:name>W_REMOVAL</spirit:name>
<spirit:description>wakeup on card removal  1 = enable wakeup event on card removal detection  0 = no wakeup event</spirit:description>
<spirit:bitOffset>10</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>W_INSERTION</spirit:name>
<spirit:description>wakeup on card insertion  1 = enable wakeup event on card insertion detection  0 = no wakeup event</spirit:description>
<spirit:bitOffset>9</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>W_CARD_INT</spirit:name>
<spirit:description>wakeup on card interrupt  1 = enable wakeup event on card interrupt detection  0 = no wakeup event</spirit:description>
<spirit:bitOffset>8</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>INT_BLK_GAP</spirit:name>
<spirit:description>block gap interrupt  this field is only valid for 4-bit mode.  1 = enables interrupt detection at block gap for multiple block transfers</spirit:description>
<spirit:bitOffset>3</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>RD_WAIT_CTL</spirit:name>
<spirit:description>read wait control  if the card supports read wait, set this bit to enable use of the read wait protocol to stop read data using the mmc1_dat[2] line by host hardware. otherwise, host controller has to stop sd clock to hold read data. when the host driver detects a card insertion, it will set this bit according to the cccr of the sdio card.</spirit:description>
<spirit:bitOffset>2</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>CONT_REQ</spirit:name>
<spirit:description>continue request  this field is used to restart a transaction which was stopped using the &lt;stop at block gap request&gt;. to cancel stop at the block gap, set the &lt;stop at block gap request&gt; field to 0 and set this field to 1 to restart the transfer. host controller automatically clears this field in either of the following cases:</spirit:description>
<spirit:bitOffset>1</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>STOP_AT_BLOCK_GAP_REQ</spirit:name>
<spirit:description>stop at block gap request  this field is used to stop executing a transaction at the next block gap for both dma and non-dma transfers. until the transfer complete is set to 1, indicating a transfer completion, the host driver will leave this bit set to 1. clearing both this field and the &lt;continue request&gt; field will not cause the transaction to restart. read wait is used to stop the read transaction at the block gap. the host controller will stop the clock at block gap request for write transfer, but for read transfer, it will stop the clock if &lt;read wait control&gt; is 0. otherwise, the host controller issues a read wait command to stop read data.</spirit:description>
<spirit:bitOffset>0</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
</spirit:register>
<spirit:register>
<spirit:name>SD_CLOCK_CTRL</spirit:name>
<spirit:description>Clock Control Register</spirit:description>
<spirit:addressOffset>0X2C</spirit:addressOffset>
<spirit:size>32</spirit:size>
<spirit:volatile>true</spirit:volatile>
<spirit:access>read-write</spirit:access>
<spirit:reset>
<spirit:value>0</spirit:value>
<spirit:mask>0xffffffff</spirit:mask>
</spirit:reset>
<spirit:field>
<spirit:name>SD_FREQ_SEL_LO</spirit:name>
<spirit:description>sdclk frequency select lower bits  this along with &lt;sd_freq_sel_hi&gt; define the clock divider value to be used by the host controller. so the final sd_freq_sel = {sd_freq_sel_hi[1:0],sd_freq_sel_lo[7:0]}. the selected value is multiplied by 2 to get the actual divide value. for. e.g   sd_freq_sel = 0x00 = base clock   sd_freq_sel = 0x01 = divide by 2 of base clock  sd_freq_sel = 0x02 = divide by 4 of base clock   sd_freq_sel = 0x3 = divide by 6 of base clock.  ...  sd_freq_sel = 0x3ff = divide by 2046 of base clock.</spirit:description>
<spirit:bitOffset>8</spirit:bitOffset>
<spirit:bitWidth>8</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>SD_FREQ_SEL_HI</spirit:name>
<spirit:description>sdclk frequency select upper bits  this along with &lt;sd_freq_sel_lo&gt; define the clock divider value to be used by the host controller. so the final sd_freq_sel = {sd_freq_sel_hi[1:0],sd_freq_sel_lo[7:0]}. the selected value is multiplied by 2 to get the actual divide value. for. e.g   sd_freq_sel = 0x00 = base clock   sd_freq_sel = 0x01 = divide by 2 of base clock  sd_freq_sel = 0x02 = divide by 4 of base clock   sd_freq_sel = 0x3 = divide by 6 of base clock.  ...  sd_freq_sel = 0x3ff = divide by 2046 of base clock.</spirit:description>
<spirit:bitOffset>6</spirit:bitOffset>
<spirit:bitWidth>2</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>CLK_GEN_SEL</spirit:name>
<spirit:description>clock generator select  this field is used to select the clock generator mode.  0x1 = programmable clock mode  0x0 = divided clock mode</spirit:description>
<spirit:bitOffset>5</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>SD_CLK_EN</spirit:name>
<spirit:description>sdclk clock enable  this bit controls the sdclk to the card. before using the card, this bit should be set during the initialization phase.</spirit:description>
<spirit:bitOffset>2</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>INT_CLK_STABLE</spirit:name>
<spirit:description>internal clock stable  this field is set to 1 once the controller detects that the internal clock is stable after setting of the &lt;internal clock enable&gt; field.</spirit:description>
<spirit:bitOffset>1</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>INT_CLK_EN</spirit:name>
<spirit:description>internal clock enable  this field controls the sdclk to the internal logic.  1 = enable clock  0 = disable</spirit:description>
<spirit:bitOffset>0</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
</spirit:register>
<spirit:register>
<spirit:name>SD_TIMEOUT_CTRL_SW_RESET</spirit:name>
<spirit:description>Timeout Control/Software Reset Register</spirit:description>
<spirit:addressOffset>0X2E</spirit:addressOffset>
<spirit:size>32</spirit:size>
<spirit:volatile>true</spirit:volatile>
<spirit:access>read-write</spirit:access>
<spirit:reset>
<spirit:value>0</spirit:value>
<spirit:mask>0xffffffff</spirit:mask>
</spirit:reset>
<spirit:field>
<spirit:name>SW_RST_DAT</spirit:name>
<spirit:description>soft reset for data port of logic</spirit:description>
<spirit:bitOffset>10</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>SW_RST_CMD</spirit:name>
<spirit:description>soft reset for command part of logic</spirit:description>
<spirit:bitOffset>9</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>SW_RST_ALL</spirit:name>
<spirit:description>software reset for all  this reset affects the status, state machine, and fifos synchronously.   this field also resets all private registers.</spirit:description>
<spirit:bitOffset>8</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>TIMEOUT_VALUE</spirit:name>
<spirit:description>timeout value  determines the interval by which mmc1_dat[3:0] line timeouts are detected. this timeout is initiated in the following cases:</spirit:description>
<spirit:bitOffset>0</spirit:bitOffset>
<spirit:bitWidth>4</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
</spirit:register>
<spirit:register>
<spirit:name>SD_NORMAL_INT_STATUS</spirit:name>
<spirit:description>Normal Interrupt Status Register</spirit:description>
<spirit:addressOffset>0X30</spirit:addressOffset>
<spirit:size>32</spirit:size>
<spirit:volatile>true</spirit:volatile>
<spirit:access>read-write</spirit:access>
<spirit:reset>
<spirit:value>0</spirit:value>
<spirit:mask>0xffffffff</spirit:mask>
</spirit:reset>
<spirit:field>
<spirit:name>ERR_INT</spirit:name>
<spirit:description>error interrupt  if any of bits in the error interrupt status register are set, then this bit is set.</spirit:description>
<spirit:bitOffset>15</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>CQ_INT</spirit:name>
<spirit:description>command queuing interrupt
   this interrupt is asserted when at least one of the bits in cqis register is set. this interrupt is cleared only clearing the source interrupt in cqis register</spirit:description>
<spirit:bitOffset>14</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>RETUNING_INT</spirit:name>
<spirit:description>re-tuning event interrupt  this status is set if re-tuning request in the &lt;present state register&gt; changes from 0x0 to 0x1.   host controller requests host driver to perform re-tuning fro next data transfer. current data transfer can be completed without re-tuning.</spirit:description>
<spirit:bitOffset>12</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>INT_C</spirit:name>
<spirit:description>this status is set if int_c is enabled and int_c# pin is in low level. writing this bit to 0x1 does not clear this bit. it is cleared by resetting the int_c interrupt factor. refer to shared bus control register.</spirit:description>
<spirit:bitOffset>11</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>INT_B</spirit:name>
<spirit:description>this status is set if int_b is enabled and int_b# pin is in low level. writing this bit to 0x1 does not clear this bit. it is cleared by resetting the int_b interrupt factor. refer to shared bus control register.</spirit:description>
<spirit:bitOffset>10</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>INT_A</spirit:name>
<spirit:description>this status is set if int_a is enabled and int_a# pin is in low level. writing this bit to 0x1 does not clear this bit. it is cleared by resetting the int_a interrupt factor. refer to shared bus control register.</spirit:description>
<spirit:bitOffset>9</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>CARD_INT</spirit:name>
<spirit:description>card interrupt  1 = host controller detects an interrupt from the card</spirit:description>
<spirit:bitOffset>8</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>CARD_REM_INT</spirit:name>
<spirit:description>card removal interrupt  1 = card removal event detected</spirit:description>
<spirit:bitOffset>7</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>CARD_INS_INT</spirit:name>
<spirit:description>card insertion interrupt  1 = card insertion event detected</spirit:description>
<spirit:bitOffset>6</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>RX_RDY</spirit:name>
<spirit:description>rx ready  this status is set if the &lt;buffer read enable&gt; field in the present state register 1 changes from 0x0 to 0x1.</spirit:description>
<spirit:bitOffset>5</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>TX_RDY</spirit:name>
<spirit:description>tx ready  this status is set if the &lt;buffer write enable&gt; field in the present state register 1 changes from 0x0 to 0x1.</spirit:description>
<spirit:bitOffset>4</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>DMA_INT</spirit:name>
<spirit:description>dma interrupt  this status is set if the host controller detects dma crossing over the &lt;host dma buffer boundary&gt; field in the block size register.</spirit:description>
<spirit:bitOffset>3</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>BLOCK_GAP_EVT</spirit:name>
<spirit:description>block gap event  if the &lt;stop at block gap request&gt; field in the block gap control register is set, this field is set when both a read/write transaction is stopped at a block gap. if the &lt;stop at block gap request&gt; field is not set to 1, this bit is not set to 1.</spirit:description>
<spirit:bitOffset>2</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>XFER_COMPLETE</spirit:name>
<spirit:description>transfer complete  this bit is set when a read/write transaction is completed  for read transaction, this bit is set at the falling edge of read transfer active status. there are two cases in which this occurs:</spirit:description>
<spirit:bitOffset>1</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>CMD_COMPLETE</spirit:name>
<spirit:description>command complete  this bit is set when the end bit of the command response (except auto cmd12) is received. note that command timeout error has higher priority than command complete.</spirit:description>
<spirit:bitOffset>0</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
</spirit:register>
<spirit:register>
<spirit:name>SD_ERROR_INT_STATUS</spirit:name>
<spirit:description>Error Interrupt Status Register</spirit:description>
<spirit:addressOffset>0X32</spirit:addressOffset>
<spirit:size>32</spirit:size>
<spirit:volatile>true</spirit:volatile>
<spirit:access>read-write</spirit:access>
<spirit:reset>
<spirit:value>0</spirit:value>
<spirit:mask>0xffffffff</spirit:mask>
</spirit:reset>
<spirit:field>
<spirit:name>CRC_STATUS_ERR</spirit:name>
<spirit:description>crc status error  1 = crc status start bit or crc status end bit or boot ack status, returned from the card in write transaction has errors</spirit:description>
<spirit:bitOffset>15</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>CPL_TIMEOUT_ERR</spirit:name>
<spirit:description>command completion signal timeout error  this field is applicable for ce-ata mode only.  1 = a command completion signal timeout occurred</spirit:description>
<spirit:bitOffset>14</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>AXI_RESP_ERR</spirit:name>
<spirit:description>axi bus response error  1 = a response other than &lt;q&gt;okay&lt;/q&gt; was received on the axi bus.</spirit:description>
<spirit:bitOffset>13</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>SPI_ERR</spirit:name>
<spirit:description>spi mode error  1 = error occurred in spi mode for which cause can be determined by reading the &lt;spi error token&gt; field in the spi mode register  0 = no error has occurred</spirit:description>
<spirit:bitOffset>12</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>ADMA_ERR</spirit:name>
<spirit:description>adma (advanced direct memory access) error  this bit is set when the host controller detects any errors during an adma-based data transfer. the adma state at the time an error occurs is saved in the adma error status register.  the host controller also generates this interrupt when it detects any invalid descriptor data. the &lt;adma error state&gt; field in the adma error status register indicates the state in which an error occurred. the host driver may find that a valid bit is not set at the error descriptor.  1 = error  0 = no error</spirit:description>
<spirit:bitOffset>9</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>AUTO_CMD12_ERR</spirit:name>
<spirit:description>auto cmd12 error  occurs when detecting that one of the bits in auto cmd12 error status register has changed from 0 to 1.</spirit:description>
<spirit:bitOffset>8</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>CUR_LIMIT_ERR</spirit:name>
<spirit:description>current limit error  this feature is not supported and this bit will always be read as 0.</spirit:description>
<spirit:bitOffset>7</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>RD_DATA_END_BIT_ERR</spirit:name>
<spirit:description>readdata end bit error  1 = 0 detected at the end bit position of read data which uses the mmc1_dat[3:0] line or at the end bit position of the crc status</spirit:description>
<spirit:bitOffset>6</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>RD_DATA_CRC_ERR</spirit:name>
<spirit:description>read data crc error  1 = read data which uses the mmc1_dat[3:0] line transferred or write crc status having a value other than 010 detected</spirit:description>
<spirit:bitOffset>5</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>DATA_TIMEOUT_ERR</spirit:name>
<spirit:description>data timeout error  1 = set when one of the following is detected:</spirit:description>
<spirit:bitOffset>4</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>CMD_INDEX_ERR</spirit:name>
<spirit:description>command index error  0 = no command index error has occurred in the command response  1 = command index error has occurred in the command response</spirit:description>
<spirit:bitOffset>3</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>CMD_END_BIT_ERR</spirit:name>
<spirit:description>command end bit error  0 = detection of end bit of a command response in 1  1 = detection of end bit of a command response is 0</spirit:description>
<spirit:bitOffset>2</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>CMD_CRC_ERR</spirit:name>
<spirit:description>command crc error  1 = set in two cases:</spirit:description>
<spirit:bitOffset>1</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>CMD_TIMEOUT_ERR</spirit:name>
<spirit:description>command timeout error  1 = no response is returned within 64 sdclk cycles from the end bit of the command</spirit:description>
<spirit:bitOffset>0</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
</spirit:register>
<spirit:register>
<spirit:name>SD_NORMAL_INT_STATUS_EN</spirit:name>
<spirit:description>Normal Interrupt Status Enable Register</spirit:description>
<spirit:addressOffset>0X34</spirit:addressOffset>
<spirit:size>32</spirit:size>
<spirit:volatile>true</spirit:volatile>
<spirit:access>read-write</spirit:access>
<spirit:reset>
<spirit:value>0</spirit:value>
<spirit:mask>0xffffffff</spirit:mask>
</spirit:reset>
<spirit:field>
<spirit:name>CQ_STATUS_EN</spirit:name>
<spirit:description>command queuing status enable</spirit:description>
<spirit:bitOffset>14</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>RETUNE_INT_EN</spirit:name>
<spirit:description>re_tuning interrupt enable  0 = disabled  1 = enabled</spirit:description>
<spirit:bitOffset>12</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>INT_C_INT_EN</spirit:name>
<spirit:description>int_c enable  0 = disabled  1 = enabled</spirit:description>
<spirit:bitOffset>11</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>INT_B_INT_EN</spirit:name>
<spirit:description>int_b enable  0 = disabled  1 = enabled</spirit:description>
<spirit:bitOffset>10</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>INT_A_INT_EN</spirit:name>
<spirit:description>int_a enable  0 = disabled  1 = enabled</spirit:description>
<spirit:bitOffset>9</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>CARD_INT_EN</spirit:name>
<spirit:description>card interrupt enable  0 = disabled  1 = enabled</spirit:description>
<spirit:bitOffset>8</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>CARD_REM_EN</spirit:name>
<spirit:description>card removal status enable  0 = disabled  1 = enabled</spirit:description>
<spirit:bitOffset>7</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>CARD_INS_EN</spirit:name>
<spirit:description>card insertion status enable  0 = disabled  1 = enabled</spirit:description>
<spirit:bitOffset>6</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>RD_RDY_EN</spirit:name>
<spirit:description>buffer read ready enable  0 = disabled  1 = enabled</spirit:description>
<spirit:bitOffset>5</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>TX_RDY_EN</spirit:name>
<spirit:description>buffer write ready enable  0 = disabled  1 = enabled</spirit:description>
<spirit:bitOffset>4</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>DMA_INT_EN</spirit:name>
<spirit:description>dma interrupt enable  0 = disabled  1 = enabled</spirit:description>
<spirit:bitOffset>3</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>BLOCK_GAP_EVT_EN</spirit:name>
<spirit:description>block gap event enable  0 = disabled  1 = enabled</spirit:description>
<spirit:bitOffset>2</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>XFER_COMPLETE_EN</spirit:name>
<spirit:description>transfer complete enable  0 = disabled  1 = enabled</spirit:description>
<spirit:bitOffset>1</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>CMD_COMPLETE_EN</spirit:name>
<spirit:description>command complete enable  0 = disabled  1 = enabled</spirit:description>
<spirit:bitOffset>0</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
</spirit:register>
<spirit:register>
<spirit:name>SD_ERROR_INT_STATUS_EN</spirit:name>
<spirit:description>Error Interrupt Status Enable Register</spirit:description>
<spirit:addressOffset>0X36</spirit:addressOffset>
<spirit:size>32</spirit:size>
<spirit:volatile>true</spirit:volatile>
<spirit:access>read-write</spirit:access>
<spirit:reset>
<spirit:value>0</spirit:value>
<spirit:mask>0xffffffff</spirit:mask>
</spirit:reset>
<spirit:field>
<spirit:name>CRC_STATUS_ERR_EN</spirit:name>
<spirit:description>crc status error enable  0 = disabled  1 = enabled</spirit:description>
<spirit:bitOffset>15</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>CPL_TIMEOUT_ERR_EN</spirit:name>
<spirit:description>cpl timeout error enable  0 = disabled  1 = enabled</spirit:description>
<spirit:bitOffset>14</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>AXI_RESP_ERR_EN</spirit:name>
<spirit:description>axi response error enable  0 = disabled  1 = enabled</spirit:description>
<spirit:bitOffset>13</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>SPI_ERR_EN</spirit:name>
<spirit:description>spi error enable  0 = disabled  1 = enabled</spirit:description>
<spirit:bitOffset>12</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>TUNING_ERR_EN</spirit:name>
<spirit:description>tuning error enable  0 = disabled  1 = enabled</spirit:description>
<spirit:bitOffset>10</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>ADMA_ERR_EN</spirit:name>
<spirit:description>adma error enable  0 = disabled  1 = enabled</spirit:description>
<spirit:bitOffset>9</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>AUTO_CMD12_ERR_EN</spirit:name>
<spirit:description>auto cmd12 error enable  0 = disabled  1 = enabled</spirit:description>
<spirit:bitOffset>8</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>CUR_LIM_ERR_EN</spirit:name>
<spirit:description>current limit error enable  0 = disabled  1 = enabled</spirit:description>
<spirit:bitOffset>7</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>RD_DATA_END_BIT_ERR_EN</spirit:name>
<spirit:description>data end bit error enable  0 = disabled  1 = enabled</spirit:description>
<spirit:bitOffset>6</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>RD_DATA_CRC_ERR_EN</spirit:name>
<spirit:description>data crc error enable  0 = disabled  1 = enabled</spirit:description>
<spirit:bitOffset>5</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>DATA_TIMEOUT_ERR_EN</spirit:name>
<spirit:description>data timeout error enable  0 = disabled  1 = enabled</spirit:description>
<spirit:bitOffset>4</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>CMD_INDEX_ERR_EN</spirit:name>
<spirit:description>command index error enable  0 = disabled  1 = enabled</spirit:description>
<spirit:bitOffset>3</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>CMD_END_BIT_ERR_EN</spirit:name>
<spirit:description>command end bit error enable  0 = disabled  1 = enabled</spirit:description>
<spirit:bitOffset>2</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>CMD_CRC_ERR_EN</spirit:name>
<spirit:description>command crc error enable  0 = disabled  1 = enabled</spirit:description>
<spirit:bitOffset>1</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>CMD_TIMEOUT_ERR_EN</spirit:name>
<spirit:description>command timeout error enable  0 = disabled  1 = enabled</spirit:description>
<spirit:bitOffset>0</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
</spirit:register>
<spirit:register>
<spirit:name>SD_NORMAL_INT_STATUS_INT_EN</spirit:name>
<spirit:description>Normal Interrupt Status Interrupt Enable Register</spirit:description>
<spirit:addressOffset>0X38</spirit:addressOffset>
<spirit:size>32</spirit:size>
<spirit:volatile>true</spirit:volatile>
<spirit:access>read-write</spirit:access>
<spirit:reset>
<spirit:value>0</spirit:value>
<spirit:mask>0xffffffff</spirit:mask>
</spirit:reset>
<spirit:field>
<spirit:name>CQ_SIGNAL_ENABLE</spirit:name>
<spirit:description>command queuing signal enable</spirit:description>
<spirit:bitOffset>14</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>RETUNE_INT_INT_EN</spirit:name>
<spirit:description>re-tuning interrupt interrupt enable  0 = disabled  1 = enabled</spirit:description>
<spirit:bitOffset>12</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>INT_C_INT_INT_EN</spirit:name>
<spirit:description>int_c interrupt interrupt enable  0 = disabled  1 = enabled</spirit:description>
<spirit:bitOffset>11</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>INT_B_INT_INT_EN</spirit:name>
<spirit:description>int_b interrupt interrupt enable  0 = disabled  1 = enabled</spirit:description>
<spirit:bitOffset>10</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>INT_A_INT_INT_EN</spirit:name>
<spirit:description>int_a interrupt interrupt enable  0 = disabled  1 = enabled</spirit:description>
<spirit:bitOffset>9</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>CARD_INT_INT_EN</spirit:name>
<spirit:description>card interrupt interrupt enable  0 = disabled  1 = enabled</spirit:description>
<spirit:bitOffset>8</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>CARD_REM_INT_EN</spirit:name>
<spirit:description>card removal interrupt enable  0 = disabled  1 = enabled</spirit:description>
<spirit:bitOffset>7</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>CARD_INS_INT_EN</spirit:name>
<spirit:description>card insertion interrupt enable  0 = disabled  1 = enabled</spirit:description>
<spirit:bitOffset>6</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>RX_RDY_INT_EN</spirit:name>
<spirit:description>buffer read ready interrupt enable  0 = disabled  1 = enabled</spirit:description>
<spirit:bitOffset>5</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>TX_RDY_INT_EN</spirit:name>
<spirit:description>buffer write ready interrupt enable  0 = disabled  1 = enabled</spirit:description>
<spirit:bitOffset>4</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>DMA_INT_INT_EN</spirit:name>
<spirit:description>dma interrupt interrupt enable  0 = disabled  1 = enabled</spirit:description>
<spirit:bitOffset>3</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>BLOCK_GAP_EVT_INT_EN</spirit:name>
<spirit:description>block gap event interrupt enable  0 = disabled  1 = enabled</spirit:description>
<spirit:bitOffset>2</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>XFER_COMPLETE_INT_EN</spirit:name>
<spirit:description>transfer complete interrupt enable  0 = disabled  1 = enabled</spirit:description>
<spirit:bitOffset>1</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>CMD_COMPLETE_INT_EN</spirit:name>
<spirit:description>command complete interrupt enable  0 = disabled  1 = enabled</spirit:description>
<spirit:bitOffset>0</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
</spirit:register>
<spirit:register>
<spirit:name>SD_ERROR_INT_STATUS_INT_EN</spirit:name>
<spirit:description>Error Interrupt Status Interrupt Enable Register</spirit:description>
<spirit:addressOffset>0X3A</spirit:addressOffset>
<spirit:size>32</spirit:size>
<spirit:volatile>true</spirit:volatile>
<spirit:access>read-write</spirit:access>
<spirit:reset>
<spirit:value>0</spirit:value>
<spirit:mask>0xffffffff</spirit:mask>
</spirit:reset>
<spirit:field>
<spirit:name>CRC_STATUS_ERR_INT_EN</spirit:name>
<spirit:description>crc status error interrupt enable  0 = disabled  1 = enabled</spirit:description>
<spirit:bitOffset>15</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>CPL_TIMEOUT_ERR_INT_EN</spirit:name>
<spirit:description>cpl timeout error interrupt enable  0 = disabled  1 = enabled</spirit:description>
<spirit:bitOffset>14</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>AXI_RESP_ERR_INT_EN</spirit:name>
<spirit:description>axi response error interrupt enable  0 = disabled  1 = enabled</spirit:description>
<spirit:bitOffset>13</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>SPI_ERR_INT_EN</spirit:name>
<spirit:description>spi error interrupt enable  0 = disabled  1 = enabled</spirit:description>
<spirit:bitOffset>12</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>TUNE_ERR_INT_EN</spirit:name>
<spirit:description>tuning error interrupt enable  0 = disabled  1 = enabled</spirit:description>
<spirit:bitOffset>10</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>ADMA_ERR_INT_EN</spirit:name>
<spirit:description>adma error interrupt enable  0 = disabled  1 = enabled</spirit:description>
<spirit:bitOffset>9</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>AUTO_CMD12_ERR_INT_EN</spirit:name>
<spirit:description>auto cmd12 error interrupt enable  0 = disabled  1 = enabled</spirit:description>
<spirit:bitOffset>8</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>CUR_LIM_ERR_INT_EN</spirit:name>
<spirit:description>current limit error interrupt enable  0 = disabled  1 = enabled</spirit:description>
<spirit:bitOffset>7</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>RD_DATA_END_BIT_ERR_INT_EN</spirit:name>
<spirit:description>data end bit error interrupt enable  0 = disabled  1 = enabled</spirit:description>
<spirit:bitOffset>6</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>RD_DATA_CRC_ERR_INT_EN</spirit:name>
<spirit:description>data crc error interrupt enable  0 = disabled  1 = enabled</spirit:description>
<spirit:bitOffset>5</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>DATA_TIMEOUT_ERR_INT_EN</spirit:name>
<spirit:description>data timeout error interrupt enable  0 = disabled  1 = enabled</spirit:description>
<spirit:bitOffset>4</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>CMD_INDEX_ERR_INT_EN</spirit:name>
<spirit:description>command index error interrupt enable  0 = disabled  1 = enabled</spirit:description>
<spirit:bitOffset>3</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>CMD_END_BIT_ERR_INT_EN</spirit:name>
<spirit:description>command end bit interrupt error enable  0 = disabled  1 = enabled</spirit:description>
<spirit:bitOffset>2</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>CMD_CRC_ERR_INT_EN</spirit:name>
<spirit:description>command crc error interrupt enable  0 = disabled  1 = enabled</spirit:description>
<spirit:bitOffset>1</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>CMD_TIMEOUT_ERR_INT_EN</spirit:name>
<spirit:description>command timeout error interrupt enable  0 = disabled  1 = enabled</spirit:description>
<spirit:bitOffset>0</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
</spirit:register>
<spirit:register>
<spirit:name>SD_AUTO_CMD12_ERROR_STATUS</spirit:name>
<spirit:description>Auto CMD12 Error Status Register</spirit:description>
<spirit:addressOffset>0X3C</spirit:addressOffset>
<spirit:size>32</spirit:size>
<spirit:volatile>true</spirit:volatile>
<spirit:access>read-write</spirit:access>
<spirit:reset>
<spirit:value>0</spirit:value>
<spirit:mask>0xffffffff</spirit:mask>
</spirit:reset>
<spirit:field>
<spirit:name>CMD_NOT_ISSUED</spirit:name>
<spirit:description>command not issued due to auto_cmd12 error</spirit:description>
<spirit:bitOffset>7</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>AUTO_CMD_INDEX_ERR</spirit:name>
<spirit:description>auto cmd12 or auto cmd23 error  this error occurs if the command index error occurs in response to a command  0 = disabled  1 = enabled</spirit:description>
<spirit:bitOffset>4</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>AUTO_CMD_END_BIT_ERR</spirit:name>
<spirit:description>auto cmd12 or auto cmd23end bit error  this error occurs when detecting that the end bit of command response is 0.  0 = disabled  1 = enabled</spirit:description>
<spirit:bitOffset>3</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>AUTO_CMD_CRC_ERR</spirit:name>
<spirit:description>auto cmd12 or auto cmd23 crc error  this error occurs when detecting crc error in the command response.  0 = disabled  1 = enabled</spirit:description>
<spirit:bitOffset>2</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>AUTO_CMD_TIMEOUT_ERR</spirit:name>
<spirit:description>auto cmd12 or auto cmd23 timeout error  this error occurs if no response is returned within 64 sdclk cycles from the end bit of command.  0 = disabled  1 = enabled</spirit:description>
<spirit:bitOffset>1</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>AUTO_CMD12_NOT_EXE</spirit:name>
<spirit:description>auto cmd12 not executed  this error occurs when host controller cannot issue auto cmd12 to stop multiple block data transfer due to some errors.  0 = disabled  1 = enabled</spirit:description>
<spirit:bitOffset>0</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
</spirit:register>
<spirit:register>
<spirit:name>HOST_CTRL_2</spirit:name>
<spirit:description>Host Control 2 Register</spirit:description>
<spirit:addressOffset>0X3E</spirit:addressOffset>
<spirit:size>32</spirit:size>
<spirit:volatile>true</spirit:volatile>
<spirit:access>read-write</spirit:access>
<spirit:reset>
<spirit:value>0</spirit:value>
<spirit:mask>0xffffffff</spirit:mask>
</spirit:reset>
<spirit:field>
<spirit:name>PRE_VAL_EN</spirit:name>
<spirit:description>preset value enable  0x1 = automatic selection by preset value are enabled  0x0 = sdclk and driver strength are controlled by host driver</spirit:description>
<spirit:bitOffset>15</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>ASYNC_INT_EN</spirit:name>
<spirit:description>asynchronous interrupt enable   this bit can be set to 0x1 if a card supports asynchronous interrupts and &lt;async_int_support&gt; is set to 0x1 in the capabilities register. asynchronous interrupt is effective when dat[1] interrupt is used in 4-bit sd mode (and zero is set to &lt;int_pin_sel&gt; in shared bus control register). if this bit is set to 0x1, the host driver can stop the sdclk during asynchronous interrupt period to save power. during this period, the host controller continues to deliver the card interrupt to the host when it is asserted by the card.   0x1 = enabled  0x0 = disabled</spirit:description>
<spirit:bitOffset>14</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>SAMPLING_CLK_SEL</spirit:name>
<spirit:description>sampling clock select  host controller uses this bit to select sampling clock to receive cmd and dat. this bit is set by tuning procedure and valid after the completion of tuning (when &lt;exe_tuning&gt; is cleared). setting 0x1 means that tuning is completed successfully and setting 0x0 means that tuning is failed. writing 0x1 to this bit is meaningless and ignored. a tuning circuit is reset by writing 0x0. this bit can be cleared by setting &lt;exe_tuning&gt;. once the tuning circuit is reset, it will take time to complete tuning sequence. therefore, host driver should keep this bit to 0x1 to perform re-tuning sequence in a short time. change of this bit is not allowed while the host controller is receiving response or a read data block.   0x1 = tuned clock is used to sample data  0x0 = fixed clock is used to sample data.</spirit:description>
<spirit:bitOffset>7</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>EXE_TUNING</spirit:name>
<spirit:description>execute tuning.  this bit is set to 0x1 to start tuning procedure and automatically cleared when tuning procedure is completed. the result of the tuning is indicated to &lt;sampling_clk_sel&gt;. tuning procedure is aborted by writing 0x0.   0x1 = execute tuning.  0x0 = not tuned or tuning completed.</spirit:description>
<spirit:bitOffset>6</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>DRV_STRENGTH_SEL</spirit:name>
<spirit:description>driver strength select.  host controller output driver in 1.8v signaling is selected by this field. in 3.3v signaling this field is not effective. this field can be set depending on driver type a, c and d support bits in the capabilities register.   this bit depends on setting of &lt;pre_val_en&gt;. if &lt;pre_val_en&gt; = 0x0, this field is set by the host driver. if &lt;pre_val_en&gt; = 0x1, this field is automatically set by a value specified in one of the preset value registers.  0x0 = driver type b  0x1 = driver type a  0x2 = driver type c  0x3 = driver type d</spirit:description>
<spirit:bitOffset>4</spirit:bitOffset>
<spirit:bitWidth>2</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>SDH_V18_EN</spirit:name>
<spirit:description>1.8v signaling enable  0x1 = 1.8v signaling enable  0x0 = 3.3v signaling enable</spirit:description>
<spirit:bitOffset>3</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>UHS_MODE_SEL</spirit:name>
<spirit:description>uhs mode select. this field is used to select one of uhs-i modes and effective when &lt;sdh_v18_en&gt; = 0x1.  if &lt;pre_val_en&gt; in the host control2 register is set to 0x1, host controller set sdclk frequency select, clock generator select in the clock control register and driver strength select according to the preset value registers. in this case, one of the preset value registers is selected by this field. host driver should reset &lt;sd_clk_en&gt; before changing this field to avoid generating clock glitch  0x0 = sdr12  0x1 = sdr25  0x2 = sdr50  0x3 = sdr104  0x4 = ddr50  all other values are reserved
for mmc mode, added two backdoor defined modes:
  5(101) hs200 mode
  5(110) hs400 mode
normally sw only need set rx114 hs200/hs400 modes</spirit:description>
<spirit:bitOffset>0</spirit:bitOffset>
<spirit:bitWidth>3</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
</spirit:register>
<spirit:register>
<spirit:name>SD_CAPABILITIES_1</spirit:name>
<spirit:description>Capabilities Register 1</spirit:description>
<spirit:addressOffset>0X40</spirit:addressOffset>
<spirit:size>32</spirit:size>
<spirit:volatile>true</spirit:volatile>
<spirit:access>read-write</spirit:access>
<spirit:reset>
<spirit:value>0</spirit:value>
<spirit:mask>0xffffffff</spirit:mask>
</spirit:reset>
<spirit:field>
<spirit:name>BASE_FREQ</spirit:name>
<spirit:description>base frequency  the base clock frequency for sdclk  0xc8 = 200 mhz (actually 198.24 mhz).  0x0 means get info via other method.</spirit:description>
<spirit:bitOffset>8</spirit:bitOffset>
<spirit:bitWidth>8</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>TIMEOUT_UNIT</spirit:name>
<spirit:description>timeout unit  the unit of base clock used to detect timeouts.  1 = mhz  0 = khz</spirit:description>
<spirit:bitOffset>7</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>TIMEOUT_FREQ</spirit:name>
<spirit:description>timeout frequency  this value indicates the base clock frequency used to detect timeouts.  0x32 = 50 mhz (actually 49.56 mhz).  0x0 means get info via other method.</spirit:description>
<spirit:bitOffset>0</spirit:bitOffset>
<spirit:bitWidth>6</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
</spirit:register>
<spirit:register>
<spirit:name>SD_CAPABILITIES_2</spirit:name>
<spirit:description>Capabilities Register 2</spirit:description>
<spirit:addressOffset>0X42</spirit:addressOffset>
<spirit:size>32</spirit:size>
<spirit:volatile>true</spirit:volatile>
<spirit:access>read-write</spirit:access>
<spirit:reset>
<spirit:value>0</spirit:value>
<spirit:mask>0xffffffff</spirit:mask>
</spirit:reset>
<spirit:field>
<spirit:name>CFG_SLOT_TYPE</spirit:name>
<spirit:description>slot type  this field indicates what type of slot the host controller is connected to.  0x0 = removable card slot  0x1 = embedded slot for one device  0x2 = shared bus slot  0x3 = reserved</spirit:description>
<spirit:bitOffset>14</spirit:bitOffset>
<spirit:bitWidth>2</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>ASYNC_INT_SUPPORT</spirit:name>
<spirit:description>asynchronous interrupt support.  0x1 = asynchronous interrupt supported  0x0 = asynchronous interrupt not supported</spirit:description>
<spirit:bitOffset>13</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>SYS_BUS_64_SUPPORT</spirit:name>
<spirit:description>64-bit system bus support  this bit indicates whether the host controller is capable of 64-bit system bus.  0x1 = 64-bit system bus supported, 0x0 = 64-bit system bus not supported.</spirit:description>
<spirit:bitOffset>12</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>VLG_18_SUPPORT</spirit:name>
<spirit:description>voltage support 1.8v  this bit indicates whether the host controller is capable of 1.8v.  0x1 = 1.8v supported, 0x0 = 1.8v not supported.</spirit:description>
<spirit:bitOffset>10</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>VLG_30_SUPPORT</spirit:name>
<spirit:description>voltage support 3.0v  this bit indicates whether the host controller is capable of 3.0v.  0x1 = 3.0v supported, 0x0 = 3.0v not supported.</spirit:description>
<spirit:bitOffset>9</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>VLG_33_SUPPORT</spirit:name>
<spirit:description>voltage support 3.3v  this bit indicates whether the host controller is capable of 3.3v.  0x1 = 3.3v supported, 0x0 = 3.3v not supported.</spirit:description>
<spirit:bitOffset>8</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>SUS_RES_SUPPORT</spirit:name>
<spirit:description>suspend resume support  this bit indicates whether the host controller is capable of suspend resume commands.  0x1 = suspend/resume supported, 0x0 = suspend/resume not supported.</spirit:description>
<spirit:bitOffset>7</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>SDMA_SUPPORT</spirit:name>
<spirit:description>sdma support  this bit indicates whether the host controller is capable of sdma.  0x1 = sdma supported, 0x0 = sdma not supported.</spirit:description>
<spirit:bitOffset>6</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>HI_SPEED_SUPPORT</spirit:name>
<spirit:description>high speed support  this bit indicates whether the host controller is capable of high speed mode (25 - 50mhz).  0x1 = high speed mode supported, 0x0 = high speed mode not supported.</spirit:description>
<spirit:bitOffset>5</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>ADMA1_SUPPORT</spirit:name>
<spirit:description>adma1 support  this bit indicates whether the host controller is capable of adma1.  0x1 = adma1 supported, 0x0 = adma1 not supported.</spirit:description>
<spirit:bitOffset>4</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>ADMA2_SUPPORT</spirit:name>
<spirit:description>adma2 support  this bit indicates whether the host controller is capable of adma2.  0x1 = adma2 supported, 0x0 = adma2 not supported.</spirit:description>
<spirit:bitOffset>3</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>EX_DATA_WIDTH_SUPPORT</spirit:name>
<spirit:description>8-bit support  this bit indicates whether the host controller is capable of 8-bit bus operation.  0x1 = 8-bit supported  0x0 = 8-bit not supported</spirit:description>
<spirit:bitOffset>2</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>MAX_BLK_LEN</spirit:name>
<spirit:description>maximum block length   the maximum block length in bytes.   0x0 = 512 bytes</spirit:description>
<spirit:bitOffset>0</spirit:bitOffset>
<spirit:bitWidth>2</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
</spirit:register>
<spirit:register>
<spirit:name>SD_CAPABILITIES_3</spirit:name>
<spirit:description>Capabilities Register 3</spirit:description>
<spirit:addressOffset>0X44</spirit:addressOffset>
<spirit:size>32</spirit:size>
<spirit:volatile>true</spirit:volatile>
<spirit:access>read-write</spirit:access>
<spirit:reset>
<spirit:value>0</spirit:value>
<spirit:mask>0xffffffff</spirit:mask>
</spirit:reset>
<spirit:field>
<spirit:name>RETUNE_MODES</spirit:name>
<spirit:description>re_tuning modes.  this field selects the re-tuning method and limits the maximum data length.  0x0 = mode1 = timer  0x1 = mode2 = timer and re-tuning request  0x2 = mode3 = auto re-tuning (for transfer) timer and re-tuning request  0x3 = reserved.</spirit:description>
<spirit:bitOffset>14</spirit:bitOffset>
<spirit:bitWidth>2</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>SDR50_TUNE</spirit:name>
<spirit:description>use tuning for sdr50 mode.   0x1 = sdr50 requires tuning  0x0 = sdr50 does not require tuning</spirit:description>
<spirit:bitOffset>13</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>TMR_RETUNE</spirit:name>
<spirit:description>timer count for re-tuning.  this field indicates an initial value of the re-tuning timer for mode 1 to 3.  0xf = get information from other source.</spirit:description>
<spirit:bitOffset>8</spirit:bitOffset>
<spirit:bitWidth>4</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>DRV_TYPE_D</spirit:name>
<spirit:description>driver type d support  0x1 = driver type d is supported  0x0 = driver type d is not supported</spirit:description>
<spirit:bitOffset>6</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>DRV_TYPE_C</spirit:name>
<spirit:description>driver type c support.  0x1 = driver type c is supported.  0x0 = driver type c is not supported.</spirit:description>
<spirit:bitOffset>5</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>DRV_TYPE_A</spirit:name>
<spirit:description>driver type a support  0x1 = driver type a is supported  0x0 = driver type a is not supported.</spirit:description>
<spirit:bitOffset>4</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>DDR50_SUPPORT</spirit:name>
<spirit:description>ddr50 support  0x1 =ddr50 is supported  0x0 =ddr50 is not supported.</spirit:description>
<spirit:bitOffset>2</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>SDR104_SUPPORT</spirit:name>
<spirit:description>sdr104 support  0x1 = sdr104 is supported  0x0 = sdr104 is not supported.</spirit:description>
<spirit:bitOffset>1</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>SDR50_SUPPORT</spirit:name>
<spirit:description>sdr50 support  0x1 = sdr50 is supported  0x0 = sdr50 is not supported.</spirit:description>
<spirit:bitOffset>0</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
</spirit:register>
<spirit:register>
<spirit:name>SD_CAPABILITIES_4</spirit:name>
<spirit:description>Capabilities Register 4</spirit:description>
<spirit:addressOffset>0X46</spirit:addressOffset>
<spirit:size>32</spirit:size>
<spirit:volatile>true</spirit:volatile>
<spirit:access>read-write</spirit:access>
<spirit:reset>
<spirit:value>0</spirit:value>
<spirit:mask>0xffffffff</spirit:mask>
</spirit:reset>
<spirit:field>
<spirit:name>&lt;CLK_MULTIPLIER&gt;</spirit:name>
<spirit:description>clock multiplier  this field indicates clock multiplier value of programmable clock generator. 0x0 means that host controller does not support programmable clock generator.</spirit:description>
<spirit:bitOffset>0</spirit:bitOffset>
<spirit:bitWidth>8</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
</spirit:register>
<spirit:register>
<spirit:name>SD_MAX_CURRENT_1</spirit:name>
<spirit:description>Maximum Current Register 1</spirit:description>
<spirit:addressOffset>0X48</spirit:addressOffset>
<spirit:size>32</spirit:size>
<spirit:volatile>true</spirit:volatile>
<spirit:access>read-write</spirit:access>
<spirit:reset>
<spirit:value>0</spirit:value>
<spirit:mask>0xffffffff</spirit:mask>
</spirit:reset>
<spirit:field>
<spirit:name>MAX_CUR_30</spirit:name>
<spirit:description>maximum current for 3.0v  0x0 = get information via another method  0x1 = 4 ma  0x2 = 8 ma  ...  0xf = 1020 ma</spirit:description>
<spirit:bitOffset>8</spirit:bitOffset>
<spirit:bitWidth>8</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>MAX_CUR_33</spirit:name>
<spirit:description>maximum current for 3.3v  0x0 = get information via another method  0x1 = 4 ma  0x2 = 8 ma  ...  0xf = 1020 ma</spirit:description>
<spirit:bitOffset>0</spirit:bitOffset>
<spirit:bitWidth>8</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
</spirit:register>
<spirit:register>
<spirit:name>SD_MAX_CURRENT_2</spirit:name>
<spirit:description>Maximum Current Register 2</spirit:description>
<spirit:addressOffset>0X4A</spirit:addressOffset>
<spirit:size>32</spirit:size>
<spirit:volatile>true</spirit:volatile>
<spirit:access>read-write</spirit:access>
<spirit:reset>
<spirit:value>0</spirit:value>
<spirit:mask>0xffffffff</spirit:mask>
</spirit:reset>
<spirit:field>
<spirit:name>MAX_CUR_18</spirit:name>
<spirit:description>maximum current for 1.8v  0x0 = get information via another method  0x1 = 4 ma  0x2 = 8 ma  ...  0xff = 1020 ma</spirit:description>
<spirit:bitOffset>0</spirit:bitOffset>
<spirit:bitWidth>8</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
</spirit:register>
<spirit:register>
<spirit:name>SD_MAX_CURRENT_3</spirit:name>
<spirit:description>Maximum Current Register 3</spirit:description>
<spirit:addressOffset>0X4C</spirit:addressOffset>
<spirit:size>32</spirit:size>
<spirit:volatile>true</spirit:volatile>
<spirit:access>read-write</spirit:access>
<spirit:reset>
<spirit:value>0</spirit:value>
<spirit:mask>0xffffffff</spirit:mask>
</spirit:reset>
</spirit:register>
<spirit:register>
<spirit:name>SD_MAX_CURRENT_4</spirit:name>
<spirit:description>Maximum Current Register 4</spirit:description>
<spirit:addressOffset>0X4E</spirit:addressOffset>
<spirit:size>32</spirit:size>
<spirit:volatile>true</spirit:volatile>
<spirit:access>read-write</spirit:access>
<spirit:reset>
<spirit:value>0</spirit:value>
<spirit:mask>0xffffffff</spirit:mask>
</spirit:reset>
</spirit:register>
<spirit:register>
<spirit:name>SD_FORCE_EVENT_AUTO_CMD12_ERROR</spirit:name>
<spirit:description>Force Event Auto cmd12 Error Register</spirit:description>
<spirit:addressOffset>0X50</spirit:addressOffset>
<spirit:size>32</spirit:size>
<spirit:volatile>true</spirit:volatile>
<spirit:access>read-write</spirit:access>
<spirit:reset>
<spirit:value>0</spirit:value>
<spirit:mask>0xffffffff</spirit:mask>
</spirit:reset>
<spirit:field>
<spirit:name>F_ACMD12_ISSUE_ERR</spirit:name>
<spirit:description>force event for command not issued by auto cmd12 error  when 1 is written at this location, it sets the &lt;command not issued due to auto_cmd12 error&gt; field in the auto cmd12 error status register.</spirit:description>
<spirit:bitOffset>7</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>F_ACMD_INDEX_ERR</spirit:name>
<spirit:description>force event for auto cmd index error  when 1 is written at this location, it sets the &lt;auto cmd error&gt; field in the auto cmd error status register.</spirit:description>
<spirit:bitOffset>4</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>F__ACMD_EBIT_ERR</spirit:name>
<spirit:description>force event for auto cmd end bit error  when 1 is written at this location, it sets the &lt;auto cmd end bit error&gt; field in the auto cmd error status register.</spirit:description>
<spirit:bitOffset>3</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>F_ACMD_CRC_ERR</spirit:name>
<spirit:description>force event for auto cmd crc error  when 1 is written at this location, it sets the &lt;auto cmd crc error&gt; field in the auto cmd error status register.</spirit:description>
<spirit:bitOffset>2</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>F_ACMD_TO_ERR</spirit:name>
<spirit:description>force event for auto cmd timeout error  when 1 is written at this location, it sets the &lt;auto cmd timeout error&gt; field in the auto cmd error status register.</spirit:description>
<spirit:bitOffset>1</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>F_ACMD12_NEXE_ERR</spirit:name>
<spirit:description>force event for auto cmd12 not executed error  when 1 is written at this location, it sets the &lt;auto cmd12 not executed&gt; field in the auto cmd12 error status register.</spirit:description>
<spirit:bitOffset>0</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
</spirit:register>
<spirit:register>
<spirit:name>SD_FORCE_EVENT_FOR_ERROR_STATUS</spirit:name>
<spirit:description>Force Event for Error Status Register</spirit:description>
<spirit:addressOffset>0X52</spirit:addressOffset>
<spirit:size>32</spirit:size>
<spirit:volatile>true</spirit:volatile>
<spirit:access>read-write</spirit:access>
<spirit:reset>
<spirit:value>0</spirit:value>
<spirit:mask>0xffffffff</spirit:mask>
</spirit:reset>
<spirit:field>
<spirit:name>F_CRC_STATUS_ERR</spirit:name>
<spirit:description>force event for crc status error  when 1 is written at this location, it sets the &lt;crc status error&gt; field in the error interrupt status register.</spirit:description>
<spirit:bitOffset>15</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>F_CPL_TIMEOUT_ERR</spirit:name>
<spirit:description>force event for cpl timeout error  when 1 is written at this location, it sets the &lt;command completion signal timeout error&gt; field in the error interrupt status register.</spirit:description>
<spirit:bitOffset>14</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>F_AXI_RESP_ERR</spirit:name>
<spirit:description>force event for axi response bit error  when 1 is written at this location, it sets the &lt;axi bus response error&gt; field in the error interrupt status register.</spirit:description>
<spirit:bitOffset>13</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>F_SPI_ERR</spirit:name>
<spirit:description>force event for spi error  when 1 is written at this location, it sets the &lt;spi mode error&gt; field in the error interrupt status register.</spirit:description>
<spirit:bitOffset>12</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>F_ADMA_ERR</spirit:name>
<spirit:description>force event for adma error  when 1 is written at this location, it sets the &lt;adma error&gt; field in the error interrupt status register.</spirit:description>
<spirit:bitOffset>9</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>F_ACMD12_ERR</spirit:name>
<spirit:description>force event for auto cmd12 error  when 1 is written at this location, it sets the &lt;auto cmd12 error&gt; field in the error interrupt status register.</spirit:description>
<spirit:bitOffset>8</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>F_CURRENT_ERR</spirit:name>
<spirit:description>force event for current limit error  when 1 is written at this location, it sets the &lt;current limit error&gt; field in the error interrupt status register.</spirit:description>
<spirit:bitOffset>7</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>F_DAT_END_BIT_ERR</spirit:name>
<spirit:description>force event for data end bit error  when 1 is written at this location, it sets the &lt;readdataend bit error&gt; field in the error interrupt status register.</spirit:description>
<spirit:bitOffset>6</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>F_DAT_CRC_ERR</spirit:name>
<spirit:description>force event for data crc error  when 1 is written at this location, it sets the &lt;read data crc error&gt; field in the error interrupt status register.</spirit:description>
<spirit:bitOffset>5</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>F_DAT_TO_ERR</spirit:name>
<spirit:description>force event for data timeout error  when 1 is written at this location, it sets the &lt;read data crc error&gt; field in the error interrupt status register.</spirit:description>
<spirit:bitOffset>4</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>F_CMD_INDEX_ERR</spirit:name>
<spirit:description>force event for command index error  when 1 is written at this location, it sets the &lt;data timeout error&gt; field in the error interrupt status register.</spirit:description>
<spirit:bitOffset>3</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>F_CMD_END_BIT_ERR</spirit:name>
<spirit:description>force event for command end bit error  when 1 is written at this location, it sets the &lt;command index error&gt; field in the error interrupt status register.</spirit:description>
<spirit:bitOffset>2</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>F_CMD_CRC_ERR</spirit:name>
<spirit:description>force event for command crc error  when 1 is written at this location, it sets the &lt;command crc error&gt; field in the error interrupt status register.</spirit:description>
<spirit:bitOffset>1</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>F_CMD_TO_ERR</spirit:name>
<spirit:description>force event for command timeout error  when 1 is written at this location, it sets the &lt;command timeout error&gt; field in the error interrupt status register.</spirit:description>
<spirit:bitOffset>0</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
</spirit:register>
<spirit:register>
<spirit:name>SD_ADMA_ERROR_STATUS</spirit:name>
<spirit:description>ADMA Error Status Register</spirit:description>
<spirit:addressOffset>0X54</spirit:addressOffset>
<spirit:size>32</spirit:size>
<spirit:volatile>true</spirit:volatile>
<spirit:access>read-write</spirit:access>
<spirit:reset>
<spirit:value>0</spirit:value>
<spirit:mask>0xffffffff</spirit:mask>
</spirit:reset>
<spirit:field>
<spirit:name>ADMA_LEN_ERR</spirit:name>
<spirit:description>adma length mismatch error  this error occurs in the following two cases:</spirit:description>
<spirit:bitOffset>2</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>ADMA_STATE</spirit:name>
<spirit:description>adma error state  this field indicates the state of adma when error occurred during adma transfer. this field never indicates 0x2 because adma never stops in this state.</spirit:description>
<spirit:bitOffset>0</spirit:bitOffset>
<spirit:bitWidth>2</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
</spirit:register>
<spirit:register>
<spirit:name>SD_ADMA_SYS_ADDR_1</spirit:name>
<spirit:description>ADMA System Address Register 1</spirit:description>
<spirit:addressOffset>0X58</spirit:addressOffset>
<spirit:size>32</spirit:size>
<spirit:volatile>true</spirit:volatile>
<spirit:access>read-write</spirit:access>
<spirit:reset>
<spirit:value>0</spirit:value>
<spirit:mask>0xffffffff</spirit:mask>
</spirit:reset>
<spirit:field>
<spirit:name>ADMA_SYS_ADDR568</spirit:name>
<spirit:description>adma system address  this register holds byte address of executing command of the descriptor table. at the start of adma, this register should be programmed to point to the start address of the descriptor table. this register is incremented whenever fetching a descriptor line. when an adma error interrupt is generated, this register will hold a valid descriptor address depending on the adma state.</spirit:description>
<spirit:bitOffset>0</spirit:bitOffset>
<spirit:bitWidth>16</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
</spirit:register>
<spirit:register>
<spirit:name>SD_ADMA_SYS_ADDR_2</spirit:name>
<spirit:description>ADMA System Address Register 2</spirit:description>
<spirit:addressOffset>0X5A</spirit:addressOffset>
<spirit:size>32</spirit:size>
<spirit:volatile>true</spirit:volatile>
<spirit:access>read-write</spirit:access>
<spirit:reset>
<spirit:value>0</spirit:value>
<spirit:mask>0xffffffff</spirit:mask>
</spirit:reset>
<spirit:field>
<spirit:name>ADMA_SYS_ADDR575</spirit:name>
<spirit:description>adma system address  this register holds byte address of executing command of the descriptor table. at the start of adma, this register should be programmed to point to the start address of the descriptor table. this register is incremented whenever fetching a descriptor line. when an adma error interrupt is generated, this register will hold a valid descriptor address depending on the adma state.</spirit:description>
<spirit:bitOffset>0</spirit:bitOffset>
<spirit:bitWidth>16</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
</spirit:register>
<spirit:register>
<spirit:name>SD_ADMA_SYS_ADDR_3</spirit:name>
<spirit:description>ADMA System Address Register 3</spirit:description>
<spirit:addressOffset>0X5C</spirit:addressOffset>
<spirit:size>32</spirit:size>
<spirit:volatile>true</spirit:volatile>
<spirit:access>read-write</spirit:access>
<spirit:reset>
<spirit:value>0</spirit:value>
<spirit:mask>0xffffffff</spirit:mask>
</spirit:reset>
<spirit:field>
<spirit:name>ADMA_SYS_ADDR581</spirit:name>
<spirit:description>adma system address  this register holds byte address of executing command of the descriptor table. at the start of adma, this register should be programmed to point to the start address of the descriptor table. this register is incremented whenever fetching a descriptor line. when an adma error interrupt is generated, this register will hold a valid descriptor address depending on the adam state.</spirit:description>
<spirit:bitOffset>0</spirit:bitOffset>
<spirit:bitWidth>16</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
</spirit:register>
<spirit:register>
<spirit:name>SD_ADMA_SYS_ADDR_4</spirit:name>
<spirit:description>ADMA System Address Register 4</spirit:description>
<spirit:addressOffset>0X5E</spirit:addressOffset>
<spirit:size>32</spirit:size>
<spirit:volatile>true</spirit:volatile>
<spirit:access>read-write</spirit:access>
<spirit:reset>
<spirit:value>0</spirit:value>
<spirit:mask>0xffffffff</spirit:mask>
</spirit:reset>
<spirit:field>
<spirit:name>ADMA_SYS_ADDR588</spirit:name>
<spirit:description>adma system address  this register holds byte address of executing command of the descriptor table. at the start of adma, this register should be programmed to point to the start address of the descriptor table. this register is incremented whenever fetching a descriptor line. when an adma error interrupt is generated, this register will hold a valid descriptor address depending on the adma state.</spirit:description>
<spirit:bitOffset>0</spirit:bitOffset>
<spirit:bitWidth>16</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
</spirit:register>
<spirit:register>
<spirit:name>PRESET_VALUE_FOR_INIT</spirit:name>
<spirit:description>Preset Value Register for Initialization</spirit:description>
<spirit:addressOffset>0X60</spirit:addressOffset>
<spirit:size>32</spirit:size>
<spirit:volatile>true</spirit:volatile>
<spirit:access>read-write</spirit:access>
<spirit:reset>
<spirit:value>0</spirit:value>
<spirit:mask>0xffffffff</spirit:mask>
</spirit:reset>
<spirit:field>
<spirit:name>DRV_STRENGTH_VAL595</spirit:name>
<spirit:description>driver strength select value  driver strength is supported by 1.8v signaling bus speed modes. this field is meaningless for 3.3v signaling.  0x0 = driver type b  0x1 = driver type a  0x2 = driver type c  0x3 = driver type d</spirit:description>
<spirit:bitOffset>14</spirit:bitOffset>
<spirit:bitWidth>2</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>CLKGEN_SEL_VAL597</spirit:name>
<spirit:description>clock generator select value.  this bit is effective when host controller supports programmable clock generator.  0x1 = programmable clock generator  0x0 = divided clock</spirit:description>
<spirit:bitOffset>10</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>SDCLK_FREQ_SEL_VAL598</spirit:name>
<spirit:description>sdclk frequency select value  10-bit preset value to set &lt;sdclk_freq_sel&gt; in the clock control register.</spirit:description>
<spirit:bitOffset>0</spirit:bitOffset>
<spirit:bitWidth>10</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
</spirit:register>
<spirit:register>
<spirit:name>PRESET_VALUE_FOR_DS</spirit:name>
<spirit:description>Preset Value Register for Default Speed</spirit:description>
<spirit:addressOffset>0X62</spirit:addressOffset>
<spirit:size>32</spirit:size>
<spirit:volatile>true</spirit:volatile>
<spirit:access>read-write</spirit:access>
<spirit:reset>
<spirit:value>0</spirit:value>
<spirit:mask>0xffffffff</spirit:mask>
</spirit:reset>
<spirit:field>
<spirit:name>DRV_STRENGTH_VAL605</spirit:name>
<spirit:description>driver strength select value  driver strength is supported by 1.8v signaling bus speed modes. this field is meaningless for 3.3v signaling.  0x0 = driver type b  0x1 = driver type a  0x2 = driver type c  0x3 = driver type d</spirit:description>
<spirit:bitOffset>14</spirit:bitOffset>
<spirit:bitWidth>2</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>CLKGEN_SEL_VAL607</spirit:name>
<spirit:description>clock generator select value.  this bit is effective when host controller supports programmable clock generator.  0x1 = programmable clock generator  0x0 = divided clock</spirit:description>
<spirit:bitOffset>10</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>SDCLK_FREQ_SEL_VAL608</spirit:name>
<spirit:description>sdclk frequency select value.  10-bit preset value to set &lt;sdclk_freq_sel&gt; in the clock control register.</spirit:description>
<spirit:bitOffset>0</spirit:bitOffset>
<spirit:bitWidth>10</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
</spirit:register>
<spirit:register>
<spirit:name>PRESET_VALUE_FOR_HS</spirit:name>
<spirit:description>Preset Value Register for High Speed</spirit:description>
<spirit:addressOffset>0X64</spirit:addressOffset>
<spirit:size>32</spirit:size>
<spirit:volatile>true</spirit:volatile>
<spirit:access>read-write</spirit:access>
<spirit:reset>
<spirit:value>0</spirit:value>
<spirit:mask>0xffffffff</spirit:mask>
</spirit:reset>
<spirit:field>
<spirit:name>DRV_STRENGTH_VAL615</spirit:name>
<spirit:description>driver strength select value  driver strength is supported by 1.8v signaling bus speed modes. this field is meaningless for 3.3v signaling.  0x0 = driver type b  0x1 = driver type a  0x2 = driver type c  0x3 = driver type d</spirit:description>
<spirit:bitOffset>14</spirit:bitOffset>
<spirit:bitWidth>2</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>CLKGEN_SEL_VAL617</spirit:name>
<spirit:description>clock generator select value  this bit is effective when host controller supports programmable clock generator.  0x1 = programmable clock generator  0x0 = divided clock</spirit:description>
<spirit:bitOffset>10</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>SDCLK_FREQ_SEL_VAL618</spirit:name>
<spirit:description>sdclk frequency select value.  10-bit preset value to set &lt;sdclk_freq_sel&gt; in the clock control register.</spirit:description>
<spirit:bitOffset>0</spirit:bitOffset>
<spirit:bitWidth>10</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
</spirit:register>
<spirit:register>
<spirit:name>PRESET_VALUE_FOR_SDR12</spirit:name>
<spirit:description>Preset Value Register for SDR12</spirit:description>
<spirit:addressOffset>0X66</spirit:addressOffset>
<spirit:size>32</spirit:size>
<spirit:volatile>true</spirit:volatile>
<spirit:access>read-write</spirit:access>
<spirit:reset>
<spirit:value>0</spirit:value>
<spirit:mask>0xffffffff</spirit:mask>
</spirit:reset>
<spirit:field>
<spirit:name>DRV_STRENGTH_VAL625</spirit:name>
<spirit:description>driver strength select value  driver strength is supported by 1.8v signaling bus speed modes. this field is meaningless for 3.3v signaling.  0x0 = driver type b  0x1 = driver type a  0x2 = driver type c  0x3 = driver type d</spirit:description>
<spirit:bitOffset>14</spirit:bitOffset>
<spirit:bitWidth>2</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>CLKGEN_SEL_VAL627</spirit:name>
<spirit:description>clock generator select value  this bit is effective when host controller supports programmable clock generator.  0x1 = programmable clock generator  0x0 = divided clock</spirit:description>
<spirit:bitOffset>10</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>SDCLK_FREQ_SEL_VAL628</spirit:name>
<spirit:description>sdclk frequency select value  10-bit preset value to set &lt;sdclk_freq_sel&gt; in the clock control register.</spirit:description>
<spirit:bitOffset>0</spirit:bitOffset>
<spirit:bitWidth>10</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
</spirit:register>
<spirit:register>
<spirit:name>PRESET_VALUE_FOR_SDR25</spirit:name>
<spirit:description>Preset Value Register for SDR25</spirit:description>
<spirit:addressOffset>0X68</spirit:addressOffset>
<spirit:size>32</spirit:size>
<spirit:volatile>true</spirit:volatile>
<spirit:access>read-write</spirit:access>
<spirit:reset>
<spirit:value>0</spirit:value>
<spirit:mask>0xffffffff</spirit:mask>
</spirit:reset>
<spirit:field>
<spirit:name>DRV_STRENGTH_VAL635</spirit:name>
<spirit:description>driver strength select value.  driver strength is supported by 1.8v signaling bus speed modes. this field is meaningless for 3.3v signaling.  0x0 = driver type b  0x1 = driver type a  0x2 = driver type c  0x3 = driver type d</spirit:description>
<spirit:bitOffset>14</spirit:bitOffset>
<spirit:bitWidth>2</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>CLKGEN_SEL_VAL637</spirit:name>
<spirit:description>clock generator select value  this bit is effective when host controller supports programmable clock generator.  0x1 = programmable clock generator  0x0 = divided clock</spirit:description>
<spirit:bitOffset>10</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>SDCLK_FREQ_SEL_VAL638</spirit:name>
<spirit:description>sdclk frequency select value  10-bit preset value to set &lt;sdclk_freq_sel&gt; in the clock control register.</spirit:description>
<spirit:bitOffset>0</spirit:bitOffset>
<spirit:bitWidth>10</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
</spirit:register>
<spirit:register>
<spirit:name>PRESET_VALUE_FOR_SDR50</spirit:name>
<spirit:description>Preset Value Register for SDR50</spirit:description>
<spirit:addressOffset>0X6A</spirit:addressOffset>
<spirit:size>32</spirit:size>
<spirit:volatile>true</spirit:volatile>
<spirit:access>read-write</spirit:access>
<spirit:reset>
<spirit:value>0</spirit:value>
<spirit:mask>0xffffffff</spirit:mask>
</spirit:reset>
<spirit:field>
<spirit:name>DRV_STRENGTH_VAL645</spirit:name>
<spirit:description>driver strength select value  driver strength is supported by 1.8v signaling bus speed modes. this field is meaningless for 3.3v signaling.  0x0 = driver type b  0x1 = driver type a  0x2 = driver type c  0x3 = driver type d</spirit:description>
<spirit:bitOffset>14</spirit:bitOffset>
<spirit:bitWidth>2</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>CLKGEN_SEL_VAL647</spirit:name>
<spirit:description>clock generator select value  this bit is effective when host controller supports programmable clock generator.  0x1 = programmable clock generator  0x0 = divided clock</spirit:description>
<spirit:bitOffset>10</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>SDCLK_FREQ_SEL_VAL648</spirit:name>
<spirit:description>sdclk frequency select value.  10-bit preset value to set &lt;sdclk_freq_sel&gt; in the clock control register.</spirit:description>
<spirit:bitOffset>0</spirit:bitOffset>
<spirit:bitWidth>10</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
</spirit:register>
<spirit:register>
<spirit:name>PRESET_VALUE_FOR_SDR104</spirit:name>
<spirit:description>Preset Value Register for SDR104</spirit:description>
<spirit:addressOffset>0X6C</spirit:addressOffset>
<spirit:size>32</spirit:size>
<spirit:volatile>true</spirit:volatile>
<spirit:access>read-write</spirit:access>
<spirit:reset>
<spirit:value>0</spirit:value>
<spirit:mask>0xffffffff</spirit:mask>
</spirit:reset>
<spirit:field>
<spirit:name>DRV_STRENGTH_VAL655</spirit:name>
<spirit:description>driver strength select value  driver strength is supported by 1.8v signaling bus speed modes. this field is meaningless for 3.3v signaling.  0x0 = driver type b  0x1 = driver type a  0x2 = driver type c  0x3 = driver type d</spirit:description>
<spirit:bitOffset>14</spirit:bitOffset>
<spirit:bitWidth>2</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>CLKGEN_SEL_VAL657</spirit:name>
<spirit:description>clock generator select value  this bit is effective when host controller supports programmable clock generator.  0x1 = programmable clock generator  0x0 = divided clock</spirit:description>
<spirit:bitOffset>10</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>SDCLK_FREQ_SEL_VAL658</spirit:name>
<spirit:description>sdclk frequency select value  10-bit preset value to set &lt;sdclk_freq_sel&gt; in the clock control register.</spirit:description>
<spirit:bitOffset>0</spirit:bitOffset>
<spirit:bitWidth>10</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
</spirit:register>
<spirit:register>
<spirit:name>PRESET_VALUE_FOR_DDR50</spirit:name>
<spirit:description>Preset Value Register for DDR50</spirit:description>
<spirit:addressOffset>0X6E</spirit:addressOffset>
<spirit:size>32</spirit:size>
<spirit:volatile>true</spirit:volatile>
<spirit:access>read-write</spirit:access>
<spirit:reset>
<spirit:value>0</spirit:value>
<spirit:mask>0xffffffff</spirit:mask>
</spirit:reset>
<spirit:field>
<spirit:name>DRV_STRENGTH_VAL665</spirit:name>
<spirit:description>driver strength select value  driver strength is supported by 1.8v signaling bus speed modes. this field is meaningless for 3.3v signaling.  0x0 = driver type b  0x1 = driver type a  0x2 = driver type c  0x3 = driver type d</spirit:description>
<spirit:bitOffset>14</spirit:bitOffset>
<spirit:bitWidth>2</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>CLKGEN_SEL_VAL667</spirit:name>
<spirit:description>clock generator select value  this bit is effective when host controller supports programmable clock generator.  0x1 = programmable clock generator  0x0 = divided clock</spirit:description>
<spirit:bitOffset>10</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>SDCLK_FREQ_SEL_VAL668</spirit:name>
<spirit:description>sdclk frequency select value.  10-bit preset value to set &lt;sdclk_freq_sel&gt; in the clock control register.</spirit:description>
<spirit:bitOffset>0</spirit:bitOffset>
<spirit:bitWidth>10</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
</spirit:register>
<spirit:register>
<spirit:name>SHARED_BUS_CTRL</spirit:name>
<spirit:description>Shared Bus Control Register</spirit:description>
<spirit:addressOffset>0XE0</spirit:addressOffset>
<spirit:size>32</spirit:size>
<spirit:volatile>true</spirit:volatile>
<spirit:access>read-write</spirit:access>
<spirit:reset>
<spirit:value>0</spirit:value>
<spirit:mask>0xffffffff</spirit:mask>
</spirit:reset>
<spirit:field>
<spirit:name>BEND_PWR_CTRL</spirit:name>
<spirit:description>back-end power control  each bit of this field controls back-end power supply for an embedded device. host interface voltage is not controlled by this field. the number of devices supported is specified by &lt;num_clk_pins&gt; and a maximum of 7 devices can be controlled.  each bit corresponds to each device. bit[24] corresponds to device 1 and bit[30] corresponds to device 7.   the function of each bit is:   0x0 = back-end power is off  0x1 = back-end power is supplied</spirit:description>
<spirit:bitOffset>24</spirit:bitOffset>
<spirit:bitWidth>7</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>INT_PIN_SEL</spirit:name>
<spirit:description>interrupt pin select  interrupt pin inputs are enabled by this field. enable of unsupported interrupt pin is meaningless.  0x0 = interrupt is detected by interrupt cycle.</spirit:description>
<spirit:bitOffset>20</spirit:bitOffset>
<spirit:bitWidth>3</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>CLK_PIN_SEL</spirit:name>
<spirit:description>clock pin select  one of the clock pin outputs is selected by this field.  0x0 = clock pins are disabled</spirit:description>
<spirit:bitOffset>16</spirit:bitOffset>
<spirit:bitWidth>3</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>BUS_WIDTH_PRESET</spirit:name>
<spirit:description>bus width preset  this field defines the bus width preset for devices on a shared bus.  0x0 = bus width defined by &lt;data_transfer_width&gt;  0x1 = 8-bit mode</spirit:description>
<spirit:bitOffset>8</spirit:bitOffset>
<spirit:bitWidth>7</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>NUM_INT_PINS</spirit:name>
<spirit:description>number of interrupt input pins  this field defines the number of interrupt input pins supported on shared bus system.  0x0 = interrupt input pin is not supported</spirit:description>
<spirit:bitOffset>4</spirit:bitOffset>
<spirit:bitWidth>2</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>NUM_CLK_PINS</spirit:name>
<spirit:description>number of clock pins  this field indicates support of clock pins to select one of the devices on shared bus.  0x0 = shared bus is not supported</spirit:description>
<spirit:bitOffset>0</spirit:bitOffset>
<spirit:bitWidth>3</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
</spirit:register>
<spirit:register>
<spirit:name>SD_SLOT_INT_STATUS</spirit:name>
<spirit:description>Slot Interrupt Status Register</spirit:description>
<spirit:addressOffset>0XFC</spirit:addressOffset>
<spirit:size>32</spirit:size>
<spirit:volatile>true</spirit:volatile>
<spirit:access>read-write</spirit:access>
<spirit:reset>
<spirit:value>0</spirit:value>
<spirit:mask>0xffffffff</spirit:mask>
</spirit:reset>
<spirit:field>
<spirit:name>SLOT_INT1</spirit:name>
<spirit:description>interrupt line for slot 1</spirit:description>
<spirit:bitOffset>1</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>SLOT_INT0</spirit:name>
<spirit:description>interrupt line for slot 0</spirit:description>
<spirit:bitOffset>0</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
</spirit:register>
<spirit:register>
<spirit:name>SD_HOST_CTRL_VER</spirit:name>
<spirit:description>Host Control Version Register</spirit:description>
<spirit:addressOffset>0XFE</spirit:addressOffset>
<spirit:size>32</spirit:size>
<spirit:volatile>true</spirit:volatile>
<spirit:access>read-write</spirit:access>
<spirit:reset>
<spirit:value>0</spirit:value>
<spirit:mask>0xffffffff</spirit:mask>
</spirit:reset>
<spirit:field>
<spirit:name>SD_VER</spirit:name>
<spirit:description>sd host specification number  0x0 = supports version 1.0  0x1 = supports version 2.0  0x2 = supports version 3.0   all other values are reserved.</spirit:description>
<spirit:bitOffset>0</spirit:bitOffset>
<spirit:bitWidth>8</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
</spirit:register>
<spirit:register>
<spirit:name>SDHC_VID_PID</spirit:name>
<spirit:description>SD HOST CTRL Vendor ID/Project ID/version ID Register</spirit:description>
<spirit:addressOffset>0X100</spirit:addressOffset>
<spirit:size>32</spirit:size>
<spirit:volatile>true</spirit:volatile>
<spirit:access>read-write</spirit:access>
<spirit:reset>
<spirit:value>0</spirit:value>
<spirit:mask>0xffffffff</spirit:mask>
</spirit:reset>
<spirit:field>
<spirit:name>VERSION_ID</spirit:name>
<spirit:description>0x1 means first ip version in project &quot;aquila&quot;</spirit:description>
<spirit:bitOffset>28</spirit:bitOffset>
<spirit:bitWidth>4</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>PROJECT_ID</spirit:name>
<spirit:description>0x1 means first project &quot;aquila&quot; in vendor asr</spirit:description>
<spirit:bitOffset>20</spirit:bitOffset>
<spirit:bitWidth>8</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>VENDOR_ID</spirit:name>
<spirit:description>stands for vendor name &quot;asr&quot;, contains three fields, every field use one or two hexadecimal to show the english character's number in alphabet
bit[19:16]: a  (a, 10th of the alphabet)
bit[15:8]: 0x13 (s, 19th of the alphabet)
bit[7:0]:0x12 (r, 18th of the alphabet)</spirit:description>
<spirit:bitOffset>0</spirit:bitOffset>
<spirit:bitWidth>20</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
</spirit:register>
<spirit:register>
<spirit:name>SDHC_OP_CTRL</spirit:name>
<spirit:description>SDHC Opeartion Control register
(Clock and Burst Size Setup Register)</spirit:description>
<spirit:addressOffset>0X104</spirit:addressOffset>
<spirit:size>32</spirit:size>
<spirit:volatile>true</spirit:volatile>
<spirit:access>read-write</spirit:access>
<spirit:reset>
<spirit:value>0</spirit:value>
<spirit:mask>0xffffffff</spirit:mask>
</spirit:reset>
<spirit:field>
<spirit:name>WR_OSTDG</spirit:name>
<spirit:description>this field controls the outstanding write requests on axi.    0x0 = allow outstanding requests on axi.    0x1 = do not allow outstanding requests on axi.</spirit:description>
<spirit:bitOffset>15</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>RD_OSTDG</spirit:name>
<spirit:description>this field controls the outstanding read requests on axi.    0x0 = allow outstanding requests on axi.    0x1 = do not allow outstanding requests on axi.</spirit:description>
<spirit:bitOffset>14</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>WR_ENDIAN</spirit:name>
<spirit:description>write endian  data being written to the card is in the following format.  1 = little endian  0 = big endian</spirit:description>
<spirit:bitOffset>7</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>RD_ENDIAN</spirit:name>
<spirit:description>read endian  data being read from the card is in the following format.  1 = little endian  0 = big endian</spirit:description>
<spirit:bitOffset>6</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>AXI_NON_POST_WR</spirit:name>
<spirit:description>axi non-post write  1 = all axi master write requests are non-post write  0 = only the last request is issued as non-post write</spirit:description>
<spirit:bitOffset>5</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>PRIORITY</spirit:name>
<spirit:description>this is a static bit that is passed along as the most significant bit of the id when axi requests are made. this bit should be changed only before and after completion of a data command and not in between.  0x0 = low priority.  0x1 = high priority.</spirit:description>
<spirit:bitOffset>4</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>DMA_SIZE</spirit:name>
<spirit:description>fifo threshold  this field is used for the fifo threshold for the internal fsm to generate a dma request to the axi master.  0x0 = 64 bytes  0x1 = 128 bytes  0x2 = 192 bytes  0x3 = 256 bytes</spirit:description>
<spirit:bitOffset>2</spirit:bitOffset>
<spirit:bitWidth>2</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>BRST_SIZE</spirit:name>
<spirit:description>dma burst size on the axi fabric  0x0 = 32 bytes burst  0x1 = 64 bytes burst  0x2 = 128 bytes    0x3 = 256 bytes</spirit:description>
<spirit:bitOffset>0</spirit:bitOffset>
<spirit:bitWidth>2</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
</spirit:register>
<spirit:register>
<spirit:name>SDHC_OP_EXT_REG</spirit:name>
<spirit:description>SDHC Operation extend CTRL Register</spirit:description>
<spirit:addressOffset>0X108</spirit:addressOffset>
<spirit:size>32</spirit:size>
<spirit:volatile>true</spirit:volatile>
<spirit:access>read-write</spirit:access>
<spirit:reset>
<spirit:value>0</spirit:value>
<spirit:mask>0xffffffff</spirit:mask>
</spirit:reset>
<spirit:field>
<spirit:name>ARM_EMA</spirit:name>
<spirit:description>arm artisan sram extra time for memory read and write
000 is fastest and 111 is the slowest</spirit:description>
<spirit:bitOffset>28</spirit:bitOffset>
<spirit:bitWidth>3</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>ARM_EMAW</spirit:name>
<spirit:description>arm artisan sram delay for write operation by extendind the internal write pulse.
00 is fastest and 11is the slowest</spirit:description>
<spirit:bitOffset>26</spirit:bitOffset>
<spirit:bitWidth>2</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>ARM_EMAS</spirit:name>
<spirit:description>this field control extends the arm artisan sram pulse width of sense-amplifier enable signal. the default setting is low but when drive high, the pulse is extended.</spirit:description>
<spirit:bitOffset>25</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>ARM_RET1N</spirit:name>
<spirit:description>retention mode 1 enable, active low.</spirit:description>
<spirit:bitOffset>24</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>PRE_GATE_CLK_CNT</spirit:name>
<spirit:description>this field controls the amount of clock cycles that are provided before clock gating is enabled on the sd_clk io pad.</spirit:description>
<spirit:bitOffset>16</spirit:bitOffset>
<spirit:bitWidth>4</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>PDLVMC</spirit:name>
<spirit:description>this field controls some power down function for the internal 64x64 memory.</spirit:description>
<spirit:bitOffset>14</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>PDFVSSM</spirit:name>
<spirit:description>this field controls some power down function for the internal 64x64 memory.</spirit:description>
<spirit:bitOffset>13</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>FORCE_CLK_ON</spirit:name>
<spirit:description>force sd i/o pad clock on  setting this field to 0x1 overrides the sd clock i/o pad clock gate and forces the clock on. this field is meant to be used in conjunction with the &lt;ovrrd_clk_oen&gt; field. bit [11]     bit [12]     setting  0                 --                &lt;force sd i/o pad clock on&gt; setting is ignored (not used)  1                0                  clocks are forced off  1                1                  clocks are forced on</spirit:description>
<spirit:bitOffset>12</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>OVRRD_CLK_OEN</spirit:name>
<spirit:description>override pad clock output enable  setting this field to 0x1 overrides the sd pad clock output enable.   this field is meant to be used in conjunction with the &lt;force_clk_on&gt; field.  bit [11]     bit [12]     setting  0                 --                &lt;force sd i/o pad clock on&gt; setting is ignored (not used)  1                0                  clocks are forced off  1                1                  clocks are forced on</spirit:description>
<spirit:bitOffset>11</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>CLK_OE_USE_POS</spirit:name>
<spirit:description>  0 = use internal clock falling edge output(to eliminate clock signal tri-state issue)  1 = use internal clock rising edge output   this field controls the sd/emmc bus clk pad output enable signal use clock rising edge output or use clock falling edge output
note: if sw set rx160&lt;31&gt; = 1 means host will run at legacy mode, just use external phy as gpio, bus clock signal wil directly output to phy io by using test mode interfaces,at this condition, recommanded sw to clear this bit.</spirit:description>
<spirit:bitOffset>10</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>CLK_GATE_ON</spirit:name>
<spirit:description>clock gate on  0 = enable dynmical clock gate  1 = enable clock free running  this field affects all clock gates in the sd design if the &lt;clock gate ctl&gt; field is set to 1.</spirit:description>
<spirit:bitOffset>9</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>CLK_GATE_CTL</spirit:name>
<spirit:description>clock gate ctl  0 = disable software clock gating override  1 = enable software clock gating override</spirit:description>
<spirit:bitOffset>8</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>USE_DAT3</spirit:name>
<spirit:description>this field allows the card detect functionality to be detected using the dat[3] pin.    0x0 = use dedicated pin.    0x1 = use dat[3].</spirit:description>
<spirit:bitOffset>7</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>SD1S_PDWN751</spirit:name>
<spirit:description>power down  this bit controls the power down port on the internal 2 port 64x64 fifo.</spirit:description>
<spirit:bitOffset>6</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>FIFO_CS</spirit:name>
<spirit:description>fifo cs  this field should be written to 0x1 before any toggling of the pdwn bit.</spirit:description>
<spirit:bitOffset>5</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>FIFO_CLK</spirit:name>
<spirit:description>fifo clock  this field should be set to 0x1 before any toggling of the pdwn bit.</spirit:description>
<spirit:bitOffset>4</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>SD1S_WTC754</spirit:name>
<spirit:description>wtc  this field is used for fifo speed setting.</spirit:description>
<spirit:bitOffset>2</spirit:bitOffset>
<spirit:bitWidth>2</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>SD1S_RTC755</spirit:name>
<spirit:description>rtc  this field is used for fifo speed setting.</spirit:description>
<spirit:bitOffset>0</spirit:bitOffset>
<spirit:bitWidth>2</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
</spirit:register>
<spirit:register>
<spirit:name>SDHC_LEGACY_CTRL_REG</spirit:name>
<spirit:description>SDHC LEGACY CTRL Parameters Register</spirit:description>
<spirit:addressOffset>0X10C</spirit:addressOffset>
<spirit:size>32</spirit:size>
<spirit:volatile>true</spirit:volatile>
<spirit:access>read-write</spirit:access>
<spirit:reset>
<spirit:value>0</spirit:value>
<spirit:mask>0xffffffff</spirit:mask>
</spirit:reset>
<spirit:field>
<spirit:name>GEN_PAD_CLK_CNT</spirit:name>
<spirit:description>pad clock count  this field should be used in conjunction with &lt;gen_pad_clk_on&gt;  this field configures the number of clock cycles generated on the io pad. the default value of 0x4a will generate 75 clock cycles.</spirit:description>
<spirit:bitOffset>24</spirit:bitOffset>
<spirit:bitWidth>8</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>SPI_ERR_TOKEN</spirit:name>
<spirit:description>spi error token  this is the spi error token received in command response when spi mode is enabled.</spirit:description>
<spirit:bitOffset>9</spirit:bitOffset>
<spirit:bitWidth>5</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>SPI_EN</spirit:name>
<spirit:description>enable spi mode  this field indicates that spi mode has been enabled. this will cause the host controller to drive the signals on the interface in accordance with spi protocol.  1 = spi mode enabled  0 = spi mode disabled</spirit:description>
<spirit:bitOffset>8</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>GEN_PAD_CLK_ON</spirit:name>
<spirit:description>generate pad clock  this bit should be set in conjunction with the field &lt;gen_pad_clk_cnt&gt;. setting this bit to 0x1 will generate the programmed number of clock cycles on the io pad.</spirit:description>
<spirit:bitOffset>6</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>SQU_FULL_CHK</spirit:name>
<spirit:description>squ full check  this bit should be set to 0x1 only if using certain piece of memory in squ in fifo mode and a &quot;read&quot; transaction is going to be performed on the sd device.</spirit:description>
<spirit:bitOffset>5</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>SQU_EMPTY_CHK</spirit:name>
<spirit:description>squ empty check  this bit should be set to 0x1 only if using certain piece of memory in squ in fifo mode and a &quot;write&quot; transaction is going to be performed on the sd device.</spirit:description>
<spirit:bitOffset>4</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>BOOT_ACK</spirit:name>
<spirit:description>boot ack  if the boot ack mode is enabled in the mmc device then this field should be written to 0x1 before issuing the alternate boot cmd0.</spirit:description>
<spirit:bitOffset>3</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>INAND_SEL</spirit:name>
<spirit:description>when driver program rx0c highest byte, the host dat/cmd line related registers will be reset.  0x1 = enable soft reset when trigger command.  0x0 = disable soft reset when trigger command.</spirit:description>
<spirit:bitOffset>2</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>ASYNC_IO_EN</spirit:name>
<spirit:description>asynchronous read interface enable  this bit enables the asynchronous latching of input data.  0x1 = async interface is enabled. the clock used to latch the input data and the internal logic clock are asynchronous.  0x0 = async interface is disabled.</spirit:description>
<spirit:bitOffset>1</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>PIO_RDFC</spirit:name>
<spirit:description>pio mode read operation fifo check.  0x0 = check all fifo data whether has been read done by cpu, if not, bus clock will stop and state will stop at block read beginning, then wait last block fifo data all has been read by cpu done, if done, the next block data will start to transfer(although use this method, the clock stop still not in block gap)  0x1 = don't check pio mode fifo whether has been read done by cpu. recommended sw setting this bit to 1 before use pio mode. in bus very high speed mode just as hs200/sdr104, sw must set this bit.</spirit:description>
<spirit:bitOffset>0</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
</spirit:register>
<spirit:register>
<spirit:name>SDHC_LEGACY_CEATA_REG</spirit:name>
<spirit:description>SDHC LEGACY CTRL for CEATA Device Register</spirit:description>
<spirit:addressOffset>0X110</spirit:addressOffset>
<spirit:size>32</spirit:size>
<spirit:volatile>true</spirit:volatile>
<spirit:access>read-write</spirit:access>
<spirit:reset>
<spirit:value>0</spirit:value>
<spirit:mask>0xffffffff</spirit:mask>
</spirit:reset>
<spirit:field>
<spirit:name>CPL_TIMEOUT</spirit:name>
<spirit:description>command completion signal timeout value</spirit:description>
<spirit:bitOffset>16</spirit:bitOffset>
<spirit:bitWidth>14</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>CHK_CPL</spirit:name>
<spirit:description>check command completion signal  when this field is set to 0x1 and the &lt;ce-ata card&gt; field is set to 1, indication is sent to the host controller to check for command completion signal from the ce-ata card.</spirit:description>
<spirit:bitOffset>2</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>SND_CPL</spirit:name>
<spirit:description>send command completion disable signal  when this field is set to 1 and the &lt;ce-ata card&gt; field is set to 1, indication is sent to the host controller to send the command completion disable signal to the ce-ata card.</spirit:description>
<spirit:bitOffset>1</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>CEATA_CARD</spirit:name>
<spirit:description>ce-ata card  1 = ce-ata card mode  0 = non ce-ata card mode</spirit:description>
<spirit:bitOffset>0</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
</spirit:register>
<spirit:register>
<spirit:name>SDHC_MMC_CTRL_REG</spirit:name>
<spirit:description>SDHC MMC DEVICE CTRL Registers</spirit:description>
<spirit:addressOffset>0X114</spirit:addressOffset>
<spirit:size>32</spirit:size>
<spirit:volatile>true</spirit:volatile>
<spirit:access>read-write</spirit:access>
<spirit:reset>
<spirit:value>0</spirit:value>
<spirit:mask>0xffffffff</spirit:mask>
</spirit:reset>
<spirit:field>
<spirit:name>DAT_LEVEL793</spirit:name>
<spirit:description>mmc1_dat[7:0] line signal level  this status is used to check the mmc_dat[7:0] line level to recover from errors and for debugging. this is especially useful in detecting the busy signal level from mmc_dat[0]. lower 4bits were same as rx26&lt;7:4&gt;</spirit:description>
<spirit:bitOffset>24</spirit:bitOffset>
<spirit:bitWidth>8</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>MMC_CARD</spirit:name>
<spirit:description>mmc card  1 = mmc card mode  0 = sd card mode</spirit:description>
<spirit:bitOffset>12</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>MMC_RESETN</spirit:name>
<spirit:description>mmc resetn   this bit controls the value of the pin mmc_resetn going to the emmc device.</spirit:description>
<spirit:bitOffset>11</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>MMC_HS200</spirit:name>
<spirit:description>this bit is set when host read device_type[196] field of extended csd register in mmc card and card support hs200 mode, setting this before host clock changes to 200mhz, follow chapter6.6.4 on emmc4.5 spec.   1 = mmc hs200 mode enable.   0 = mmc hs200 mode disable, there has other backdoor registers to enable hs200 mode, please refer to rx3e registers.</spirit:description>
<spirit:bitOffset>10</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>MMC_HS400</spirit:name>
<spirit:description>this bit is set when host read device_type[196] field of extended csd register in mmc card and card support hs400 mode, setting this before host clock changes to 200mhz, follow emmc5.0 spec.   1 = mmc hs400 mode enable.   0 = mmc hs400 mode disable, there has other backdoor registers to enable hs200 mode, please refer to rx3e registers.</spirit:description>
<spirit:bitOffset>9</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>ENHANCE_STROBE_EN</spirit:name>
<spirit:description>this bit control whether host/phy will use (delayed) strobe signal to sample the cmd response, this feature is for emmc5.1 spec enhance hs400 mode, sw should check the device related ext register to decide whether host/phy should support this feature.</spirit:description>
<spirit:bitOffset>8</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>CPL_COMPLETE</spirit:name>
<spirit:description>cpl_complete  this bit is set to 1 when a command completion signal is detected and the &lt;cpl_complete enable&gt; field has been set to 1.  this field is cleared by writing 0x1.  a write of 0x0 has no effect.</spirit:description>
<spirit:bitOffset>6</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>CPL_COMPLETE_EN</spirit:name>
<spirit:description>cpl_complete enable  1 = this bit when set to 0x1 will enable the cpl_complete bit to get set to 0x1 when a command completion signal is detected.</spirit:description>
<spirit:bitOffset>5</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>CPL_COMPLETE_INT_EN</spirit:name>
<spirit:description>cpl_complete interrupt enable  1 = an interrupt will be generated whenever the &lt;cpl_complete&gt; field is set</spirit:description>
<spirit:bitOffset>4</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>MISC_INT</spirit:name>
<spirit:description>misc_int  this status bit is set to 1 when the programmed number of clocks in &lt;gen_pad_clk_cnt&gt; is completed and &lt;misc_int_en&gt; field has been set to 0x1.  this field is cleared by writing 0x1.  a write of 0x0 has no effect.</spirit:description>
<spirit:bitOffset>2</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>MISC_INT_EN</spirit:name>
<spirit:description>misc_int status enable  1 = this bit when set to 0x1 will enable the misc_int bit to get set to 0x1 when the programmed number of clocks have been generated on the pad.</spirit:description>
<spirit:bitOffset>1</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>MISC_INT_INT_EN</spirit:name>
<spirit:description>misc_int interrupt enable  0x1 = an interrupt will be generated whenever the &lt;misc_int&gt; field is set to 0x1.</spirit:description>
<spirit:bitOffset>0</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
</spirit:register>
<spirit:register>
<spirit:name>SDHC_RX_CFG_REG</spirit:name>
<spirit:description>SDHC RX Configuration Register</spirit:description>
<spirit:addressOffset>0X118</spirit:addressOffset>
<spirit:size>32</spirit:size>
<spirit:volatile>true</spirit:volatile>
<spirit:access>read-write</spirit:access>
<spirit:reset>
<spirit:value>0</spirit:value>
<spirit:mask>0xffffffff</spirit:mask>
</spirit:reset>
<spirit:field>
<spirit:name>TUNING_DLY_INC</spirit:name>
<spirit:description>when hw auto-tuning is being performed the host controller takes over the control of the delay value being programmed in the delay element. this field defines a value by which the delay value is incremented for each step.</spirit:description>
<spirit:bitOffset>18</spirit:bitOffset>
<spirit:bitWidth>10</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>SDCLK_DELAY</spirit:name>
<spirit:description>this field controls the delay value to the delay element.</spirit:description>
<spirit:bitOffset>8</spirit:bitOffset>
<spirit:bitWidth>10</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>SDCLK_SEL1</spirit:name>
<spirit:description>this field is used for rx data/cmd sample clock selections:
this field controls the second mux selects. 
   0x0 = select clock from gpio pad feedback. 
   0x1 = select clock output from ddl, if for sw tuning, sw should set to 0x1
   0x2, 0x3 = select internal clock.</spirit:description>
<spirit:bitOffset>2</spirit:bitOffset>
<spirit:bitWidth>2</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>SDCLK_SEL0</spirit:name>
<spirit:description>this field is used for sw tuning process.
this field controls the first mux selects.    0x0 = select clock from pad.    0x1 = select inverted clock from pad.    0x2 = select internal clock.    0x3 = select inverted internal clock.</spirit:description>
<spirit:bitOffset>0</spirit:bitOffset>
<spirit:bitWidth>2</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
</spirit:register>
<spirit:register>
<spirit:name>SDHC_TX_CFG_REG</spirit:name>
<spirit:description>SDHC TX Configuration Register</spirit:description>
<spirit:addressOffset>0X11C</spirit:addressOffset>
<spirit:size>32</spirit:size>
<spirit:volatile>true</spirit:volatile>
<spirit:access>read-write</spirit:access>
<spirit:reset>
<spirit:value>0</spirit:value>
<spirit:mask>0xffffffff</spirit:mask>
</spirit:reset>
<spirit:field>
<spirit:name>TX_MUX_SEL</spirit:name>
<spirit:description>tx output clock selection.    0x0 = select clock from inverter of base clock input    0x1 = select clock from ddll output clock</spirit:description>
<spirit:bitOffset>31</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>TX_INT_CLK_SEL</spirit:name>
<spirit:description>tx output clock selection.    0x0 = select clock from the original inverter of base clock or ddll output clock    0x1 = select clock from inverter of internal work clock, will gurantee the hold time at default speed mode or high speed mode.</spirit:description>
<spirit:bitOffset>30</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>TX_DLINE_SRC_SEL</spirit:name>
<spirit:description>tx delayline clock source selection.    0x0 = select base clock as tx delayline input source clock     0x1 = select internal work clock as tx delayline input source clock, normally this bit only worked at hs200 mode, but if ddr mode need to do tx tuning, this tx delayline input clock source bit should be force to 0</spirit:description>
<spirit:bitOffset>29</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>TX_HOLD_DELAY1</spirit:name>
<spirit:description>this field controls the delay value to the tx delay element for sdr104 mode.</spirit:description>
<spirit:bitOffset>16</spirit:bitOffset>
<spirit:bitWidth>10</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>TX_HOLD_DELAY0</spirit:name>
<spirit:description>this field controls the delay value to the tx delay element for all modes other than the sdr104 mode.</spirit:description>
<spirit:bitOffset>0</spirit:bitOffset>
<spirit:bitWidth>10</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
</spirit:register>
<spirit:register>
<spirit:name>SDHC_HWTUNE_CFG_REG</spirit:name>
<spirit:description>SDHC HW TUNING Configuration Register</spirit:description>
<spirit:addressOffset>0X120</spirit:addressOffset>
<spirit:size>32</spirit:size>
<spirit:volatile>true</spirit:volatile>
<spirit:access>read-write</spirit:access>
<spirit:reset>
<spirit:value>0</spirit:value>
<spirit:mask>0xffffffff</spirit:mask>
</spirit:reset>
<spirit:field>
<spirit:name>TUNING_CLK_DLY</spirit:name>
<spirit:description>this ro field indicates the final ddll delay counter value after tuning complete set, during tuning process this field will increase step by step, so normally no meaning to read it during hw tuning process.</spirit:description>
<spirit:bitOffset>20</spirit:bitOffset>
<spirit:bitWidth>10</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>TUNING_WD_CNT</spirit:name>
<spirit:description>this field controls the tuning success window width. if tuning success times &gt;= tuning_wd_cnt, tuning is successful, then  hw will choose middle of the window as the final tuning ddll delay counter value. default is 10 times as spec requirment, driver can adjust the total tuning count according to real condition.</spirit:description>
<spirit:bitOffset>10</spirit:bitOffset>
<spirit:bitWidth>10</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>TUNING_TT_CNT</spirit:name>
<spirit:description>this field controls the total tuning times, default is 40 times as spec requirment, driver can adjust the total tuning count according to real condition. total tuning count equals tuning_tt_cnt + 1</spirit:description>
<spirit:bitOffset>0</spirit:bitOffset>
<spirit:bitWidth>10</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
</spirit:register>
<spirit:register>
<spirit:name>SDHC_HWTUNE_CFG2_REG</spirit:name>
<spirit:description>SDHC HW TUNING Configuration2 Register</spirit:description>
<spirit:addressOffset>0X124</spirit:addressOffset>
<spirit:size>32</spirit:size>
<spirit:volatile>true</spirit:volatile>
<spirit:access>read-write</spirit:access>
<spirit:reset>
<spirit:value>0</spirit:value>
<spirit:mask>0xffffffff</spirit:mask>
</spirit:reset>
<spirit:field>
<spirit:name>TUNING_HW_START_CNT</spirit:name>
<spirit:description>this field will let sw have the flexibility to config the hw auto-tuning start dll counter value.</spirit:description>
<spirit:bitOffset>16</spirit:bitOffset>
<spirit:bitWidth>10</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>TUNING_SUCCESS_CNT</spirit:name>
<spirit:description>this ro field indicates if hw auto-tuning failed, the cmd19 tuning success times. sw can read for references to decide whether adjust tuning step (tuning_dly_inc) or change the tuning window count (tuning_wd_cnt), this field only valid after tuning complete with fail. during tuning process, read this field is meaningless.</spirit:description>
<spirit:bitOffset>6</spirit:bitOffset>
<spirit:bitWidth>10</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>TUNING_HW_SDCLK_SEL1</spirit:name>
<spirit:description>this field is used for hw auto tuning, the meaning is like rx118&lt;3:2&gt; sw tuning definition.</spirit:description>
<spirit:bitOffset>2</spirit:bitOffset>
<spirit:bitWidth>2</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>TUNING_HW_SDCLK_SEL0</spirit:name>
<spirit:description>this field will let sw have the flexibility to config the hw auto-tuning dll source clock selection.</spirit:description>
<spirit:bitOffset>0</spirit:bitOffset>
<spirit:bitWidth>2</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
</spirit:register>
<spirit:register>
<spirit:name>SDHC_ROUNDTRIP_TIMING_REG</spirit:name>
<spirit:description>SDHC ROUND TRIP(TRANSIMIT TO RECEIVE) TIMING PARAM Regsiter</spirit:description>
<spirit:addressOffset>0X128</spirit:addressOffset>
<spirit:size>32</spirit:size>
<spirit:volatile>true</spirit:volatile>
<spirit:access>read-write</spirit:access>
<spirit:reset>
<spirit:value>0</spirit:value>
<spirit:mask>0xffffffff</spirit:mask>
</spirit:reset>
<spirit:field>
<spirit:name>DATA0BUSY_WAIT_CYCLES</spirit:name>
<spirit:description>this field controls host check data0 busy signal after how many cycles of the end bit of crc status in write operation, normally only hs200/sdr104/hs400 should use this field.</spirit:description>
<spirit:bitOffset>24</spirit:bitOffset>
<spirit:bitWidth>4</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>WRDATA0_WAIT_CYCLES</spirit:name>
<spirit:description>this field only valid when this register bit[2] or bit[1] or bit[0] be set at corresponding speed mode, if bit[1] or bit[0] be set, this field indicate the host controller internal logic data fsm should wait how many cycles between the bus driving direction turn around from data0 end bit to start bit of crc stauts when performance bus write operation</spirit:description>
<spirit:bitOffset>16</spirit:bitOffset>
<spirit:bitWidth>4</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>CMD2RESP_WAIT_CYCLES</spirit:name>
<spirit:description>this field only valid when this register bit[2] or bit[1] or bit[0] be set at corresponding speed mode, if bit[1] or bit[0] be set, this field indicate the host controller internal logic cmd fsm should wait how many clock cycles between the bus driving direction turn around from cmd end bit to  response start bit.</spirit:description>
<spirit:bitOffset>8</spirit:bitOffset>
<spirit:bitWidth>4</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>TRS2RCV_PARAM_EN2</spirit:name>
<spirit:description>this field control whether at hs400 mode to enable sw to control the wait cycles should insert between cmd/data transmit to receive direction turn around period, in theory, hs400 mode need enable for phy output and input dll latency.</spirit:description>
<spirit:bitOffset>2</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>TRS2RCV_PARAM_EN1</spirit:name>
<spirit:description>this field control whether at ddr50/sdr50 mode to enable sw to control the wait cycles should insert between cmd/data transmit to receive direction turn around period</spirit:description>
<spirit:bitOffset>1</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>TRS2RCV_PARAM_EN0</spirit:name>
<spirit:description>this field control whether at hs200/sdr104 mode to enable sw to control the wait cycles should insert between cmd/data transmit to receive direction turn around period</spirit:description>
<spirit:bitOffset>0</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
</spirit:register>
<spirit:register>
<spirit:name>SDHC_GPIO_CFG_REG</spirit:name>
<spirit:description>SDHC GPIO CFG Register</spirit:description>
<spirit:addressOffset>0X12C</spirit:addressOffset>
<spirit:size>32</spirit:size>
<spirit:volatile>true</spirit:volatile>
<spirit:access>read-write</spirit:access>
<spirit:reset>
<spirit:value>0</spirit:value>
<spirit:mask>0xffffffff</spirit:mask>
</spirit:reset>
<spirit:field>
<spirit:name>SDHC_GPO</spirit:name>
<spirit:description>value needed to be driven to gpo pins; sw program these 16bits field, and the value will showed on gpo output ports on sdhc top module.</spirit:description>
<spirit:bitOffset>16</spirit:bitOffset>
<spirit:bitWidth>16</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>SDHC_GPI</spirit:name>
<spirit:description>value on gpi input ports; these 16bit fields were read-only attribute.</spirit:description>
<spirit:bitOffset>0</spirit:bitOffset>
<spirit:bitWidth>16</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
</spirit:register>
<spirit:register>
<spirit:name>SDHC_DLINE_CTRL_REG</spirit:name>
<spirit:description>SDHC DELAYLINE Control Register</spirit:description>
<spirit:addressOffset>0X130</spirit:addressOffset>
<spirit:size>32</spirit:size>
<spirit:volatile>true</spirit:volatile>
<spirit:access>read-write</spirit:access>
<spirit:reset>
<spirit:value>0</spirit:value>
<spirit:mask>0xffffffff</spirit:mask>
</spirit:reset>
<spirit:field>
<spirit:name>TX_DLINE_CODE</spirit:name>
<spirit:description>delayline dtc delay control signals, sw will program this field for tuning process, detailed delayline delay equation please check delayline documents.</spirit:description>
<spirit:bitOffset>24</spirit:bitOffset>
<spirit:bitWidth>8</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>RX_DLINE_CODE</spirit:name>
<spirit:description>delayline dtc delay control signals, sw will program this field for tuning process, detailed delayline delay equation please check delayline documents.</spirit:description>
<spirit:bitOffset>16</spirit:bitOffset>
<spirit:bitWidth>8</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>DLINE_PU</spirit:name>
<spirit:description>power-up signal:
  0 =power down
  1 = power up
the time period from power up signal be set to the internal regulator output voltage be stable is about 100ns.</spirit:description>
<spirit:bitOffset>0</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
</spirit:register>
<spirit:register>
<spirit:name>SDHC_DLINE_CFG_REG</spirit:name>
<spirit:description>SDHC DELAYLINE CFG Register</spirit:description>
<spirit:addressOffset>0X134</spirit:addressOffset>
<spirit:size>32</spirit:size>
<spirit:volatile>true</spirit:volatile>
<spirit:access>read-write</spirit:access>
<spirit:reset>
<spirit:value>0</spirit:value>
<spirit:mask>0xffffffff</spirit:mask>
</spirit:reset>
<spirit:field>
<spirit:name>TX_DLINE_GAIN</spirit:name>
<spirit:description>tx delayline gain 2x set, this bit only worked at tx_dline_reg&lt;6&gt; be set
1 = extended delayline delay range and decreased resolution, normally for 100mhz frequency which still need use dll delayline.
0 = default(for 200mhz case)</spirit:description>
<spirit:bitOffset>24</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>TX_DLINE_REG</spirit:name>
<spirit:description>tx delayline delay cfg register control signals, sw will program this field for tuning process, detailed delayline delay equation please check delayline documents.</spirit:description>
<spirit:bitOffset>16</spirit:bitOffset>
<spirit:bitWidth>8</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>RX_DLINE_GAIN</spirit:name>
<spirit:description>rx delayline gain 2x set, this bit only worked at rx_dline_reg&lt;6&gt; be set
1 = extended delayline delay range and decreased resolution, normally for 100mhz frequency which still need use dll delayline.
0 = default(for 200mhz case)</spirit:description>
<spirit:bitOffset>8</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>RX_DLINE_REG</spirit:name>
<spirit:description>rx delayline delay cfg register control signals, sw will program this field for tuning process, detailed delayline delay equation please check delayline documents.</spirit:description>
<spirit:bitOffset>0</spirit:bitOffset>
<spirit:bitWidth>8</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
</spirit:register>
<spirit:register>
<spirit:name>SDHC_PHY_CTRL_REG</spirit:name>
<spirit:description>SDHC PHY Control Register</spirit:description>
<spirit:addressOffset>0X160</spirit:addressOffset>
<spirit:size>32</spirit:size>
<spirit:volatile>true</spirit:volatile>
<spirit:access>read-write</spirit:access>
<spirit:reset>
<spirit:value>0</spirit:value>
<spirit:mask>0xffffffff</spirit:mask>
</spirit:reset>
<spirit:field>
<spirit:name>HOST_LEGACY_MODE</spirit:name>
<spirit:description>this field is backdoor register for sw to use old legacy topology host mode. by default, due to emmc5 phy/host topology changes, clock generation logic will moved into phy inside, phy will output working clock to host. if sw set this bit, below factors will be true:
1 host will use internal clock divider to generate clock
2 affect sw/hw rx tuning, host will use rx118/rx130 setting for dll slave delayline control, otherwise will keep use new added rx168 setting for dll slave delayline control.
3 host will treat phy just as gpio, only use phy test mode interface signals tdi/tdo/tdoe to output/input data/cmd/clk.
4 if sw set host _legacy_mode, recommended don't support hs400 mode, base clock frequency should better set &lt;=200mhz and only up to hs200 mode
5 tbd, whether add backdoor delayline in rx/tx tuning path for clock tuning not used phy internal delayline
   0x0 = host legacy mode disable, default use new external emmc5.0/sd phy topology 
   0x1 = host legacy mode enable.</spirit:description>
<spirit:bitOffset>31</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>PHY_DCHNL_STATUS</spirit:name>
<spirit:description>current phy 8 data channel enable status. on reset, hw logic will enable 1 bit mode data channle by default.</spirit:description>
<spirit:bitOffset>16</spirit:bitOffset>
<spirit:bitWidth>8</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>PHY_DCHNL_SW</spirit:name>
<spirit:description>sw programmed 8 data channels enable signals, every bit stands for 1 data channel, every bit value description is as below:
  0x1 = this data channel is enable.
  0x0 = this data channel is disable.
note: cmd channel is always enable inside phy</spirit:description>
<spirit:bitOffset>8</spirit:bitOffset>
<spirit:bitWidth>8</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>PHY_DCHNL_SEL</spirit:name>
<spirit:description>phy 8 data channle sw enable selection. if sw want to control phy data channel function enable, should firstly set this bit and then set corresponding bits at bit[15:8].
  0x1 = phy data channel function enable will be controlled by sw programmed register bits at bit[15:8], if set this bit, sw should set bit[15:8] before use phy for data transfer.
  0x0 = phy data channel function enable will be automatically controlled by host hardware logic, at this mode, sw can read bit[23:16] for current hw data channel control status, normally, for emmc protocol host hw will automatically set 8 data channel function enable at initialization phase;for sd protocol, hw will set 4 data channel function enable at initialization phase.</spirit:description>
<spirit:bitOffset>2</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>PHY_PLL_LOCK</spirit:name>
<spirit:description>when sw follow phy program sequence, after sw enable 
phy input source clock from apmu offset 0xe0, sw should also program this bit to 1, in order to let phy know the internal input 400mhz clock source is stable.
  0x1 = phy 400mhz clock source input stable signal
  0x0 = phy 400mhz clock source input instable</spirit:description>
<spirit:bitOffset>1</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>PHY_FUNC_EN</spirit:name>
<spirit:description>phy function enable signal, phy will use this enable signal for internal circuit reset, if host core logic enter lower power mode, power gating(udr_latch) should keep phy_en = 0, for normal function, sw should set this bit before using phy and do other phy related setting before set this bit.
  0x1 = phy function enable/phy power up
  0x0 = phy function disable/phy enter lower power mode</spirit:description>
<spirit:bitOffset>0</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
</spirit:register>
<spirit:register>
<spirit:name>SDHC_PHY_FUNC_REG</spirit:name>
<spirit:description>SDHC PHY Function Configuration Register</spirit:description>
<spirit:addressOffset>0X164</spirit:addressOffset>
<spirit:size>32</spirit:size>
<spirit:volatile>true</spirit:volatile>
<spirit:access>read-write</spirit:access>
<spirit:reset>
<spirit:value>0</spirit:value>
<spirit:mask>0xffffffff</spirit:mask>
</spirit:reset>
<spirit:field>
<spirit:name>RX_USE_STROBE</spirit:name>
<spirit:description>from host, in fact is hs400 ddr mode
rx_use_strobe = (uhs_mode[2:0] == 110b) | hs400_mode | enhance_strobe_en;</spirit:description>
<spirit:bitOffset>18</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>RX_USE_DLYLINE</spirit:name>
<spirit:description>from host, in fact was hs200 or sdr104, host will also have a backdoor register(bit3) for setting this bit also in sdr50/ddr50(52) modes</spirit:description>
<spirit:bitOffset>17</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>TX_USE_INVERT</spirit:name>
<spirit:description>this field be set when one of below two conditions meet:
1 rx3e&lt;2:0&gt; be set to all sdr mode.
2 rx118&lt;30&gt; = 0 be set, but rx118&lt;30&gt; set to 1 only affect phy test mode output put paths(tdo/tdoe) signals, all function output data/cmd and output enable signals will be controlled by phy logic.</spirit:description>
<spirit:bitOffset>16</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>HS200_USE_RFIFO</spirit:name>
<spirit:description>this bit control whether sw enable rfifo when running at hs200 mode:
  0x0= disable rfifo in hs200(default hs200 mode use delayline output clock sample data and directly sampled again by host internal core clock)
  0x1 = enable rfifo in hs200(if enable rfifo, delayline output clock sampled data will go to async fifo, then pop of fifo and go to host)</spirit:description>
<spirit:bitOffset>15</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>RX_DIS_CKSTOP</spirit:name>
<spirit:description>due to phy addition, input data latency will be increased, host add this back door register to disable stopping clock behavior at middle of the data block when occurred fifo overflow conditions, only permitted stop clock at block gap.
this field is actually a backdoor register for only sdr25/hs50/ddr50 or lower mode, since for hs200/hs400 higher mode spec claimed could not stop bus clock at middle of the data block.</spirit:description>
<spirit:bitOffset>14</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>PHY_TDI_SEL</spirit:name>
<spirit:description>this field control phy test mode input signal tdi source selection:
  0x0= tdi will sampled by phy internal clock signal clock, normally this signal is same as host working clock (cclk_in) from phy.
  0x1 = tdi directly from phy internal io pad di port.</spirit:description>
<spirit:bitOffset>13</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>TX_CKOUT_REVERSE</spirit:name>
<spirit:description>this field is backdoor register to control whether host controller reverse the output data phase:
  0x0 = keep original design clock odd/even output phase, odd phase always 0, even phase = card_clk_en
  0x1 = reverse odd phase data to even output port, reverse even phase data to odd output port</spirit:description>
<spirit:bitOffset>12</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>TX_DDR_REVERSE</spirit:name>
<spirit:description>this field is backdoor register to control whether host controller reverse the output data phase:
  0x0 = keep original design data odd/even output phase
  0x1 = reverse odd phase data to even output port, reverse even phase data to odd output port</spirit:description>
<spirit:bitOffset>11</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>RX_DDR_BKEN</spirit:name>
<spirit:description>back door register to control ddr mode rx direction whenever ddr50 mode, just force phy to use delayline output clock's both edge sample bus data in phy, and then output dqin_o[7:0] and dqin_e[7:0] to host, delayline's input clock is cki.
  0x1 = back door mode is enable.
  0x0 = back door mode is disable.</spirit:description>
<spirit:bitOffset>10</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>RFIFO_BYPASS</spirit:name>
<spirit:description>if set, host will bypass phy interface read fifo on hs400 mode, otherwise host will use the ck_rx_cmd directly sampled cmd in certain mode, normally need use rfifo in hs400 mode, since internal clock was async with phy output data/cmd rx clock. please be noticed that this bit only worked at hs400 mode, for tuning mode use free running clock case, data/cmd async read path can choose data async fifo put in host rx interface(use async_io_en, rx10c&lt;1&gt;)</spirit:description>
<spirit:bitOffset>9</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>CMD_USE_EVEN</spirit:name>
<spirit:description>this bit indicate when on enhanced hs400 mode whether cmd use 3/4t ds sampled signal as controller input, default use 1/4t ds sampled signal.</spirit:description>
<spirit:bitOffset>8</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>PHY_TEST_EN</spirit:name>
<spirit:description>phy test mode enable signal, control pad output and output enable signals' source:
if phy_test_en=1, test mode enable (phy bypass mode) - pad output is controlled directly by tdo (output data) and tdoe (output enable) from host normal function.
this field has different meaning with rx160&lt;31&gt; host_legacy_mode, host_legacy_mode had strong effects, but this field only affect data/cmd/clk input/output paths. if sw set this bit, only item3 of rx160&lt;31&gt;=1 was taken effect, that means:
&lt;p&gt;0x1= host will treat phy just as gpio, only use phy test mode interface signals tdi/tdo/tdoe to output/input data/cmd/clk.
&lt;p&gt;0x0 = host will use emmc normal function data/cmd/clk paths.
note: recommended sw to set this bit in bootrom for safety purpose.
apmu also have backdoor register which can config phy enter bypass mode, but apmu regsiter be set will let tdo/tdoe from other mfpi function not emmc controller.and if sw want to use this mode, it assumed phy internal clock generation logic was ok and this bit be set not suit for ddr mode backup method, otherwise please use rx160&lt;31&gt; for using whole pure backup method(just only use phy's io pad)</spirit:description>
<spirit:bitOffset>7</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>PHY_MODE_STATUS</spirit:name>
<spirit:description>these 3bits reflect current phy working mode selection in host design, if phy_mode_swen = 1, this field value equal phy_mode_sw[2:0];
if phy_mode_swen = 0, this field value equal hw internal logic controlled signal phy_mode_hw[2:0].</spirit:description>
<spirit:bitOffset>4</spirit:bitOffset>
<spirit:bitWidth>3</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>PHY_MODE_SW</spirit:name>
<spirit:description>these 3bits only worked when sw set phy_mode_swen=1, sw can program these 3 bits to force host controller use &quot;phy_mode_sw&quot; field and ignore host internal hw generated mode selection signal &quot;phy_mode_hw&quot;:
  0x000 = mmc default speed mode(&lt;=26mhz), sd ds/sdr12/sdr25(&lt;=50mhz).
  0x001 = mmc hs mode(&lt;=50mhz,sdr protocol), sd mode sdr50 (&lt;=100mhz)
  0x010 = ddr50(or ddr52)
  0x011 = hs200(or sdr104)
  0x100 = hs400
  0x101 = hs400 cmd enhanced mode
  all other values are reserved</spirit:description>
<spirit:bitOffset>1</spirit:bitOffset>
<spirit:bitWidth>3</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>PHY_MODE_SWEN</spirit:name>
<spirit:description>this bit give sw ability to control phy working mode selection, if set this bit, sw should synchronized set bit</spirit:description>
<spirit:bitOffset>0</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
</spirit:register>
<spirit:register>
<spirit:name>SDHC_PHY_DLLCFG_REG</spirit:name>
<spirit:description>SDHC PHY DLL Configuration Register</spirit:description>
<spirit:addressOffset>0X0168</spirit:addressOffset>
<spirit:size>32</spirit:size>
<spirit:volatile>true</spirit:volatile>
<spirit:access>read-write</spirit:access>
<spirit:reset>
<spirit:value>0</spirit:value>
<spirit:mask>0xffffffff</spirit:mask>
</spirit:reset>
<spirit:field>
<spirit:name>DLL_ENABLE</spirit:name>
<spirit:description>enable dll.
   0 = dll function disable(power down)
   1 = dll function enable(power up)</spirit:description>
<spirit:bitOffset>31</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>DLL_DELAY_SRC</spirit:name>
<spirit:description>phy internal dedicated delayline input clock source selection.
0: delayline input clock default selected pclk(bus clock feedback) as source
1: give phy another option for change the delayline input clock source to phy internal cki(cclk_in), this option normally only worked at hs200 mode for host manually tuning method.</spirit:description>
<spirit:bitOffset>30</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>DLL_REFRESH_SW</spirit:name>
<spirit:description>   1 = sw ask to manually update dll_refresh signal
   0 = sw just keep manually update signal dll_refresh as invalid.</spirit:description>
<spirit:bitOffset>29</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>DLL_REFRESH_SWEN</spirit:name>
<spirit:description>   1 = sw control dll_refresh manually update signal enable
   0 = host hw control dll_refresh manually update signal</spirit:description>
<spirit:bitOffset>28</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>DLL_REFRESH_ENABLE</spirit:name>
<spirit:description>   1 = our host controller would generate dll_refresh signal manually adjust the delay of strobe signal;
   0 = dll_rerresh signal will be always 0</spirit:description>
<spirit:bitOffset>27</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>DLL_STEP_CTRL</spirit:name>
<spirit:description>when hw auto-tuning is being performed the host controller takes over the control of the delay value being programmed in the delay element. this field defines a value by which the delay value is incremented for each step. 
note: due to new emmc5.x topology, dll slave delayline will be put into phy inside, so if use new phy topology, recommanded sw promgrammed this field, if worked at host_legacy_mode (rx160&lt;31&gt;=1), sw can just use old rx114 register to control hw/sw tuning process.</spirit:description>
<spirit:bitOffset>16</spirit:bitOffset>
<spirit:bitWidth>8</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>DLL_DELAY_CTRL</spirit:name>
<spirit:description>phy dll slave delayline tuning delay value control for hs400 mode if phy does not use internal dll master conunter value to update dll slave.this field only be worked at with dll_reg1&lt;1&gt;(rx168&lt;1&gt;) = 1.
note: due to new emmc5.x topology, dll slave delayline will be put into phy inside, so if use old topology which worked at host_legacy_mode (rx160&lt;31&gt;=1) or for hs200/ddr50 tuninng, need use rx114/rx130/rx134 registers to control hw/sw tuning process.</spirit:description>
<spirit:bitOffset>8</spirit:bitOffset>
<spirit:bitWidth>8</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>DLL_VREG_CTRL</spirit:name>
<spirit:description>dll regulator output voltage control</spirit:description>
<spirit:bitOffset>6</spirit:bitOffset>
<spirit:bitWidth>2</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>DLL_FULLDLY_RANGE</spirit:name>
<spirit:description>dll delayline full delay range</spirit:description>
<spirit:bitOffset>4</spirit:bitOffset>
<spirit:bitWidth>2</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>DLL_PREDLY_NUM</spirit:name>
<spirit:description>dll delayline pre-delay numbers</spirit:description>
<spirit:bitOffset>2</spirit:bitOffset>
<spirit:bitWidth>2</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>DLL_BYPASS_ENABLE</spirit:name>
<spirit:description>dll master bypass enable for hs400
  1 = dll master is bypassed, and dll_delay_ctrl directly controls the slave dll.
  0 = dll on. use delay value from master dll.</spirit:description>
<spirit:bitOffset>1</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>DLL_REFRESH_METHOD</spirit:name>
<spirit:description>dll master code refresh method:
  1 = always refreshed by ck_refresh synchronized to filter clock.
  0 = before locked: refreshed by ck_refresh. after locked: refreshed by host generated dll_refresh rising edge.</spirit:description>
<spirit:bitOffset>0</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
</spirit:register>
<spirit:register>
<spirit:name>SDHC_PHY_DLLCFG1_REG</spirit:name>
<spirit:description>SDHC PHY DLL Configuration1 Register</spirit:description>
<spirit:addressOffset>0X016C</spirit:addressOffset>
<spirit:size>32</spirit:size>
<spirit:volatile>true</spirit:volatile>
<spirit:access>read-write</spirit:access>
<spirit:reset>
<spirit:value>0</spirit:value>
<spirit:mask>0xffffffff</spirit:mask>
</spirit:reset>
<spirit:field>
<spirit:name>DLL_REG3_CTRL</spirit:name>
<spirit:description>dll delay code offset</spirit:description>
<spirit:bitOffset>8</spirit:bitOffset>
<spirit:bitWidth>8</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>DLL_REG2_CTRL</spirit:name>
<spirit:description>dll loop parameter register.
&lt;7&gt;: dll force lock
&lt;6&gt;: sel_vote_tf (to be verified)
&lt;5&gt;: bypass decimate filter
&lt;4&gt;: reserved
&lt;3:2&gt;: dll loop filter gain in locking process.
&lt;1:0&gt;: dll loop filter gain in locked process
default: 8’h0c</spirit:description>
<spirit:bitOffset>0</spirit:bitOffset>
<spirit:bitWidth>8</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
</spirit:register>
<spirit:register>
<spirit:name>SDHC_PHY_DLLSTS_REG</spirit:name>
<spirit:description>SDHC PHY DLL Status &amp; reserved configuration Register</spirit:description>
<spirit:addressOffset>0X0170</spirit:addressOffset>
<spirit:size>32</spirit:size>
<spirit:volatile>true</spirit:volatile>
<spirit:access>read-write</spirit:access>
<spirit:reset>
<spirit:value>0</spirit:value>
<spirit:mask>0xffffffff</spirit:mask>
</spirit:reset>
<spirit:field>
<spirit:name>PHY_WORK_MODE</spirit:name>
<spirit:description>this field indicates current phy working mode flag, from phy output signal rdo_reg2&lt;7:0&gt;:
&lt;7&gt;:sdr26
&lt;6&gt;: sdr52
&lt;5&gt;: ddr52
&lt;4&gt;: hs200
&lt;3&gt;: hs400
&lt;2&gt;: hs400_extd
&lt;1&gt;: start_dll
&lt;0&gt;: dll_error</spirit:description>
<spirit:bitOffset>8</spirit:bitOffset>
<spirit:bitWidth>8</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>DLL_REFRESH_STATE</spirit:name>
<spirit:description>this bit indicates dll manully refresh mode refresh signal state, this bit only valid when dll_refresh_en be set.
   0: no refresh
   1: manully refresh state, is from dll_refresh_hw(host hw control logic)</spirit:description>
<spirit:bitOffset>1</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>DLL_LOCK_STATE</spirit:name>
<spirit:description>this bit indicates whether master dll is at lock state or not.
   0: unlock state
   1: lock state</spirit:description>
<spirit:bitOffset>0</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
</spirit:register>
<spirit:register>
<spirit:name>SDHC_PHY_DLLSTS1_REG</spirit:name>
<spirit:description>SDHC PHY DLL Status1 Register</spirit:description>
<spirit:addressOffset>0X0174</spirit:addressOffset>
<spirit:size>32</spirit:size>
<spirit:volatile>true</spirit:volatile>
<spirit:access>read-write</spirit:access>
<spirit:reset>
<spirit:value>0</spirit:value>
<spirit:mask>0xffffffff</spirit:mask>
</spirit:reset>
<spirit:field>
<spirit:name>DLL_MASTER_DELAY</spirit:name>
<spirit:description>the newest delay value for the delay line in master dll. 
   unit: 1 delay unit;
   note: this field always reflects the up-to-date value no matter whether dll is locked or not</spirit:description>
<spirit:bitOffset>16</spirit:bitOffset>
<spirit:bitWidth>9</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>DLL_SLAVE_DELAY</spirit:name>
<spirit:description>this field relects the delay value currently used for strobe signal or used for sw/hw tuning process final delay value.</spirit:description>
<spirit:bitOffset>0</spirit:bitOffset>
<spirit:bitWidth>8</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
</spirit:register>
<spirit:register>
<spirit:name>SDHC_PHY_PADCFG_REG</spirit:name>
<spirit:description>SDHC PHY Pad Configration Register</spirit:description>
<spirit:addressOffset>0X0178</spirit:addressOffset>
<spirit:size>32</spirit:size>
<spirit:volatile>true</spirit:volatile>
<spirit:access>read-write</spirit:access>
<spirit:reset>
<spirit:value>0</spirit:value>
<spirit:mask>0xffffffff</spirit:mask>
</spirit:reset>
<spirit:field>
<spirit:name>CLK_PU</spirit:name>
<spirit:description>clk pullup 2 bits resistor selection:
  00 = high-z
  01 = 50k ohms
  10 = 40k ohms
  11 =33k ohms</spirit:description>
<spirit:bitOffset>20</spirit:bitOffset>
<spirit:bitWidth>2</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>DS_PU</spirit:name>
<spirit:description>ds pullup 2 bits resistor selection:
  00 = high-z
  01 = 50k ohms
  10 = 40k ohms
  11 =33k ohms</spirit:description>
<spirit:bitOffset>18</spirit:bitOffset>
<spirit:bitWidth>2</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>CMD_PU</spirit:name>
<spirit:description>cmd pullup 2 bits resistor selection:
  00 = high-z
  01 = 50k ohms
  10 = 40k ohms
  11 =33k ohms</spirit:description>
<spirit:bitOffset>16</spirit:bitOffset>
<spirit:bitWidth>2</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>CLK_PD</spirit:name>
<spirit:description>clk pulldown 2 bits resistor selection:
  00 = high-z
  01 = 50k ohms
  10 = 40k ohms
  11 =33k ohms</spirit:description>
<spirit:bitOffset>12</spirit:bitOffset>
<spirit:bitWidth>2</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>DS_PD</spirit:name>
<spirit:description>ds pulldown 2 bits resistor selection:
  00 = high-z
  01 = 50k ohms
  10 = 40k ohms
  11 =33k ohms</spirit:description>
<spirit:bitOffset>10</spirit:bitOffset>
<spirit:bitWidth>2</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>CMD_PD</spirit:name>
<spirit:description>cmd pulldown 2 bits resistor selection:
  00 = high-z
  01 = 50k ohms
  10 = 40k ohms
  11 =33k ohms</spirit:description>
<spirit:bitOffset>8</spirit:bitOffset>
<spirit:bitWidth>2</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>SLEW_RATE</spirit:name>
<spirit:description>pad slew rate control:
   00 = low
   01 = medium
   10 = high
   11 = very high</spirit:description>
<spirit:bitOffset>3</spirit:bitOffset>
<spirit:bitWidth>2</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>DRIVE_SEL</spirit:name>
<spirit:description>for drive nominal impedance selection:
   000 = high-z
   001 = 200
   010 = 100
   011 = 66
   100 = 50
   101 = 40
   110 = 33
   111 = 33</spirit:description>
<spirit:bitOffset>0</spirit:bitOffset>
<spirit:bitWidth>3</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
</spirit:register>
<spirit:register>
<spirit:name>SDHC_PHY_PADCFG1_REG</spirit:name>
<spirit:description>SDHC PHY Pad Configration1 Register</spirit:description>
<spirit:addressOffset>0X017C</spirit:addressOffset>
<spirit:size>32</spirit:size>
<spirit:volatile>true</spirit:volatile>
<spirit:access>read-write</spirit:access>
<spirit:reset>
<spirit:value>0</spirit:value>
<spirit:mask>0xffffffff</spirit:mask>
</spirit:reset>
<spirit:field>
<spirit:name>DQX_PU</spirit:name>
<spirit:description>dq pullup  resistor value selection, every two bits stands for one io
selection: x stand for 7~0
  00 = high-z
  01 = 50k ohms
  10 = 40k ohms
  11 =33k ohms</spirit:description>
<spirit:bitOffset>16</spirit:bitOffset>
<spirit:bitWidth>16</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>DQX_PD</spirit:name>
<spirit:description>dq pulldown resistor value selection, every two bits stands for one io
selection: x stand for 7~0
  00 = high-z
  01 = 50k ohms
  10 = 40k ohms
  11 =33k ohms</spirit:description>
<spirit:bitOffset>0</spirit:bitOffset>
<spirit:bitWidth>16</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
</spirit:register>
<spirit:register>
<spirit:name>SDHC_PHY_LBCTRL_REG</spirit:name>
<spirit:description>SDHC PHY LoopBack Control Register</spirit:description>
<spirit:addressOffset>0X0180</spirit:addressOffset>
<spirit:size>32</spirit:size>
<spirit:volatile>true</spirit:volatile>
<spirit:access>read-write</spirit:access>
<spirit:reset>
<spirit:value>0</spirit:value>
<spirit:mask>0xffffffff</spirit:mask>
</spirit:reset>
<spirit:field>
<spirit:name>CLEAR_LB_ERR_STATUS</spirit:name>
<spirit:description>write 1 to clear sdhc_phy_lbsts_reg register</spirit:description>
<spirit:bitOffset>31</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>START_STUCK0_DET_CLK</spirit:name>
<spirit:description>after operation is finished, check emmc_lb_err_status register.</spirit:description>
<spirit:bitOffset>2</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>START_STUCK1_DET_CLK</spirit:name>
<spirit:description>after operation is finished, check emmc_lb_err_status register.</spirit:description>
<spirit:bitOffset>1</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>LB_TEST_TRIGGER</spirit:name>
<spirit:description>carry on loopback testing immediately. before seting this bit, host driver should program sdhc_phy_lbcnt_reg register (offset: 0x188).  when sdhc_phy_lbcnt_reg register reaches 0, loopback testing will stop and this bit will be cleared automatically. 
  only take effect when loopback mode enable is set.</spirit:description>
<spirit:bitOffset>0</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
</spirit:register>
<spirit:register>
<spirit:name>SDHC_PHY_LBFUNC_REG</spirit:name>
<spirit:description>SDHC PHY LoopBack Function Configuration Register</spirit:description>
<spirit:addressOffset>0X0184</spirit:addressOffset>
<spirit:size>32</spirit:size>
<spirit:volatile>true</spirit:volatile>
<spirit:access>read-write</spirit:access>
<spirit:reset>
<spirit:value>0</spirit:value>
<spirit:mask>0xffffffff</spirit:mask>
</spirit:reset>
<spirit:field>
<spirit:name>LB_DS_CNT</spirit:name>
<spirit:description>this field stands for total latency from tx to rx through phy loopback path, sw should program this field to sync with phy's characters, recommended sw set this field to 5 in hs400 or hs200 with rfifo mode, other modes set to 4. note this field should be &gt; 1.</spirit:description>
<spirit:bitOffset>24</spirit:bitOffset>
<spirit:bitWidth>4</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>LB_FILTER_CNT</spirit:name>
<spirit:description>don't compare the first lb_filter_cnt data bits and the last lb_filter_cnt data bits when performing loopback testing</spirit:description>
<spirit:bitOffset>20</spirit:bitOffset>
<spirit:bitWidth>4</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>LB_CMD_MASK</spirit:name>
<spirit:description>if set, the corresponding path will not perform lookback test.</spirit:description>
<spirit:bitOffset>16</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>LB_DQ_MASK</spirit:name>
<spirit:description>if set, the corresponding path will not perform lookback test.</spirit:description>
<spirit:bitOffset>8</spirit:bitOffset>
<spirit:bitWidth>8</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>LB_INVERT_CLK</spirit:name>
<spirit:description>normally, when loopback test is triggered and data pattern starts to be driven, ckout_e will become 1 and ckout_o stays at 0.
if this bit is set, ckout_e will become 1 and ckout_o stays at 0. only valid when bit[28] is set.</spirit:description>
<spirit:bitOffset>3</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>CLK_PASSTH_DS</spirit:name>
<spirit:description>loopback mode need host send clock control signal wr_ck_o/wr_ck_e/wr_ck_oe to phy
   0: no need output clock control signals to phy,
for hs400 mode use ds test, since ds in loopback comes from phy internal free running clock cki, so no need clock control signals.
   1: for other working modes in loopback enable, should set this bit. wr_ck_oe in loopback mode will be 1t earlier than wr_ck_o/wr_ck_e</spirit:description>
<spirit:bitOffset>2</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>LB_PATTERN_SEL</spirit:name>
<spirit:description>   0: use programmable 32-bit pattern;
   1: prbs7</spirit:description>
<spirit:bitOffset>1</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>LB_MODE_EN</spirit:name>
<spirit:description>enter loopback mode. normally, host driver shall only change this bit when no other operation is ongoing.</spirit:description>
<spirit:bitOffset>0</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
</spirit:register>
<spirit:register>
<spirit:name>SDHC_PHY_LBCNT_REG</spirit:name>
<spirit:description>SDHC PHY LoopBack Comparison Count
Register</spirit:description>
<spirit:addressOffset>0X0188</spirit:addressOffset>
<spirit:size>32</spirit:size>
<spirit:volatile>true</spirit:volatile>
<spirit:access>read-write</spirit:access>
<spirit:reset>
<spirit:value>0</spirit:value>
<spirit:mask>0xffffffff</spirit:mask>
</spirit:reset>
<spirit:field>
<spirit:name>LB_COMP_CNT</spirit:name>
<spirit:description>this field records how many bits to be compared for current loopback testing. after loopback testing starts, host controller decrements this register until it reaches 0.
please be noticed that after sw write this field, host will dynamically control this counter value, during loopback test process, this counter may changed cycle by cycle.</spirit:description>
<spirit:bitOffset>0</spirit:bitOffset>
<spirit:bitWidth>32</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
</spirit:register>
<spirit:register>
<spirit:name>SDHC_PHY_LBSTS_REG</spirit:name>
<spirit:description>SDHC PHY LoopBack Error Status Register</spirit:description>
<spirit:addressOffset>0X018C</spirit:addressOffset>
<spirit:size>32</spirit:size>
<spirit:volatile>true</spirit:volatile>
<spirit:access>read-write</spirit:access>
<spirit:reset>
<spirit:value>0</spirit:value>
<spirit:mask>0xffffffff</spirit:mask>
</spirit:reset>
<spirit:field>
<spirit:name>LB_CLK_STUCK0_ERR</spirit:name>
<spirit:description>clk path is stuck at 0</spirit:description>
<spirit:bitOffset>21</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>LB_CLK_STUCK1_ERR</spirit:name>
<spirit:description>clk path is stuck at 1</spirit:description>
<spirit:bitOffset>20</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>LB_CMD_EVEN_ERR</spirit:name>
<spirit:description>if set, the cmd line path doesn't pass loopback testing</spirit:description>
<spirit:bitOffset>17</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>LB_CMD_ODD_ERR</spirit:name>
<spirit:description>if set, the cmd line path doesn't pass loopback testing</spirit:description>
<spirit:bitOffset>16</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>LB_DQ_EVEN_ERR</spirit:name>
<spirit:description>if set, the corresponding data path doesn't pass loopback testing</spirit:description>
<spirit:bitOffset>8</spirit:bitOffset>
<spirit:bitWidth>8</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>LB_DQ_ODD_ERR</spirit:name>
<spirit:description>if set, the corresponding data path doesn't pass loopback testing</spirit:description>
<spirit:bitOffset>0</spirit:bitOffset>
<spirit:bitWidth>8</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
</spirit:register>
<spirit:register>
<spirit:name>SDHC_PHY_LBDATA_REG</spirit:name>
<spirit:description>SDHC PHY LoopBack DATA Pattern Configuration Register</spirit:description>
<spirit:addressOffset>0X0190</spirit:addressOffset>
<spirit:size>32</spirit:size>
<spirit:volatile>true</spirit:volatile>
<spirit:access>read-write</spirit:access>
<spirit:reset>
<spirit:value>0</spirit:value>
<spirit:mask>0xffffffff</spirit:mask>
</spirit:reset>
<spirit:field>
<spirit:name>LB_PATTERN_RST</spirit:name>
<spirit:description>reset data pattern fifo;</spirit:description>
<spirit:bitOffset>31</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>LB_PATTERN_WRITE</spirit:name>
<spirit:description>push a new data pattern into fifo;</spirit:description>
<spirit:bitOffset>30</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>LB_CMD_PATTERN</spirit:name>
<spirit:description>  bit[17:16]:even/odd for cmd line;</spirit:description>
<spirit:bitOffset>16</spirit:bitOffset>
<spirit:bitWidth>2</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>LB_DATA_PATTERN</spirit:name>
<spirit:description>  bit [7:0]: odd data pattern for data line
  bit[15:8]: even data pattern for data line</spirit:description>
<spirit:bitOffset>0</spirit:bitOffset>
<spirit:bitWidth>16</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
</spirit:register>
<spirit:register>
<spirit:name>SDHC_PHY_LBDATA_REG</spirit:name>
<spirit:description>SDHC PHY LoopBack DATA Pattern Configuration Register</spirit:description>
<spirit:addressOffset>0X194</spirit:addressOffset>
<spirit:size>32</spirit:size>
<spirit:volatile>true</spirit:volatile>
<spirit:access>read-write</spirit:access>
<spirit:reset>
<spirit:value>0</spirit:value>
<spirit:mask>0xffffffff</spirit:mask>
</spirit:reset>
<spirit:field>
<spirit:name>CQE_FSM_RST</spirit:name>
<spirit:description>a back door register which can let sw force cqe state machine goes to a stable idle state if hw meets some problems. write 1 means force cqe fsm into idle state. write 0 has no meaning.</spirit:description>
<spirit:bitOffset>31</spirit:bitOffset>
<spirit:bitWidth>1</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
<spirit:field>
<spirit:name>CQE_DEBUG_SEL</spirit:name>
<spirit:description>these 4bits field indicate which internal 32bits debug bus signals will show on 0x1f4 register:
  [0000]: slot index &amp; fsm informations
  [0001]: slot index informations
  [0010]: internal task slot fetch signals
  [0011]: internal task ready signals
this field is for hw designer debug purpose.</spirit:description>
<spirit:bitOffset>0</spirit:bitOffset>
<spirit:bitWidth>4</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
</spirit:register>
<spirit:register>
<spirit:name>CQE_CQBDCTRL_REG</spirit:name>
<spirit:description>SDHC Command Queue Debug Information Content Registers</spirit:description>
<spirit:addressOffset>0X01F4</spirit:addressOffset>
<spirit:size>32</spirit:size>
<spirit:volatile>true</spirit:volatile>
<spirit:access>read-write</spirit:access>
<spirit:reset>
<spirit:value>0</spirit:value>
<spirit:mask>0xffffffff</spirit:mask>
</spirit:reset>
<spirit:field>
<spirit:name>CQE_DEBUG_INFO</spirit:name>
<spirit:description>32bits debug signals information output to sw. please be noticed that these register value may changed cycle by cycle due to cqe hw internal design logic may still running during sw read this value. and see 0x1f0&lt;3:0&gt; to check which 32bits debug bus information will be selected output to this field.</spirit:description>
<spirit:bitOffset>0</spirit:bitOffset>
<spirit:bitWidth>32</spirit:bitWidth>
<spirit:access>read-write</spirit:access>
</spirit:field>
</spirit:register>
</spirit:addressBlock>
</spirit:memoryMap>
</spirit:memoryMaps>
</spirit:component>